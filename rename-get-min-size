From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsIFrame::GetMinSize to GetXULMinSize, and related methods.  r?dholbert

Written purely with sed, over .h and .cpp files in layout/.

MozReview-Commit-ID: Jhe3o3kIOe0

diff --git a/layout/forms/nsTextControlFrame.cpp b/layout/forms/nsTextControlFrame.cpp
--- a/layout/forms/nsTextControlFrame.cpp
+++ b/layout/forms/nsTextControlFrame.cpp
@@ -581,20 +581,20 @@ nsTextControlFrame::ReflowTextControlChi
   FinishReflowChild(aKid, aPresContext, desiredSize,
                     &kidReflowState, xOffset, yOffset, 0);
 
   // consider the overflow
   aParentDesiredSize.mOverflowAreas.UnionWith(desiredSize.mOverflowAreas);
 }
 
 nsSize
-nsTextControlFrame::GetMinSize(nsBoxLayoutState& aState)
+nsTextControlFrame::GetXULMinSize(nsBoxLayoutState& aState)
 {
   // XXXbz why?  Why not the nsBoxFrame sizes?
-  return nsBox::GetMinSize(aState);
+  return nsBox::GetXULMinSize(aState);
 }
 
 bool
 nsTextControlFrame::IsCollapsed()
 {
   // We're never collapsed in the box sense.
   return false;
 }
diff --git a/layout/forms/nsTextControlFrame.h b/layout/forms/nsTextControlFrame.h
--- a/layout/forms/nsTextControlFrame.h
+++ b/layout/forms/nsTextControlFrame.h
@@ -57,17 +57,17 @@ public:
                   const mozilla::LogicalSize& aPadding,
                   bool aShrinkWrap) override;
 
   virtual void Reflow(nsPresContext*           aPresContext,
                       nsHTMLReflowMetrics&     aDesiredSize,
                       const nsHTMLReflowState& aReflowState,
                       nsReflowStatus&          aStatus) override;
 
-  virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual bool IsCollapsed() override;
 
   virtual bool IsLeaf() const override;
   
 #ifdef ACCESSIBILITY
   virtual mozilla::a11y::AccType AccessibleType() override;
 #endif
 
diff --git a/layout/generic/nsContainerFrame.cpp b/layout/generic/nsContainerFrame.cpp
--- a/layout/generic/nsContainerFrame.cpp
+++ b/layout/generic/nsContainerFrame.cpp
@@ -692,17 +692,17 @@ nsContainerFrame::SyncWindowProperties(n
   if (!aRC)
     return;
 
   if (!weak.IsAlive()) {
     return;
   }
 
   nsBoxLayoutState aState(aPresContext, aRC);
-  nsSize minSize = rootFrame->GetMinSize(aState);
+  nsSize minSize = rootFrame->GetXULMinSize(aState);
   nsSize maxSize = rootFrame->GetMaxSize(aState);
 
   SetSizeConstraints(aPresContext, windowWidget, minSize, maxSize);
 #endif
 }
 
 void nsContainerFrame::SetSizeConstraints(nsPresContext* aPresContext,
                                           nsIWidget* aWidget,
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -8724,17 +8724,17 @@ nsFrame::GetPrefSize(nsBoxLayoutState& a
       size.height = blockSize.height;
   }
 
   metrics->mPrefSize = size;
   return size;
 }
 
 nsSize
-nsFrame::GetMinSize(nsBoxLayoutState& aState)
+nsFrame::GetXULMinSize(nsBoxLayoutState& aState)
 {
   nsSize size(0,0);
   DISPLAY_MIN_SIZE(this, size);
   // Don't use the cache if we have HTMLReflowState constraints --- they might have changed
   nsBoxLayoutMetrics *metrics = BoxMetrics();
   if (!DoesNeedRecalc(metrics->mMinSize)) {
     size = metrics->mMinSize;
     return size;
diff --git a/layout/generic/nsFrame.h b/layout/generic/nsFrame.h
--- a/layout/generic/nsFrame.h
+++ b/layout/generic/nsFrame.h
@@ -404,17 +404,17 @@ public:
                                uint32_t aSelectFlags);
 
   // Helper for GetContentAndOffsetsFromPoint; calculation of content offsets
   // in this function assumes there is no child frame that can be targeted.
   virtual ContentOffsets CalcContentOffsetsFromFramePoint(nsPoint aPoint);
 
   // Box layout methods
   virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetFlex() override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
 
   // We compute and store the HTML content's overflow area. So don't
   // try to compute it in the box code.
   virtual bool ComputesOwnOverflowArea() override { return true; }
 
diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -263,17 +263,17 @@ static void
 GetScrollbarMetrics(nsBoxLayoutState& aState, nsIFrame* aBox, nsSize* aMin,
                     nsSize* aPref, bool aVertical)
 {
   NS_ASSERTION(aState.GetRenderingContext(),
                "Must have rendering context in layout state for size "
                "computations");
 
   if (aMin) {
-    *aMin = aBox->GetMinSize(aState);
+    *aMin = aBox->GetXULMinSize(aState);
     nsBox::AddMargin(aBox, *aMin);
     if (aMin->width < 0) {
       aMin->width = 0;
     }
     if (aMin->height < 0) {
       aMin->height = 0;
     }
   }
@@ -1424,38 +1424,38 @@ nsXULScrollFrame::GetPrefSize(nsBoxLayou
 
   AddBorderAndPadding(pref);
   bool widthSet, heightSet;
   nsIFrame::AddCSSPrefSize(this, pref, widthSet, heightSet);
   return pref;
 }
 
 nsSize
-nsXULScrollFrame::GetMinSize(nsBoxLayoutState& aState)
+nsXULScrollFrame::GetXULMinSize(nsBoxLayoutState& aState)
 {
 #ifdef DEBUG_LAYOUT
   PropagateDebug(aState);
 #endif
 
   nsSize min = mHelper.mScrolledFrame->GetMinSizeForScrollArea(aState);
 
   ScrollbarStyles styles = GetScrollbarStyles();
 
   if (mHelper.mVScrollbarBox &&
       styles.mVertical == NS_STYLE_OVERFLOW_SCROLL) {
-     nsSize vSize = mHelper.mVScrollbarBox->GetMinSize(aState);
+     nsSize vSize = mHelper.mVScrollbarBox->GetXULMinSize(aState);
      AddMargin(mHelper.mVScrollbarBox, vSize);
      min.width += vSize.width;
      if (min.height < vSize.height)
         min.height = vSize.height;
   }
 
   if (mHelper.mHScrollbarBox &&
       styles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL) {
-     nsSize hSize = mHelper.mHScrollbarBox->GetMinSize(aState);
+     nsSize hSize = mHelper.mHScrollbarBox->GetXULMinSize(aState);
      AddMargin(mHelper.mHScrollbarBox, hSize);
      min.height += hSize.height;
      if (min.width < hSize.width)
         min.width = hSize.width;
   }
 
   AddBorderAndPadding(min);
   bool widthSet, heightSet;
@@ -4653,17 +4653,17 @@ void
 nsXULScrollFrame::LayoutScrollArea(nsBoxLayoutState& aState,
                                    const nsPoint& aScrollPosition)
 {
   uint32_t oldflags = aState.LayoutFlags();
   nsRect childRect = nsRect(mHelper.mScrollPort.TopLeft() - aScrollPosition,
                             mHelper.mScrollPort.Size());
   int32_t flags = NS_FRAME_NO_MOVE_VIEW;
 
-  nsSize minSize = mHelper.mScrolledFrame->GetMinSize(aState);
+  nsSize minSize = mHelper.mScrolledFrame->GetXULMinSize(aState);
 
   if (minSize.height > childRect.height)
     childRect.height = minSize.height;
 
   if (minSize.width > childRect.width)
     childRect.width = minSize.width;
 
   aState.SetLayoutFlags(flags);
@@ -5319,17 +5319,17 @@ ScrollFrameHelper::LayoutScrollbars(nsBo
 
     if (mScrollCornerBox) {
       nsBoxFrame::LayoutChildAt(aState, mScrollCornerBox, r);
     }
 
     if (hasResizer) {
       // if a resizer is present, get its size. Assume a default size of 15 pixels.
       nscoord defaultSize = nsPresContext::CSSPixelsToAppUnits(15);
-      nsSize resizerMinSize = mResizerBox->GetMinSize(aState);
+      nsSize resizerMinSize = mResizerBox->GetXULMinSize(aState);
 
       nscoord vScrollbarWidth = mVScrollbarBox ?
         mVScrollbarBox->GetPrefSize(aState).width : defaultSize;
       r.width = std::max(std::max(r.width, vScrollbarWidth), resizerMinSize.width);
       if (aContentArea.x == mScrollPort.x && !scrollbarOnLeft) {
         r.x = aContentArea.XMost() - r.width;
       }
 
diff --git a/layout/generic/nsGfxScrollFrame.h b/layout/generic/nsGfxScrollFrame.h
--- a/layout/generic/nsGfxScrollFrame.h
+++ b/layout/generic/nsGfxScrollFrame.h
@@ -1119,17 +1119,17 @@ public:
     return pt;
   }
 
   // nsIAnonymousContentCreator
   virtual nsresult CreateAnonymousContent(nsTArray<ContentInfo>& aElements) override;
   virtual void AppendAnonymousContentTo(nsTArray<nsIContent*>& aElements,
                                         uint32_t aFilter) override;
 
-  virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
 
   NS_IMETHOD DoLayout(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsresult GetPadding(nsMargin& aPadding) override;
 
   virtual bool GetBorderRadii(const nsSize& aFrameSize, const nsSize& aBorderArea,
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2868,17 +2868,17 @@ public:
     vAlign_Bottom
   };
 
   /**
    * This calculates the minimum size required for a box based on its state
    * @param[in] aBoxLayoutState The desired state to calculate for
    * @return The minimum size
    */
-  virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState) = 0;
+  virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) = 0;
 
   /**
    * This calculates the preferred size of a box based on its state
    * @param[in] aBoxLayoutState The desired state to calculate for
    * @return The preferred size
    */
   virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) = 0;
 
diff --git a/layout/generic/nsPlaceholderFrame.cpp b/layout/generic/nsPlaceholderFrame.cpp
--- a/layout/generic/nsPlaceholderFrame.cpp
+++ b/layout/generic/nsPlaceholderFrame.cpp
@@ -33,17 +33,17 @@ NS_IMPL_FRAMEARENA_HELPERS(nsPlaceholder
 
 #ifdef DEBUG
 NS_QUERYFRAME_HEAD(nsPlaceholderFrame)
   NS_QUERYFRAME_ENTRY(nsPlaceholderFrame)
 NS_QUERYFRAME_TAIL_INHERITING(nsFrame)
 #endif
 
 /* virtual */ nsSize
-nsPlaceholderFrame::GetMinSize(nsBoxLayoutState& aBoxLayoutState)
+nsPlaceholderFrame::GetXULMinSize(nsBoxLayoutState& aBoxLayoutState)
 {
   nsSize size(0, 0);
   DISPLAY_MIN_SIZE(this, size);
   return size;
 }
 
 /* virtual */ nsSize
 nsPlaceholderFrame::GetPrefSize(nsBoxLayoutState& aBoxLayoutState)
diff --git a/layout/generic/nsPlaceholderFrame.h b/layout/generic/nsPlaceholderFrame.h
--- a/layout/generic/nsPlaceholderFrame.h
+++ b/layout/generic/nsPlaceholderFrame.h
@@ -83,23 +83,23 @@ public:
   nsIFrame*  GetOutOfFlowFrame() const { return mOutOfFlowFrame; }
   void       SetOutOfFlowFrame(nsIFrame* aFrame) {
                NS_ASSERTION(!aFrame || !aFrame->GetPrevContinuation(),
                             "OOF must be first continuation");
                mOutOfFlowFrame = aFrame;
              }
 
   // nsIFrame overrides
-  // We need to override GetMinSize and GetPrefSize because XUL uses
+  // We need to override GetXULMinSize and GetPrefSize because XUL uses
   // placeholders not within lines.
   virtual void AddInlineMinISize(nsRenderingContext* aRenderingContext,
                                  InlineMinISizeData* aData) override;
   virtual void AddInlinePrefISize(nsRenderingContext* aRenderingContext,
                                   InlinePrefISizeData* aData) override;
-  virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual void Reflow(nsPresContext* aPresContext,
                       nsHTMLReflowMetrics& aDesiredSize,
                       const nsHTMLReflowState& aReflowState,
                       nsReflowStatus& aStatus) override;
 
diff --git a/layout/xul/grid/nsGrid.cpp b/layout/xul/grid/nsGrid.cpp
--- a/layout/xul/grid/nsGrid.cpp
+++ b/layout/xul/grid/nsGrid.cpp
@@ -921,17 +921,17 @@ nsGrid::GetMinRowHeight(nsBoxLayoutState
     if (aIsHorizontal)
      child = GetCellAt(i,aIndex);
     else
      child = GetCellAt(aIndex,i);
 
     // ignore collapsed children
     if (!child->IsCollapsed())
     {
-      nsSize childSize = child->GetMinSize(aState);
+      nsSize childSize = child->GetXULMinSize(aState);
 
       nsSprocketLayout::AddLargestSize(size, childSize, aIsHorizontal);
     }
   }
 
   row->mMin = GET_HEIGHT(size, aIsHorizontal);
 
   return row->mMin;
@@ -996,17 +996,17 @@ nsGrid::GetMaxRowHeight(nsBoxLayoutState
     if (aIsHorizontal)
      child = GetCellAt(i,aIndex);
     else
      child = GetCellAt(aIndex,i);
 
     // ignore collapsed children
     if (!child->IsCollapsed())
     {
-      nsSize min = child->GetMinSize(aState);
+      nsSize min = child->GetXULMinSize(aState);
       nsSize childSize = nsBox::BoundsCheckMinMax(min, child->GetMaxSize(aState));
       nsSprocketLayout::AddLargestSize(size, childSize, aIsHorizontal);
     }
   }
 
   row->mMax = GET_HEIGHT(size, aIsHorizontal) + top + bottom;
 
   return row->mMax;
diff --git a/layout/xul/grid/nsGridCell.cpp b/layout/xul/grid/nsGridCell.cpp
--- a/layout/xul/grid/nsGridCell.cpp
+++ b/layout/xul/grid/nsGridCell.cpp
@@ -52,35 +52,35 @@ nsGridCell::GetPrefSize(nsBoxLayoutState
 
     nsBoxLayout::AddLargestSize(sum, pref);
   }
 
   return sum;
 }
 
 nsSize
-nsGridCell::GetMinSize(nsBoxLayoutState& aState)
+nsGridCell::GetXULMinSize(nsBoxLayoutState& aState)
 {
   nsSize sum(0, 0);
 
   // take our 2 children and add them up.
   // we are as wide as the widest child plus its left offset
   // we are tall as the tallest child plus its top offset
 
   if (mBoxInColumn) {
-    nsSize min = mBoxInColumn->GetMinSize(aState);
+    nsSize min = mBoxInColumn->GetXULMinSize(aState);
 
     nsBox::AddMargin(mBoxInColumn, min);
     nsGridLayout2::AddOffset(mBoxInColumn, min);
 
     nsBoxLayout::AddLargestSize(sum, min);
   }
 
   if (mBoxInRow) {
-    nsSize min = mBoxInRow->GetMinSize(aState);
+    nsSize min = mBoxInRow->GetXULMinSize(aState);
 
     nsBox::AddMargin(mBoxInRow, min);
     nsGridLayout2::AddOffset(mBoxInRow, min);
 
     nsBoxLayout::AddLargestSize(sum, min);
   }
 
   return sum;
diff --git a/layout/xul/grid/nsGridCell.h b/layout/xul/grid/nsGridCell.h
--- a/layout/xul/grid/nsGridCell.h
+++ b/layout/xul/grid/nsGridCell.h
@@ -29,17 +29,17 @@ class nsIFrame;
 
 class nsGridCell final
 {
 public:
     nsGridCell();
     ~nsGridCell();
 
     nsSize      GetPrefSize(nsBoxLayoutState& aBoxLayoutState);
-    nsSize      GetMinSize(nsBoxLayoutState& aBoxLayoutState);
+    nsSize      GetXULMinSize(nsBoxLayoutState& aBoxLayoutState);
     nsSize      GetMaxSize(nsBoxLayoutState& aBoxLayoutState);
     bool        IsCollapsed();
 
 // accessors
     nsIFrame*   GetBoxInColumn()               { return mBoxInColumn; }
     nsIFrame*   GetBoxInRow()                  { return mBoxInRow; }
     void        SetBoxInRow(nsIFrame* aBox)    { mBoxInRow = aBox; }
     void        SetBoxInColumn(nsIFrame* aBox) { mBoxInColumn = aBox; }
diff --git a/layout/xul/grid/nsGridLayout2.cpp b/layout/xul/grid/nsGridLayout2.cpp
--- a/layout/xul/grid/nsGridLayout2.cpp
+++ b/layout/xul/grid/nsGridLayout2.cpp
@@ -88,19 +88,19 @@ nsGridLayout2::AddWidth(nsSize& aSize, n
     if (aSize2 == NS_INTRINSICSIZE)
       size = NS_INTRINSICSIZE;
     else
       size += aSize2;
   }
 }
 
 nsSize
-nsGridLayout2::GetMinSize(nsIFrame* aBox, nsBoxLayoutState& aState)
+nsGridLayout2::GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
-  nsSize minSize = nsStackLayout::GetMinSize(aBox, aState); 
+  nsSize minSize = nsStackLayout::GetXULMinSize(aBox, aState); 
 
   // if there are no <rows> tags that will sum up our columns,
   // sum up our columns here.
   nsSize total(0,0);
   nsIFrame* rowsBox = mGrid.GetRowsBox();
   nsIFrame* columnsBox = mGrid.GetColumnsBox();
   if (!rowsBox || !columnsBox) {
     if (!rowsBox) {
diff --git a/layout/xul/grid/nsGridLayout2.h b/layout/xul/grid/nsGridLayout2.h
--- a/layout/xul/grid/nsGridLayout2.h
+++ b/layout/xul/grid/nsGridLayout2.h
@@ -34,17 +34,17 @@ public:
   virtual void IntrinsicISizesDirty(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual nsGridRowGroupLayout* CastToRowGroupLayout() override { return nullptr; }
   virtual nsGridLayout2* CastToGridLayout() override { return this; }
   virtual nsGrid* GetGrid(nsIFrame* aBox, int32_t* aIndex, nsGridRowLayout* aRequestor=nullptr) override;
   virtual nsIGridPart* GetParentGridPart(nsIFrame* aBox, nsIFrame** aParentBox) override {
     NS_NOTREACHED("Should not be called"); return nullptr;
   }
-  virtual nsSize GetMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual void CountRowsColumns(nsIFrame* aBox, int32_t& aRowCount, int32_t& aComputedColumnCount) override { aRowCount++; }
   virtual void DirtyRows(nsIFrame* aBox, nsBoxLayoutState& aState) override { }
   virtual int32_t BuildRows(nsIFrame* aBox, nsGridRow* aRows) override;
   virtual nsMargin GetTotalMargin(nsIFrame* aBox, bool aIsHorizontal) override;
   virtual Type GetType() override { return eGrid; }
   virtual void ChildrenInserted(nsIFrame* aBox, nsBoxLayoutState& aState,
diff --git a/layout/xul/grid/nsGridRowGroupLayout.cpp b/layout/xul/grid/nsGridRowGroupLayout.cpp
--- a/layout/xul/grid/nsGridRowGroupLayout.cpp
+++ b/layout/xul/grid/nsGridRowGroupLayout.cpp
@@ -116,19 +116,19 @@ nsGridRowGroupLayout::GetMaxSize(nsIFram
       AddWidth(maxSize, max, isHorizontal);
     }
   }
 
   return maxSize;
 }
 
 nsSize
-nsGridRowGroupLayout::GetMinSize(nsIFrame* aBox, nsBoxLayoutState& aState)
+nsGridRowGroupLayout::GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
-  nsSize minSize = nsGridRowLayout::GetMinSize(aBox, aState); 
+  nsSize minSize = nsGridRowLayout::GetXULMinSize(aBox, aState); 
 
   int32_t index = 0;
   nsGrid* grid = GetGrid(aBox, &index);
 
   if (grid) 
   {
     // make sure we add in extra columns sizes as well
     bool isHorizontal = IsHorizontal(aBox);
diff --git a/layout/xul/grid/nsGridRowGroupLayout.h b/layout/xul/grid/nsGridRowGroupLayout.h
--- a/layout/xul/grid/nsGridRowGroupLayout.h
+++ b/layout/xul/grid/nsGridRowGroupLayout.h
@@ -21,17 +21,17 @@
  */
 class nsGridRowGroupLayout : public nsGridRowLayout
 {
 public:
 
   friend already_AddRefed<nsBoxLayout> NS_NewGridRowGroupLayout();
 
   virtual nsGridRowGroupLayout* CastToRowGroupLayout() override { return this; }
-  virtual nsSize GetMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual void CountRowsColumns(nsIFrame* aBox, int32_t& aRowCount, int32_t& aComputedColumnCount) override;
   virtual void DirtyRows(nsIFrame* aBox, nsBoxLayoutState& aState) override;
   virtual int32_t BuildRows(nsIFrame* aBox, nsGridRow* aRows) override;
   virtual nsMargin GetTotalMargin(nsIFrame* aBox, bool aIsHorizontal) override;
   virtual int32_t GetRowCount() override { return mRowCount; }
   virtual Type GetType() override { return eRowGroup; }
diff --git a/layout/xul/grid/nsGridRowLeafLayout.cpp b/layout/xul/grid/nsGridRowLeafLayout.cpp
--- a/layout/xul/grid/nsGridRowLeafLayout.cpp
+++ b/layout/xul/grid/nsGridRowLeafLayout.cpp
@@ -48,24 +48,24 @@ nsGridRowLeafLayout::GetPrefSize(nsIFram
   }
   else {
     return grid->GetPrefRowSize(aState, index, isHorizontal);
     //AddBorderAndPadding(aBox, pref);
   }
 }
 
 nsSize
-nsGridRowLeafLayout::GetMinSize(nsIFrame* aBox, nsBoxLayoutState& aState)
+nsGridRowLeafLayout::GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   int32_t index = 0;
   nsGrid* grid = GetGrid(aBox, &index);
   bool isHorizontal = IsHorizontal(aBox);
 
   if (!grid)
-    return nsGridRowLayout::GetMinSize(aBox, aState); 
+    return nsGridRowLayout::GetXULMinSize(aBox, aState); 
   else {
     nsSize minSize = grid->GetMinRowSize(aState, index, isHorizontal);
     AddBorderAndPadding(aBox, minSize);
     return minSize;
   }
 }
 
 nsSize
diff --git a/layout/xul/grid/nsGridRowLeafLayout.h b/layout/xul/grid/nsGridRowLeafLayout.h
--- a/layout/xul/grid/nsGridRowLeafLayout.h
+++ b/layout/xul/grid/nsGridRowLeafLayout.h
@@ -24,17 +24,17 @@
 // row.
 class nsGridRowLeafLayout final : public nsGridRowLayout
 {
 public:
 
   friend already_AddRefed<nsBoxLayout> NS_NewGridRowLeafLayout();
 
   virtual nsSize GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual void ChildAddedOrRemoved(nsIFrame* aBox, nsBoxLayoutState& aState) override;
   NS_IMETHOD Layout(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual void CountRowsColumns(nsIFrame* aBox, int32_t& aRowCount, int32_t& aComputedColumnCount) override;
   virtual void DirtyRows(nsIFrame* aBox, nsBoxLayoutState& aState) override;
   virtual int32_t BuildRows(nsIFrame* aBox, nsGridRow* aRows) override;
   virtual Type GetType() override { return eRowLeaf; }
 
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -401,23 +401,23 @@ nsBox::GetPrefSize(nsBoxLayoutState& aSt
 
   if (IsCollapsed())
     return pref;
 
   AddBorderAndPadding(pref);
   bool widthSet, heightSet;
   nsIFrame::AddCSSPrefSize(this, pref, widthSet, heightSet);
 
-  nsSize minSize = GetMinSize(aState);
+  nsSize minSize = GetXULMinSize(aState);
   nsSize maxSize = GetMaxSize(aState);
   return BoundsCheck(minSize, pref, maxSize);
 }
 
 nsSize
-nsBox::GetMinSize(nsBoxLayoutState& aState)
+nsBox::GetXULMinSize(nsBoxLayoutState& aState)
 {
   NS_ASSERTION(aState.GetRenderingContext(), "must have rendering context");
 
   nsSize min(0,0);
   DISPLAY_MIN_SIZE(this, min);
 
   if (IsCollapsed())
     return min;
@@ -601,17 +601,17 @@ nsIFrame::AddCSSPrefSize(nsIFrame* aBox,
     aHeightSet = false;
 
     // add in the css min, max, pref
     const nsStylePosition* position = aBox->StylePosition();
 
     // see if the width or height was specifically set
     // XXX Handle eStyleUnit_Enumerated?
     // (Handling the eStyleUnit_Enumerated types requires
-    // GetPrefSize/GetMinSize methods that don't consider
+    // GetPrefSize/GetXULMinSize methods that don't consider
     // (min-/max-/)(width/height) properties.)
     const nsStyleCoord &width = position->mWidth;
     if (width.GetUnit() == eStyleUnit_Coord) {
         aSize.width = width.GetCoordValue();
         aWidthSet = true;
     } else if (width.IsCalcUnit()) {
         if (!width.CalcHasPercent()) {
             // pass 0 for percentage basis since we know there are no %s
@@ -713,17 +713,17 @@ nsIFrame::AddCSSMinSize(nsBoxLayoutState
         NS_ASSERTION(minWidth.GetPercentValue() == 0.0f,
           "Non-zero percentage values not currently supported");
         aSize.width = 0;
         aWidthSet = true; // FIXME: should we really do this for
                              // nonzero values?
     }
     // XXX Handle eStyleUnit_Enumerated?
     // (Handling the eStyleUnit_Enumerated types requires
-    // GetPrefSize/GetMinSize methods that don't consider
+    // GetPrefSize/GetXULMinSize methods that don't consider
     // (min-/max-/)(width/height) properties.
     // calc() with percentage is treated like '0' (unset)
 
     const nsStyleCoord &minHeight = position->mMinHeight;
     if ((minHeight.GetUnit() == eStyleUnit_Coord &&
          minHeight.GetCoordValue() != 0) ||
         (minHeight.IsCalcUnit() && !minHeight.CalcHasPercent())) {
         nscoord min = nsRuleNode::ComputeCoordPercentCalc(minHeight, 0);
@@ -782,17 +782,17 @@ nsIFrame::AddCSSMaxSize(nsIFrame* aBox, 
 
     // add in the css min, max, pref
     const nsStylePosition* position = aBox->StylePosition();
 
     // and max
     // see if the width or height was specifically set
     // XXX Handle eStyleUnit_Enumerated?
     // (Handling the eStyleUnit_Enumerated types requires
-    // GetPrefSize/GetMinSize methods that don't consider
+    // GetPrefSize/GetXULMinSize methods that don't consider
     // (min-/max-/)(width/height) properties.)
     const nsStyleCoord maxWidth = position->mMaxWidth;
     if (maxWidth.ConvertsToLength()) {
         aSize.width = nsRuleNode::ComputeCoordPercentCalc(maxWidth, 0);
         aWidthSet = true;
     }
     // percentages and calc() with percentages are treated like 'none'
 
diff --git a/layout/xul/nsBox.h b/layout/xul/nsBox.h
--- a/layout/xul/nsBox.h
+++ b/layout/xul/nsBox.h
@@ -15,17 +15,17 @@ class nsBox : public nsIFrame {
 
 public:
 
   friend class nsIFrame;
 
   static void Shutdown();
 
   virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetFlex() override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual nsSize GetMinSizeForScrollArea(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual bool IsCollapsed() override;
 
diff --git a/layout/xul/nsBoxFrame.cpp b/layout/xul/nsBoxFrame.cpp
--- a/layout/xul/nsBoxFrame.cpp
+++ b/layout/xul/nsBoxFrame.cpp
@@ -585,21 +585,21 @@ static void printSize(char * aDesc, nsco
 
 /* virtual */ nscoord
 nsBoxFrame::GetMinISize(nsRenderingContext *aRenderingContext)
 {
   nscoord result;
   DISPLAY_MIN_WIDTH(this, result);
 
   nsBoxLayoutState state(PresContext(), aRenderingContext);
-  nsSize minSize = GetMinSize(state);
+  nsSize minSize = GetXULMinSize(state);
 
-  // GetMinSize returns border-box width, and we want to return content
+  // GetXULMinSize returns border-box width, and we want to return content
   // width.  Since Reflow uses the reflow state's border and padding, we
-  // actually just want to subtract what GetMinSize added, which is the
+  // actually just want to subtract what GetXULMinSize added, which is the
   // result of GetBorderAndPadding.
   nsMargin bp;
   GetBorderAndPadding(bp);
 
   result = minSize.width - bp.LeftRight();
   result = std::max(result, 0);
 
   return result;
@@ -671,17 +671,17 @@ nsBoxFrame::Reflow(nsPresContext*       
 
   LogicalSize prefSize(wm);
 
   // if we are told to layout intrinsic then get our preferred size.
   NS_ASSERTION(computedSize.ISize(wm) != NS_INTRINSICSIZE,
                "computed inline size should always be computed");
   if (computedSize.BSize(wm) == NS_INTRINSICSIZE) {
     nsSize physicalPrefSize = GetPrefSize(state);
-    nsSize minSize = GetMinSize(state);
+    nsSize minSize = GetXULMinSize(state);
     nsSize maxSize = GetMaxSize(state);
     // XXXbz isn't GetPrefSize supposed to bounds-check for us?
     physicalPrefSize = BoundsCheck(minSize, physicalPrefSize, maxSize);
     prefSize = LogicalSize(wm, physicalPrefSize);
   }
 
   // get our desiredSize
   computedSize.ISize(wm) += m.IStart(wm) + m.IEnd(wm);
@@ -773,17 +773,17 @@ nsBoxFrame::GetPrefSize(nsBoxLayoutState
       if (!heightSet)
         size.height = layoutSize.height;
     }
     else {
       size = nsBox::GetPrefSize(aBoxLayoutState);
     }
   }
 
-  nsSize minSize = GetMinSize(aBoxLayoutState);
+  nsSize minSize = GetXULMinSize(aBoxLayoutState);
   nsSize maxSize = GetMaxSize(aBoxLayoutState);
   mPrefSize = BoundsCheck(minSize, size, maxSize);
  
   return mPrefSize;
 }
 
 nscoord
 nsBoxFrame::GetBoxAscent(nsBoxLayoutState& aBoxLayoutState)
@@ -802,17 +802,17 @@ nsBoxFrame::GetBoxAscent(nsBoxLayoutStat
     mAscent = mLayoutManager->GetAscent(this, aBoxLayoutState);
   else
     mAscent = nsBox::GetBoxAscent(aBoxLayoutState);
 
   return mAscent;
 }
 
 nsSize
-nsBoxFrame::GetMinSize(nsBoxLayoutState& aBoxLayoutState)
+nsBoxFrame::GetXULMinSize(nsBoxLayoutState& aBoxLayoutState)
 {
   NS_ASSERTION(aBoxLayoutState.GetRenderingContext(),
                "must have rendering context");
 
   nsSize size(0,0);
   DISPLAY_MIN_SIZE(this, size);
   if (!DoesNeedRecalc(mMinSize)) {
     return mMinSize;
@@ -825,24 +825,24 @@ nsBoxFrame::GetMinSize(nsBoxLayoutState&
   if (IsCollapsed())
     return size;
 
   // if the size was not completely redefined in CSS then ask our children
   bool widthSet, heightSet;
   if (!nsIFrame::AddCSSMinSize(aBoxLayoutState, this, size, widthSet, heightSet))
   {
     if (mLayoutManager) {
-      nsSize layoutSize = mLayoutManager->GetMinSize(this, aBoxLayoutState);
+      nsSize layoutSize = mLayoutManager->GetXULMinSize(this, aBoxLayoutState);
       if (!widthSet)
         size.width = layoutSize.width;
       if (!heightSet)
         size.height = layoutSize.height;
     }
     else {
-      size = nsBox::GetMinSize(aBoxLayoutState);
+      size = nsBox::GetXULMinSize(aBoxLayoutState);
     }
   }
   
   mMinSize = size;
 
   return size;
 }
 
@@ -1782,17 +1782,17 @@ nsBoxFrame::DisplayDebugInfoFor(nsIFrame
 
                     bool widthSet, heightSet;
                     nsIFrame::AddCSSPrefSize(child, prefSizeCSS, widthSet, heightSet);
                     nsIFrame::AddCSSMinSize (state, child, minSizeCSS, widthSet, heightSet);
                     nsIFrame::AddCSSMaxSize (child, maxSizeCSS, widthSet, heightSet);
                     nsIFrame::AddCSSFlex    (child, flexCSS);
 
                     nsSize prefSize = child->GetPrefSize(state);
-                    nsSize minSize = child->GetMinSize(state);
+                    nsSize minSize = child->GetXULMinSize(state);
                     nsSize maxSize = child->GetMaxSize(state);
                     nscoord flexSize = child->GetFlex();
                     nscoord ascentSize = child->GetBoxAscent(state);
 
                     char min[100];
                     char pref[100];
                     char max[100];
                     char calc[100];
diff --git a/layout/xul/nsBoxFrame.h b/layout/xul/nsBoxFrame.h
--- a/layout/xul/nsBoxFrame.h
+++ b/layout/xul/nsBoxFrame.h
@@ -57,17 +57,17 @@ public:
   // call this method to get the rect so you don't draw on the debug border or outer border.
 
   virtual void SetLayoutManager(nsBoxLayout* aLayout) override { mLayoutManager = aLayout; }
   virtual nsBoxLayout* GetLayoutManager() override { return mLayoutManager; }
 
   virtual nsresult RelayoutChildAtOrdinal(nsIFrame* aChild) override;
 
   virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetFlex() override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
 #ifdef DEBUG_LAYOUT
   virtual nsresult SetDebug(nsBoxLayoutState& aBoxLayoutState, bool aDebug) override;
   virtual nsresult GetDebug(bool& aDebug) override;
 #endif
   virtual Valignment GetVAlign() const override { return mValign; }
diff --git a/layout/xul/nsBoxLayout.cpp b/layout/xul/nsBoxLayout.cpp
--- a/layout/xul/nsBoxLayout.cpp
+++ b/layout/xul/nsBoxLayout.cpp
@@ -38,17 +38,17 @@ nsBoxLayout::GetPrefSize(nsIFrame* aBox,
 {
   nsSize pref (0, 0);
   AddBorderAndPadding(aBox, pref);
 
   return pref;
 }
 
 nsSize
-nsBoxLayout::GetMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
+nsBoxLayout::GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
 {
   nsSize minSize (0,0);
   AddBorderAndPadding(aBox, minSize);
   return minSize;
 }
 
 nsSize
 nsBoxLayout::GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
diff --git a/layout/xul/nsBoxLayout.h b/layout/xul/nsBoxLayout.h
--- a/layout/xul/nsBoxLayout.h
+++ b/layout/xul/nsBoxLayout.h
@@ -32,17 +32,17 @@ public:
 
   NS_DECL_ISUPPORTS
 
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_BOX_LAYOUT_IID)
 
   NS_IMETHOD Layout(nsIFrame* aBox, nsBoxLayoutState& aState);
 
   virtual nsSize GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState);
-  virtual nsSize GetMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState);
+  virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState);
   virtual nsSize GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState);
   virtual nscoord GetAscent(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState);
   virtual void ChildrenInserted(nsIFrame* aBox, nsBoxLayoutState& aState,
                                 nsIFrame* aPrevBox,
                                 const nsFrameList::Slice& aNewChildren) {}
   virtual void ChildrenAppended(nsIFrame* aBox, nsBoxLayoutState& aState,
                                 const nsFrameList::Slice& aNewChildren) {}
   virtual void ChildrenRemoved(nsIFrame* aBox, nsBoxLayoutState& aState, nsIFrame* aChildList) {}
diff --git a/layout/xul/nsImageBoxFrame.cpp b/layout/xul/nsImageBoxFrame.cpp
--- a/layout/xul/nsImageBoxFrame.cpp
+++ b/layout/xul/nsImageBoxFrame.cpp
@@ -564,17 +564,17 @@ nsImageBoxFrame::GetPrefSize(nsBoxLayout
   size.width += borderPadding.LeftRight();
   size.height += borderPadding.TopBottom();
 
   bool widthSet, heightSet;
   nsIFrame::AddCSSPrefSize(this, size, widthSet, heightSet);
   NS_ASSERTION(size.width != NS_INTRINSICSIZE && size.height != NS_INTRINSICSIZE,
                "non-intrinsic size expected");
 
-  nsSize minSize = GetMinSize(aState);
+  nsSize minSize = GetXULMinSize(aState);
   nsSize maxSize = GetMaxSize(aState);
 
   if (!widthSet && !heightSet) {
     if (minSize.width != NS_INTRINSICSIZE)
       minSize.width -= borderPadding.LeftRight();
     if (minSize.height != NS_INTRINSICSIZE)
       minSize.height -= borderPadding.TopBottom();
     if (maxSize.width != NS_INTRINSICSIZE)
@@ -618,17 +618,17 @@ nsImageBoxFrame::GetPrefSize(nsBoxLayout
 
     size.height += borderPadding.TopBottom();
   }
 
   return BoundsCheck(minSize, size, maxSize);
 }
 
 nsSize
-nsImageBoxFrame::GetMinSize(nsBoxLayoutState& aState)
+nsImageBoxFrame::GetXULMinSize(nsBoxLayoutState& aState)
 {
   // An image can always scale down to (0,0).
   nsSize size(0,0);
   DISPLAY_MIN_SIZE(this, size);
   AddBorderAndPadding(size);
   bool widthSet, heightSet;
   nsIFrame::AddCSSMinSize(aState, this, size, widthSet, heightSet);
   return size;
diff --git a/layout/xul/nsImageBoxFrame.h b/layout/xul/nsImageBoxFrame.h
--- a/layout/xul/nsImageBoxFrame.h
+++ b/layout/xul/nsImageBoxFrame.h
@@ -43,17 +43,17 @@ public:
   typedef mozilla::image::DrawResult DrawResult;
   typedef mozilla::layers::ImageContainer ImageContainer;
   typedef mozilla::layers::LayerManager LayerManager;
 
   friend class nsDisplayXULImage;
   NS_DECL_FRAMEARENA_HELPERS
 
   virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
   virtual void MarkIntrinsicISizesDirty() override;
 
   nsresult Notify(imgIRequest *aRequest, int32_t aType, const nsIntRect* aData);
 
   friend nsIFrame* NS_NewImageBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
 
   virtual void Init(nsIContent*       aContent,
diff --git a/layout/xul/nsLeafBoxFrame.cpp b/layout/xul/nsLeafBoxFrame.cpp
--- a/layout/xul/nsLeafBoxFrame.cpp
+++ b/layout/xul/nsLeafBoxFrame.cpp
@@ -126,21 +126,21 @@ nsLeafBoxFrame::BuildDisplayList(nsDispl
 /* virtual */ nscoord
 nsLeafBoxFrame::GetMinISize(nsRenderingContext *aRenderingContext)
 {
   nscoord result;
   DISPLAY_MIN_WIDTH(this, result);
   nsBoxLayoutState state(PresContext(), aRenderingContext);
 
   WritingMode wm = GetWritingMode();
-  LogicalSize minSize(wm, GetMinSize(state));
+  LogicalSize minSize(wm, GetXULMinSize(state));
 
-  // GetMinSize returns border-box size, and we want to return content
+  // GetXULMinSize returns border-box size, and we want to return content
   // inline-size.  Since Reflow uses the reflow state's border and padding, we
-  // actually just want to subtract what GetMinSize added, which is the
+  // actually just want to subtract what GetXULMinSize added, which is the
   // result of GetBorderAndPadding.
   nsMargin bp;
   GetBorderAndPadding(bp);
 
   result = minSize.ISize(wm) - LogicalMargin(wm, bp).IStartEnd(wm);
 
   return result;
 }
@@ -244,26 +244,26 @@ nsLeafBoxFrame::Reflow(nsPresContext*   
 
   nsMargin m;
   m = aReflowState.ComputedPhysicalBorderPadding();
 
   //GetBorderAndPadding(m);
 
   // this happens sometimes. So lets handle it gracefully.
   if (aReflowState.ComputedHeight() == 0) {
-    nsSize minSize = GetMinSize(state);
+    nsSize minSize = GetXULMinSize(state);
     computedSize.height = minSize.height - m.top - m.bottom;
   }
 
   nsSize prefSize(0,0);
 
   // if we are told to layout intrinic then get our preferred size.
   if (computedSize.width == NS_INTRINSICSIZE || computedSize.height == NS_INTRINSICSIZE) {
      prefSize = GetPrefSize(state);
-     nsSize minSize = GetMinSize(state);
+     nsSize minSize = GetXULMinSize(state);
      nsSize maxSize = GetMaxSize(state);
      prefSize = BoundsCheck(minSize, prefSize, maxSize);
   }
 
   // get our desiredSize
   if (aReflowState.ComputedWidth() == NS_INTRINSICSIZE) {
     computedSize.width = prefSize.width;
   } else {
@@ -348,19 +348,19 @@ nsLeafBoxFrame::CharacterDataChanged(Cha
 
 /* virtual */ nsSize
 nsLeafBoxFrame::GetPrefSize(nsBoxLayoutState& aState)
 {
     return nsBox::GetPrefSize(aState);
 }
 
 /* virtual */ nsSize
-nsLeafBoxFrame::GetMinSize(nsBoxLayoutState& aState)
+nsLeafBoxFrame::GetXULMinSize(nsBoxLayoutState& aState)
 {
-    return nsBox::GetMinSize(aState);
+    return nsBox::GetXULMinSize(aState);
 }
 
 /* virtual */ nsSize
 nsLeafBoxFrame::GetMaxSize(nsBoxLayoutState& aState)
 {
     return nsBox::GetMaxSize(aState);
 }
 
diff --git a/layout/xul/nsLeafBoxFrame.h b/layout/xul/nsLeafBoxFrame.h
--- a/layout/xul/nsLeafBoxFrame.h
+++ b/layout/xul/nsLeafBoxFrame.h
@@ -12,17 +12,17 @@
 class nsLeafBoxFrame : public nsLeafFrame
 {
 public:
   NS_DECL_FRAMEARENA_HELPERS
 
   friend nsIFrame* NS_NewLeafBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
 
   virtual nsSize GetPrefSize(nsBoxLayoutState& aState) override;
-  virtual nsSize GetMinSize(nsBoxLayoutState& aState) override;
+  virtual nsSize GetXULMinSize(nsBoxLayoutState& aState) override;
   virtual nsSize GetMaxSize(nsBoxLayoutState& aState) override;
   virtual nscoord GetFlex() override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aState) override;
 
   virtual nsIAtom* GetType() const override;
   virtual bool IsFrameOfType(uint32_t aFlags) const override
   {
     // This is bogus, but it's what we've always done.
diff --git a/layout/xul/nsListBoxLayout.cpp b/layout/xul/nsListBoxLayout.cpp
--- a/layout/xul/nsListBoxLayout.cpp
+++ b/layout/xul/nsListBoxLayout.cpp
@@ -42,19 +42,19 @@ nsListBoxLayout::GetPrefSize(nsIFrame* a
       if (width > pref.width)
         pref.width = width;
     }
   }
   return pref;
 }
 
 nsSize
-nsListBoxLayout::GetMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
+nsListBoxLayout::GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState)
 {
-  nsSize minSize = nsGridRowGroupLayout::GetMinSize(aBox, aBoxLayoutState);
+  nsSize minSize = nsGridRowGroupLayout::GetXULMinSize(aBox, aBoxLayoutState);
 
   nsListBoxBodyFrame* frame = static_cast<nsListBoxBodyFrame*>(aBox);
   if (frame) {
     nscoord rowheight = frame->GetRowHeightAppUnits();
     minSize.height = frame->GetRowCount() * rowheight;
     // Pad the height.
     nscoord y = frame->GetAvailableHeight();
     if (minSize.height > y && y > 0 && rowheight > 0) {
diff --git a/layout/xul/nsListBoxLayout.h b/layout/xul/nsListBoxLayout.h
--- a/layout/xul/nsListBoxLayout.h
+++ b/layout/xul/nsListBoxLayout.h
@@ -16,17 +16,17 @@ class nsBoxLayoutState;
 class nsListBoxLayout : public nsGridRowGroupLayout
 {
 public:
   nsListBoxLayout();
 
   // nsBoxLayout
   NS_IMETHOD Layout(nsIFrame* aBox, nsBoxLayoutState& aState) override;
   virtual nsSize GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
 
 protected:
   NS_IMETHOD LayoutInternal(nsIFrame* aBox, nsBoxLayoutState& aState);
 };
 
 #endif
 
diff --git a/layout/xul/nsMenuFrame.cpp b/layout/xul/nsMenuFrame.cpp
--- a/layout/xul/nsMenuFrame.cpp
+++ b/layout/xul/nsMenuFrame.cpp
@@ -711,19 +711,19 @@ nsMenuFrame::IsSizedToPopup(nsIContent* 
 {
   nsAutoString sizedToPopup;
   aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::sizetopopup, sizedToPopup);
   return sizedToPopup.EqualsLiteral("always") ||
          (!aRequireAlways && sizedToPopup.EqualsLiteral("pref"));
 }
 
 nsSize
-nsMenuFrame::GetMinSize(nsBoxLayoutState& aBoxLayoutState)
+nsMenuFrame::GetXULMinSize(nsBoxLayoutState& aBoxLayoutState)
 {
-  nsSize size = nsBoxFrame::GetMinSize(aBoxLayoutState);
+  nsSize size = nsBoxFrame::GetXULMinSize(aBoxLayoutState);
   DISPLAY_MIN_SIZE(this, size);
 
   if (IsSizedToPopup(mContent, true))
     SizeToPopup(aBoxLayoutState, size);
 
   return size;
 }
 
@@ -1386,17 +1386,17 @@ nsMenuFrame::GetPrefSize(nsBoxLayoutStat
   DISPLAY_PREF_SIZE(this, size);
 
   // If we are using sizetopopup="always" then
   // nsBoxFrame will already have enforced the minimum size
   if (!IsSizedToPopup(mContent, true) &&
       IsSizedToPopup(mContent, false) &&
       SizeToPopup(aState, size)) {
     // We now need to ensure that size is within the min - max range.
-    nsSize minSize = nsBoxFrame::GetMinSize(aState);
+    nsSize minSize = nsBoxFrame::GetXULMinSize(aState);
     nsSize maxSize = GetMaxSize(aState);
     size = BoundsCheck(minSize, size, maxSize);
   }
 
   return size;
 }
 
 NS_IMETHODIMP
diff --git a/layout/xul/nsMenuFrame.h b/layout/xul/nsMenuFrame.h
--- a/layout/xul/nsMenuFrame.h
+++ b/layout/xul/nsMenuFrame.h
@@ -76,17 +76,17 @@ class nsMenuFrame final : public nsBoxFr
 public:
   explicit nsMenuFrame(nsStyleContext* aContext);
 
   NS_DECL_QUERYFRAME_TARGET(nsMenuFrame)
   NS_DECL_QUERYFRAME
   NS_DECL_FRAMEARENA_HELPERS
 
   NS_IMETHOD DoLayout(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual void Init(nsIContent*       aContent,
                     nsContainerFrame* aParent,
                     nsIFrame*         aPrevInFlow) override;
 
 #ifdef DEBUG_LAYOUT
   virtual nsresult SetDebug(nsBoxLayoutState& aState, bool aDebug) override;
diff --git a/layout/xul/nsMenuPopupFrame.cpp b/layout/xul/nsMenuPopupFrame.cpp
--- a/layout/xul/nsMenuPopupFrame.cpp
+++ b/layout/xul/nsMenuPopupFrame.cpp
@@ -453,17 +453,17 @@ nsMenuPopupFrame::LayoutPopup(nsBoxLayou
         return;
       }
     }
   }
 
   // get the preferred, minimum and maximum size. If the menu is sized to the
   // popup, then the popup's width is the menu's width.
   nsSize prefSize = GetPrefSize(aState);
-  nsSize minSize = GetMinSize(aState); 
+  nsSize minSize = GetXULMinSize(aState); 
   nsSize maxSize = GetMaxSize(aState);
 
   if (aSizedToPopup) {
     prefSize.width = aParentMenu->GetRect().width;
   }
   prefSize = BoundsCheck(minSize, prefSize, maxSize);
 
   // if the size changed then set the bounds to be the preferred size
diff --git a/layout/xul/nsSliderFrame.cpp b/layout/xul/nsSliderFrame.cpp
--- a/layout/xul/nsSliderFrame.cpp
+++ b/layout/xul/nsSliderFrame.cpp
@@ -1338,22 +1338,22 @@ nsSliderFrame::DestroyFrom(nsIFrame* aDe
 nsSize
 nsSliderFrame::GetPrefSize(nsBoxLayoutState& aState)
 {
   EnsureOrient();
   return nsBoxFrame::GetPrefSize(aState);
 }
 
 nsSize
-nsSliderFrame::GetMinSize(nsBoxLayoutState& aState)
+nsSliderFrame::GetXULMinSize(nsBoxLayoutState& aState)
 {
   EnsureOrient();
 
   // our min size is just our borders and padding
-  return nsBox::GetMinSize(aState);
+  return nsBox::GetXULMinSize(aState);
 }
 
 nsSize
 nsSliderFrame::GetMaxSize(nsBoxLayoutState& aState)
 {
   EnsureOrient();
   return nsBoxFrame::GetMaxSize(aState);
 }
diff --git a/layout/xul/nsSliderFrame.h b/layout/xul/nsSliderFrame.h
--- a/layout/xul/nsSliderFrame.h
+++ b/layout/xul/nsSliderFrame.h
@@ -51,17 +51,17 @@ public:
 
 #ifdef DEBUG_FRAME_DUMP
   virtual nsresult GetFrameName(nsAString& aResult) const override {
     return MakeFrameName(NS_LITERAL_STRING("SliderFrame"), aResult);
   }
 #endif
 
   virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
   NS_IMETHOD DoLayout(nsBoxLayoutState& aBoxLayoutState) override;
 
   // nsIFrame overrides
   virtual void DestroyFrom(nsIFrame* aDestructRoot) override;
 
   virtual void BuildDisplayListForChildren(nsDisplayListBuilder*   aBuilder,
                                            const nsRect&           aDirtyRect,
diff --git a/layout/xul/nsSplitterFrame.cpp b/layout/xul/nsSplitterFrame.cpp
--- a/layout/xul/nsSplitterFrame.cpp
+++ b/layout/xul/nsSplitterFrame.cpp
@@ -664,17 +664,17 @@ nsSplitterFrameInner::MouseDown(nsIDOMEv
     nsIContent* content = childBox->GetContent();
     nsIDocument* doc = content->OwnerDoc();
     int32_t dummy;
     nsIAtom* atom = doc->BindingManager()->ResolveTag(content, &dummy);
 
     // skip over any splitters
     if (atom != nsGkAtoms::splitter) { 
         nsSize prefSize = childBox->GetPrefSize(state);
-        nsSize minSize = childBox->GetMinSize(state);
+        nsSize minSize = childBox->GetXULMinSize(state);
         nsSize maxSize = nsBox::BoundsCheckMinMax(minSize, childBox->GetMaxSize(state));
         prefSize = nsBox::BoundsCheck(minSize, prefSize, maxSize);
 
         mOuter->AddMargin(childBox, minSize);
         mOuter->AddMargin(childBox, prefSize);
         mOuter->AddMargin(childBox, maxSize);
 
         nscoord flex = childBox->GetFlex();
diff --git a/layout/xul/nsSprocketLayout.cpp b/layout/xul/nsSprocketLayout.cpp
--- a/layout/xul/nsSprocketLayout.cpp
+++ b/layout/xul/nsSprocketLayout.cpp
@@ -316,17 +316,17 @@ nsSprocketLayout::Layout(nsIFrame* aBox,
 
       if (!childBoxSize->bogus) {
         // We have a valid box size entry.  This entry already contains information about our
         // sizes along the axis of the box (e.g., widths in a horizontal box).  If our default
         // ALIGN is not stretch, however, then we also need to know the child's size along the
         // opposite axis.
         if (!(frameState & NS_STATE_AUTO_STRETCH)) {
            nsSize prefSize = child->GetPrefSize(aState);
-           nsSize minSize = child->GetMinSize(aState);
+           nsSize minSize = child->GetXULMinSize(aState);
            nsSize maxSize = child->GetMaxSize(aState);
            prefSize = nsBox::BoundsCheck(minSize, prefSize, maxSize);
        
            AddMargin(child, prefSize);
            width = std::min(prefSize.width, originalClientRect.width);
            height = std::min(prefSize.height, originalClientRect.height);
         }
       }
@@ -457,17 +457,17 @@ nsSprocketLayout::Layout(nsIFrame* aBox,
 
       child->SetBounds(aState, childRect);
       bool sizeChanged = (childRect.width != oldRect.width ||
                             childRect.height != oldRect.height);
 
       if (sizeChanged) {
         // Our size is different.  Sanity check against our maximum allowed size to ensure
         // we didn't exceed it.
-        nsSize minSize = child->GetMinSize(aState);
+        nsSize minSize = child->GetXULMinSize(aState);
         nsSize maxSize = child->GetMaxSize(aState);
         maxSize = nsBox::BoundsCheckMinMax(minSize, maxSize);
 
         // make sure the size is in our max size.
         if (childRect.width > maxSize.width)
           childRect.width = maxSize.width;
 
         if (childRect.height > maxSize.height)
@@ -740,17 +740,17 @@ nsSprocketLayout::PopulateBoxSizes(nsIFr
     bool collapsed = child->IsCollapsed();
 
     if (!collapsed) {
     // only one flexible child? Cool we will just make its preferred size
     // 0 then and not even have to ask for it.
     //if (flexes != 1)  {
 
       pref = child->GetPrefSize(aState);
-      minSize = child->GetMinSize(aState);
+      minSize = child->GetXULMinSize(aState);
       maxSize = nsBox::BoundsCheckMinMax(minSize, child->GetMaxSize(aState));
       ascent = child->GetBoxAscent(aState);
       nsMargin margin;
       child->GetMargin(margin);
       ascent += margin.top;
     //}
 
       pref = nsBox::BoundsCheck(minSize, pref, maxSize);
@@ -1040,17 +1040,17 @@ nsSprocketLayout::ChildResized(nsIFrame*
 
       // if we are a horizontal box see if the child will fit inside us.
       if ( childActualHeight > containingHeight) {
             // if we are a horizontal box and the child is bigger than our height
 
             // ok if the height changed then we need to reflow everyone but us at the new height
             // so we will set the changed index to be us. And signal that we need a new pass.
 
-            nsSize min = aChild->GetMinSize(aState);            
+            nsSize min = aChild->GetXULMinSize(aState);            
             nsSize max = nsBox::BoundsCheckMinMax(min, aChild->GetMaxSize(aState));
             AddMargin(aChild, max);
 
             if (isHorizontal)
               childActualHeight = max.height < childActualHeight ? max.height : childActualHeight;
             else
               childActualHeight = max.width < childActualHeight ? max.width : childActualHeight;
 
@@ -1075,17 +1075,17 @@ nsSprocketLayout::ChildResized(nsIFrame*
                   node = node->next;
                 }
 
               }              
             }
       } 
       
       if (childActualWidth > childLayoutWidth) {
-            nsSize min = aChild->GetMinSize(aState);
+            nsSize min = aChild->GetXULMinSize(aState);
             nsSize max = nsBox::BoundsCheckMinMax(min, aChild->GetMaxSize(aState));
             
             AddMargin(aChild, max);
 
             // our width now becomes the new size
 
             if (isHorizontal)
               childActualWidth = max.width < childActualWidth ? max.width : childActualWidth;
@@ -1355,17 +1355,17 @@ nsSprocketLayout::GetPrefSize(nsIFrame* 
     
    // now add our border and padding
    AddBorderAndPadding(aBox, vpref);
 
   return vpref;
 }
 
 nsSize
-nsSprocketLayout::GetMinSize(nsIFrame* aBox, nsBoxLayoutState& aState)
+nsSprocketLayout::GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
    nsSize minSize (0, 0);
    bool isHorizontal = IsHorizontal(aBox);
 
    nscoord biggestMin = 0;
 
 
    // run through all the children and get their min, max, and preferred sizes
@@ -1377,17 +1377,17 @@ nsSprocketLayout::GetMinSize(nsIFrame* a
    bool isEqual = !!(frameState & NS_STATE_EQUAL_SIZE);
    int32_t count = 0;
 
    while (child) 
    {  
        // ignore collapsed children
       if (!child->IsCollapsed())
       {
-        nsSize min = child->GetMinSize(aState);
+        nsSize min = child->GetXULMinSize(aState);
         nsSize pref(0,0);
         
         // if the child is not flexible then
         // its min size is its pref size.
         if (child->GetFlex() == 0) {
             pref = child->GetPrefSize(aState);
             if (isHorizontal)
                min.width = pref.width;
@@ -1447,17 +1447,17 @@ nsSprocketLayout::GetMaxSize(nsIFrame* a
    int32_t count = 0;
 
    while (child) 
    {  
       // ignore collapsed children
       if (!child->IsCollapsed())
       {
         // if completely redefined don't even ask our child for its size.
-        nsSize min = child->GetMinSize(aState);
+        nsSize min = child->GetXULMinSize(aState);
         nsSize max = nsBox::BoundsCheckMinMax(min, child->GetMaxSize(aState));
 
         AddMargin(child, max);
         AddSmallestSize(maxSize, max, isHorizontal);
 
         if (isEqual) {
           if (isHorizontal)
           {
diff --git a/layout/xul/nsSprocketLayout.h b/layout/xul/nsSprocketLayout.h
--- a/layout/xul/nsSprocketLayout.h
+++ b/layout/xul/nsSprocketLayout.h
@@ -66,17 +66,17 @@ class nsSprocketLayout : public nsBoxLay
 public:
 
   friend nsresult NS_NewSprocketLayout(nsCOMPtr<nsBoxLayout>& aNewLayout);
   static void Shutdown();
 
   NS_IMETHOD Layout(nsIFrame* aBox, nsBoxLayoutState& aState) override;
 
   virtual nsSize GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetAscent(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
 
   nsSprocketLayout();
 
   static bool IsHorizontal(nsIFrame* aBox);
 
   static void SetLargestSize(nsSize& aSize1, const nsSize& aSize2, bool aIsHorizontal);
diff --git a/layout/xul/nsStackLayout.cpp b/layout/xul/nsStackLayout.cpp
--- a/layout/xul/nsStackLayout.cpp
+++ b/layout/xul/nsStackLayout.cpp
@@ -80,24 +80,24 @@ nsStackLayout::GetPrefSize(nsIFrame* aBo
   }
 
   AddBorderAndPadding(aBox, prefSize);
 
   return prefSize;
 }
 
 nsSize
-nsStackLayout::GetMinSize(nsIFrame* aBox, nsBoxLayoutState& aState)
+nsStackLayout::GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   nsSize minSize (0, 0);
 
   nsIFrame* child = nsBox::GetChildBox(aBox);
   while (child) {
     if (child->StyleXUL()->mStretchStack) {
-      nsSize min = child->GetMinSize(aState);
+      nsSize min = child->GetXULMinSize(aState);
 
       AddMargin(child, min);
       nsMargin offset;
       GetOffset(child, offset);
       min.width += offset.LeftRight();
       min.height += offset.TopBottom();
       AddLargestSize(minSize, min);
     }
@@ -113,17 +113,17 @@ nsStackLayout::GetMinSize(nsIFrame* aBox
 nsSize
 nsStackLayout::GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aState)
 {
   nsSize maxSize (NS_INTRINSICSIZE, NS_INTRINSICSIZE);
 
   nsIFrame* child = nsBox::GetChildBox(aBox);
   while (child) {
     if (child->StyleXUL()->mStretchStack) {
-      nsSize min = child->GetMinSize(aState);
+      nsSize min = child->GetXULMinSize(aState);
       nsSize max = child->GetMaxSize(aState);
 
       max = nsBox::BoundsCheckMinMax(min, max);
 
       AddMargin(child, max);
       nsMargin offset;
       GetOffset(child, offset);
       max.width += offset.LeftRight();
@@ -293,17 +293,17 @@ nsStackLayout::Layout(nsIFrame* aBox, ns
           //   left only - offset from left edge, preferred width
           //   right only - offset from right edge, preferred width
           //   left and right - offset from left and right edges, width in between this
           //   neither - no offset, full width of stack
           // Vertical direction is similar.
           //
           // Margins on the child are also included in the edge offsets
           if (offsetSpecified) {
-            nsSize min = child->GetMinSize(aState);
+            nsSize min = child->GetXULMinSize(aState);
             nsSize max = child->GetMaxSize(aState);
             if (offsetSpecified & SPECIFIED_LEFT) {
               childRect.x = clientRect.x + offset.left + margin.left;
               if (offsetSpecified & SPECIFIED_RIGHT) {
                 nscoord width = clientRect.width - offset.LeftRight() - margin.LeftRight();
                 childRect.width = clamped(width, min.width, max.width);
               }
               else {
diff --git a/layout/xul/nsStackLayout.h b/layout/xul/nsStackLayout.h
--- a/layout/xul/nsStackLayout.h
+++ b/layout/xul/nsStackLayout.h
@@ -30,17 +30,17 @@ public:
   friend nsresult NS_NewStackLayout(nsCOMPtr<nsBoxLayout>& aNewLayout);
   static void Shutdown();
 
   nsStackLayout();
 
   NS_IMETHOD Layout(nsIFrame* aBox, nsBoxLayoutState& aState) override;
 
   virtual nsSize GetPrefSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetMaxSize(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetAscent(nsIFrame* aBox, nsBoxLayoutState& aBoxLayoutState) override;
 
   // get the child offsets for aChild and set them in aMargin. Returns a
   // bitfield mask of the SPECIFIED_LEFT, SPECIFIED_RIGHT, SPECIFIED_TOP and
   // SPECIFIED_BOTTOM offsets indicating which sides have been specified by
   // attributes.
   static uint8_t GetOffset(nsIFrame* aChild, nsMargin& aMargin);
diff --git a/layout/xul/nsTextBoxFrame.cpp b/layout/xul/nsTextBoxFrame.cpp
--- a/layout/xul/nsTextBoxFrame.cpp
+++ b/layout/xul/nsTextBoxFrame.cpp
@@ -1121,17 +1121,17 @@ nsTextBoxFrame::GetPrefSize(nsBoxLayoutS
 
     return size;
 }
 
 /**
  * Ok return our dimensions
  */
 nsSize
-nsTextBoxFrame::GetMinSize(nsBoxLayoutState& aBoxLayoutState)
+nsTextBoxFrame::GetXULMinSize(nsBoxLayoutState& aBoxLayoutState)
 {
     CalcTextSize(aBoxLayoutState);
 
     nsSize size = mTextSize;
     DISPLAY_MIN_SIZE(this, size);
 
     // if there is cropping our min width becomes our border and padding
     if (mCropType != CropNone && mCropType != CropAuto) {
diff --git a/layout/xul/nsTextBoxFrame.h b/layout/xul/nsTextBoxFrame.h
--- a/layout/xul/nsTextBoxFrame.h
+++ b/layout/xul/nsTextBoxFrame.h
@@ -15,17 +15,17 @@ class nsFontMetrics;
 class nsTextBoxFrame : public nsLeafBoxFrame
 {
 public:
   NS_DECL_QUERYFRAME_TARGET(nsTextBoxFrame)
   NS_DECL_QUERYFRAME
   NS_DECL_FRAMEARENA_HELPERS
 
   virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
   NS_IMETHOD DoLayout(nsBoxLayoutState& aBoxLayoutState) override;
   virtual void MarkIntrinsicISizesDirty() override;
 
   enum CroppingStyle { CropNone, CropLeft, CropRight, CropCenter, CropAuto };
 
   friend nsIFrame* NS_NewTextBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
 
diff --git a/layout/xul/tree/nsTreeBodyFrame.cpp b/layout/xul/tree/nsTreeBodyFrame.cpp
--- a/layout/xul/tree/nsTreeBodyFrame.cpp
+++ b/layout/xul/tree/nsTreeBodyFrame.cpp
@@ -178,17 +178,17 @@ nsTreeBodyFrame::Init(nsIContent*       
 
   if (LookAndFeel::GetInt(LookAndFeel::eIntID_UseOverlayScrollbars) != 0) {
     mScrollbarActivity = new ScrollbarActivity(
                            static_cast<nsIScrollbarMediator*>(this));
   }
 }
 
 nsSize
-nsTreeBodyFrame::GetMinSize(nsBoxLayoutState& aBoxLayoutState)
+nsTreeBodyFrame::GetXULMinSize(nsBoxLayoutState& aBoxLayoutState)
 {
   EnsureView();
 
   nsIContent* baseElement = GetBaseElement();
 
   nsSize min(0,0);
   int32_t desiredRows;
   if (MOZ_UNLIKELY(!baseElement)) {
diff --git a/layout/xul/tree/nsTreeBodyFrame.h b/layout/xul/tree/nsTreeBodyFrame.h
--- a/layout/xul/tree/nsTreeBodyFrame.h
+++ b/layout/xul/tree/nsTreeBodyFrame.h
@@ -119,17 +119,17 @@ public:
   nsresult BeginUpdateBatch();
   nsresult EndUpdateBatch();
   nsresult ClearStyleAndImageCaches();
 
   void CancelImageRequests();
 
   void ManageReflowCallback(const nsRect& aRect, nscoord aHorzWidth);
 
-  virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState) override;
+  virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual void SetBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
                          bool aRemoveOverflowArea = false) override;
 
   // nsIReflowCallback
   virtual bool ReflowFinished() override;
   virtual void ReflowCallbackCanceled() override;
 
   // nsICSSPseudoComparator
