From: L. David Baron <dbaron@dbaron.org>

In a constrained height situation, we need to reflow anything with floats.  (Bug 563584)  Fixes assertion on layout/generic/crashtests/408883-1.html .

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1862,16 +1862,30 @@ nsBlockFrame::ReflowDirtyLines(nsBlockRe
       line->MarkDirty();
       line->ClearPreviousMarginDirty();
     } else if (line->mBounds.YMost() + deltaY > aState.mBottomEdge) {
       // Lines that aren't dirty but get slid past our height constraint must
       // be reflowed.
       line->MarkDirty();
     }
 
+    // If we have a constrained height (i.e., breaking columns/pages),
+    // and the distance to the bottom might have changed, then we need
+    // to reflow any line that might have floats in it, both because the
+    // breakpoints within those floats may have changed and because we
+    // might have to push/pull the floats in their entirety.
+    // FIXME: What about a deltaY or height change that forces us to
+    // push lines?  Why does that work?
+    if (!line->IsDirty() &&
+        aState.mReflowState.availableHeight != NS_UNCONSTRAINEDSIZE &&
+        (deltaY != 0 || aState.mReflowState.mFlags.mVResize) &&
+        (line->IsBlock() || line->HasFloats() || line->HadFloatPushed())) {
+      line->MarkDirty();
+    }
+
     if (!line->IsDirty()) {
       // See if there's any reflow damage that requires that we mark the
       // line dirty.
       PropagateFloatDamage(aState, line, deltaY);
     }
 
     if (needToRecoverState && line->IsDirty()) {
       // We need to reconstruct the bottom margin only if we didn't
diff --git a/layout/generic/nsLineLayout.h b/layout/generic/nsLineLayout.h
--- a/layout/generic/nsLineLayout.h
+++ b/layout/generic/nsLineLayout.h
@@ -365,16 +365,19 @@ public:
    * This can't be null. It usually returns a block frame but may return
    * some other kind of frame when inline frames are reflowed in a non-block
    * context (e.g. MathML or floating first-letter).
    */
   nsIFrame* GetLineContainerFrame() const { return mBlockReflowState->frame; }
   const nsLineList::iterator* GetLine() const {
     return GetFlag(LL_GOTLINEBOX) ? &mLineBox : nsnull;
   }
+  nsLineList::iterator* GetLine() {
+    return GetFlag(LL_GOTLINEBOX) ? &mLineBox : nsnull;
+  }
   
   /**
    * Returns the accumulated advance width of frames before the current frame
    * on the line, plus the line container's left border+padding.
    * This is always positive, the advance width is measured from
    * the right edge for RTL blocks and from the left edge for LTR blocks.
    * In other words, the current frame's distance from the line container's
    * start content edge is:
