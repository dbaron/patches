From: L. David Baron <dbaron@dbaron.org>

Implement the arbitrary-string-to-RGB part of the HTML5 algorithm for backwards-compatible color parsing.  (Bug 121738, bug 227072)

diff --git a/content/base/src/nsAttrValue.cpp b/content/base/src/nsAttrValue.cpp
--- a/content/base/src/nsAttrValue.cpp
+++ b/content/base/src/nsAttrValue.cpp
@@ -1131,36 +1131,44 @@ nsAttrValue::ParseColor(const nsAString&
     return PR_FALSE;
   }
 
   nscolor color;
   // No color names begin with a '#'; in standards mode, all acceptable
   // numeric colors do.
   if (colorStr.First() == '#') {
     colorStr.Cut(0, 1);
+    // FIXME: According to HTML5 we should only accept #rgb values
+    // here in the cases where we're following the "rules for parsing a
+    // legacy color value".  (Does that match the quirks mode check
+    // below?)
     if (NS_HexToRGB(colorStr, &color)) {
       SetColorValue(color, aString);
       return PR_TRUE;
     }
   } else {
     if (NS_ColorNameToRGB(colorStr, &color)) {
       SetColorValue(color, aString);
       return PR_TRUE;
     }
   }
 
-  if (aDocument->GetCompatibilityMode() != eCompatibility_NavQuirks) {
-    return PR_FALSE;
+  // In compatibility mode, try LooseHexToRGB as a fallback for either
+  // of the above two possibilities.
+  // FIXME: HTML5's algorithm for "rules for parsing a legacy color
+  // value" also says we should check CSS system colors.
+  // FIXME: Is quirks mode actually the case where HTML5 says we should
+  // follow the "rules for parsing a legacy color value"?
+  if (aDocument->GetCompatibilityMode() == eCompatibility_NavQuirks &&
+      NS_LooseHexToRGB(colorStr, &color)) {
+    SetColorValue(color, aString);
+    return PR_TRUE;
   }
 
-  // In compatibility mode, try LooseHexToRGB as a fallback for either
-  // of the above two possibilities.
-  NS_LooseHexToRGB(colorStr, &color);
-  SetColorValue(color, aString);
-  return PR_TRUE;
+  return PR_FALSE;
 }
 
 PRBool nsAttrValue::ParseFloatValue(const nsAString& aString)
 {
   ResetIfSet();
 
   PRInt32 ec;
   float val = PromiseFlatString(aString).ToFloat(&ec);
diff --git a/gfx/src/nsColor.cpp b/gfx/src/nsColor.cpp
--- a/gfx/src/nsColor.cpp
+++ b/gfx/src/nsColor.cpp
@@ -150,59 +150,87 @@ NS_GFX_(PRBool) NS_HexToRGB(const nsStri
       // single digit to compute the new value.
       r = (r << 4) | r;
       g = (g << 4) | g;
       b = (b << 4) | b;
     }
     NS_ASSERTION((r >= 0) && (r <= 255), "bad r");
     NS_ASSERTION((g >= 0) && (g <= 255), "bad g");
     NS_ASSERTION((b >= 0) && (b <= 255), "bad b");
-    if (nsnull != aResult) {
-      *aResult = NS_RGB(r, g, b);
-    }
+    *aResult = NS_RGB(r, g, b);
     return PR_TRUE;
   }
 
   // Improperly formatted color value
   return PR_FALSE;
 }
 
-// compatible with legacy Nav behavior
+// This implements part of the algorithm for legacy behavior described in
+// http://www.whatwg.org/specs/web-apps/current-work/complete/common-microsyntaxes.html#rules-for-parsing-a-legacy-color-value
 NS_GFX_(PRBool) NS_LooseHexToRGB(const nsString& aColorSpec, nscolor* aResult)
 {
+  if (aColorSpec.EqualsLiteral("transparent")) {
+    return PR_FALSE;
+  }
+
   int nameLen = aColorSpec.Length();
   const PRUnichar* colorSpec = aColorSpec.get();
+  if (nameLen > 128) {
+    nameLen = 128;
+  }
+
   if ('#' == colorSpec[0]) {
     ++colorSpec;
     --nameLen;
   }
 
-  if (3 < nameLen) {
-    // Convert the ascii to binary
-    int dpc = (nameLen / 3) + (((nameLen % 3) != 0) ? 1 : 0);
-    if (4 < dpc) {
-      dpc = 4;
+  // digits per component
+  int dpc = (nameLen + 2) / 3;
+  int newdpc = dpc;
+
+  // Use only the rightmost 8 characters of each component.
+  if (newdpc > 8) {
+    nameLen -= newdpc - 8;
+    colorSpec += newdpc - 8;
+    newdpc = 8;
+  }
+
+  // And then keep trimming characters at the left until we'd trim one
+  // that would leave a nonzero value, but not past 2 characters per
+  // component.
+  while (newdpc > 2) {
+    PRBool haveNonzero = PR_FALSE;
+    for (int c = 0; c < 3; ++c) {
+      NS_ABORT_IF_FALSE(c * dpc < nameLen,
+                        "should not pass end of string while newdpc > 2");
+      PRUnichar ch = colorSpec[c * dpc];
+      if (('1' <= ch && ch <= '9') ||
+          ('A' <= ch && ch <= 'F') ||
+          ('a' <= ch && ch <= 'f')) {
+        haveNonzero = PR_TRUE;
+        break;
+      }
     }
+    if (haveNonzero) {
+      break;
+    }
+    --newdpc;
+    --nameLen;
+    ++colorSpec;
+  }
 
-    // Translate components from hex to binary
-    int r = ComponentValue(colorSpec, nameLen, 0, dpc);
-    int g = ComponentValue(colorSpec, nameLen, 1, dpc);
-    int b = ComponentValue(colorSpec, nameLen, 2, dpc);
-    NS_ASSERTION((r >= 0) && (r <= 255), "bad r");
-    NS_ASSERTION((g >= 0) && (g <= 255), "bad g");
-    NS_ASSERTION((b >= 0) && (b <= 255), "bad b");
-    if (nsnull != aResult) {
-      *aResult = NS_RGB(r, g, b);
-    }
-  }
-  else {
-    if (nsnull != aResult) {
-      *aResult = NS_RGB(0, 0, 0);
-    }
-  }
+  // Translate components from hex to binary
+  int r = ComponentValue(colorSpec, nameLen, 0, dpc);
+  int g = ComponentValue(colorSpec, nameLen, 1, dpc);
+  int b = ComponentValue(colorSpec, nameLen, 2, dpc);
+  NS_ASSERTION((r >= 0) && (r <= 255), "bad r");
+  NS_ASSERTION((g >= 0) && (g <= 255), "bad g");
+  NS_ASSERTION((b >= 0) && (b <= 255), "bad b");
+
+  *aResult = NS_RGB(r, g, b);
   return PR_TRUE;
 }
 
 NS_GFX_(PRBool) NS_ColorNameToRGB(const nsAString& aColorName, nscolor* aResult)
 {
   if (!gColorTable) return PR_FALSE;
 
   PRInt32 id = gColorTable->Lookup(aColorName);
