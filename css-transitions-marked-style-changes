From: L. David Baron <dbaron@dbaron.org>

Make style changes know whether they are for transitions or not.  (Bug 435441)  r=bzbarsky

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -1539,17 +1539,17 @@ nsCSSFrameConstructor::nsCSSFrameConstru
   , mCountersDirty(PR_FALSE)
   , mIsDestroyingFrameTree(PR_FALSE)
   , mRebuildAllStyleData(PR_FALSE)
   , mHasRootAbsPosContainingBlock(PR_FALSE)
   , mHoverGeneration(0)
   , mRebuildAllExtraHint(nsChangeHint(0))
 {
   // XXXbz this should be in Init() or something!
-  if (!mPendingRestyles.Init()) {
+  if (!mPendingRestyles.Init() || !mPendingAnimationRestyles.Init()) {
     // now what?
   }
 
 #ifdef DEBUG
   static PRBool gFirstTime = PR_TRUE;
   if (gFirstTime) {
     gFirstTime = PR_FALSE;
     char* flags = PR_GetEnv("GECKO_FRAMECTOR_DEBUG_FLAGS");
@@ -11593,47 +11593,44 @@ nsCSSFrameConstructor::RebuildAllStyleDa
   // change list has frame reconstructs in it (since frames to be
   // reconstructed will still have their old style context pointers
   // until they are destroyed).
   mPresShell->StyleSet()->EndReconstruct();
   batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
 }
 
 void
-nsCSSFrameConstructor::ProcessPendingRestyles()
-{
-  NS_PRECONDITION(mDocument, "No document?  Pshaw!\n");
-  NS_PRECONDITION(!nsContentUtils::IsSafeToRunScript(),
-                  "Missing a script blocker!");
-
-  PRUint32 count = mPendingRestyles.Count();
+nsCSSFrameConstructor::ProcessPendingRestyleTable(
+                   nsDataHashtable<nsISupportsHashKey, RestyleData>& aRestyles)
+{
+  PRUint32 count = aRestyles.Count();
 
   // Make sure to not rebuild quote or counter lists while we're
   // processing restyles
   BeginUpdate();
 
   // loop so that we process any restyle events generated by processing
   while (count) {
     // Use the stack if we can, otherwise fall back on heap-allocation.
     nsAutoTArray<RestyleEnumerateData, RESTYLE_ARRAY_STACKSIZE> restyleArr;
     RestyleEnumerateData* restylesToProcess = restyleArr.AppendElements(count);
   
     if (!restylesToProcess) {
       return;
     }
 
     RestyleEnumerateData* lastRestyle = restylesToProcess;
-    mPendingRestyles.Enumerate(CollectRestyles, &lastRestyle);
+    aRestyles.Enumerate(CollectRestyles, &lastRestyle);
 
     NS_ASSERTION(lastRestyle - restylesToProcess == PRInt32(count),
                  "Enumeration screwed up somehow");
 
     // Clear the hashtable so we don't end up trying to process a restyle we're
     // already processing, sending us into an infinite loop.
-    mPendingRestyles.Clear();
+    aRestyles.Clear();
 
     for (RestyleEnumerateData* currentRestyle = restylesToProcess;
          currentRestyle != lastRestyle;
          ++currentRestyle) {
       ProcessOneRestyle(currentRestyle->mContent,
                         currentRestyle->mRestyleHint,
                         currentRestyle->mChangeHint);
     }
@@ -11641,28 +11638,53 @@ nsCSSFrameConstructor::ProcessPendingRes
     count = mPendingRestyles.Count();
   }
 
   EndUpdate();
 
 #ifdef DEBUG
   mPresShell->VerifyStyleTree();
 #endif
+}
+
+void
+nsCSSFrameConstructor::ProcessPendingRestyles()
+{
+  NS_PRECONDITION(mDocument, "No document?  Pshaw!\n");
+  NS_PRECONDITION(!nsContentUtils::IsSafeToRunScript(),
+                  "Missing a script blocker!");
+
+  // Process non-animation restyles...
+  ProcessPendingRestyleTable(mPendingRestyles);
+
+  // ...and then process animation restyles.  This needs to happen
+  // second because we need to start animations that resulted from the
+  // first set of restyles (e.g., CSS transitions with negative
+  // transition-delay), and because we need to immediately
+  // restyle-with-animation any just-restyled elements that are
+  // mid-transition (since processing the non-animation restyle ignores
+  // the running transition so it can check for a new change on the same
+  // property, and then posts an immediate animation style change).
+  nsPresContext *presContext = mPresShell->GetPresContext();
+  presContext->SetProcessingAnimationStyleChange(PR_TRUE);
+  ProcessPendingRestyleTable(mPendingAnimationRestyles);
+  presContext->SetProcessingAnimationStyleChange(PR_FALSE);
 
   if (mRebuildAllStyleData) {
     // We probably wasted a lot of work up above, but this seems safest
     // and it should be rarely used.
     RebuildAllStyleData(nsChangeHint(0));
   }
 }
 
 void
-nsCSSFrameConstructor::PostRestyleEvent(nsIContent* aContent,
-                                        nsReStyleHint aRestyleHint,
-                                        nsChangeHint aMinChangeHint)
+nsCSSFrameConstructor::PostRestyleEventCommon(nsIContent* aContent,
+                                              nsReStyleHint aRestyleHint,
+                                              nsChangeHint aMinChangeHint,
+                                              PRBool aForAnimation)
 {
   if (NS_UNLIKELY(mPresShell->IsDestroying())) {
     return;
   }
 
   if (aRestyleHint == 0 && !aMinChangeHint) {
     // Nothing to do here
     return;
@@ -11670,22 +11692,25 @@ nsCSSFrameConstructor::PostRestyleEvent(
 
   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eELEMENT),
                "Shouldn't be trying to restyle non-elements directly");
 
   RestyleData existingData;
   existingData.mRestyleHint = nsReStyleHint(0);
   existingData.mChangeHint = NS_STYLE_HINT_NONE;
 
-  mPendingRestyles.Get(aContent, &existingData);
+  nsDataHashtable<nsISupportsHashKey, RestyleData> &restyles =
+    aForAnimation ? mPendingAnimationRestyles : mPendingRestyles;
+
+  restyles.Get(aContent, &existingData);
   existingData.mRestyleHint =
     nsReStyleHint(existingData.mRestyleHint | aRestyleHint);
   NS_UpdateHint(existingData.mChangeHint, aMinChangeHint);
 
-  mPendingRestyles.Put(aContent, existingData);
+  restyles.Put(aContent, existingData);
 
   PostRestyleEventInternal();
 }
     
 void
 nsCSSFrameConstructor::PostRestyleEventInternal()
 {
   if (!mRestyleEvent.IsPending()) {
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -176,16 +176,19 @@ private:
 class nsCSSFrameConstructor
 {
 public:
   nsCSSFrameConstructor(nsIDocument *aDocument, nsIPresShell* aPresShell);
   ~nsCSSFrameConstructor(void) {
     NS_ASSERTION(mUpdateCount == 0, "Dying in the middle of our own update?");
   }
 
+  struct RestyleData;
+  friend struct RestyleData;
+
   // Maintain global objects - gXBLService
   static nsIXBLService * GetXBLService();
   static void ReleaseGlobals() { NS_IF_RELEASE(gXBLService); }
 
   // get the alternate text for a content node
   static void GetAlternateTextFor(nsIContent*    aContent,
                                   nsIAtom*       aTag,  // content object's tag
                                   nsXPIDLString& aAltText);
@@ -269,16 +272,19 @@ private:
   // Note: It's the caller's responsibility to make sure to wrap a
   // ProcessOneRestyle call in a view update batch.
   // This function does not call ProcessAttachedQueue() on the binding manager.
   // If the caller wants that to happen synchronously, it needs to handle that
   // itself.
   void ProcessOneRestyle(nsIContent* aContent, nsReStyleHint aRestyleHint,
                          nsChangeHint aChangeHint);
 
+  void ProcessPendingRestyleTable(
+           nsDataHashtable<nsISupportsHashKey, RestyleData>& aRestyles);
+
 public:
   // Restyling for a ContentInserted (notification after insertion) or
   // for a CharacterDataChanged.  |aContainer| must be non-null; when
   // the container is null, no work is needed.
   void RestyleForInsertOrChange(nsIContent* aContainer,
                                 nsIContent* aChild);
   // This would be the same as RestyleForInsertOrChange if we got the
   // notification before the removal.  However, we get it after, so we
@@ -298,19 +304,53 @@ public:
   // itself.
   void ProcessPendingRestyles();
   
   // Rebuilds all style data by throwing out the old rule tree and
   // building a new one, and additionally applying aExtraHint (which
   // must not contain nsChangeHint_ReconstructFrame) to the root frame.
   void RebuildAllStyleData(nsChangeHint aExtraHint);
 
+  // See PostRestyleEventCommon below.
   void PostRestyleEvent(nsIContent* aContent, nsReStyleHint aRestyleHint,
-                        nsChangeHint aMinChangeHint);
+                        nsChangeHint aMinChangeHint)
+  {
+    nsPresContext *presContext = mPresShell->GetPresContext();
+    if (presContext) {
+      PostRestyleEventCommon(aContent, aRestyleHint, aMinChangeHint,
+                             presContext->IsProcessingAnimationStyleChange());
+    }
+  }
+
+  // See PostRestyleEventCommon below.
+  void PostAnimationRestyleEvent(nsIContent* aContent,
+                                 nsReStyleHint aRestyleHint,
+                                 nsChangeHint aMinChangeHint)
+  {
+    PostRestyleEventCommon(aContent, aRestyleHint, aMinChangeHint, PR_TRUE);
+  }
 private:
+  /**
+   * Notify the frame constructor that a content node needs to have its
+   * style recomputed.
+   * @param aContent: The content node to be restyled.
+   * @param aRestyleHint: Which nodes need to have selector matching run
+   *                      on them.
+   * @param aMinChangeHint: A minimum change hint for aContent and its
+   *                        descendants.
+   * @param aForAnimation: Whether the style should be computed with or
+   *                       without animation data.  Animation code
+   *                       sometimes needs to pass true; other code
+   *                       should generally pass the the pres context's
+   *                       IsProcessingAnimationStyleChange() value
+   *                       (which is the default value).
+   */
+  void PostRestyleEventCommon(nsIContent* aContent, nsReStyleHint aRestyleHint,
+                              nsChangeHint aMinChangeHint,
+                              PRBool aForAnimation);
   void PostRestyleEventInternal();
 public:
 
   /**
    * Asynchronously clear style data from the root frame downwards and ensure
    * it will all be rebuilt. This is safe to call anytime; it will schedule
    * a restyle and take effect next time style changes are flushed.
    * This method is used to recompute the style data when some change happens
@@ -1702,18 +1742,16 @@ private:
   }
 
   void CountersDirty() {
     NS_PRECONDITION(mUpdateCount != 0, "Instant counter updates are bad news");
     mCountersDirty = PR_TRUE;
   }
 
 public:
-  struct RestyleData;
-  friend struct RestyleData;
 
   struct RestyleData {
     nsReStyleHint mRestyleHint;  // What we want to restyle
     nsChangeHint  mChangeHint;   // The minimal change hint for "self"
   };
 
   struct RestyleEnumerateData : public RestyleData {
     nsCOMPtr<nsIContent> mContent;
@@ -1789,13 +1827,14 @@ private:
   PRUint32            mHoverGeneration;
   nsChangeHint        mRebuildAllExtraHint;
 
   nsRevocableEventPtr<RestyleEvent> mRestyleEvent;
 
   nsCOMPtr<nsILayoutHistoryState> mTempFrameTreeState;
 
   nsDataHashtable<nsISupportsHashKey, RestyleData> mPendingRestyles;
+  nsDataHashtable<nsISupportsHashKey, RestyleData> mPendingAnimationRestyles;
 
   static nsIXBLService * gXBLService;
 };
 
 #endif /* nsCSSFrameConstructor_h___ */
diff --git a/layout/base/nsIPresShell.h b/layout/base/nsIPresShell.h
--- a/layout/base/nsIPresShell.h
+++ b/layout/base/nsIPresShell.h
@@ -396,16 +396,17 @@ public:
   NS_IMETHOD CancelAllPendingReflows() = 0;
 
   /**
    * Recreates the frames for a node
    */
   NS_IMETHOD RecreateFramesFor(nsIContent* aContent) = 0;
 
   void PostRecreateFramesFor(nsIContent* aContent);
+  void RestyleForAnimation(nsIContent* aContent);
   
   /**
    * Determine if it is safe to flush all pending notifications
    * @param aIsSafeToFlush PR_TRUE if it is safe, PR_FALSE otherwise.
    * 
    */
   NS_IMETHOD IsSafeToFlush(PRBool& aIsSafeToFlush) = 0;
 
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -813,16 +813,26 @@ public:
     return !mSameDocDirtyRegion.IsEmpty() || !mCrossDocDirtyRegion.IsEmpty();
   }
 
   void ClearMozAfterPaintEvents() {
     mSameDocDirtyRegion.SetEmpty();
     mCrossDocDirtyRegion.SetEmpty();
   }
 
+  PRBool IsProcessingAnimationStyleChange() const {
+    return mProcessingAnimationStyleChange;
+  }
+
+  void SetProcessingAnimationStyleChange(PRBool aProcessing) {
+    NS_ASSERTION(aProcessing != mProcessingAnimationStyleChange,
+                 "should never nest");
+    mProcessingAnimationStyleChange = aProcessing;
+  }
+
   /**
    * Notify the prescontext that the presshell is about to reflow a reflow root.
    * The single argument indicates whether this reflow should be interruptible.
    * If aInterruptible is false then CheckForInterrupt and HasPendingInterrupt
    * will always return false. If aInterruptible is true then CheckForInterrupt
    * will return true when a pending event is detected.  This is for use by the
    * presshell only.  Reflow code wanting to prevent interrupts should use
    * InterruptPreventer.
@@ -1026,20 +1036,20 @@ protected:
   unsigned              mGetUserFontSetCalled : 1;
   // Do we currently have an event posted to call FlushUserFontSet?
   unsigned              mPostedFlushUserFontSet : 1;
 
   // resize reflow is supressed when the only change has been to zoom
   // the document rather than to change the document's dimensions
   unsigned              mSupressResizeReflow : 1;
 
-#ifdef IBMBIDI
   unsigned              mIsVisual : 1;
 
-#endif
+  unsigned              mProcessingAnimationStyleChange : 1;
+
 #ifdef DEBUG
   PRBool                mInitialized;
 #endif
 
 
 protected:
 
   virtual ~nsPresContext() NS_HIDDEN;
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -3563,17 +3563,24 @@ PresShell::RecreateFramesFor(nsIContent*
 #endif
   return rv;
 }
 
 void
 nsIPresShell::PostRecreateFramesFor(nsIContent* aContent)
 {
   FrameConstructor()->PostRestyleEvent(aContent, eReStyle_Self,
-          nsChangeHint_ReconstructFrame);
+                                       nsChangeHint_ReconstructFrame);
+}
+
+void
+nsIPresShell::RestyleForAnimation(nsIContent* aContent)
+{
+  FrameConstructor()->PostAnimationRestyleEvent(aContent, eReStyle_Self,
+                                                NS_STYLE_HINT_NONE);
 }
 
 NS_IMETHODIMP
 PresShell::ClearFrameRefs(nsIFrame* aFrame)
 {
   mPresContext->EventStateManager()->ClearFrameRefs(aFrame);
   
   if (aFrame == mCurrentEventFrame) {
