From: L. David Baron <dbaron@dbaron.org>

Make style changes know whether they are for transitions or not.  (Bug 435441)

diff --git a/content/xul/document/src/nsXULDocument.cpp b/content/xul/document/src/nsXULDocument.cpp
--- a/content/xul/document/src/nsXULDocument.cpp
+++ b/content/xul/document/src/nsXULDocument.cpp
@@ -4720,17 +4720,18 @@ nsXULDocument::DirectionChanged(const ch
   // matter too much
   nsXULDocument* doc = (nsXULDocument *)aData;
   if (doc)
       doc->ResetDocumentDirection();
 
   nsIPresShell *shell = doc->GetPrimaryShell();
   if (shell) {
       shell->FrameConstructor()->
-          PostRestyleEvent(doc->GetRootContent(), eReStyle_Self, NS_STYLE_HINT_NONE);
+          PostRestyleEvent(doc->GetRootContent(), eReStyle_Self,
+                           NS_STYLE_HINT_NONE, PR_FALSE);
   }
 
   return 0;
 }
 
 NS_IMETHODIMP
 nsXULDocument::GetBoxObjectFor(nsIDOMElement* aElement, nsIBoxObject** aResult)
 {
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -1533,17 +1533,17 @@ nsCSSFrameConstructor::nsCSSFrameConstru
   , mCountersDirty(PR_FALSE)
   , mIsDestroyingFrameTree(PR_FALSE)
   , mRebuildAllStyleData(PR_FALSE)
   , mHasRootAbsPosContainingBlock(PR_FALSE)
   , mHoverGeneration(0)
   , mRebuildAllExtraHint(nsChangeHint(0))
 {
   // XXXbz this should be in Init() or something!
-  if (!mPendingRestyles.Init()) {
+  if (!mPendingRestyles.Init() || !mPendingAnimationRestyles.Init()) {
     // now what?
   }
 
 #ifdef DEBUG
   static PRBool gFirstTime = PR_TRUE;
   if (gFirstTime) {
     gFirstTime = PR_FALSE;
     char* flags = PR_GetEnv("GECKO_FRAMECTOR_DEBUG_FLAGS");
@@ -7925,17 +7925,17 @@ nsCSSFrameConstructor::DoContentStateCha
 
     nsReStyleHint rshint = 
       styleSet->HasStateDependentStyle(presContext, aContent, aStateMask);
       
     if ((aStateMask & NS_EVENT_STATE_HOVER) && rshint != 0) {
       ++mHoverGeneration;
     }
 
-    PostRestyleEvent(aContent, rshint, hint);
+    PostRestyleEvent(aContent, rshint, hint, PR_FALSE);
   }
 }
 
 nsresult
 nsCSSFrameConstructor::AttributeChanged(nsIContent* aContent,
                                         PRInt32 aNameSpaceID,
                                         nsIAtom* aAttribute,
                                         PRInt32 aModType,
@@ -8017,17 +8017,17 @@ nsCSSFrameConstructor::AttributeChanged(
   // See if we can optimize away the style re-resolution -- must be called after
   // the frame's AttributeChanged() in case it does something that affects the style
   nsFrameManager *frameManager = shell->FrameManager();
   nsReStyleHint rshint = frameManager->HasAttributeDependentStyle(aContent,
                                                                   aAttribute,
                                                                   aModType,
                                                                   aStateMask);
 
-  PostRestyleEvent(aContent, rshint, hint);
+  PostRestyleEvent(aContent, rshint, hint, PR_FALSE);
 
   return result;
 }
 
 void
 nsCSSFrameConstructor::BeginUpdate() {
   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
                "Someone forgot a script blocker");
@@ -9096,17 +9096,18 @@ nsCSSFrameConstructor::RecreateFramesFor
     rv = ContentRemoved(container, aContent, indexInContainer,
                         REMOVE_FOR_RECONSTRUCTION, &didReconstruct);
 
     if (NS_SUCCEEDED(rv) && !didReconstruct) {
       // Now, recreate the frames associated with this content object. If
       // ContentRemoved triggered reconstruction, then we don't need to do this
       // because the frames will already have been built.
       if (aAsyncInsert) {
-        PostRestyleEvent(aContent, nsReStyleHint(0), nsChangeHint_ReconstructFrame);
+        PostRestyleEvent(aContent, nsReStyleHint(0),
+                         nsChangeHint_ReconstructFrame, PR_FALSE);
       } else {
         rv = ContentInserted(container, aContent,
                              indexInContainer, mTempFrameTreeState);
       }
     }
   }
 
 #ifdef ACCESSIBILITY
@@ -11303,17 +11304,17 @@ nsCSSFrameConstructor::RestyleForAppend(
 #endif
   PRUint32 selectorFlags =
     aContainer->GetFlags() & (NODE_ALL_SELECTOR_FLAGS &
                               ~NODE_HAS_SLOW_SELECTOR_NOAPPEND);
   if (selectorFlags == 0)
     return;
 
   if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
-    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE, PR_FALSE);
     // Restyling the container is the most we can do here, so we're done.
     return;
   }
 
   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
     // see whether we need to restyle the container
     PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
     for (PRInt32 index = 0; index < aNewIndexInContainer; ++index) {
@@ -11323,27 +11324,27 @@ nsCSSFrameConstructor::RestyleForAppend(
       // likely to restyle).
       if (nsStyleUtil::IsSignificantChild(aContainer->GetChildAt(index),
                                           PR_TRUE, PR_FALSE)) {
         wasEmpty = PR_FALSE;
         break;
       }
     }
     if (wasEmpty) {
-      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE, PR_FALSE);
       // Restyling the container is the most we can do here, so we're done.
       return;
     }
   }
   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
     // restyle the last element child before this node
     for (PRInt32 index = aNewIndexInContainer - 1; index >= 0; --index) {
       nsIContent *content = aContainer->GetChildAt(index);
       if (content->IsNodeOfType(nsINode::eELEMENT)) {
-        PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
+        PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE, PR_FALSE);
         break;
       }
     }
   }
 }
 
 // Restyling for a ContentInserted or CharacterDataChanged notification.
 // This could be used for ContentRemoved as well if we got the
@@ -11359,17 +11360,17 @@ nsCSSFrameConstructor::RestyleForInsertO
                "anonymous nodes should not be in child lists");
   PRUint32 selectorFlags =
     aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
   if (selectorFlags == 0)
     return;
 
   if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
                        NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
-    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE, PR_FALSE);
     // Restyling the container is the most we can do here, so we're done.
     return;
   }
 
   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
     // see whether we need to restyle the container
     PRBool wasEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
     for (PRInt32 index = 0; ; ++index) {
@@ -11383,17 +11384,17 @@ nsCSSFrameConstructor::RestyleForInsertO
       // IsSignificantChild less likely to be true, and thus make us more
       // likely to restyle).
       if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
         wasEmpty = PR_FALSE;
         break;
       }
     }
     if (wasEmpty) {
-      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE, PR_FALSE);
       // Restyling the container is the most we can do here, so we're done.
       return;
     }
   }
 
   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
     // restyle the previously-first element child if it is after this node
     PRBool passedChild = PR_FALSE;
@@ -11402,33 +11403,35 @@ nsCSSFrameConstructor::RestyleForInsertO
       if (!content)
         break; // went through all children
       if (content == aChild) {
         passedChild = PR_TRUE;
         continue;
       }
       if (content->IsNodeOfType(nsINode::eELEMENT)) {
         if (passedChild) {
-          PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
+          PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE,
+                           PR_FALSE);
         }
         break;
       }
     }
     // restyle the previously-last element child if it is before this node
     passedChild = PR_FALSE;
     for (PRInt32 index = aContainer->GetChildCount() - 1;
          index >= 0; --index) {
       nsIContent *content = aContainer->GetChildAt(index);
       if (content == aChild) {
         passedChild = PR_TRUE;
         continue;
       }
       if (content->IsNodeOfType(nsINode::eELEMENT)) {
         if (passedChild) {
-          PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
+          PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE,
+                           PR_FALSE);
         }
         break;
       }
     }
   }
 }
 
 void
@@ -11440,17 +11443,17 @@ nsCSSFrameConstructor::RestyleForRemove(
                "anonymous nodes should not be in child lists");
   PRUint32 selectorFlags =
     aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
   if (selectorFlags == 0)
     return;
 
   if (selectorFlags & (NODE_HAS_SLOW_SELECTOR |
                        NODE_HAS_SLOW_SELECTOR_NOAPPEND)) {
-    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+    PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE, PR_FALSE);
     // Restyling the container is the most we can do here, so we're done.
     return;
   }
 
   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
     // see whether we need to restyle the container
     PRBool isEmpty = PR_TRUE; // :empty or :-moz-only-whitespace
     for (PRInt32 index = 0; ; ++index) {
@@ -11462,42 +11465,44 @@ nsCSSFrameConstructor::RestyleForRemove(
       // IsSignificantChild less likely to be true, and thus make us more
       // likely to restyle).
       if (nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE)) {
         isEmpty = PR_FALSE;
         break;
       }
     }
     if (isEmpty) {
-      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE);
+      PostRestyleEvent(aContainer, eReStyle_Self, NS_STYLE_HINT_NONE, PR_FALSE);
       // Restyling the container is the most we can do here, so we're done.
       return;
     }
   }
 
   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
     // restyle the previously-first element child if it is after aOldChild
     for (PRInt32 index = 0; ; ++index) {
       nsIContent *content = aContainer->GetChildAt(index);
       if (!content)
         break; // went through all children
       if (content->IsNodeOfType(nsINode::eELEMENT)) {
         if (index >= aIndexInContainer) {
-          PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
+          PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE,
+                           PR_FALSE);
         }
         break;
       }
     }
     // restyle the previously-last element child if it is before aOldChild
     for (PRInt32 index = aContainer->GetChildCount() - 1;
          index >= 0; --index) {
       nsIContent *content = aContainer->GetChildAt(index);
       if (content->IsNodeOfType(nsINode::eELEMENT)) {
         if (index < aIndexInContainer) {
-          PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE);
+          PostRestyleEvent(content, eReStyle_Self, NS_STYLE_HINT_NONE,
+                           PR_FALSE);
         }
         break;
       }
     }
   }
 }
 
 
@@ -11604,47 +11609,44 @@ nsCSSFrameConstructor::RebuildAllStyleDa
   // change list has frame reconstructs in it (since frames to be
   // reconstructed will still have their old style context pointers
   // until they are destroyed).
   mPresShell->StyleSet()->EndReconstruct();
   batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
 }
 
 void
-nsCSSFrameConstructor::ProcessPendingRestyles()
-{
-  NS_PRECONDITION(mDocument, "No document?  Pshaw!\n");
-  NS_PRECONDITION(!nsContentUtils::IsSafeToRunScript(),
-                  "Missing a script blocker!");
-
-  PRUint32 count = mPendingRestyles.Count();
+nsCSSFrameConstructor::ProcessPendingRestyleTable(
+                   nsDataHashtable<nsISupportsHashKey, RestyleData>& aRestyles)
+{
+  PRUint32 count = aRestyles.Count();
 
   // Make sure to not rebuild quote or counter lists while we're
   // processing restyles
   BeginUpdate();
 
   // loop so that we process any restyle events generated by processing
   while (count) {
     // Use the stack if we can, otherwise fall back on heap-allocation.
     nsAutoTArray<RestyleEnumerateData, RESTYLE_ARRAY_STACKSIZE> restyleArr;
     RestyleEnumerateData* restylesToProcess = restyleArr.AppendElements(count);
   
     if (!restylesToProcess) {
       return;
     }
 
     RestyleEnumerateData* lastRestyle = restylesToProcess;
-    mPendingRestyles.Enumerate(CollectRestyles, &lastRestyle);
+    aRestyles.Enumerate(CollectRestyles, &lastRestyle);
 
     NS_ASSERTION(lastRestyle - restylesToProcess == PRInt32(count),
                  "Enumeration screwed up somehow");
 
     // Clear the hashtable so we don't end up trying to process a restyle we're
     // already processing, sending us into an infinite loop.
-    mPendingRestyles.Clear();
+    aRestyles.Clear();
 
     for (RestyleEnumerateData* currentRestyle = restylesToProcess;
          currentRestyle != lastRestyle;
          ++currentRestyle) {
       ProcessOneRestyle(currentRestyle->mContent,
                         currentRestyle->mRestyleHint,
                         currentRestyle->mChangeHint);
     }
@@ -11652,28 +11654,43 @@ nsCSSFrameConstructor::ProcessPendingRes
     count = mPendingRestyles.Count();
   }
 
   EndUpdate();
 
 #ifdef DEBUG
   mPresShell->VerifyStyleTree();
 #endif
+}
+
+void
+nsCSSFrameConstructor::ProcessPendingRestyles()
+{
+  NS_PRECONDITION(mDocument, "No document?  Pshaw!\n");
+  NS_PRECONDITION(!nsContentUtils::IsSafeToRunScript(),
+                  "Missing a script blocker!");
+
+  ProcessPendingRestyleTable(mPendingRestyles);
+  nsPresContext *presContext = mPresShell->GetPresContext();
+  presContext->SetProcessingAnimationStyleChange(PR_TRUE);
+  ProcessPendingRestyleTable(mPendingAnimationRestyles);
+  presContext->SetProcessingAnimationStyleChange(PR_FALSE);
 
   if (mRebuildAllStyleData) {
     // We probably wasted a lot of work up above, but this seems safest
     // and it should be rarely used.
     RebuildAllStyleData(nsChangeHint(0));
   }
 }
 
 void
 nsCSSFrameConstructor::PostRestyleEvent(nsIContent* aContent,
                                         nsReStyleHint aRestyleHint,
-                                        nsChangeHint aMinChangeHint)
+                                        nsChangeHint aMinChangeHint,
+                                        PRBool aForAnimation)
 {
   if (NS_UNLIKELY(mPresShell->IsDestroying())) {
     return;
   }
 
   if (aRestyleHint == 0 && !aMinChangeHint) {
     // Nothing to do here
     return;
@@ -11681,22 +11698,25 @@ nsCSSFrameConstructor::PostRestyleEvent(
 
   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eELEMENT),
                "Shouldn't be trying to restyle non-elements directly");
 
   RestyleData existingData;
   existingData.mRestyleHint = nsReStyleHint(0);
   existingData.mChangeHint = NS_STYLE_HINT_NONE;
 
-  mPendingRestyles.Get(aContent, &existingData);
+  nsDataHashtable<nsISupportsHashKey, RestyleData> &restyles =
+    aForAnimation ? mPendingAnimationRestyles : mPendingRestyles;
+
+  restyles.Get(aContent, &existingData);
   existingData.mRestyleHint =
     nsReStyleHint(existingData.mRestyleHint | aRestyleHint);
   NS_UpdateHint(existingData.mChangeHint, aMinChangeHint);
 
-  mPendingRestyles.Put(aContent, existingData);
+  restyles.Put(aContent, existingData);
 
   PostRestyleEventInternal();
 }
     
 void
 nsCSSFrameConstructor::PostRestyleEventInternal()
 {
   if (!mRestyleEvent.IsPending()) {
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -269,16 +269,19 @@ private:
   // Note: It's the caller's responsibility to make sure to wrap a
   // ProcessOneRestyle call in a view update batch.
   // This function does not call ProcessAttachedQueue() on the binding manager.
   // If the caller wants that to happen synchronously, it needs to handle that
   // itself.
   void ProcessOneRestyle(nsIContent* aContent, nsReStyleHint aRestyleHint,
                          nsChangeHint aChangeHint);
 
+  void ProcessPendingRestyleTable(
+           nsDataHashtable<nsISupportsHashKey, RestyleData>& aRestyles);
+
 public:
   // Restyling for a ContentInserted (notification after insertion) or
   // for a CharacterDataChanged.  |aContainer| must be non-null; when
   // the container is null, no work is needed.
   void RestyleForInsertOrChange(nsIContent* aContainer,
                                 nsIContent* aChild);
   // This would be the same as RestyleForInsertOrChange if we got the
   // notification before the removal.  However, we get it after, so we
@@ -299,17 +302,17 @@ public:
   void ProcessPendingRestyles();
   
   // Rebuilds all style data by throwing out the old rule tree and
   // building a new one, and additionally applying aExtraHint (which
   // must not contain nsChangeHint_ReconstructFrame) to the root frame.
   void RebuildAllStyleData(nsChangeHint aExtraHint);
 
   void PostRestyleEvent(nsIContent* aContent, nsReStyleHint aRestyleHint,
-                        nsChangeHint aMinChangeHint);
+                        nsChangeHint aMinChangeHint, PRBool aForAnimation);
 private:
   void PostRestyleEventInternal();
 public:
 
   /**
    * Asynchronously clear style data from the root frame downwards and ensure
    * it will all be rebuilt. This is safe to call anytime; it will schedule
    * a restyle and take effect next time style changes are flushed.
@@ -1787,13 +1790,14 @@ private:
   PRUint32            mHoverGeneration;
   nsChangeHint        mRebuildAllExtraHint;
 
   nsRevocableEventPtr<RestyleEvent> mRestyleEvent;
 
   nsCOMPtr<nsILayoutHistoryState> mTempFrameTreeState;
 
   nsDataHashtable<nsISupportsHashKey, RestyleData> mPendingRestyles;
+  nsDataHashtable<nsISupportsHashKey, RestyleData> mPendingAnimationRestyles;
 
   static nsIXBLService * gXBLService;
 };
 
 #endif /* nsCSSFrameConstructor_h___ */
diff --git a/layout/base/nsIPresShell.h b/layout/base/nsIPresShell.h
--- a/layout/base/nsIPresShell.h
+++ b/layout/base/nsIPresShell.h
@@ -387,16 +387,17 @@ public:
   NS_IMETHOD CancelAllPendingReflows() = 0;
 
   /**
    * Recreates the frames for a node
    */
   NS_IMETHOD RecreateFramesFor(nsIContent* aContent) = 0;
 
   void PostRecreateFramesFor(nsIContent* aContent);
+  void PostRestyleFor(nsIContent* aContent, PRBool aForAnimation);
   
   /**
    * Determine if it is safe to flush all pending notifications
    * @param aIsSafeToFlush PR_TRUE if it is safe, PR_FALSE otherwise.
    * 
    */
   NS_IMETHOD IsSafeToFlush(PRBool& aIsSafeToFlush) = 0;
 
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -816,16 +816,26 @@ public:
     return !mSameDocDirtyRegion.IsEmpty() || !mCrossDocDirtyRegion.IsEmpty();
   }
 
   void ClearMozAfterPaintEvents() {
     mSameDocDirtyRegion.SetEmpty();
     mCrossDocDirtyRegion.SetEmpty();
   }
 
+  PRBool IsProcessingAnimationStyleChange() const {
+    return mProcessingAnimationStyleChange;
+  }
+
+  void SetProcessingAnimationStyleChange(PRBool aProcessing) {
+    NS_ASSERTION(aProcessing != mProcessingAnimationStyleChange,
+                 "should never nest");
+    mProcessingAnimationStyleChange = aProcessing;
+  }
+
   /**
    * Notify the prescontext that the presshell is about to reflow a reflow root.
    * The single argument indicates whether this reflow should be interruptible.
    * If aInterruptible is false then CheckForInterrupt and HasPendingInterrupt
    * will always return false. If aInterruptible is true then CheckForInterrupt
    * will return true when a pending event is detected.  This is for use by the
    * presshell only.  Reflow code wanting to prevent interrupts should use
    * InterruptPreventer.
@@ -1023,20 +1033,20 @@ protected:
   unsigned              mGetUserFontSetCalled : 1;
   // Do we currently have an event posted to call FlushUserFontSet?
   unsigned              mPostedFlushUserFontSet : 1;
 
   // resize reflow is supressed when the only change has been to zoom
   // the document rather than to change the document's dimensions
   unsigned              mSupressResizeReflow : 1;
 
-#ifdef IBMBIDI
   unsigned              mIsVisual : 1;
 
-#endif
+  unsigned              mProcessingAnimationStyleChange : 1;
+
 #ifdef DEBUG
   PRBool                mInitialized;
 #endif
 
 
 protected:
 
   virtual ~nsPresContext() NS_HIDDEN;
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -3681,17 +3681,24 @@ PresShell::RecreateFramesFor(nsIContent*
 #endif
   return rv;
 }
 
 void
 nsIPresShell::PostRecreateFramesFor(nsIContent* aContent)
 {
   FrameConstructor()->PostRestyleEvent(aContent, eReStyle_Self,
-          nsChangeHint_ReconstructFrame);
+          nsChangeHint_ReconstructFrame, PR_FALSE);
+}
+
+void
+nsIPresShell::PostRestyleFor(nsIContent* aContent, PRBool aForAnimation)
+{
+  FrameConstructor()->PostRestyleEvent(aContent, eReStyle_Self,
+                                       NS_STYLE_HINT_NONE, aForAnimation);
 }
 
 NS_IMETHODIMP
 PresShell::ClearFrameRefs(nsIFrame* aFrame)
 {
   mPresContext->EventStateManager()->ClearFrameRefs(aFrame);
   
   if (aFrame == mCurrentEventFrame) {
@@ -5113,17 +5120,18 @@ nsIPresShell::ReconstructStyleDataIntern
     return;
   }
 
   if (!root) {
     // No content to restyle
     return;
   }
   
-  mFrameConstructor->PostRestyleEvent(root, eReStyle_Self, NS_STYLE_HINT_NONE);
+  mFrameConstructor->PostRestyleEvent(root, eReStyle_Self, NS_STYLE_HINT_NONE,
+                                      PR_FALSE);
 
 #ifdef ACCESSIBILITY
   InvalidateAccessibleSubtree(nsnull);
 #endif
 }
 
 void
 nsIPresShell::ReconstructStyleDataExternal()
diff --git a/layout/mathml/nsMathMLTokenFrame.cpp b/layout/mathml/nsMathMLTokenFrame.cpp
--- a/layout/mathml/nsMathMLTokenFrame.cpp
+++ b/layout/mathml/nsMathMLTokenFrame.cpp
@@ -267,17 +267,17 @@ void
 nsMathMLTokenFrame::ProcessTextData()
 {
   // see if the style changes from normal to italic or vice-versa
   if (!SetTextStyle())
     return;
 
   // explicitly request a re-resolve to pick up the change of style
   PresContext()->PresShell()->FrameConstructor()->
-    PostRestyleEvent(mContent, eReStyle_Self, NS_STYLE_HINT_NONE);
+    PostRestyleEvent(mContent, eReStyle_Self, NS_STYLE_HINT_NONE, PR_FALSE);
 }
 
 ///////////////////////////////////////////////////////////////////////////
 // For <mi>, if the content is not a single character, turn the font to
 // normal (this function will also query attributes from the mstyle hierarchy)
 // Returns PR_TRUE if there is a style change.
 //
 // http://www.w3.org/TR/2003/REC-MathML2-20031021/chapter3.html#presm.commatt
diff --git a/layout/mathml/nsMathMLmtableFrame.cpp b/layout/mathml/nsMathMLmtableFrame.cpp
--- a/layout/mathml/nsMathMLmtableFrame.cpp
+++ b/layout/mathml/nsMathMLmtableFrame.cpp
@@ -493,17 +493,18 @@ nsMathMLmtableOuterFrame::AttributeChang
           }
         }
       }
     }
   }
 
   // Explicitly request a re-resolve and reflow in our subtree to pick up any changes
   PresContext()->PresShell()->FrameConstructor()->
-    PostRestyleEvent(mContent, eReStyle_Self, nsChangeHint_ReflowFrame);
+    PostRestyleEvent(mContent, eReStyle_Self, nsChangeHint_ReflowFrame,
+                     PR_FALSE);
 
   return NS_OK;
 }
 
 nsIFrame*
 nsMathMLmtableOuterFrame::GetRowFrameAt(nsPresContext* aPresContext,
                                         PRInt32         aRowIndex)
 {
@@ -670,17 +671,18 @@ nsMathMLmtableFrame::SetInitialChildList
 void
 nsMathMLmtableFrame::RestyleTable()
 {
   // re-sync MathML specific style data that may have changed
   MapAllAttributesIntoCSS(this);
 
   // Explicitly request a re-resolve and reflow in our subtree to pick up any changes
   PresContext()->PresShell()->FrameConstructor()->
-    PostRestyleEvent(mContent, eReStyle_Self, nsChangeHint_ReflowFrame);
+    PostRestyleEvent(mContent, eReStyle_Self, nsChangeHint_ReflowFrame,
+                     PR_FALSE);
 }
 
 // --------
 // implementation of nsMathMLmtrFrame
 
 nsIFrame*
 NS_NewMathMLmtrFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 {
@@ -725,17 +727,18 @@ nsMathMLmtrFrame::AttributeChanged(PRInt
       cellFrame->GetContent()->
         UnsetAttr(kNameSpaceID_None, nsGkAtoms::MOZcolumnalign, PR_FALSE);
       MapColAttributesIntoCSS(tableFrame, this, cellFrame);
     }
   }
 
   // Explicitly request a re-resolve and reflow in our subtree to pick up any changes
   PresContext()->PresShell()->FrameConstructor()->
-    PostRestyleEvent(mContent, eReStyle_Self, nsChangeHint_ReflowFrame);
+    PostRestyleEvent(mContent, eReStyle_Self, nsChangeHint_ReflowFrame,
+                     PR_FALSE);
 
   return NS_OK;
 }
 
 // --------
 // implementation of nsMathMLmtdFrame
 
 nsIFrame*
diff --git a/layout/svg/base/src/nsSVGEffects.cpp b/layout/svg/base/src/nsSVGEffects.cpp
--- a/layout/svg/base/src/nsSVGEffects.cpp
+++ b/layout/svg/base/src/nsSVGEffects.cpp
@@ -210,34 +210,34 @@ nsSVGFilterProperty::DoUpdate()
   // Repaint asynchronously in case the filter frame is being torn down
   nsChangeHint changeHint =
     nsChangeHint(nsChangeHint_RepaintFrame | nsChangeHint_UpdateEffects);
 
   if (!mFrame->IsFrameOfType(nsIFrame::eSVG)) {
     NS_UpdateHint(changeHint, nsChangeHint_ReflowFrame);
   }
   mFramePresShell->FrameConstructor()->PostRestyleEvent(
-    mFrame->GetContent(), nsReStyleHint(0), changeHint);
+    mFrame->GetContent(), nsReStyleHint(0), changeHint, PR_FALSE);
 }
 
 void
 nsSVGMarkerProperty::DoUpdate()
 {
   nsSVGRenderingObserver::DoUpdate();
   if (!mFrame)
     return;
 
   NS_ASSERTION(mFrame->IsFrameOfType(nsIFrame::eSVG), "SVG frame expected");
 
   // Repaint asynchronously
   nsChangeHint changeHint =
     nsChangeHint(nsChangeHint_RepaintFrame | nsChangeHint_UpdateEffects);
 
   mFramePresShell->FrameConstructor()->PostRestyleEvent(
-    mFrame->GetContent(), nsReStyleHint(0), changeHint);
+    mFrame->GetContent(), nsReStyleHint(0), changeHint, PR_FALSE);
 }
 
 void
 nsSVGTextPathProperty::DoUpdate()
 {
   nsSVGRenderingObserver::DoUpdate();
   if (!mFrame)
     return;
