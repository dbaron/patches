From: L. David Baron <dbaron@dbaron.org>

Properly dirty intrinsic widths when doing things that change inflation.  (Bug 759755, patch 2)

diff --git a/dom/base/nsDOMWindowUtils.cpp b/dom/base/nsDOMWindowUtils.cpp
--- a/dom/base/nsDOMWindowUtils.cpp
+++ b/dom/base/nsDOMWindowUtils.cpp
@@ -278,17 +278,18 @@ MaybeReflowForInflationScreenWidthChange
             mudv->AppendSubtree(array);
             for (PRUint32 i = 0, iEnd = array.Length(); i < iEnd; ++i) {
               nsCOMPtr<nsIPresShell> shell;
               nsCOMPtr<nsIContentViewer> cv = do_QueryInterface(array[i]);
               cv->GetPresShell(getter_AddRefs(shell));
               if (shell) {
                 nsIFrame *rootFrame = shell->GetRootFrame();
                 if (rootFrame) {
-                  shell->FrameNeedsReflow(rootFrame, nsIPresShell::eResize,
+                  shell->FrameNeedsReflow(rootFrame,
+                                          nsIPresShell::eStyleChange,
                                           NS_FRAME_IS_DIRTY);
                 }
               }
             }
           }
         }
       }
     }
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -2511,16 +2511,18 @@ PresShell::FrameNeedsReflow(nsIFrame *aF
            a && !FRAME_IS_REFLOW_ROOT(a);
            a = a->GetParent())
         a->MarkIntrinsicWidthsDirty();
     }
 
     if (aIntrinsicDirty == eStyleChange) {
       // Mark all descendants dirty (using an nsTArray stack rather than
       // recursion).
+      // Note that nsHTMLReflowState::InitResizeFlags has some similar
+      // code; see comments there for how and why it differs.
       nsAutoTArray<nsIFrame*, 32> stack;
       stack.AppendElement(subtreeRoot);
 
       do {
         nsIFrame *f = stack.ElementAt(stack.Length() - 1);
         stack.RemoveElementAt(stack.Length() - 1);
 
         if (f->GetType() == nsGkAtoms::placeholderFrame) {
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -364,16 +364,54 @@ nsHTMLReflowState::InitResizeFlags(nsPre
     bool dirty = nsFontInflationData::UpdateFontInflationDataWidthFor(*this);
     if (dirty) {
       // FIXME: This isn't so great for the cases where
       // nsHTMLReflowState::SetComputedWidth is called, if the first time
       // we go through InitResizeFlags we set mHResize to true, and then
       // the second time we'd set it to false even without the
       // NS_FRAME_IS_DIRTY bit already set.
       frame->AddStateBits(NS_FRAME_IS_DIRTY);
+
+      // Mark intrinsic widths on all descendants dirty.  We need to do
+      // this (1) since we're changing the size of text and need to
+      // clear text runs on text frames and (2) since we actually are
+      // changing some intrinsic widths, but only those that live inside
+      // of containers.
+
+      // It makes sense to do this for descendants but not ancestors
+      // (which is unusual) because we're only changing the unusual
+      // inflation-dependent intrinsic widths (i.e., ones computed with
+      // nsPresContext::mInflationDisabledForShrinkWrap set to false),
+      // which should never affect anything outside of their inflation
+      // flow root (or, for that matter, even their inflation
+      // container).
+
+      // This is also different from what PresShell::FrameNeedsReflow
+      // does because it doesn't go through placeholders.  It doesn't
+      // need to because we're actually doing something that cares about
+      // frame tree geometry (the width on an ancestor) rather than
+      // style.
+
+      nsAutoTArray<nsIFrame*, 32> stack;
+      stack.AppendElement(frame);
+
+      do {
+        nsIFrame *f = stack.ElementAt(stack.Length() - 1);
+        stack.RemoveElementAt(stack.Length() - 1);
+
+        nsIFrame::ChildListIterator lists(f);
+        for (; !lists.IsDone(); lists.Next()) {
+          nsFrameList::Enumerator childFrames(lists.CurrentList());
+          for (; !childFrames.AtEnd(); childFrames.Next()) {
+            nsIFrame* kid = childFrames.get();
+            kid->MarkIntrinsicWidthsDirty();
+            stack.AppendElement(kid);
+          }
+        }
+      } while (stack.Length() != 0);
     }
   }
 
   mFlags.mHResize = !(frame->GetStateBits() & NS_FRAME_IS_DIRTY) &&
                     frame->GetSize().width !=
                       mComputedWidth + mComputedBorderPadding.LeftRight();
   if (mFlags.mHResize &&
       nsLayoutUtils::FontSizeInflationEnabled(aPresContext)) {
