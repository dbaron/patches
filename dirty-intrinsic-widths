From: L. David Baron <dbaron@dbaron.org>

Properly dirty intrinsic widths when doing things that change inflation.  (Bug 759755, patch 3)

diff --git a/dom/base/nsDOMWindowUtils.cpp b/dom/base/nsDOMWindowUtils.cpp
--- a/dom/base/nsDOMWindowUtils.cpp
+++ b/dom/base/nsDOMWindowUtils.cpp
@@ -278,17 +278,18 @@ MaybeReflowForInflationScreenWidthChange
             mudv->AppendSubtree(array);
             for (PRUint32 i = 0, iEnd = array.Length(); i < iEnd; ++i) {
               nsCOMPtr<nsIPresShell> shell;
               nsCOMPtr<nsIContentViewer> cv = do_QueryInterface(array[i]);
               cv->GetPresShell(getter_AddRefs(shell));
               if (shell) {
                 nsIFrame *rootFrame = shell->GetRootFrame();
                 if (rootFrame) {
-                  shell->FrameNeedsReflow(rootFrame, nsIPresShell::eResize,
+                  shell->FrameNeedsReflow(rootFrame,
+                                          nsIPresShell::eStyleChange,
                                           NS_FRAME_IS_DIRTY);
                 }
               }
             }
           }
         }
       }
     }
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -2511,16 +2511,18 @@ PresShell::FrameNeedsReflow(nsIFrame *aF
            a && !FRAME_IS_REFLOW_ROOT(a);
            a = a->GetParent())
         a->MarkIntrinsicWidthsDirty();
     }
 
     if (aIntrinsicDirty == eStyleChange) {
       // Mark all descendants dirty (using an nsTArray stack rather than
       // recursion).
+      // Note that nsHTMLReflowState::InitResizeFlags has some similar
+      // code; see comments there for how and why it differs.
       nsAutoTArray<nsIFrame*, 32> stack;
       stack.AppendElement(subtreeRoot);
 
       do {
         nsIFrame *f = stack.ElementAt(stack.Length() - 1);
         stack.RemoveElementAt(stack.Length() - 1);
 
         if (f->GetType() == nsGkAtoms::placeholderFrame) {
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -349,31 +349,83 @@ IsQuirkContainingBlockHeight(const nsHTM
       if (!rs->frame->GetStyleDisplay()->IsAbsolutelyPositioned()) {
         return false;
       }
     }
   }
   return true;
 }
 
+static void
+MarkDirtyForInflationChange(nsIFrame *aFrame)
+{
+  // FIXME: This isn't so great for the cases where
+  // nsHTMLReflowState::SetComputedWidth is called, if the first time
+  // we go through InitResizeFlags we set mHResize to true, and then
+  // the second time we'd set it to false even without the
+  // NS_FRAME_IS_DIRTY bit already set.
+  if (aFrame->GetType() == nsGkAtoms::svgForeignObjectFrame) {
+    // Foreign object frames use dirty bits in a special way.
+    aFrame->AddStateBits(NS_FRAME_HAS_DIRTY_CHILDREN);
+    nsIFrame *kid = aFrame->GetFirstPrincipalChild();
+    if (kid) {
+      kid->AddStateBits(NS_FRAME_IS_DIRTY);
+    }
+  } else {
+    aFrame->AddStateBits(NS_FRAME_IS_DIRTY);
+  }
+
+  // Mark intrinsic widths on all descendants dirty.  We need to do
+  // this (1) since we're changing the size of text and need to
+  // clear text runs on text frames and (2) since we actually are
+  // changing some intrinsic widths, but only those that live inside
+  // of containers.
+
+  // It makes sense to do this for descendants but not ancestors
+  // (which is unusual) because we're only changing the unusual
+  // inflation-dependent intrinsic widths (i.e., ones computed with
+  // nsPresContext::mInflationDisabledForShrinkWrap set to false),
+  // which should never affect anything outside of their inflation
+  // flow root (or, for that matter, even their inflation
+  // container).
+
+  // This is also different from what PresShell::FrameNeedsReflow
+  // does because it doesn't go through placeholders.  It doesn't
+  // need to because we're actually doing something that cares about
+  // frame tree geometry (the width on an ancestor) rather than
+  // style.
+
+  nsAutoTArray<nsIFrame*, 32> stack;
+  stack.AppendElement(aFrame);
+
+  do {
+    nsIFrame *f = stack.ElementAt(stack.Length() - 1);
+    stack.RemoveElementAt(stack.Length() - 1);
+
+    nsIFrame::ChildListIterator lists(f);
+    for (; !lists.IsDone(); lists.Next()) {
+      nsFrameList::Enumerator childFrames(lists.CurrentList());
+      for (; !childFrames.AtEnd(); childFrames.Next()) {
+        nsIFrame* kid = childFrames.get();
+        kid->MarkIntrinsicWidthsDirty();
+        stack.AppendElement(kid);
+      }
+    }
+  } while (stack.Length() != 0);
+}
 
 void
 nsHTMLReflowState::InitResizeFlags(nsPresContext* aPresContext, nsIAtom* aFrameType)
 {
   if (frame->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT) {
     // Create our font inflation data if we don't have it already, and
     // give it our current width information.
     bool dirty = nsFontInflationData::UpdateFontInflationDataWidthFor(*this);
     if (dirty) {
-      // FIXME: This isn't so great for the cases where
-      // nsHTMLReflowState::SetComputedWidth is called, if the first time
-      // we go through InitResizeFlags we set mHResize to true, and then
-      // the second time we'd set it to false even without the
-      // NS_FRAME_IS_DIRTY bit already set.
-      frame->AddStateBits(NS_FRAME_IS_DIRTY);
+      MarkDirtyForInflationChange(frame);
     }
   }
 
   mFlags.mHResize = !(frame->GetStateBits() & NS_FRAME_IS_DIRTY) &&
                     frame->GetSize().width !=
                       mComputedWidth + mComputedBorderPadding.LeftRight();
   if (mFlags.mHResize &&
       nsLayoutUtils::FontSizeInflationEnabled(aPresContext)) {
@@ -388,22 +440,17 @@ nsHTMLReflowState::InitResizeFlags(nsPre
     // Note that this makes horizontal resizing a good bit more
     // expensive.  However, font size inflation is targeted at a set of
     // devices (zoom-and-pan devices) where the main use case for
     // horizontal resizing needing to be efficient (window resizing) is
     // not present.  It does still increase the cost of dynamic changes
     // caused by script where a style or content change in one place
     // causes a resize in another (e.g., rebalancing a table).
 
-    // FIXME: This isn't so great for the cases where
-    // nsHTMLReflowState::SetComputedWith is called, if the first time
-    // we go through InitResizeFlags we set mHResize to true, and then
-    // the second time we'd set it to false even without the
-    // NS_FRAME_IS_DIRTY bit already set.
-    frame->AddStateBits(NS_FRAME_IS_DIRTY);
+    MarkDirtyForInflationChange(frame);
   }
 
   // XXX Should we really need to null check mCBReflowState?  (We do for
   // at least nsBoxFrame).
   if (IS_TABLE_CELL(aFrameType) &&
       (mFlags.mSpecialHeightReflow ||
        (frame->GetFirstInFlow()->GetStateBits() &
          NS_TABLE_CELL_HAD_SPECIAL_REFLOW)) &&
