From: L. David Baron <dbaron@dbaron.org>

Fire assertions when guard objects are used as temporaries.  (FIXME:  Is NS_STACK_CLASS needed when deriving from something that already has it?  FIXME:  Add NS_NONTEMPORARY_CLASS.)  (Bug 531460)

diff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h
--- a/js/src/xpconnect/src/xpcprivate.h
+++ b/js/src/xpconnect/src/xpcprivate.h
@@ -91,16 +91,17 @@
 #include "prlong.h"
 #include "prmem.h"
 #include "prenv.h"
 #include "prclist.h"
 #include "nsString.h"
 #include "nsReadableUtils.h"
 #include "nsXPIDLString.h"
 #include "nsAutoJSValHolder.h"
+#include "mozilla/AutoRestore.h"
 
 #include "nsThreadUtils.h"
 #include "nsIJSContextStack.h"
 #include "nsDeque.h"
 
 #include "nsIConsoleService.h"
 #include "nsIScriptError.h"
 #include "nsIExceptionService.h"
@@ -300,32 +301,33 @@ static inline void xpc_NotifyAll(XPCLock
 // a null monitor in without things blowing up. This is used for wrappers that
 // are guaranteed to be used only on one thread. We avoid lock overhead by
 // using a null monitor. By changing this class we can avoid having multiplte
 // code paths or (conditional) manual calls to PR_{Enter,Exit}Monitor.
 //
 // Note that xpconnect only makes *one* monitor and *mostly* holds it locked
 // only through very small critical sections.
 
-class XPCAutoLock : public nsAutoLockBase {
+class NS_STACK_CLASS XPCAutoLock : public nsAutoLockBase {
 public:
 
     static XPCLock* NewLock(const char* name)
                         {return nsAutoMonitor::NewMonitor(name);}
     static void     DestroyLock(XPCLock* lock)
                         {nsAutoMonitor::DestroyMonitor(lock);}
 
-    XPCAutoLock(XPCLock* lock)
+    XPCAutoLock(XPCLock* lock MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
 #ifdef DEBUG_jband
         : nsAutoLockBase(lock ? (void*) lock : (void*) this, eAutoMonitor),
 #else
         : nsAutoLockBase(lock, eAutoMonitor),
 #endif
           mLock(lock)
     {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
         if(mLock)
             PR_EnterMonitor(mLock);
     }
 
     ~XPCAutoLock()
     {
         if(mLock)
         {
@@ -334,16 +336,17 @@ public:
 #endif
                 PR_ExitMonitor(mLock);
             NS_ASSERTION(status == PR_SUCCESS, "PR_ExitMonitor failed");
         }
     }
 
 private:
     XPCLock*  mLock;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 
     // Not meant to be implemented. This makes it a compiler error to
     // construct or assign an XPCAutoLock object incorrectly.
     XPCAutoLock(void) {}
     XPCAutoLock(XPCAutoLock& /*aMon*/) {}
     XPCAutoLock& operator =(XPCAutoLock& /*aMon*/) {
         return *this;
     }
@@ -353,22 +356,23 @@ private:
     static void* operator new(size_t /*size*/) CPP_THROW_NEW {
         return nsnull;
     }
     static void operator delete(void* /*memory*/) {}
 };
 
 /************************************************/
 
-class XPCAutoUnlock : public nsAutoUnlockBase {
+class NS_STACK_CLASS XPCAutoUnlock : public nsAutoUnlockBase {
 public:
-    XPCAutoUnlock(XPCLock* lock)
+    XPCAutoUnlock(XPCLock* lock MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
         : nsAutoUnlockBase(lock),
           mLock(lock)
     {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
         if(mLock)
         {
 #ifdef DEBUG
             PRStatus status =
 #endif
                 PR_ExitMonitor(mLock);
             NS_ASSERTION(status == PR_SUCCESS, "PR_ExitMonitor failed");
         }
@@ -377,16 +381,17 @@ public:
     ~XPCAutoUnlock()
     {
         if(mLock)
             PR_EnterMonitor(mLock);
     }
 
 private:
     XPCLock*  mLock;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 
     // Not meant to be implemented. This makes it a compiler error to
     // construct or assign an XPCAutoUnlock object incorrectly.
     XPCAutoUnlock(void) {}
     XPCAutoUnlock(XPCAutoUnlock& /*aMon*/) {}
     XPCAutoUnlock& operator =(XPCAutoUnlock& /*aMon*/) {
         return *this;
     }
@@ -3767,21 +3772,24 @@ private:
     PRUint32 mColumnNumber;
     PRUint32 mFlags;
     nsCString mCategory;
 };
 
 /***************************************************************************/
 // XXX allowing for future notifications to XPCCallContext
 
-class AutoJSRequest
+class NS_STACK_CLASS AutoJSRequest
 {
 public:
-    AutoJSRequest(XPCCallContext& aCCX)
-      : mCCX(aCCX), mCX(aCCX.GetJSContext()) {BeginRequest();}
+    AutoJSRequest(XPCCallContext& aCCX MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
+      : mCCX(aCCX), mCX(aCCX.GetJSContext()) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+        BeginRequest();
+    }
     ~AutoJSRequest() {EndRequest();}
 
     void EndRequest() {
         if(mCX) {
             JS_EndRequest(mCX);
             mCX = nsnull;
         }
     }
@@ -3790,23 +3798,28 @@ private:
         if(JS_GetContextThread(mCX))
             JS_BeginRequest(mCX);
         else
             mCX = nsnull;
     }
 private:
     XPCCallContext& mCCX;
     JSContext* mCX;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
-class AutoJSSuspendRequest
+class NS_STACK_CLASS AutoJSSuspendRequest
 {
 public:
-    AutoJSSuspendRequest(XPCCallContext& aCCX)
-      : mCX(aCCX.GetJSContext()) {SuspendRequest();}
+    AutoJSSuspendRequest(XPCCallContext& aCCX
+                         MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
+      : mCX(aCCX.GetJSContext()) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+        SuspendRequest();
+    }
     ~AutoJSSuspendRequest() {ResumeRequest();}
 
     void ResumeRequest() {
         if(mCX) {
             JS_ResumeRequest(mCX, mDepth);
             mCX = nsnull;
         }
     }
@@ -3815,23 +3828,28 @@ private:
         if(JS_GetContextThread(mCX))
             mDepth = JS_SuspendRequest(mCX);
         else
             mCX = nsnull;
     }
 private:
     JSContext* mCX;
     jsrefcount mDepth;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
-class AutoJSSuspendRequestWithNoCallContext
+class NS_STACK_CLASS AutoJSSuspendRequestWithNoCallContext
 {
 public:
-    AutoJSSuspendRequestWithNoCallContext(JSContext *aCX)
-      : mCX(aCX) {SuspendRequest();}
+    AutoJSSuspendRequestWithNoCallContext(JSContext *aCX
+                                          MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
+      : mCX(aCX) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+        SuspendRequest();
+    }
     ~AutoJSSuspendRequestWithNoCallContext() {ResumeRequest();}
 
     void ResumeRequest() {
         if(mCX) {
             JS_ResumeRequest(mCX, mDepth);
             mCX = nsnull;
         }
     }
@@ -3840,23 +3858,28 @@ private:
         if(JS_GetContextThread(mCX))
             mDepth = JS_SuspendRequest(mCX);
         else
             mCX = nsnull;
     }
 private:
     JSContext* mCX;
     jsrefcount mDepth;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
-class AutoJSSuspendNonMainThreadRequest
+class NS_STACK_CLASS AutoJSSuspendNonMainThreadRequest
 {
 public:
-    AutoJSSuspendNonMainThreadRequest(JSContext *aCX)
-        : mCX(aCX) {SuspendRequest();}
+    AutoJSSuspendNonMainThreadRequest(JSContext *aCX
+                                      MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
+        : mCX(aCX) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+        SuspendRequest();
+    }
     ~AutoJSSuspendNonMainThreadRequest() {ResumeRequest();}
 
     void ResumeRequest() {
         if (mCX) {
             JS_ResumeRequest(mCX, mDepth);
             mCX = nsnull;
         }
     }
@@ -3866,25 +3889,31 @@ private:
         if (mCX && !XPCPerThreadData::IsMainThread(mCX))
             mDepth = JS_SuspendRequest(mCX);
         else
             mCX = nsnull;
     }
 
     JSContext *mCX;
     jsrefcount mDepth;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
         
 
 /*****************************************/
 
-class AutoJSRequestWithNoCallContext
+class NS_STACK_CLASS AutoJSRequestWithNoCallContext
 {
 public:
-    AutoJSRequestWithNoCallContext(JSContext* aCX) : mCX(aCX) {BeginRequest();}
+    AutoJSRequestWithNoCallContext(JSContext* aCX
+                                   MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
+        : mCX(aCX) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+        BeginRequest();
+    }
     ~AutoJSRequestWithNoCallContext() {EndRequest();}
 
     void EndRequest() {
         if(mCX) {
             JS_EndRequest(mCX);
             mCX = nsnull;
         }
     }
@@ -3892,51 +3921,58 @@ private:
     void BeginRequest() {
         if(JS_GetContextThread(mCX))
             JS_BeginRequest(mCX);
         else
             mCX = nsnull;
     }
 private:
     JSContext* mCX;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 /***************************************************************************/
-class AutoJSErrorAndExceptionEater
+class NS_STACK_CLASS AutoJSErrorAndExceptionEater
 {
 public:
-    AutoJSErrorAndExceptionEater(JSContext* aCX)
+    AutoJSErrorAndExceptionEater(JSContext* aCX
+                                 MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
         : mCX(aCX),
           mOldErrorReporter(JS_SetErrorReporter(mCX, nsnull)),
-          mOldExceptionState(JS_SaveExceptionState(mCX)) {}
+          mOldExceptionState(JS_SaveExceptionState(mCX)) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+    }
     ~AutoJSErrorAndExceptionEater()
     {
         JS_SetErrorReporter(mCX, mOldErrorReporter);
         JS_RestoreExceptionState(mCX, mOldExceptionState);
     }
 private:
     JSContext*        mCX;
     JSErrorReporter   mOldErrorReporter;
     JSExceptionState* mOldExceptionState;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 /******************************************************************************
  * Handles pre/post script processing and the setting/resetting the error
  * reporter
  */
-class AutoScriptEvaluate
+class NS_STACK_CLASS AutoScriptEvaluate
 {
 public:
     /**
      * Saves the JSContext as well as initializing our state
      * @param cx The JSContext, this can be null, we don't do anything then
      */
-    AutoScriptEvaluate(JSContext * cx)
+    AutoScriptEvaluate(JSContext * cx MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
          : mJSContext(cx), mState(0), mErrorReporterSet(PR_FALSE),
-           mEvaluated(PR_FALSE), mContextHasThread(0) {}
+           mEvaluated(PR_FALSE), mContextHasThread(0) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+    }
 
     /**
      * Does the pre script evaluation and sets the error reporter if given
      * This function should only be called once, and will assert if called
      * more than once
      * @param errorReporter the error reporter callback function to set
      */
 
@@ -3946,43 +3982,48 @@ public:
      */
     ~AutoScriptEvaluate();
 private:
     JSContext* mJSContext;
     JSExceptionState* mState;
     PRBool mErrorReporterSet;
     PRBool mEvaluated;
     jsword mContextHasThread;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 
     // No copying or assignment allowed
     AutoScriptEvaluate(const AutoScriptEvaluate &);
     AutoScriptEvaluate & operator =(const AutoScriptEvaluate &);
 };
 
 /***************************************************************************/
-class AutoResolveName
+class NS_STACK_CLASS AutoResolveName
 {
 public:
-    AutoResolveName(XPCCallContext& ccx, jsval name)
+    AutoResolveName(XPCCallContext& ccx, jsval name
+                    MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM)
         : mTLS(ccx.GetThreadData()),
           mOld(mTLS->SetResolveName(name)),
-          mCheck(name) {}
+          mCheck(name) {
+        MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
+    }
     ~AutoResolveName()
         {
 #ifdef DEBUG
             jsval old = 
 #endif
             mTLS->SetResolveName(mOld);
             NS_ASSERTION(old == mCheck, "Bad Nesting!");
         }
 
 private:
     XPCPerThreadData* mTLS;
     jsval mOld;
     jsval mCheck;
+    MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER
 };
 
 /***************************************************************************/
 class XPCMarkableJSVal
 {
 public:
     XPCMarkableJSVal(jsval val) : mVal(val), mValPtr(&mVal) {}
     XPCMarkableJSVal(jsval *pval) : mVal(0), mValPtr(pval) {}
