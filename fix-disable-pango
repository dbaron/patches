From: Jonathan Kew <jfkthame@gmail.com>

Fix --disable-pango build on desktop Linux/Gtk.  (Bug 703042)  DO NOT CHECK IN

diff --git a/gfx/thebes/Makefile.in b/gfx/thebes/Makefile.in
--- a/gfx/thebes/Makefile.in
+++ b/gfx/thebes/Makefile.in
@@ -269,17 +269,19 @@ CPPSRCS	+=	gfxOS2Fonts.cpp \
 CPPSRCS +=	gfxPDFSurface.cpp
 endif
 
 ifeq ($(MOZ_WIDGET_TOOLKIT),gtk2)
 
 ifdef MOZ_PANGO
 CPPSRCS += gfxPangoFonts.cpp
 else
-CPPSRCS += gfxFT2Fonts.cpp
+CPPSRCS += gfxFT2Fonts.cpp \
+	gfxFT2FontList.cpp \
+	$(NULL)
 endif
 
 ifdef MOZ_X11
 CPPSRCS += gfxXlibSurface.cpp gfxXlibNativeRenderer.cpp
 endif
 
 CPPSRCS +=  gfxPlatformGtk.cpp gfxGdkNativeRenderer.cpp
 CPPSRCS +=	gfxPDFSurface.cpp gfxPSSurface.cpp
diff --git a/gfx/thebes/gfxFT2FontList.cpp b/gfx/thebes/gfxFT2FontList.cpp
--- a/gfx/thebes/gfxFT2FontList.cpp
+++ b/gfx/thebes/gfxFT2FontList.cpp
@@ -239,28 +239,30 @@ private:
 
 static void
 FTFontDestroyFunc(void *data)
 {
     FTUserFontData *userFontData = static_cast<FTUserFontData*>(data);
     delete userFontData;
 }
 
+#ifdef ANDROID
 /* static */
 FT2FontEntry*
 FT2FontEntry::CreateFontEntry(const FontListEntry& aFLE)
 {
     FT2FontEntry *fe = new FT2FontEntry(aFLE.faceName());
     fe->mFilename = aFLE.filepath();
     fe->mFTFontIndex = aFLE.index();
     fe->mWeight = aFLE.weight();
     fe->mStretch = aFLE.stretch();
     fe->mItalic = aFLE.italic();
     return fe;
 }
+#endif
 
 /* static */
 FT2FontEntry*
 FT2FontEntry::CreateFontEntry(FT_Face aFace,
                               const char* aFilename, PRUint8 aIndex,
                               const PRUint8 *aFontData)
 {
     static cairo_user_data_key_t key;
@@ -392,16 +394,17 @@ FT2FontEntry::GetFontTable(PRUint32 aTab
 }
 
 /*
  * FT2FontFamily
  * A standard gfxFontFamily; just adds a method used to support sending
  * the font list from chrome to content via IPC.
  */
 
+#ifdef ANDROID
 void
 FT2FontFamily::AddFacesToFontList(InfallibleTArray<FontListEntry>* aFontList)
 {
     for (int i = 0, n = mAvailableFonts.Length(); i < n; ++i) {
         const FT2FontEntry *fe =
             static_cast<const FT2FontEntry*>(mAvailableFonts[i].get());
         if (!fe) {
             continue;
@@ -628,30 +631,32 @@ private:
         const FNCMapEntry* from = static_cast<const FNCMapEntry*>(aFrom);
         to->mFilename.Assign(from->mFilename);
         to->mTimestamp = from->mTimestamp;
         to->mFilesize = from->mFilesize;
         to->mFaces.Assign(from->mFaces);
         to->mFileExists = from->mFileExists;
     }
 };
+#endif
 
 /***************************************************************
  *
  * gfxFT2FontList
  *
  */
 
 // For Mobile, we use gfxFT2Fonts, and we build the font list by directly
 // scanning the system's Fonts directory for OpenType and TrueType files.
 
 gfxFT2FontList::gfxFT2FontList()
 {
 }
 
+#ifdef ANDROID
 void
 gfxFT2FontList::AppendFacesFromCachedFaceList(nsCString& aFileName,
                                               bool aStdFile,
                                               nsCString& aFaceList)
 {
     const char *beginning = aFaceList.get();
     const char *end = strchr(beginning, ',');
     while (end) {
@@ -706,42 +711,47 @@ AppendToFaceList(nsCString& aFaceList,
     aFaceList.Append(',');
     aFaceList.Append(aFontEntry->IsItalic() ? '1' : '0');
     aFaceList.Append(',');
     aFaceList.AppendInt(aFontEntry->Weight());
     aFaceList.Append(',');
     aFaceList.AppendInt(aFontEntry->Stretch());
     aFaceList.Append(',');
 }
+#endif
 
 void
 gfxFT2FontList::AppendFacesFromFontFile(nsCString& aFileName,
                                         bool aStdFile,
                                         FontNameCache *aCache)
 {
     nsCString faceList;
     PRUint32 filesize = 0, timestamp = 0;
+    struct stat s;
+#ifdef ANDROID
     if (aCache) {
         aCache->GetInfoForFile(aFileName, faceList, &timestamp, &filesize);
     }
 
-    struct stat s;
     int statRetval = stat(aFileName.get(), &s);
     if (!faceList.IsEmpty() && 0 == statRetval &&
         s.st_mtime == timestamp && s.st_size == filesize)
     {
         LOG(("using cached font info for %s", aFileName.get()));
         AppendFacesFromCachedFaceList(aFileName, aStdFile, faceList);
         return;
     }
+#endif
 
 #ifdef XP_WIN
     FT_Library ftLibrary = gfxWindowsPlatform::GetPlatform()->GetFTLibrary();
 #elif defined(ANDROID)
     FT_Library ftLibrary = gfxAndroidPlatform::GetPlatform()->GetFTLibrary();
+#elif defined(MOZ_WIDGET_GTK2)
+    FT_Library ftLibrary = gfxPlatformGtk::GetPlatform()->GetFTLibrary();
 #endif
     FT_Face dummy;
     if (FT_Err_Ok == FT_New_Face(ftLibrary, aFileName.get(), -1, &dummy)) {
         LOG(("reading font info via FreeType for %s", aFileName.get()));
         nsCString faceList;
         timestamp = s.st_mtime;
         filesize = s.st_size;
         for (FT_Long i = 0; i < dummy->num_faces; i++) {
@@ -763,33 +773,37 @@ gfxFT2FontList::AppendFacesFromFontFile(
                         family->SetBadUnderlineFamily();
                     }
                 }
                 fe->mStandardFace = aStdFile;
                 family->AddFontEntry(fe);
                 if (family->IsBadUnderlineFamily()) {
                     fe->mIsBadUnderlineFont = true;
                 }
+#ifdef ANDROID
                 AppendToFaceList(faceList, name, fe);
+#endif
 #ifdef PR_LOGGING
                 if (LOG_ENABLED()) {
                     LOG(("(fontinit) added (%s) to family (%s)"
                          " with style: %s weight: %d stretch: %d",
                          NS_ConvertUTF16toUTF8(fe->Name()).get(), 
                          NS_ConvertUTF16toUTF8(family->Name()).get(), 
                          fe->IsItalic() ? "italic" : "normal",
                          fe->Weight(), fe->Stretch()));
                 }
 #endif
             }
         }
         FT_Done_Face(dummy);
+#ifdef ANDROID
         if (aCache && 0 == statRetval && !faceList.IsEmpty()) {
             aCache->CacheFileInfo(aFileName, faceList, timestamp, filesize);
         }
+#endif
     }
 }
 
 // Called on each family after all fonts are added to the list;
 // this will sort faces to give priority to "standard" font files
 // if aUserArg is non-null (i.e. we're using it as a boolean flag)
 static PLDHashOperator
 FinalizeFamilyMemberList(nsStringHashKey::KeyType aKey,
@@ -952,16 +966,17 @@ gfxFT2FontList::FindFonts()
 
     // Finalize the families by sorting faces into standard order
     // and marking "simple" families.
     // Passing non-null userData here says that we want faces to be sorted.
     mFontFamilies.Enumerate(FinalizeFamilyMemberList, this);
 #endif // XP_WIN && ANDROID
 }
 
+#ifdef ANDROID
 void
 gfxFT2FontList::AppendFaceFromFontListEntry(const FontListEntry& aFLE,
                                             bool aStdFile)
 {
     FT2FontEntry* fe = FT2FontEntry::CreateFontEntry(aFLE);
     if (fe) {
         fe->mStandardFace = aStdFile;
         nsAutoString name(aFLE.familyName());
@@ -994,16 +1009,17 @@ AddFamilyToFontList(nsStringHashKey::Key
     return PL_DHASH_NEXT;
 }
 
 void
 gfxFT2FontList::GetFontList(InfallibleTArray<FontListEntry>* retValue)
 {
     mFontFamilies.Enumerate(AddFamilyToFontList, retValue);
 }
+#endif
 
 nsresult
 gfxFT2FontList::InitFontList()
 {
     // reset font lists
     gfxPlatformFontList::InitFontList();
     
     FindFonts();
diff --git a/gfx/thebes/gfxFT2FontList.h b/gfx/thebes/gfxFT2FontList.h
--- a/gfx/thebes/gfxFT2FontList.h
+++ b/gfx/thebes/gfxFT2FontList.h
@@ -42,22 +42,24 @@
 #define GFX_FT2FONTLIST_H
 
 #ifdef XP_WIN
 #include "gfxWindowsPlatform.h"
 #include <windows.h>
 #endif
 #include "gfxPlatformFontList.h"
 
+#ifdef ANDROID
 namespace mozilla {
     namespace dom {
         class FontListEntry;
     };
 };
 using mozilla::dom::FontListEntry;
+#endif
 
 class FontNameCache;
 typedef struct FT_FaceRec_* FT_Face;
 
 class FT2FontEntry : public gfxFontEntry
 {
 public:
     FT2FontEntry(const nsAString& aFaceName) :
@@ -74,21 +76,23 @@ public:
         return Name();
     }
 
     // create a font entry for a downloaded font
     static FT2FontEntry* 
     CreateFontEntry(const gfxProxyFontEntry &aProxyEntry,
                     const PRUint8 *aFontData, PRUint32 aLength);
 
+#ifdef ANDROID
     // create a font entry representing an installed font, identified by
     // a FontListEntry; the freetype and cairo faces will not be instantiated
     // until actually needed
     static FT2FontEntry*
     CreateFontEntry(const FontListEntry& aFLE);
+#endif
 
     // create a font entry for a given freetype face; if it is an installed font,
     // also record the filename and index
     static FT2FontEntry* 
     CreateFontEntry(FT_Face aFace, const char *aFilename, PRUint8 aIndex,
                     const PRUint8 *aFontData = nsnull);
         // aFontData is NS_Malloc'ed data that aFace depends on, to be freed
         // after the face is destroyed; null if there is no such buffer
@@ -110,18 +114,20 @@ public:
 };
 
 class FT2FontFamily : public gfxFontFamily
 {
 public:
     FT2FontFamily(const nsAString& aName) :
         gfxFontFamily(aName) { }
 
+#ifdef ANDROID
     // Append this family's faces to the IPC fontlist
     void AddFacesToFontList(InfallibleTArray<FontListEntry>* aFontList);
+#endif
 };
 
 class gfxFT2FontList : public gfxPlatformFontList
 {
 public:
     gfxFT2FontList();
 
     virtual gfxFontEntry* GetDefaultFont(const gfxFontStyle* aStyle,
@@ -129,32 +135,36 @@ public:
 
     virtual gfxFontEntry* LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
                                           const nsAString& aFontName);
 
     virtual gfxFontEntry* MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
                                            const PRUint8 *aFontData,
                                            PRUint32 aLength);
 
+#ifdef ANDROID
     void GetFontList(InfallibleTArray<FontListEntry>* retValue);
+#endif
 
     static gfxFT2FontList* PlatformFontList() {
         return static_cast<gfxFT2FontList*>(gfxPlatformFontList::PlatformFontList());
     }
 
 protected:
     virtual nsresult InitFontList();
 
+#ifdef ANDROID
     void AppendFaceFromFontListEntry(const FontListEntry& aFLE,
                                      bool isStdFile);
 
+    void AppendFacesFromCachedFaceList(nsCString& aFileName,
+                                       bool isStdFile,
+                                       nsCString& aFaceList);
+#endif
+
     void AppendFacesFromFontFile(nsCString& aFileName,
                                  bool isStdFile = false,
                                  FontNameCache *aCache = nsnull);
 
-    void AppendFacesFromCachedFaceList(nsCString& aFileName,
-                                       bool isStdFile,
-                                       nsCString& aFaceList);
-
     void FindFonts();
 };
 
 #endif /* GFX_FT2FONTLIST_H */
diff --git a/gfx/thebes/gfxFT2Fonts.cpp b/gfx/thebes/gfxFT2Fonts.cpp
--- a/gfx/thebes/gfxFT2Fonts.cpp
+++ b/gfx/thebes/gfxFT2Fonts.cpp
@@ -62,16 +62,18 @@
 #include "nsUnicodeRange.h"
 #include "nsCRT.h"
 
 #include "prlog.h"
 #include "prinit.h"
 
 #include "mozilla/Preferences.h"
 
+using namespace mozilla;
+
 static PRLogModuleInfo *gFontLog = PR_NewLogModule("ft2fonts");
 
 // rounding and truncation functions for a Freetype floating point number
 // (FT26Dot6) stored in a 32bit integer with high 26 bits for the integer
 // part and low 6 bits for the fractional part.
 #define MOZ_FT_ROUND(x) (((x) + 32) & ~63) // 63 = 2^6 - 1
 #define MOZ_FT_TRUNC(x) ((x) >> 6)
 #define CONVERT_DESIGN_UNITS_TO_PIXELS(v, s) \
@@ -244,21 +246,23 @@ void gfxFT2FontGroup::GetPrefFonts(nsIAt
         FamilyListToArrayList(fontString, aLangGroup, &fonts);
 
         platform->SetPrefFontEntries(key, fonts);
     }
     aFontEntryList.AppendElements(fonts);
 }
 
 static PRInt32 GetCJKLangGroupIndex(const char *aLangGroup) {
+/*
     PRInt32 i;
     for (i = 0; i < COUNT_OF_CJK_LANG_GROUP; i++) {
         if (!PL_strcasecmp(aLangGroup, sCJKLangGroup[i]))
             return i;
     }
+*/
     return -1;
 }
 
 // this function assigns to the array passed in.
 void gfxFT2FontGroup::GetCJKPrefFonts(nsTArray<nsRefPtr<gfxFontEntry> >& aFontEntryList) {
     gfxToolkitPlatform *platform = gfxToolkitPlatform::GetPlatform();
 
     nsCAutoString key("x-internal-cjk-");
@@ -284,18 +288,20 @@ void gfxFT2FontGroup::GetCJKPrefFonts(ns
                     break;
                 const char *start = p;
                 while (++p != p_end && *p != kComma)
                     /* nothing */ ;
                 nsCAutoString lang(Substring(start, p));
                 lang.CompressWhitespace(false, true);
                 PRInt32 index = GetCJKLangGroupIndex(lang.get());
                 if (index >= 0) {
+/*
                     nsCOMPtr<nsIAtom> atom = do_GetAtom(sCJKLangGroup[index]);
                     GetPrefFonts(atom, aFontEntryList);
+*/
                 }
                 p++;
             }
         }
 
         // Add the system locale
 #ifdef XP_WIN
         switch (::GetACP()) {
@@ -335,17 +341,17 @@ void gfxFT2FontGroup::GetCJKPrefFonts(ns
 
 already_AddRefed<gfxFT2Font>
 gfxFT2FontGroup::WhichFontSupportsChar(const nsTArray<nsRefPtr<gfxFontEntry> >& aFontEntryList, PRUint32 aCh)
 {
     for (PRUint32 i = 0; i < aFontEntryList.Length(); i++) {
         gfxFontEntry *fe = aFontEntryList[i].get();
         if (fe->HasCharacter(aCh)) {
             nsRefPtr<gfxFT2Font> font =
-                gfxFT2Font::GetOrMakeFont(static_cast<FontEntry*>(fe), &mStyle);
+                gfxFT2Font::GetOrMakeFont(static_cast<FT2FontEntry*>(fe), &mStyle);
             return font.forget();
         }
     }
     return nsnull;
 }
 
 already_AddRefed<gfxFont>
 gfxFT2FontGroup::WhichPrefFontSupportsChar(PRUint32 aCh)
@@ -392,17 +398,17 @@ gfxFT2FontGroup::WhichPrefFontSupportsCh
 
     return nsnull;
 }
 
 already_AddRefed<gfxFont>
 gfxFT2FontGroup::WhichSystemFontSupportsChar(PRUint32 aCh)
 {
 #if defined(XP_WIN) || defined(ANDROID)
-    FontEntry *fe = static_cast<FontEntry*>
+    FT2FontEntry *fe = static_cast<FT2FontEntry*>
         (gfxPlatformFontList::PlatformFontList()->FindFontForChar(aCh, GetFontAt(0)));
     if (fe) {
         nsRefPtr<gfxFT2Font> f = gfxFT2Font::GetOrMakeFont(fe, &mStyle);
         nsRefPtr<gfxFont> font = f.get();
         return font.forget();
     }
 #else
     nsRefPtr<gfxFont> selectedFont;
diff --git a/gfx/thebes/gfxPlatformGtk.cpp b/gfx/thebes/gfxPlatformGtk.cpp
--- a/gfx/thebes/gfxPlatformGtk.cpp
+++ b/gfx/thebes/gfxPlatformGtk.cpp
@@ -49,16 +49,17 @@
 #ifdef MOZ_PANGO
 #include "gfxPangoFonts.h"
 #include "gfxContext.h"
 #include "gfxUserFontSet.h"
 #else
 #include <ft2build.h>
 #include FT_FREETYPE_H
 #include "gfxFT2Fonts.h"
+#include "gfxFT2FontList.h"
 #endif
 
 #include "cairo.h"
 #include <gtk/gtk.h>
 
 #include "gfxImageSurface.h"
 #ifdef MOZ_X11
 #include <gdk/gdkx.h>
@@ -89,17 +90,17 @@
 #ifndef MOZ_PANGO
 #include <ft2build.h>
 #include FT_FREETYPE_H
 #endif
 
 gfxFontconfigUtils *gfxPlatformGtk::sFontconfigUtils = nsnull;
 
 #ifndef MOZ_PANGO
-typedef nsDataHashtable<nsStringHashKey, nsRefPtr<FontFamily> > FontTable;
+typedef nsDataHashtable<nsStringHashKey, nsRefPtr<FT2FontFamily> > FontTable;
 typedef nsDataHashtable<nsCStringHashKey, nsTArray<nsRefPtr<gfxFontEntry> > > PrefFontTable;
 static FontTable *gPlatformFonts = NULL;
 static FontTable *gPlatformFontAliases = NULL;
 static PrefFontTable *gPrefFonts = NULL;
 static gfxSparseBitSet *gCodepointsWithNoFonts = NULL;
 static FT_Library gPlatformFTLibrary = NULL;
 #endif
 
@@ -345,23 +346,23 @@ gfxPlatformGtk::UpdateFontList()
         if (FcPatternGetString(fs->fonts[i], FC_FAMILY, 0, (FcChar8 **) &str) != FcResultMatch)
             continue;
 
         //printf("Family: %s\n", str);
 
         nsAutoString name(NS_ConvertUTF8toUTF16(nsDependentCString(str)).get());
         nsAutoString key(name);
         ToLowerCase(key);
-        nsRefPtr<FontFamily> ff;
+        nsRefPtr<FT2FontFamily> ff;
         if (!gPlatformFonts->Get(key, &ff)) {
-            ff = new FontFamily(name);
+            ff = new FT2FontFamily(name);
             gPlatformFonts->Put(key, ff);
         }
 
-        FontEntry *fe = new FontEntry(ff->Name());
+        FT2FontEntry *fe = new FT2FontEntry(ff->Name());
         ff->AddFontEntry(fe);
 
         if (FcPatternGetString(fs->fonts[i], FC_FILE, 0, (FcChar8 **) &str) == FcResultMatch) {
             fe->mFilename = nsDependentCString(str);
             //printf(" - file: %s\n", str);
         }
 
         int x;
@@ -405,17 +406,17 @@ gfxPlatformGtk::ResolveFontName(const ns
                                 FontResolverCallback aCallback,
                                 void *aClosure,
                                 bool& aAborted)
 {
 
     nsAutoString name(aFontName);
     ToLowerCase(name);
 
-    nsRefPtr<FontFamily> ff;
+    nsRefPtr<FT2FontFamily> ff;
     if (gPlatformFonts->Get(name, &ff) ||
         gPlatformFontAliases->Get(name, &ff)) {
         aAborted = !(*aCallback)(ff->Name(), aClosure);
         return NS_OK;
     }
 
     nsCAutoString utf8Name = NS_ConvertUTF16toUTF8(aFontName);
 
@@ -650,42 +651,43 @@ gfxPlatformGtk::GetPlatformCMSOutputProf
 
 #ifndef MOZ_PANGO
 FT_Library
 gfxPlatformGtk::GetFTLibrary()
 {
     return gPlatformFTLibrary;
 }
 
-FontFamily *
+FT2FontFamily *
 gfxPlatformGtk::FindFontFamily(const nsAString& aName)
 {
     nsAutoString name(aName);
     ToLowerCase(name);
 
-    nsRefPtr<FontFamily> ff;
+    nsRefPtr<FT2FontFamily> ff;
     if (!gPlatformFonts->Get(name, &ff)) {
         return nsnull;
     }
     return ff.get();
 }
 
-FontEntry *
+FT2FontEntry *
 gfxPlatformGtk::FindFontEntry(const nsAString& aName, const gfxFontStyle& aFontStyle)
 {
-    nsRefPtr<FontFamily> ff = FindFontFamily(aName);
+    nsRefPtr<FT2FontFamily> ff = FindFontFamily(aName);
     if (!ff)
         return nsnull;
 
-    return ff->FindFontEntry(aFontStyle);
+    bool needsBold;
+    return static_cast<FT2FontEntry*>(ff->FindFontForStyle(aFontStyle, needsBold));
 }
 
 static PLDHashOperator
 FindFontForCharProc(nsStringHashKey::KeyType aKey,
-                    nsRefPtr<FontFamily>& aFontFamily,
+                    nsRefPtr<FT2FontFamily>& aFontFamily,
                     void* aUserArg)
 {
     FontSearch *data = (FontSearch*)aUserArg;
     aFontFamily->FindFontForChar(data);
     return PL_DHASH_NEXT;
 }
 
 already_AddRefed<gfxFont>
@@ -701,17 +703,17 @@ gfxPlatformGtk::FindFontForChar(PRUint32
 
     FontSearch data(aCh, aFont);
 
     // find fonts that support the character
     gPlatformFonts->Enumerate(FindFontForCharProc, &data);
 
     if (data.mBestMatch) {
         nsRefPtr<gfxFT2Font> font =
-            gfxFT2Font::GetOrMakeFont(static_cast<FontEntry*>(data.mBestMatch.get()),
+            gfxFT2Font::GetOrMakeFont(static_cast<FT2FontEntry*>(data.mBestMatch.get()),
                                       aFont->GetStyle()); 
         gfxFont* ret = font.forget().get();
         return already_AddRefed<gfxFont>(ret);
     }
 
     // no match? add to set of non-matching codepoints
     gCodepointsWithNoFonts->set(aCh);
 
diff --git a/gfx/thebes/gfxPlatformGtk.h b/gfx/thebes/gfxPlatformGtk.h
--- a/gfx/thebes/gfxPlatformGtk.h
+++ b/gfx/thebes/gfxPlatformGtk.h
@@ -44,18 +44,18 @@
 #include "nsTArray.h"
 
 extern "C" {
     typedef struct _GdkDrawable GdkDrawable;
 }
 
 class gfxFontconfigUtils;
 #ifndef MOZ_PANGO
-class FontFamily;
-class FontEntry;
+class FT2FontFamily;
+class FT2FontEntry;
 typedef struct FT_LibraryRec_ *FT_Library;
 #endif
 
 class THEBES_API gfxPlatformGtk : public gfxPlatform {
 public:
     gfxPlatformGtk();
     virtual ~gfxPlatformGtk();
 
@@ -102,18 +102,18 @@ public:
      * Check whether format is supported on a platform or not (if unclear,
      * returns true).
      */
     virtual bool IsFontFormatSupported(nsIURI *aFontURI,
                                          PRUint32 aFormatFlags);
 #endif
 
 #ifndef MOZ_PANGO
-    FontFamily *FindFontFamily(const nsAString& aName);
-    FontEntry *FindFontEntry(const nsAString& aFamilyName, const gfxFontStyle& aFontStyle);
+    FT2FontFamily *FindFontFamily(const nsAString& aName);
+    FT2FontEntry *FindFontEntry(const nsAString& aFamilyName, const gfxFontStyle& aFontStyle);
     already_AddRefed<gfxFont> FindFontForChar(PRUint32 aCh, gfxFont *aFont);
     bool GetPrefFontEntries(const nsCString& aLangGroup, nsTArray<nsRefPtr<gfxFontEntry> > *aFontEntryList);
     void SetPrefFontEntries(const nsCString& aLangGroup, nsTArray<nsRefPtr<gfxFontEntry> >& aFontEntryList);
 #endif
 
 #ifndef MOZ_PANGO
     FT_Library GetFTLibrary();
 #endif
