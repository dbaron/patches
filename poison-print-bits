From: L. David Baron <dbaron@dbaron.org>

Print which bits have errors to try to distinguish overwriting from hardware problems.  (Bug 785737)  r=roc

diff --git a/layout/base/nsPresArena.cpp b/layout/base/nsPresArena.cpp
--- a/layout/base/nsPresArena.cpp
+++ b/layout/base/nsPresArena.cpp
@@ -11,22 +11,22 @@
 #include "nsCRT.h"
 #include "nsDebug.h"
 #include "nsTArray.h"
 #include "nsTHashtable.h"
 #include "prmem.h"
 #include "prinit.h"
 #include "prlog.h"
 #include "nsArenaMemoryStats.h"
+#include "nsCOMPtr.h"
+#include "nsServiceManagerUtils.h"
+#include "nsPrintfCString.h"
 
 #ifdef MOZ_CRASHREPORTER
 #include "nsICrashReporter.h"
-#include "nsCOMPtr.h"
-#include "nsServiceManagerUtils.h"
-#include "nsPrintfCString.h"
 #endif
 
 #include "mozilla/StandardInteger.h"
 
 // Even on 32-bit systems, we allocate objects from the frame arena
 // that require 8-byte alignment.  The cast to uintptr_t is needed
 // because plarena isn't as careful about mask construction as it
 // ought to be.
@@ -316,18 +316,26 @@ struct nsPresArena::State {
       // LIFO behavior for best cache utilization
       result = list->mEntries.ElementAt(len - 1);
       list->mEntries.RemoveElementAt(len - 1);
 #ifdef DEBUG
       {
         char* p = reinterpret_cast<char*>(result);
         char* limit = p + list->mEntrySize;
         for (; p < limit; p += sizeof(uintptr_t)) {
-          NS_ABORT_IF_FALSE(*reinterpret_cast<uintptr_t*>(p) == ARENA_POISON,
-                            "PresArena: poison overwritten");
+          uintptr_t val = *reinterpret_cast<uintptr_t*>(p);
+          NS_ABORT_IF_FALSE(val == ARENA_POISON,
+                            nsPrintfCString("PresArena: poison overwritten; "
+                                            "wanted %.16llx "
+                                            "found %.16llx "
+                                            "errors in bits %.16llx",
+                                            uint64_t(ARENA_POISON),
+                                            uint64_t(val),
+                                            uint64_t(ARENA_POISON ^ val)
+                                            ).get());
         }
       }
 #endif
       return result;
     }
 
     // Allocate a new chunk from the arena
     list->mEntriesEverAllocated++;
