From: L. David Baron <dbaron@dbaron.org>

Bug 1055865 patch 4 - Use normal inline handling for setting the size of a non-floating nsFirstLetterFrame.

This is the actual fix for the bug.  This changes the vertical sizing of
inline ::first-letter frames to work like inlines (and size based on
font metrics), so that the line-height calculation that happens later
will produces the same results as inlines would produce.

In the case we're concerned with of having a text frame child that's
0x0, this changes the inline ::first-letter from from being 0x0 to
having a height that is determined from the font metrics.

diff --git a/layout/generic/nsFirstLetterFrame.cpp b/layout/generic/nsFirstLetterFrame.cpp
--- a/layout/generic/nsFirstLetterFrame.cpp
+++ b/layout/generic/nsFirstLetterFrame.cpp
@@ -228,25 +228,23 @@ nsFirstLetterFrame::Reflow(nsPresContext
     nsLineLayout* ll = aReflowState.mLineLayout;
     bool          pushedFrame;
 
     ll->SetInFirstLetter(
       mStyleContext->GetPseudo() == nsCSSPseudoElements::firstLetter);
     ll->BeginSpan(this, &aReflowState, bp.IStart(wm),
                   availSize.ISize(wm), &mBaseline);
     ll->ReflowFrame(kid, aReflowStatus, &kidMetrics, pushedFrame);
-    ll->EndSpan(this);
+    // REVIEW: Mix of writing modes should be ok given they're within
+    // the same line and both sizes.
+    aMetrics.ISize(lineWM) = ll->EndSpan(this) + bp.IStartEnd(wm);
     ll->SetInFirstLetter(false);
 
-    LogicalSize convertedSize = kidMetrics.Size(lineWM).ConvertTo(wm, lineWM);
-    convertedSize.ISize(wm) += bp.IStartEnd(wm);
-    convertedSize.BSize(wm) += bp.BStartEnd(wm);
-    aMetrics.SetSize(wm, convertedSize);
-    aMetrics.SetBlockStartAscent(kidMetrics.BlockStartAscent() +
-                                 bp.BStart(wm));
+    nsLayoutUtils::SetBSizeFromFontMetrics(this, aMetrics, aReflowState,
+                                           bp, lineWM, wm);
   }
 
   // Ensure that the overflow rect contains the child textframe's overflow rect.
   // Note that if this is floating, the overline/underline drawable area is in
   // the overflow rect of the child textframe.
   aMetrics.UnionOverflowAreasWithDesiredBounds();
   ConsiderChildOverflow(aMetrics.mOverflowAreas, kid);
 
