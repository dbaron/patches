Make serialization handle system fonts and the font shorthand better.  (Bug 475214)

diff --git a/layout/style/nsCSSDeclaration.cpp b/layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp
+++ b/layout/style/nsCSSDeclaration.cpp
@@ -896,38 +896,55 @@ nsCSSDeclaration::GetValue(nsCSSProperty
       if (AppendValueToString(eCSSProperty_cue_before, aValue)) {
         aValue.Append(PRUnichar(' '));
         if (!AppendValueToString(eCSSProperty_cue_after, aValue))
           aValue.Truncate();
       }
       break;
     }
     case eCSSProperty_font: {
-      nsCSSValue style, variant, weight, size, lh, family, systemFont;
-      GetValueOrImportantValue(eCSSProperty__x_system_font, systemFont);
-      GetValueOrImportantValue(eCSSProperty_font_style, style);
-      GetValueOrImportantValue(eCSSProperty_font_variant, variant);
-      GetValueOrImportantValue(eCSSProperty_font_weight, weight);
-      GetValueOrImportantValue(eCSSProperty_font_size, size);
-      GetValueOrImportantValue(eCSSProperty_line_height, lh);
-      GetValueOrImportantValue(eCSSProperty_font_family, family);
+      const nsCSSValue &systemFont = *static_cast<const nsCSSValue*>(
+        data->StorageFor(eCSSProperty__x_system_font));
+      const nsCSSValue &style = *static_cast<const nsCSSValue*>(
+        data->StorageFor(eCSSProperty_font_style));
+      const nsCSSValue &variant = *static_cast<const nsCSSValue*>(
+        data->StorageFor(eCSSProperty_font_variant));
+      const nsCSSValue &weight = *static_cast<const nsCSSValue*>(
+        data->StorageFor(eCSSProperty_font_weight));
+      const nsCSSValue &size = *static_cast<const nsCSSValue*>(
+        data->StorageFor(eCSSProperty_font_size));
+      const nsCSSValue &lh = *static_cast<const nsCSSValue*>(
+        data->StorageFor(eCSSProperty_line_height));
+      const nsCSSValue &family = *static_cast<const nsCSSValue*>(
+        data->StorageFor(eCSSProperty_font_family));
+      const nsCSSValue &stretch = *static_cast<const nsCSSValue*>(
+        data->StorageFor(eCSSProperty_font_stretch));
+      const nsCSSValue &sizeAdjust = *static_cast<const nsCSSValue*>(
+        data->StorageFor(eCSSProperty_font_size_adjust));
 
       if (systemFont.GetUnit() != eCSSUnit_None &&
           systemFont.GetUnit() != eCSSUnit_Null) {
+        if (style.GetUnit() != eCSSUnit_System_Font ||
+            variant.GetUnit() != eCSSUnit_System_Font ||
+            weight.GetUnit() != eCSSUnit_System_Font ||
+            size.GetUnit() != eCSSUnit_System_Font ||
+            lh.GetUnit() != eCSSUnit_System_Font ||
+            family.GetUnit() != eCSSUnit_System_Font ||
+            stretch.GetUnit() != eCSSUnit_System_Font ||
+            sizeAdjust.GetUnit() != eCSSUnit_System_Font) {
+          // This can't be represented as a shorthand.
+          return NS_OK;
+        }
         AppendCSSValueToString(eCSSProperty__x_system_font, systemFont, aValue);
       } else {
         // The font-stretch and font-size-adjust
         // properties are reset by this shorthand property to their
         // initial values, but can't be represented in its syntax.
-        const nsCSSValue *stretchValue = static_cast<const nsCSSValue*>(
-          data->StorageFor(eCSSProperty_font_stretch));
-        const nsCSSValue *sizeAdjustValue = static_cast<const nsCSSValue*>(
-          data->StorageFor(eCSSProperty_font_size_adjust));
-        if (*stretchValue != nsCSSValue(eCSSUnit_Normal) ||
-            *sizeAdjustValue != nsCSSValue(eCSSUnit_None)) {
+        if (stretch != nsCSSValue(eCSSUnit_Normal) ||
+            sizeAdjust != nsCSSValue(eCSSUnit_None)) {
           return NS_OK;
         }
 
         if (style.GetUnit() != eCSSUnit_Normal) {
           AppendCSSValueToString(eCSSProperty_font_style, style, aValue);
           aValue.Append(PRUnichar(' '));
         }
         if (variant.GetUnit() != eCSSUnit_Normal) {
@@ -1049,16 +1066,22 @@ nsCSSDeclaration::AppendPropertyAndValue
   PRBool  isImportant = GetValueIsImportant(aProperty);
   AppendImportanceToString(isImportant, aResult);
   aResult.AppendLiteral("; ");
 }
 
 nsresult
 nsCSSDeclaration::ToString(nsAString& aString) const
 {
+  nsCSSValue systemFont;
+  GetValueOrImportantValue(eCSSProperty__x_system_font, systemFont);
+  const PRBool haveSystemFont = systemFont.GetUnit() != eCSSUnit_None &&
+                                systemFont.GetUnit() != eCSSUnit_Null;
+  PRBool didSystemFont = PR_FALSE;
+
   PRInt32 count = mOrder.Length();
   PRInt32 index;
   nsAutoTArray<nsCSSProperty, 16> shorthandsUsed;
   for (index = 0; index < count; index++) {
     nsCSSProperty property = OrderValueAt(index);
     PRBool doneProperty = PR_FALSE;
 
     // If we already used this property in a shorthand, skip it.
@@ -1089,16 +1112,39 @@ nsCSSDeclaration::ToString(nsAString& aS
       // value; otherwise it's not possible to use this shorthand.
       GetValue(shorthand, value);
       if (!value.IsEmpty()) {
         AppendPropertyAndValueToString(shorthand, value, aString);
         shorthandsUsed.AppendElement(shorthand);
         doneProperty = PR_TRUE;
         break;
       }
+
+      NS_ASSERTION(shorthand != eCSSProperty_font ||
+                   *(shorthands + 1) == eCSSProperty_UNKNOWN,
+                   "font should always be the only containing shorthand");
+      if (shorthand == eCSSProperty_font && haveSystemFont) {
+        if (!didSystemFont) {
+          // Output the shorthand font declaration that we will
+          // partially override later.  But don't add it to
+          // |shorthandsUsed|, since we will have to override it.
+          AppendCSSValueToString(eCSSProperty__x_system_font, systemFont,
+                                 value);
+          AppendPropertyAndValueToString(eCSSProperty_font, value, aString);
+          value.Truncate();
+          didSystemFont = PR_TRUE;
+        }
+
+        nsCSSValue val;
+        if (property == eCSSProperty__x_system_font ||
+            (GetValueOrImportantValue(property, val),
+             val.GetUnit() == eCSSUnit_System_Font)) {
+          doneProperty = PR_TRUE;
+        }
+      }
     }
     if (doneProperty)
       continue;
     
     NS_ASSERTION(value.IsEmpty(), "value should be empty now");
     AppendPropertyAndValueToString(property, value, aString);
   }
   if (! aString.IsEmpty()) {
