From: L. David Baron <dbaron@dbaron.org>

Bug 828312 patch 2:  Return whether all lines were marked dirty from PrepareResizeReflow.  r=bzbarsky

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1620,33 +1620,34 @@ IsAlignedLeft(uint8_t aAlignment,
          NS_STYLE_TEXT_ALIGN_LEFT == aAlignment ||
          (((NS_STYLE_TEXT_ALIGN_DEFAULT == aAlignment &&
            NS_STYLE_DIRECTION_LTR == aDirection) ||
           (NS_STYLE_TEXT_ALIGN_END == aAlignment &&
            NS_STYLE_DIRECTION_RTL == aDirection)) &&
          !(NS_STYLE_UNICODE_BIDI_PLAINTEXT & aUnicodeBidi));
 }
 
-nsresult
+bool
 nsBlockFrame::PrepareResizeReflow(nsBlockReflowState& aState)
 {
   const nsStyleText* styleText = StyleText();
   const nsStyleTextReset* styleTextReset = StyleTextReset();
   // See if we can try and avoid marking all the lines as dirty
   bool tryAndSkipLines =
     // The block must be LTR (bug 806284)
     StyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR &&
     // The text must be left-aligned.
     IsAlignedLeft(styleText->mTextAlign, 
                   aState.mReflowState.mStyleVisibility->mDirection,
                   styleTextReset->mUnicodeBidi,
                   this) &&
     // The left content-edge must be a constant distance from the left
     // border-edge.
     !StylePadding()->mPadding.GetLeft().HasPercent();
+  bool markedAllDirty = false;
 
 #ifdef DEBUG
   if (gDisableResizeOpt) {
     tryAndSkipLines = false;
   }
   if (gNoisyReflow) {
     if (!tryAndSkipLines) {
       IndentBy(stdout, gNoiseIndent);
@@ -1717,24 +1718,25 @@ nsBlockFrame::PrepareResizeReflow(nsBloc
            line->GetBreakTypeBefore(), line->GetBreakTypeAfter(),
            line->mBounds.XMost());
       }
 #endif
     }
   }
   else {
     // Mark everything dirty
+    markedAllDirty = true;
     for (line_iterator line = begin_lines(), line_end = end_lines();
          line != line_end;
          ++line)
     {
       line->MarkDirty();
     }
   }
-  return NS_OK;
+  return markedAllDirty;
 }
 
 //----------------------------------------
 
 /**
  * Propagate reflow "damage" from from earlier lines to the current
  * line.  The reflow damage comes from the following sources:
  *  1. The regions of float damage remembered during reflow.
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -568,18 +568,20 @@ protected:
   void DoCollectFloats(nsIFrame* aFrame, nsFrameList& aList,
                        bool aCollectFromSiblings);
 
   // Remove a float, abs, rel positioned frame from the appropriate block's list
   static void DoRemoveOutOfFlowFrame(nsIFrame* aFrame);
 
   /** set up the conditions necessary for an resize reflow
     * the primary task is to mark the minimumly sufficient lines dirty. 
+    *
+    * Returns whether *all* lines were marked dirty.
     */
-  nsresult PrepareResizeReflow(nsBlockReflowState& aState);
+  bool PrepareResizeReflow(nsBlockReflowState& aState);
 
   /** reflow all lines that have been marked dirty */
   nsresult ReflowDirtyLines(nsBlockReflowState& aState);
 
   /** Mark a given line dirty due to reflow being interrupted on or before it */
   void MarkLineDirtyForInterrupt(nsLineBox* aLine);
 
   //----------------------------------------
