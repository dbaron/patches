From: L. David Baron <dbaron@dbaron.org>

Store the original parent of first-in-flow pushed floats.  (Bug 588237)

diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -56,16 +56,18 @@
 
 
 #ifdef DEBUG
 #include "nsBlockDebugFlags.h"
 #endif
 
 using namespace mozilla;
 
+NS_DECLARE_FRAME_PROPERTY(PushedFloatOriginalParent, nsnull);
+
 nsBlockReflowState::nsBlockReflowState(const nsHTMLReflowState& aReflowState,
                                        nsPresContext* aPresContext,
                                        nsBlockFrame* aFrame,
                                        const nsHTMLReflowMetrics& aMetrics,
                                        PRBool aTopMarginRoot,
                                        PRBool aBottomMarginRoot,
                                        PRBool aBlockNeedsFloatManager)
   : mBlock(aFrame),
@@ -526,27 +528,30 @@ nsBlockReflowState::AddFloat(nsLineLayou
 
   NS_ABORT_IF_FALSE(aFloat->GetParent(), "float must have parent");
   NS_ABORT_IF_FALSE(aFloat->GetParent()->IsFrameOfType(nsIFrame::eBlockFrame),
                     "float's parent must be block");
   NS_ABORT_IF_FALSE(aFloat->GetParent() == mBlock ||
                     (aFloat->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT),
                     "float should be in this block unless it was marked as "
                     "pushed float");
+  NS_ABORT_IF_FALSE(!aFloat->GetPrevContinuation(),
+                    "float being added must be first-in-flow");
   if (aFloat->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT) {
     // If, in a previous reflow, the float was pushed entirely to
     // another column/page, we need to steal it back.  (We might just
     // push it again, though.)  Likewise, if that previous reflow
     // reflowed this block but not its next continuation, we might need
     // to steal it from our own float-continuations list.
     nsBlockFrame *floatParent =
       static_cast<nsBlockFrame*>(aFloat->GetParent());
     floatParent->StealFrame(mPresContext, aFloat);
 
     aFloat->RemoveStateBits(NS_FRAME_IS_PUSHED_FLOAT);
+    aFloat->Properties().Delete(PushedFloatOriginalParent());
 
     // Appending is fine, since if a float was pushed to the next
     // page/column, all later floats were also pushed.
     mBlock->mFloats.AppendFrame(mBlock, aFloat);
   }
 
   // Because we are in the middle of reflowing a placeholder frame
   // within a line (and possibly nested in an inline frame or two
@@ -929,16 +934,25 @@ nsBlockReflowState::PushFloatPastBreak(n
     mFloatManager->SetPushedLeftFloatPastBreak();
   } else {
     NS_ABORT_IF_FALSE(aFloat->GetStyleDisplay()->mFloats ==
                         NS_STYLE_FLOAT_RIGHT,
                       "unexpected float value");
     mFloatManager->SetPushedRightFloatPastBreak();
   }
 
+  // A first-continuation pushed float must be annotated with its
+  // original parent (before pushing).  So if aFloat is not currently
+  // marked as a pushed float, and it has no prev-continuation, mark
+  // mBlock as its original parent.
+  if (!(aFloat->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT) &&
+      !aFloat->GetPrevContinuation()) {
+    aFloat->Properties().Set(PushedFloatOriginalParent(), mBlock);
+  }
+
   // Put the float on the pushed floats list, even though it
   // isn't actually a continuation.
   nsresult rv = mBlock->StealFrame(mPresContext, aFloat);
   NS_ASSERTION(NS_SUCCEEDED(rv), "StealFrame should succeed");
   AppendPushedFloat(aFloat);
 
   NS_FRAME_SET_OVERFLOW_INCOMPLETE(mReflowStatus);
 }
