From: L. David Baron <dbaron@dbaron.org>

Store the original parent of first-in-flow pushed floats.  (Bug 588237)

diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -161,16 +161,19 @@ public:
 
   friend nsIFrame* NS_NewBlockFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
 
   // This is a child list too, but we let nsBlockReflowState get to it
   // directly too.
   NS_DECLARE_FRAME_PROPERTY(PushedFloatProperty,
                             nsContainerFrame::DestroyFrameList)
 
+  // This is a pointer (weak) from a pushed float to its original parent.
+  NS_DECLARE_FRAME_PROPERTY(PushedFloatOriginalParent, nsnull);
+
   // nsQueryFrame
   NS_DECL_QUERYFRAME
 
   // nsIFrame
   NS_IMETHOD Init(nsIContent*      aContent,
                   nsIFrame*        aParent,
                   nsIFrame*        aPrevInFlow);
   NS_IMETHOD SetInitialChildList(nsIAtom*        aListName,
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -527,27 +527,33 @@ nsBlockReflowState::AddFloat(nsLineLayou
 
   NS_ABORT_IF_FALSE(aFloat->GetParent(), "float must have parent");
   NS_ABORT_IF_FALSE(aFloat->GetParent()->IsFrameOfType(nsIFrame::eBlockFrame),
                     "float's parent must be block");
   NS_ABORT_IF_FALSE(aFloat->GetParent() == mBlock ||
                     (aFloat->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT),
                     "float should be in this block unless it was marked as "
                     "pushed float");
+  NS_ABORT_IF_FALSE(!aFloat->GetPrevContinuation(),
+                    "float being added must be first-in-flow");
   if (aFloat->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT) {
     // If, in a previous reflow, the float was pushed entirely to
     // another column/page, we need to steal it back.  (We might just
     // push it again, though.)  Likewise, if that previous reflow
     // reflowed this block but not its next continuation, we might need
     // to steal it from our own float-continuations list.
     nsBlockFrame *floatParent =
       static_cast<nsBlockFrame*>(aFloat->GetParent());
     floatParent->StealFrame(mPresContext, aFloat);
 
     aFloat->RemoveStateBits(NS_FRAME_IS_PUSHED_FLOAT);
+    NS_ABORT_IF_FALSE(aFloat->Properties().
+                        Get(nsBlockFrame::PushedFloatOriginalParent()),
+                      "must have original parent");
+    aFloat->Properties().Delete(nsBlockFrame::PushedFloatOriginalParent());
 
     // Appending is fine, since if a float was pushed to the next
     // page/column, all later floats were also pushed.
     mBlock->mFloats.AppendFrame(mBlock, aFloat);
   }
 
   // Because we are in the middle of reflowing a placeholder frame
   // within a line (and possibly nested in an inline frame or two
@@ -934,16 +940,28 @@ nsBlockReflowState::PushFloatPastBreak(n
     mFloatManager->SetPushedLeftFloatPastBreak();
   } else {
     NS_ABORT_IF_FALSE(aFloat->GetStyleDisplay()->mFloats ==
                         NS_STYLE_FLOAT_RIGHT,
                       "unexpected float value");
     mFloatManager->SetPushedRightFloatPastBreak();
   }
 
+  // A first-continuation pushed float must be annotated with its
+  // original parent (before pushing).  So if aFloat is not currently
+  // marked as a pushed float, and it has no prev-continuation, mark
+  // mBlock as its original parent.
+  if (!(aFloat->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT) &&
+      !aFloat->GetPrevContinuation()) {
+    NS_ABORT_IF_FALSE(!aFloat->Properties().
+                        Get(nsBlockFrame::PushedFloatOriginalParent()),
+                      "must not have original parent");
+    aFloat->Properties().Set(nsBlockFrame::PushedFloatOriginalParent(), mBlock);
+  }
+
   // Put the float on the pushed floats list, even though it
   // isn't actually a continuation.
   nsresult rv = mBlock->StealFrame(mPresContext, aFloat);
   NS_ASSERTION(NS_SUCCEEDED(rv), "StealFrame should succeed");
   AppendPushedFloat(aFloat);
 
   NS_FRAME_SET_OVERFLOW_INCOMPLETE(mReflowStatus);
 }
