Extension to show memory use.

diff --git a/extensions/top/Makefile.in b/extensions/top/Makefile.in
new file mode 100644
--- /dev/null
+++ b/extensions/top/Makefile.in
@@ -0,0 +1,82 @@
+# vim: set shiftwidth=8 tabstop=8 autoindent noexpandtab copyindent:
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= top
+DIRS		= src
+EXTENSION_VERSION = 0.1
+
+XPI_NAME	= $(MODULE)
+USE_EXTENSION_MANIFEST = 1
+NO_JAR_AUTO_REG	= 1
+# XXX STRIP_XPI causes build failure on Windows
+ifeq (,$(filter WINNT WINCE,$(OS_ARCH)))
+STRIP_XPI	= 1
+endif
+INSTALL_EXTENSION_ID = {db175481-4807-4920-b52d-5bda711e4032}
+XPI_PKGNAME	= $(MODULE)-$(EXTENSION_VERSION)
+
+DIST_FILES	= \
+		install.rdf \
+		$(NULL)
+
+ifneq ($(UNIVERSAL_BINARY),)
+# When we're building a universal binary, and we have to produce the
+# exact same file both times if we're doing a universal build.  We then
+# fix up the install.rdf in combine-platform-xpis.sh to have only the
+# correct targetPlatforms listed (but after putting the universal binary
+# in the Darwin directory that lets it be shared by both).
+TARGET_PLATFORM	= $(OS_TARGET)
+else
+TARGET_PLATFORM	= $(OS_TARGET)_$(TARGET_XPCOM_ABI)
+endif
+
+XULAPP_DEFINES	= \
+		-DEXTENSION_VERSION=$(EXTENSION_VERSION) \
+		-DFIREFOX_VERSION=$(FIREFOX_VERSION) \
+		-DTARGET_PLATFORM=$(TARGET_PLATFORM) \
+		-DINSTALL_EXTENSION_ID=$(INSTALL_EXTENSION_ID) \
+		$(NULL)
+
+include $(topsrcdir)/config/rules.mk
diff --git a/extensions/top/content/leakAlert.js b/extensions/top/content/leakAlert.js
new file mode 100644
--- /dev/null
+++ b/extensions/top/content/leakAlert.js
@@ -0,0 +1,128 @@
+/* vim: set shiftwidth=4 tabstop=4 autoindent noexpandtab copyindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the leak-monitor extension.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/* Window that comes up to show memory use. */
+
+const CC = Components.classes;
+const CI = Components.interfaces;
+
+var gTreeView = new XULTreeView();
+
+function getReport()
+{
+	return window.arguments[0].QueryInterface(CI.leakmonIReport);
+}
+
+function LeakAlertOnLoad()
+{
+	document.getElementById("lwjs-tree").view = gTreeView;
+
+	var report = getReport();
+	var reason;
+	switch (report.reason) {
+		case CI.leakmonIReport.NEW_LEAKS:
+			reason = "leak";
+			break;
+		case CI.leakmonIReport.RECLAIMED_LEAKS:
+			reason = "reclaim"
+			break;
+		default:
+			throw "Unknown report type";
+	}
+
+	/* change the dialog so it shows appropriate UI for the report type */
+	document.title = document.documentElement.getAttribute("title." + reason) +
+	                 " (" + report.ident + ")";
+	document.getElementById("desc." + reason).removeAttribute("collapsed");
+
+	/* populate the tree from the report */
+	var lwjss = report.getLeakedWrappedJSs({});
+
+	for each (var lwjs in lwjss) {
+		gTreeView.childData.appendChild(new JSObjectRecord(
+			"[leaked object]", lwjs));
+	}
+}
+
+function LeakAlertOnUnload()
+{
+}
+
+function LeakAlertCopyReport()
+{
+	var text = getReport().reportText;
+	var clipboard = CC["@mozilla.org/widget/clipboardhelper;1"]
+		                .getService(CI.nsIClipboardHelper);
+	clipboard.copyString(text);
+}
+
+function JSObjectRecord(name, lwjs)
+{
+	this.lwjs = lwjs;
+
+	this.setColumnPropertyName("name", "name");
+	this.setColumnPropertyName("filename", "fileName");
+	this.setColumnPropertyName("linestart", "lineStart");
+	this.setColumnPropertyName("lineend", "lineEnd");
+	this.setColumnPropertyName("string", "stringRep");
+
+	/* we have to set these *after* calling setColumnPropertyName */
+	this.name = name;
+	for each (var m in
+	          ["fileName", "lineStart", "lineEnd", "stringRep"]) {
+		this[m] = lwjs[m];
+	}
+	if (!this.fileName) {
+		this.lineStart = "";
+		this.lineEnd = "";
+	}
+	/* collapse whitespace in stringRep */
+	this.stringRep = this.stringRep.replace(/\s+/, " ");
+
+	if (lwjs.numProperties > 0)
+		this.reserveChildren(true);
+}
+
+JSObjectRecord.prototype = new XULTreeViewRecord(gTreeView.share);
+
+JSObjectRecord.prototype.onPreOpen = function() {
+	this.childData = new Array();
+	for (var i = 0; i < this.lwjs.numProperties; ++i) {
+		this.appendChild(new JSObjectRecord(
+			this.lwjs.getPropertyNameAt(i), this.lwjs.getPropertyValueAt(i)));
+	}
+}
diff --git a/extensions/top/content/leakAlert.xul b/extensions/top/content/leakAlert.xul
new file mode 100644
--- /dev/null
+++ b/extensions/top/content/leakAlert.xul
@@ -0,0 +1,83 @@
+<?xml version="1.0"?>
+<!-- vim: set shiftwidth=4 tabstop=4 noexpandtab autoindent copyindent: -->
+<!-- ***** BEGIN LICENSE BLOCK *****
+   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
+   -
+   - The contents of this file are subject to the Mozilla Public License Version
+   - 1.1 (the "License"); you may not use this file except in compliance with
+   - the License. You may obtain a copy of the License at
+   - http://www.mozilla.org/MPL/
+   -
+   - Software distributed under the License is distributed on an "AS IS" basis,
+   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+   - for the specific language governing rights and limitations under the
+   - License.
+   -
+   - The Original Code is the leak-monitor extension.
+   -
+   - The Initial Developer of the Original Code is the Mozilla Foundation.
+   - Portions created by the Initial Developer are Copyright (C) 2006
+   - the Initial Developer. All Rights Reserved.
+   -
+   - Contributor(s):
+   -   L. David Baron <dbaron@dbaron.org> (original author)
+   -
+   - Alternatively, the contents of this file may be used under the terms of
+   - either the GNU General Public License Version 2 or later (the "GPL"), or
+   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+   - in which case the provisions of the GPL or the LGPL are applicable instead
+   - of those above. If you wish to allow use of your version of this file only
+   - under the terms of either the GPL or the LGPL, and not to allow others to
+   - use your version of this file under the terms of the MPL, indicate your
+   - decision by deleting the provisions above and replace them with the notice
+   - and other provisions required by the LGPL or the GPL. If you do not delete
+   - the provisions above, a recipient may use your version of this file under
+   - the terms of any one of the MPL, the GPL or the LGPL.
+   -
+   - ***** END LICENSE BLOCK ***** -->
+<!-- Window that comes up to show memory use. -->
+
+<?xml-stylesheet href="chrome://global/skin/" type="text/css"?>
+
+<!DOCTYPE dialog SYSTEM "chrome://top/locale/top.dtd">
+
+<dialog xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        id="top"
+        onload="LeakAlertOnLoad()"
+        onunload="LeakAlertOnUnload()"
+        title=""
+        title.leak="&top.title;"
+        title.reclaim="&top.reclaimed.title;"
+        buttons="accept,extra2"
+        buttonlabelextra2="&top.copyReport;"
+        ondialogextra2="LeakAlertCopyReport()"
+        persist="screenX screenY width height"
+        >
+	<script type="application/x-javascript"
+	        src="chrome://top/content/tree-utils.js" />
+	<script type="application/x-javascript"
+	        src="chrome://top/content/top.js" />
+
+	<description id="desc.leak" collapsed="true">&top.explanation;</description>
+	<description id="desc.reclaim" collapsed="true">&top.reclaimed.explanation;</description>
+
+	<tree id="lwjs-tree" flex="1" style="height: 10em; width: 30em">
+		<treecols>
+			<treecol primary="true" flex="2" id="lwjs:name"
+			         label="&top.lwjstree.columnLabel.name;" />
+			<splitter class="tree-splitter" />
+			<treecol flex="3" id="lwjs:filename" crop="center"
+			         label="&top.lwjstree.columnLabel.filename;" />
+			<splitter class="tree-splitter" />
+			<treecol style="width: 3em" id="lwjs:linestart"
+			         label="&top.lwjstree.columnLabel.linestart;" />
+			<splitter class="tree-splitter" />
+			<treecol style="width: 3em" id="lwjs:lineend"
+			         label="&top.lwjstree.columnLabel.lineend;" />
+			<splitter class="tree-splitter" />
+			<treecol flex="2" id="lwjs:string"
+			         label="&top.lwjstree.columnLabel.string;" />
+		</treecols>
+		<treechildren id="lwjs-body" />
+	</tree>
+</dialog>
diff --git a/extensions/top/content/tree-utils.js b/extensions/top/content/tree-utils.js
new file mode 100644
--- /dev/null
+++ b/extensions/top/content/tree-utils.js
@@ -0,0 +1,1651 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is The JavaScript Debugger.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert Ginda, <rginda@netscape.com>, original author
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * BasicOView provides functionality of tree whose elements have no children.
+ * Usage:
+ * var myTree = new BasicOView()
+ * myTree.setColumnNames (["col 1", "col 2"]);
+ * myTree.data = [["row 1, col 1", "row 1, col 2"],
+ *                    ["row 2, col 1", "row 2, col 2"]];
+ * { override get*Properties, etc, as suits your purpose. }
+ *
+ * treeBoxObject.view = myTree;
+ * 
+ * You'll need to make the appropriate myTree.tree.invalidate calls
+ * when myTree.data changes.
+ */
+
+function BasicOView()
+{
+    this.tree = null;
+}
+
+/* functions *you* should call to initialize and maintain the tree state */
+
+/* scroll the line specified by |line| to the center of the tree */
+BasicOView.prototype.centerLine =
+function bov_ctrln (line)
+{
+    var first = this.tree.getFirstVisibleRow();
+    var last = this.tree.getLastVisibleRow();
+    this.scrollToRow(line - (last - first + 1) / 2);
+}
+
+/* call this to set the association between column names and data columns */
+BasicOView.prototype.setColumnNames =
+function bov_setcn (aryNames)
+{
+    this.columnNames = new Object();
+    for (var i = 0; i < aryNames.length; ++i)
+        this.columnNames[aryNames[i]] = i;
+}
+
+/*
+ * scroll the source so |line| is at either the top, center, or bottom
+ * of the view, depending on the value of |align|.
+ *
+ * line is the one based target line.
+ * if align is negative, the line will be scrolled to the top, if align is
+ * zero the line will be centered, and if align is greater than 0 the line
+ * will be scrolled to the bottom.  0 is the default.
+ */
+BasicOView.prototype.scrollTo =
+function bov_scrollto (line, align)
+{
+    if (!this.tree)
+        return;
+
+    var headerRows = 1;
+
+    var first = this.tree.getFirstVisibleRow();
+    var last  = this.tree.getLastVisibleRow();
+    var viz   = last - first + 1 - headerRows; /* total number of visible rows */
+
+    /* all rows are visible, nothing to scroll */
+    if (first == 0 && last >= this.rowCount)
+        return;
+
+    /* tree lines are 0 based, we accept one based lines, deal with it */
+    --line;
+
+    /* safety clamp */
+    if (line < 0)
+        line = 0;
+    if (line >= this.rowCount)
+        line = this.rowCount - 1;
+
+    if (align < 0)
+    {
+        if (line > this.rowCount - viz)    /* overscroll, can't put a row from */
+            line = this.rowCount - viz; /* last page at the top. */
+        this.tree.scrollToRow(line);
+    }
+    else if (align > 0)
+    {
+        if (line < viz) /* underscroll, can't put a row from the first page */
+            line = 0;   /* at the bottom. */
+        else
+            line = line - viz + headerRows;
+
+        this.tree.scrollToRow(line);
+    }
+    else
+    {
+        var half_viz = viz / 2;
+        /* lines past this line can't be centered without causing the tree
+         * to show more rows than we have. */
+        var lastCenterable = this.rowCount - half_viz;
+        if (line > half_viz)
+            line = lastCenterable;
+        /* lines before this can't be centered without causing the tree
+         * to attempt to display negative rows. */
+        else if (line < half_viz)
+            line = half_viz;
+        else
+        /* round the vizible rows down to a whole number, or we try to end up
+         * on a N + 0.5 row! */
+            half_viz = Math.floor(half_viz);
+
+        this.tree.scrollToRow(line - half_viz);
+    }
+}
+
+BasicOView.prototype.__defineGetter__("selectedIndex", bov_getsel);
+function bov_getsel()
+{
+    if (!this.tree || this.tree.view.selection.getRangeCount() < 1)
+        return -1;
+
+    var min = new Object();
+    this.tree.view.selection.getRangeAt(0, min, {});
+    return min.value;
+}
+
+BasicOView.prototype.__defineSetter__("selectedIndex", bov_setsel);
+function bov_setsel(i)
+{
+    if (i == -1)
+        this.tree.view.selection.clearSelection();
+    else
+        this.tree.view.selection.timedSelect (i, 500);
+    return i;
+}
+
+/*
+ * functions the tree will call to retrieve the list state (nsITreeView.)
+ */
+
+BasicOView.prototype.rowCount = 0;
+
+BasicOView.prototype.getCellProperties =
+function bov_cellprops (row, col, properties)
+{
+}
+
+BasicOView.prototype.getColumnProperties =
+function bov_colprops (col, properties)
+{
+}
+
+BasicOView.prototype.getRowProperties =
+function bov_rowprops (index, properties)
+{
+}
+
+BasicOView.prototype.isContainer =
+function bov_isctr (index)
+{
+    return false;
+}
+
+BasicOView.prototype.isContainerOpen =
+function bov_isctropen (index)
+{
+    return false;
+}
+
+BasicOView.prototype.isContainerEmpty =
+function bov_isctrempt (index)
+{
+    return false;
+}
+
+BasicOView.prototype.isSeparator =
+function bov_isseparator (index)
+{
+    return false;
+}
+
+BasicOView.prototype.isSorted =
+function bov_issorted (index)
+{
+    return false;
+}
+
+BasicOView.prototype.canDrop =
+function bov_drop (index, orientation)
+{
+    return false;
+}
+
+BasicOView.prototype.drop =
+function bov_drop (index, orientation)
+{
+    return false;
+}
+
+BasicOView.prototype.getParentIndex =
+function bov_getpi (index)
+{
+    if (index < 0)
+        return -1;
+
+    return 0;
+}
+
+BasicOView.prototype.hasNextSibling =
+function bov_hasnxtsib (rowIndex, afterIndex)
+{
+    return (afterIndex < (this.rowCount - 1));
+}
+
+BasicOView.prototype.getLevel =
+function bov_getlvl (index)
+{
+    return 0;
+}
+
+BasicOView.prototype.getImageSrc =
+function bov_getimgsrc (row, col)
+{
+}
+
+BasicOView.prototype.getProgressMode =
+function bov_getprgmode (row, col)
+{
+}
+
+BasicOView.prototype.getCellValue =
+function bov_getcellval (row, col)
+{
+}
+
+BasicOView.prototype.getCellText =
+function bov_getcelltxt (row, col)
+{
+    if (!this.columnNames)
+        return "";
+    
+    if (typeof col == "object")
+        col = col.id;
+
+    var ary = col.match (/:(.*)/);
+    if (ary)
+        col = ary[1];
+
+    var colName = this.columnNames[col];
+    
+    if (typeof colName == "undefined")
+        return "";
+    
+    return this.data[row][colName];
+}
+
+BasicOView.prototype.setTree =
+function bov_seto (tree)
+{
+    this.tree = tree;
+}
+
+BasicOView.prototype.toggleOpenState =
+function bov_toggleopen (index)
+{
+}
+
+BasicOView.prototype.cycleHeader =
+function bov_cyclehdr (col)
+{
+}
+
+BasicOView.prototype.selectionChanged =
+function bov_selchg ()
+{
+}
+
+BasicOView.prototype.cycleCell =
+function bov_cyclecell (row, col)
+{
+}
+
+BasicOView.prototype.isEditable =
+function bov_isedit (row, col)
+{
+    return false;
+}
+
+BasicOView.prototype.isSelectable =
+function bov_isselect (row, col)
+{
+    return false;
+}
+
+BasicOView.prototype.setCellValue =
+function bov_setct (row, col, value)
+{
+}
+
+BasicOView.prototype.setCellText =
+function bov_setct (row, col, value)
+{
+}
+
+BasicOView.prototype.onRouteFocus =
+function bov_rfocus (event)
+{
+    if ("onFocus" in this)
+        this.onFocus(event);
+}
+
+BasicOView.prototype.onRouteBlur =
+function bov_rblur (event)
+{
+    if ("onBlur" in this)
+        this.onBlur(event);
+}
+
+BasicOView.prototype.onRouteDblClick =
+function bov_rdblclick (event)
+{
+    if (!("onRowCommand" in this) || event.target.localName != "treechildren")
+        return;
+
+    var rowIndex = this.tree.view.selection.currentIndex;
+    if (rowIndex == -1 || rowIndex > this.rowCount)
+        return;
+    var rec = this.childData.locateChildByVisualRow(rowIndex);
+    if (!rec)
+    {
+        ASSERT (0, "bogus row index " + rowIndex);
+        return;
+    }
+
+    this.onRowCommand(rec, event);
+}
+
+BasicOView.prototype.onRouteKeyPress =
+function bov_rkeypress (event)
+{
+    var rec;
+    var rowIndex;
+    
+    if ("onRowCommand" in this && (event.keyCode == 13 || event.charCode == 32))
+    {
+        if (!this.selection)
+            return;
+        
+        rowIndex = this.tree.view.selection.currentIndex;
+        if (rowIndex == -1 || rowIndex > this.rowCount)
+            return;
+        rec = this.childData.locateChildByVisualRow(rowIndex);
+        if (!rec)
+        {
+            ASSERT (0, "bogus row index " + rowIndex);
+            return;
+        }
+
+        this.onRowCommand(rec, event);
+    }
+    else if ("onKeyPress" in this)
+    {
+        rowIndex = this.tree.view.selection.currentIndex;
+        if (rowIndex != -1 && rowIndex < this.rowCount)
+        {
+            rec = this.childData.locateChildByVisualRow(rowIndex);
+            if (!rec)
+            {
+                ASSERT (0, "bogus row index " + rowIndex);
+                return;
+            }
+        }
+        else
+        {
+            rec = null;
+        }
+        
+        this.onKeyPress(rec, event);
+    }
+}
+
+BasicOView.prototype.performAction =
+function bov_pact (action)
+{
+}
+
+BasicOView.prototype.performActionOnRow =
+function bov_pactrow (action)
+{
+}
+
+BasicOView.prototype.performActionOnCell =
+function bov_pactcell (action)
+{
+}
+
+/*
+ * record for the XULTreeView.  these things take care of keeping the
+ * XULTreeView properly informed of changes in value and child count.  you 
+ * shouldn't have to maintain tree state at all.
+ *
+ * |share| should be an otherwise empty object to store cache data.
+ * you should use the same object as the |share| for the XULTreeView that you
+ * indend to contain these records.
+ *
+ */
+function XULTreeViewRecord(share)
+{
+    this._share = share;
+    this.visualFootprint = 1;
+    this.isHidden = true; /* records are considered hidden until they are
+                           * inserted into a live tree */
+}
+
+XULTreeViewRecord.prototype.isContainerOpen = false;
+
+/*
+ * walk the parent tree to find our tree container.  return null if there is
+ * none
+ */
+XULTreeViewRecord.prototype.findContainerTree =
+function xtvr_gettree ()
+{
+    if (!("parentRecord" in this))
+        return null;
+    var parent = this.parentRecord;
+    
+    while (parent)
+    {
+        if ("_treeView" in parent)
+            return parent._treeView;
+        if ("parentRecord" in parent)
+            parent = parent.parentRecord;
+        else
+            parent = null;
+    }
+
+    return null;
+}
+
+XULTreeViewRecord.prototype.__defineGetter__("childIndex", xtvr_getChildIndex);
+function xtvr_getChildIndex ()
+{
+    //dd ("getChildIndex {");
+    
+    if (!("parentRecord" in this))
+    {
+        delete this._childIndex;
+        //dd ("} -1");
+        return -1;
+    }
+    
+    if ("_childIndex" in this)
+    {
+        if ("childData" in this && this._childIndex in this.childData &&
+            this.childData[this._childIndex] == this)
+        {
+            //dd ("} " + this._childIndex);
+            return this._childIndex;
+        }
+    }
+
+    var childData = this.parentRecord.childData;
+    var len = childData.length;
+    for (var i = 0; i < len; ++i)
+    {
+        if (childData[i] == this)
+        {
+            this._childIndex = i;
+            //dd ("} " + this._childIndex);
+            return i;
+        }
+    }
+    
+    delete this._childIndex;
+    //dd ("} -1");
+    return -1;
+}
+
+XULTreeViewRecord.prototype.__defineSetter__("childIndex", xtvr_setChildIndex);
+function xtvr_setChildIndex ()
+{
+    dd("xtvr: childIndex is read only, ignore attempt to write to it\n");
+    if (typeof getStackTrace == "function")
+        dd(getStackTrace());
+}
+
+/* count the number of parents, not including the root node */
+XULTreeViewRecord.prototype.__defineGetter__("level", xtvr_getLevel);
+function xtvr_getLevel ()
+{
+    if (!("parentRecord" in this))
+        return -1;
+    
+    var rv = 0;
+    var parentRecord = this.parentRecord;
+    while ("parentRecord" in parentRecord &&
+           (parentRecord = parentRecord.parentRecord)) ++rv;
+    return rv;
+}
+
+/*
+ * associates a property name on this record, with a column in the tree.  This
+ * method will set up a get/set pair for the property name you specify which
+ * will take care of updating the tree when the value changes.  DO NOT try
+ * to change your mind later.  Do not attach a different name to the same colID,
+ * and do not rename the colID.  You have been warned.
+ */
+XULTreeViewRecord.prototype.setColumnPropertyName =
+function xtvr_setcol (colID, propertyName)
+{
+    function xtvr_getValueShim ()
+    {
+        return this._colValues[colID];
+    }
+    function xtvr_setValueShim (newValue)
+    {
+        this._colValues[colID] = newValue;
+        return newValue;
+    }
+
+    if (!("_colValues" in this))
+        this._colValues = new Object();
+    
+    if (typeof propertyName == "function")
+    {
+        this._colValues.__defineGetter__(colID, propertyName);
+    }
+    else
+    {
+        this.__defineGetter__(propertyName, xtvr_getValueShim);
+        this.__defineSetter__(propertyName, xtvr_setValueShim);
+    }
+}
+
+XULTreeViewRecord.prototype.setColumnPropertyValue =
+function xtvr_setcolv (colID, value)
+{
+    this._colValues[colID] = value;
+}
+
+/*
+ * set the default sort column and reSort.
+ */
+XULTreeViewRecord.prototype.setSortColumn =
+function xtvr_setcol (colID, dir)
+{
+    //dd ("setting sort column to " + colID);
+    this._share.sortColumn = colID;
+    this._share.sortDirection = (typeof dir == "undefined") ? 1 : dir;
+    this.reSort();
+}
+
+/*
+ * set the default sort direction.  1 is ascending, -1 is descending, 0 is no
+ * sort.  setting this to 0 will *not* recover the natural insertion order,
+ * it will only affect newly added items.
+ */
+XULTreeViewRecord.prototype.setSortDirection =
+function xtvr_setdir (dir)
+{
+    this._share.sortDirection = dir;
+}
+
+/*
+ * invalidate this row in the tree
+ */
+XULTreeViewRecord.prototype.invalidate =
+function xtvr_invalidate()
+{
+    var tree = this.findContainerTree();
+    if (tree)
+    {
+        var row = this.calculateVisualRow();
+        if (row != -1)
+            tree.tree.invalidateRow(row);
+    }
+}
+
+/*
+ * invalidate any data in the cache.
+ */
+XULTreeViewRecord.prototype.invalidateCache =
+function xtvr_killcache()
+{
+    this._share.rowCache = new Object();
+    this._share.lastComputedIndex = -1;
+    this._share.lastIndexOwner = null;
+}
+
+/*
+ * default comparator function for sorts.  if you want a custom sort, override
+ * this method.  We declare xtvr_sortcmp as a top level function, instead of
+ * a function expression so we can refer to it later.
+ */
+XULTreeViewRecord.prototype.sortCompare = xtvr_sortcmp;
+function xtvr_sortcmp (a, b)
+{
+    var sc = a._share.sortColumn;
+    var sd = a._share.sortDirection;    
+    
+    a = a[sc];
+    b = b[sc];
+
+    if (a < b)
+        return -1 * sd;
+    
+    if (a > b)
+        return 1 * sd;
+    
+    return 0;
+}
+
+/*
+ * this method will cause all child records to be reSorted.  any records
+ * with the default sortCompare method will be sorted by the colID passed to
+ * setSortColumn.
+ *
+ * the local parameter is used internally to control whether or not the 
+ * sorted rows are invalidated.  don't use it yourself.
+ */
+XULTreeViewRecord.prototype.reSort =
+function xtvr_resort (leafSort)
+{
+    if (!("childData" in this) || this.childData.length < 1 ||
+        (this.childData[0].sortCompare == xtvr_sortcmp &&
+         !("sortColumn" in this._share) || this._share.sortDirection == 0))
+    {
+        /* if we have no children, or we have the default sort compare and no
+         * sort flags, then just exit */
+        return;
+    }
+
+    this.childData.sort(this.childData[0].sortCompare);
+    
+    for (var i = 0; i < this.childData.length; ++i)
+    {
+        if ("isContainerOpen" in this.childData[i] &&
+            this.childData[i].isContainerOpen)
+            this.childData[i].reSort(true);
+        else
+            this.childData[i].sortIsInvalid = true;
+    }
+    
+    if (!leafSort)
+    {
+        this.invalidateCache();
+        var tree = this.findContainerTree();
+        if (tree && tree.tree)
+        {
+            var rowIndex = this.calculateVisualRow();
+            /*
+            dd ("invalidating " + rowIndex + " - " +
+                (rowIndex + this.visualFootprint - 1));
+            */
+            tree.tree.invalidateRange (rowIndex,
+                                       rowIndex + this.visualFootprint - 1);
+        }
+    }
+    delete this.sortIsInvalid;
+}
+    
+/*
+ * call this to indicate that this node may have children at one point.  make
+ * sure to call it before adding your first child.
+ */
+XULTreeViewRecord.prototype.reserveChildren =
+function xtvr_rkids (always)
+{
+    if (!("childData" in this))
+        this.childData = new Array();
+    if (!("isContainerOpen" in this))
+        this.isContainerOpen = false;
+    if (always)
+        this.alwaysHasChildren = true;
+    else
+        delete this.alwaysHasChildren;
+}
+
+/*
+ * add a child to the end of the child list for this record.  takes care of 
+ * updating the tree as well.
+ */
+XULTreeViewRecord.prototype.appendChild =
+function xtvr_appchild (child)
+{
+    if (!(child instanceof XULTreeViewRecord))
+        throw Components.results.NS_ERROR_INVALID_ARG;
+    
+    child.isHidden = false;
+    child.parentRecord = this;
+    this.childData.push(child);
+    
+    if ("isContainerOpen" in this && this.isContainerOpen)
+    {
+        //dd ("appendChild: " + xtv_formatRecord(child, ""));
+        if (this.calculateVisualRow() >= 0)
+        {
+            var tree = this.findContainerTree();
+            if (tree && tree.frozen)
+                this.needsReSort = true;
+            else
+                this.reSort(true);  /* reSort, don't invalidate.  we're going  
+                                     * to do that in the 
+                                     * onVisualFootprintChanged call. */
+        }
+        this.onVisualFootprintChanged(child.calculateVisualRow(),
+                                      child.visualFootprint);
+    }
+}
+
+/*
+ * add a list of children to the end of the child list for this record.
+ * faster than multiple appendChild() calls.
+ */
+XULTreeViewRecord.prototype.appendChildren =
+function xtvr_appchild (children)
+{
+    var idx = this.childData.length;
+    var delta = 0;
+    var len = children.length;
+    for (var i = 0; i <  len; ++i)
+    {
+        var child = children[i];
+        child.isHidden = false;
+        child.parentRecord = this;
+        this.childData.push(child);
+        delta += child.visualFootprint;
+    }
+    
+    if ("isContainerOpen" in this && this.isContainerOpen)
+    {
+        if (this.calculateVisualRow() >= 0)
+        {
+            this.reSort(true);  /* reSort, don't invalidate.  we're going to do
+                                 * that in the onVisualFootprintChanged call. */
+        }
+        this.onVisualFootprintChanged(this.childData[0].calculateVisualRow(),
+                                      delta);
+    }
+}
+
+/*
+ * remove a child from this record. updates the tree too.  DON'T call this with
+ * an index not actually contained by this record.
+ */
+XULTreeViewRecord.prototype.removeChildAtIndex =
+function xtvr_remchild (index)
+{
+    if (!ASSERT(this.childData.length, "removing from empty childData"))
+        return;
+    
+    var orphan = this.childData[index];
+    var fpDelta = -orphan.visualFootprint;
+    var changeStart = orphan.calculateVisualRow();
+    delete orphan.parentRecord;
+    arrayRemoveAt (this.childData, index);
+    
+    if (!orphan.isHidden && "isContainerOpen" in this && this.isContainerOpen)
+    {
+        this.onVisualFootprintChanged (changeStart, fpDelta);
+    }
+}
+
+/*
+ * hide this record and all descendants.
+ */
+XULTreeViewRecord.prototype.hide =
+function xtvr_hide ()
+{
+    if (this.isHidden)
+        return;
+
+    /* get the row before hiding */
+    var row = this.calculateVisualRow();
+    this.invalidateCache();
+    this.isHidden = true;
+    /* go right to the parent so we don't muck with our own visualFootprint
+     * record, we'll need it to be correct if we're ever unHidden. */
+    if ("parentRecord" in this)
+        this.parentRecord.onVisualFootprintChanged (row, -this.visualFootprint);
+}
+
+/*
+ * unhide this record and all descendants.
+ */
+XULTreeViewRecord.prototype.unHide =
+function xtvr_uhide ()
+{
+    if (!this.isHidden)
+        return;
+
+    this.isHidden = false;
+    this.invalidateCache();
+    var row = this.calculateVisualRow();
+    if (this.parentRecord)
+        this.parentRecord.onVisualFootprintChanged (row, this.visualFootprint);
+}
+
+/*
+ * open this record, exposing it's children.  DON'T call this method if the
+ * record has no children.
+ */
+XULTreeViewRecord.prototype.open =
+function xtvr_open ()
+{
+    if (this.isContainerOpen)
+        return;
+
+    if ("onPreOpen" in this)
+        this.onPreOpen();
+    
+    this.isContainerOpen = true;
+    var delta = 0;
+    for (var i = 0; i < this.childData.length; ++i)
+    {
+        if (!this.childData[i].isHidden)
+            delta += this.childData[i].visualFootprint;
+    }
+
+    /* this reSort should only happen if the sort column changed */
+    this.reSort(true);
+    this.visualFootprint += delta;
+    if ("parentRecord" in this)
+    {
+        this.parentRecord.onVisualFootprintChanged(this.calculateVisualRow(),
+                                                   0);
+        this.parentRecord.onVisualFootprintChanged(this.calculateVisualRow() +
+                                                   1, delta);
+    }
+}
+
+/*
+ * close this record, hiding it's children.  DON'T call this method if the record
+ * has no children, or if it is already closed.
+ */
+XULTreeViewRecord.prototype.close =
+function xtvr_close ()
+{
+    if (!this.isContainerOpen)
+        return;
+    
+    this.isContainerOpen = false;
+    var delta = 1 - this.visualFootprint;
+    this.visualFootprint += delta;
+    if ("parentRecord" in this)
+    {
+        this.parentRecord.onVisualFootprintChanged(this.calculateVisualRow(),
+                                                   0);
+        this.parentRecord.onVisualFootprintChanged(this.calculateVisualRow() +
+                                                   1, delta);
+    }
+
+    if ("onPostClose" in this)
+        this.onPostClose();
+}
+
+/*
+ * called when a node above this one grows or shrinks.  we need to adjust
+ * our own visualFootprint to match the change, and pass the message on.
+ */
+XULTreeViewRecord.prototype.onVisualFootprintChanged =
+function xtvr_vpchange (start, amount)
+{
+    /* if we're not hidden, but this notification came from a hidden node 
+     * (start == -1), ignore it, it doesn't affect us. */
+    if (start == -1 && !this.isHidden)
+    {
+        
+        //dd ("vfp change (" + amount + ") from hidden node ignored.");
+        return;
+    }
+    
+    this.visualFootprint += amount;
+
+    if ("parentRecord" in this)
+        this.parentRecord.onVisualFootprintChanged(start, amount);
+}
+
+/*
+ * calculate the "visual" row for this record.  If the record isn't actually
+ * visible return -1.
+ * eg.
+ * Name        Visual Row
+ * node1       0
+ *   node11    1
+ *   node12    2
+ * node2       3
+ *   node21    4
+ * node3       5
+ */
+XULTreeViewRecord.prototype.calculateVisualRow =
+function xtvr_calcrow ()
+{
+    /* if this is the second time in a row that someone asked us, fetch the last
+     * result from the cache. */
+    if (this._share.lastIndexOwner == this)
+        return this._share.lastComputedIndex;
+
+    var vrow;
+
+        /* if this is an uninserted or hidden node, or... */
+    if (!("parentRecord" in this) || (this.isHidden) ||
+        /* if parent isn't open, or... */
+        (!this.parentRecord.isContainerOpen) ||
+        /* parent isn't visible */
+        ((vrow = this.parentRecord.calculateVisualRow()) == -1))
+    {
+        /* then we're not visible, return -1 */
+        //dd ("cvr: returning -1");
+        return -1;
+    }
+
+    /* parent is the root node XXX parent is not visible */
+    if (vrow == null)
+        vrow = 0;
+    else
+    /* parent is not the root node, add one for the space they take up. */
+        ++vrow;
+
+    /* add in the footprint for all of the earlier siblings */
+    var ci = this.childIndex;
+    for (var i = 0; i < ci; ++i)
+    {
+        if (!this.parentRecord.childData[i].isHidden)
+            vrow += this.parentRecord.childData[i].visualFootprint;
+    }
+
+    /* save this calculation to the cache. */
+    this._share.lastIndexOwner = this;
+    this._share.lastComputedIndex = vrow;
+
+    return vrow;
+}
+
+/*
+ * locates the child record for the visible row |targetRow|.  DO NOT call this
+ * with a targetRow less than this record's visual row, or greater than this
+ * record's visual row + the number of visible children it has.
+ */
+XULTreeViewRecord.prototype.locateChildByVisualRow =
+function xtvr_find (targetRow, myRow)
+{
+    if (targetRow in this._share.rowCache)
+        return this._share.rowCache[targetRow];
+
+    /* if this is true, we *are* the index */
+    if (targetRow == myRow)
+        return (this._share.rowCache[targetRow] = this);
+
+    /* otherwise, we've got to search the kids */
+    var childStart = myRow; /* childStart represents the starting visual row
+                             * for the child we're examining. */
+    for (var i = 0; i < this.childData.length; ++i)
+    {
+        var child = this.childData[i];
+        /* ignore hidden children */
+        if (child.isHidden)
+            continue;
+        /* if this kid is the targetRow, we're done */
+        if (childStart == targetRow)
+            return (this._share.rowCache[targetRow] = child);
+        /* if this kid contains the index, ask *it* to find the record */
+        else if (targetRow <= childStart + child.visualFootprint) {
+            /* this *has* to succeed */
+            var rv = child.locateChildByVisualRow(targetRow, childStart + 1);
+            //XXXASSERT (rv, "Can't find a row that *has* to be there.");
+            /* don't cache this, the previous call to locateChildByVisualRow
+             * just did. */
+            return rv;
+        }
+
+        /* otherwise, get ready to ask the next kid */
+        childStart += child.visualFootprint;
+    }
+
+    return null;
+}   
+
+/* XTLabelRecords can be used to drop a label into an arbitrary place in an
+ * arbitrary tree.  normally, specializations of XULTreeViewRecord are tied to
+ * a specific tree because of implementation details.  XTLabelRecords are
+ * specially designed (err, hacked) to work around these details.  this makes
+ * them slower, but more generic.
+ *
+ * we set up a getter for _share that defers to the parent object.  this lets
+ * XTLabelRecords work in any tree.
+ */
+function XTLabelRecord (columnName, label, blankCols)
+{
+    this.setColumnPropertyName (columnName, "label");
+    this.label = label;
+    this.property = null;
+    
+    if (typeof blankCols == "object")
+    {
+        for (var i in blankCols)
+            this._colValues[blankCols[i]] = "";
+    }
+}
+
+XTLabelRecord.prototype = new XULTreeViewRecord (null);
+
+XTLabelRecord.prototype.__defineGetter__("_share", tolr_getshare);
+function tolr_getshare()
+{
+    if ("parentRecord" in this)
+        return this.parentRecord._share;
+
+    ASSERT (0, "XTLabelRecord cannot be the root of a visible tree.");
+    return null;
+}
+
+/* XTRootRecord is used internally by XULTreeView, you probably don't need to 
+ * make any of these */ 
+function XTRootRecord (tree, share)
+{
+    this._share = share;
+    this._treeView = tree;
+    this.visualFootprint = 0;
+    this.isHidden = false;
+    this.reserveChildren();
+    this.isContainerOpen = true;
+}
+
+/* no cache passed in here, we set it in the XTRootRecord contructor instead. */
+XTRootRecord.prototype = new XULTreeViewRecord (null);
+
+XTRootRecord.prototype.open =
+XTRootRecord.prototype.close =
+function torr_notimplemented()
+{
+    /* don't do this on a root node */
+}
+
+XTRootRecord.prototype.calculateVisualRow =
+function torr_calcrow ()
+{
+    return null;
+}
+
+XTRootRecord.prototype.reSort =
+function torr_resort ()
+{
+    if ("_treeView" in this && this._treeView.frozen)
+    {
+        this._treeView.needsReSort = true;
+        return;
+    }
+    
+    if (!("childData" in this) || this.childData.length < 1 ||
+        (this.childData[0].sortCompare == xtvr_sortcmp &&
+         !("sortColumn" in this._share) || this._share.sortDirection == 0))
+    {
+        /* if we have no children, or we have the default sort compare but we're
+         * missing a sort flag, then just exit */
+        return;
+    }
+    
+    this.childData.sort(this.childData[0].sortCompare);
+    
+    for (var i = 0; i < this.childData.length; ++i)
+    {
+        if ("isContainerOpen" in this.childData[i] &&
+            this.childData[i].isContainerOpen)
+            this.childData[i].reSort(true);
+        else
+            this.childData[i].sortIsInvalid = true;
+    }
+    
+    if ("_treeView" in this && this._treeView.tree)
+    {
+        /*
+        dd ("root node: invalidating 0 - " + this.visualFootprint +
+            " for sort");
+        */
+        this.invalidateCache();
+        this._treeView.tree.invalidateRange (0, this.visualFootprint);
+    }
+}
+
+XTRootRecord.prototype.locateChildByVisualRow =
+function torr_find (targetRow)
+{
+    if (targetRow in this._share.rowCache)
+        return this._share.rowCache[targetRow];
+
+    var childStart = -1; /* childStart represents the starting visual row
+                          * for the child we're examining. */
+    for (var i = 0; i < this.childData.length; ++i)
+    {
+        var child = this.childData[i];
+        /* ignore hidden children */
+        if (child.isHidden)
+            continue;
+        /* if this kid is the targetRow, we're done */
+        if (childStart == targetRow)
+            return (this._share.rowCache[targetRow] = child);
+        /* if this kid contains the index, ask *it* to find the record */
+        else if (targetRow <= childStart + child.visualFootprint) {
+            /* this *has* to succeed */
+            var rv = child.locateChildByVisualRow(targetRow, childStart + 1);
+            //XXXASSERT (rv, "Can't find a row that *has* to be there.");
+            /* don't cache this, the previous call to locateChildByVisualRow
+             * just did. */
+            return rv;
+        }
+
+        /* otherwise, get ready to ask the next kid */
+        childStart += child.visualFootprint;
+    }
+
+    return null;
+}
+
+XTRootRecord.prototype.onVisualFootprintChanged =
+function torr_vfpchange (start, amount)
+{
+    if (!this._treeView.frozen)
+    {
+        this.invalidateCache();
+        this.visualFootprint += amount;
+        if ("_treeView" in this && "tree" in this._treeView && 
+            this._treeView.tree)
+        {
+            if (amount != 0)
+                this._treeView.tree.rowCountChanged (start, amount);
+            else
+                this._treeView.tree.invalidateRow (start);
+        }
+    }
+    else
+    {
+        if ("changeAmount"  in this._treeView)
+            this._treeView.changeAmount += amount;
+        else
+            this._treeView.changeAmount = amount;
+        if ("changeStart" in this._treeView)
+            this._treeView.changeStart = 
+                Math.min (start, this._treeView.changeStart);
+        else
+            this._treeView.changeStart = start;
+    }
+}
+
+/*
+ * XULTreeView provides functionality of tree whose elements have multiple
+ * levels of children.
+ */
+
+function XULTreeView(share)
+{
+    if (!share)
+        share = new Object();
+    this.childData = new XTRootRecord(this, share);
+    this.childData.invalidateCache();
+    this.tree = null;
+    this.share = share;
+    this.frozen = 0;
+}
+
+/* functions *you* should call to initialize and maintain the tree state */
+
+/*
+ * Changes to the tree contents will not cause the tree to be invalidated
+ * until thaw() is called.  All changes will be pooled into a single invalidate
+ * call.
+ *
+ * Freeze/thaws are nestable, the tree will not update until the number of
+ * thaw() calls matches the number of freeze() calls.
+ */
+XULTreeView.prototype.freeze =
+function xtv_freeze ()
+{
+    if (++this.frozen == 1)
+    {
+        this.changeStart = 0;
+        this.changeAmount = 0;
+    }
+    //dd ("freeze " + this.frozen);
+}
+
+/*
+ * Reflect any changes to the tree content since the last freeze.
+ */
+XULTreeView.prototype.thaw =
+function xtv_thaw ()
+{
+    if (this.frozen == 0)
+    {
+        ASSERT (0, "not frozen");
+        return;
+    }
+    
+    if (--this.frozen == 0 && "changeStart" in this)
+    {
+        this.childData.onVisualFootprintChanged(this.changeStart,
+                                                this.changeAmount);
+    }
+    
+    if ("needsReSort" in this) {
+        this.childData.reSort();
+        delete this.needsReSort;
+    }
+    
+    
+    delete this.changeStart;
+    delete this.changeAmount;
+}
+
+XULTreeView.prototype.saveBranchState =
+function xtv_savebranch (target, source, recurse)
+{
+    var len = source.length;
+    for (var i = 0; i < len; ++i)
+    {
+        if (source[i].isContainerOpen)
+        {
+            target[i] = new Object();
+            target[i].name = source[i]._colValues["col-0"];
+            if (recurse)
+                this.saveBranchState (target[i], source[i].childData, true);
+        }
+    }
+}
+
+XULTreeView.prototype.restoreBranchState =
+function xtv_restorebranch (target, source, recurse)
+{
+    for (var i in source)
+    {
+        if (typeof source[i] == "object")
+        {
+            var name = source[i].name;
+            var len = target.length;
+            for (var j = 0; j < len; ++j)
+            {
+                if (target[j]._colValues["col-0"] == name &&
+                    "childData" in target[j])
+                {
+                    //dd ("opening " + name);
+                    target[j].open();
+                    if (recurse)
+                    {
+                        this.restoreBranchState (target[j].childData,
+                                                 source[i], true);
+                    }
+                    break;
+                }
+            }
+        }
+    }
+}
+
+/* scroll the line specified by |line| to the center of the tree */
+XULTreeView.prototype.centerLine =
+function xtv_ctrln (line)
+{
+    var first = this.tree.getFirstVisibleRow();
+    var last = this.tree.getLastVisibleRow();
+    this.scrollToRow(line - (last - first + 1) / 2);
+}
+
+/*
+ * functions the tree will call to retrieve the list state (nsITreeView.)
+ */
+
+XULTreeView.prototype.__defineGetter__("rowCount", xtv_getRowCount);
+function xtv_getRowCount ()
+{
+    if (!this.childData)
+      return 0;
+
+    return this.childData.visualFootprint;
+}
+
+XULTreeView.prototype.isContainer =
+function xtv_isctr (index)
+{
+    var row = this.childData.locateChildByVisualRow (index);
+
+    return Boolean(row && ("alwaysHasChildren" in row || "childData" in row));
+}
+
+XULTreeView.prototype.__defineGetter__("selectedIndex", xtv_getsel);
+function xtv_getsel()
+{
+    if (!this.tree || this.tree.view.selection.getRangeCount() < 1)
+        return -1;
+
+    var min = new Object();
+    this.tree.view.selection.getRangeAt(0, min, {});
+    return min.value;
+}
+
+XULTreeView.prototype.__defineSetter__("selectedIndex", xtv_setsel);
+function xtv_setsel(i)
+{
+    this.tree.view.selection.clearSelection();
+    if (i != -1)
+        this.tree.view.selection.timedSelect (i, 500);
+    return i;
+}
+
+XULTreeView.prototype.scrollTo = BasicOView.prototype.scrollTo;
+
+XULTreeView.prototype.isContainerOpen =
+function xtv_isctropen (index)
+{
+    var row = this.childData.locateChildByVisualRow (index);
+    return row && row.isContainerOpen;
+}
+
+XULTreeView.prototype.toggleOpenState =
+function xtv_toggleopen (index)
+{
+    var row = this.childData.locateChildByVisualRow (index);
+    //ASSERT(row, "bogus row");
+    if (row)
+    {
+        if (row.isContainerOpen)
+            row.close();
+        else
+            row.open();
+    }
+}
+
+XULTreeView.prototype.isContainerEmpty =
+function xtv_isctrempt (index)
+{
+    var row = this.childData.locateChildByVisualRow (index);
+    if ("alwaysHasChildren" in row)
+        return false;
+
+    if (!row || !("childData" in row))
+        return true;
+
+    return !row.childData.length;
+}
+
+XULTreeView.prototype.isSeparator =
+function xtv_isseparator (index)
+{
+    return false;
+}
+
+XULTreeView.prototype.getParentIndex =
+function xtv_getpi (index)
+{
+    if (index < 0)
+        return -1;
+    
+    var row = this.childData.locateChildByVisualRow (index);
+    
+    var rv = row.parentRecord.calculateVisualRow();
+    //dd ("getParentIndex: row " + index + " returning " + rv);
+    return (rv != null) ? rv : -1;
+}
+
+XULTreeView.prototype.hasNextSibling =
+function xtv_hasnxtsib (rowIndex, afterIndex)
+{
+    var row = this.childData.locateChildByVisualRow (rowIndex);
+    return row.childIndex < row.parentRecord.childData.length - 1;
+}
+
+XULTreeView.prototype.getLevel =
+function xtv_getlvl (index)
+{
+    var row = this.childData.locateChildByVisualRow (index);
+    if (!row)
+        return 0;
+    
+    return row.level;
+}
+
+XULTreeView.prototype.getImageSrc =
+function xtv_getimgsrc (index, col)
+{
+}
+
+XULTreeView.prototype.getProgressMode =
+function xtv_getprgmode (index, col)
+{
+}
+
+XULTreeView.prototype.getCellValue =
+function xtv_getcellval (index, col)
+{
+}
+
+XULTreeView.prototype.getCellText =
+function xtv_getcelltxt (index, col)
+{
+    var row = this.childData.locateChildByVisualRow (index);
+    //ASSERT(row, "bogus row " + index);
+
+    if (typeof col == "object")
+        col = col.id;
+
+    var ary = col.match (/:(.*)/);
+    if (ary)
+        col = ary[1];
+
+    if (row && row._colValues && col in row._colValues)
+        return row._colValues[col];
+    else
+        return "";
+}
+
+XULTreeView.prototype.getCellProperties =
+function xtv_cellprops (row, col, properties)
+{}
+
+XULTreeView.prototype.getColumnProperties =
+function xtv_colprops (col, properties)
+{}
+
+XULTreeView.prototype.getRowProperties =
+function xtv_rowprops (index, properties)
+{}
+
+XULTreeView.prototype.isSorted =
+function xtv_issorted (index)
+{
+    return false;
+}
+
+XULTreeView.prototype.canDrop =
+function xtv_drop (index, orientation)
+{
+    var row = this.childData.locateChildByVisualRow (index);
+    //ASSERT(row, "bogus row " + index);
+    return (row && ("canDrop" in row) && row.canDrop(orientation));
+}
+
+XULTreeView.prototype.drop =
+function xtv_drop (index, orientation)
+{
+    var row = this.childData.locateChildByVisualRow (index);
+    //ASSERT(row, "bogus row " + index);
+    return (row && ("drop" in row) && row.drop(orientation));
+}
+
+XULTreeView.prototype.setTree =
+function xtv_seto (tree)
+{
+    this.childData.invalidateCache();
+    this.tree = tree;
+}
+
+XULTreeView.prototype.cycleHeader =
+function xtv_cyclehdr (col)
+{
+}
+
+XULTreeView.prototype.selectionChanged =
+function xtv_selchg ()
+{
+}
+
+XULTreeView.prototype.cycleCell =
+function xtv_cyclecell (row, col)
+{
+}
+
+XULTreeView.prototype.isEditable =
+function xtv_isedit (row, col)
+{
+    return false;
+}
+
+XULTreeView.prototype.isSelectable =
+function xtv_isselect (row, col)
+{
+    return false;
+}
+
+XULTreeView.prototype.setCellValue =
+function xtv_setct (row, col, value)
+{
+}
+
+XULTreeView.prototype.setCellText =
+function xtv_setct (row, col, value)
+{
+}
+
+XULTreeView.prototype.performAction =
+function xtv_pact (action)
+{
+}
+
+XULTreeView.prototype.performActionOnRow =
+function xtv_pactrow (action)
+{
+}
+
+XULTreeView.prototype.performActionOnCell =
+function xtv_pactcell (action)
+{
+}
+
+XULTreeView.prototype.onRouteFocus =
+function xtv_rfocus (event)
+{
+    if ("onFocus" in this)
+        this.onFocus(event);
+}
+
+XULTreeView.prototype.onRouteBlur =
+function xtv_rblur (event)
+{
+    if ("onBlur" in this)
+        this.onBlur(event);
+}
+
+XULTreeView.prototype.onRouteDblClick =
+function xtv_rdblclick (event)
+{
+    if (!("onRowCommand" in this) || event.target.localName != "treechildren")
+        return;
+
+    var rowIndex = this.tree.view.selection.currentIndex;
+    if (rowIndex == -1 || rowIndex > this.rowCount)
+        return;
+    var rec = this.childData.locateChildByVisualRow(rowIndex);
+    if (!rec)
+    {
+        ASSERT (0, "bogus row index " + rowIndex);
+        return;
+    }
+
+    this.onRowCommand(rec, event);
+}
+
+XULTreeView.prototype.onRouteKeyPress =
+function xtv_rkeypress (event)
+{
+    var rec;
+    var rowIndex;
+    
+    if ("onRowCommand" in this && (event.keyCode == 13 || event.charCode == 32))
+    {
+        if (!this.selection)
+            return;
+        
+        rowIndex = this.tree.view.selection.currentIndex;
+        if (rowIndex == -1 || rowIndex > this.rowCount)
+            return;
+        rec = this.childData.locateChildByVisualRow(rowIndex);
+        if (!rec)
+        {
+            ASSERT (0, "bogus row index " + rowIndex);
+            return;
+        }
+
+        this.onRowCommand(rec, event);
+    }
+    else if ("onKeyPress" in this)
+    {
+        rowIndex = this.tree.view.selection.currentIndex;
+        if (rowIndex != -1 && rowIndex < this.rowCount)
+        {
+            rec = this.childData.locateChildByVisualRow(rowIndex);
+            if (!rec)
+            {
+                ASSERT (0, "bogus row index " + rowIndex);
+                return;
+            }
+        }
+        else
+        {
+            rec = null;
+        }
+        
+        this.onKeyPress(rec, event);
+    }
+}
+
+/******************************************************************************/
+
+function xtv_formatRecord (rec, indent)
+{
+    var str = "";
+    
+    for (var i in rec._colValues)
+            str += rec._colValues[i] + ", ";
+    
+    str += "[";
+    
+    str += rec.calculateVisualRow() + ", ";
+    str += rec.childIndex + ", ";
+    str += rec.level + ", ";
+    str += rec.visualFootprint + ", ";
+    str += rec.isHidden + "]";
+    
+    return (indent + str);
+}
+    
+function xtv_formatBranch (rec, indent, recurse)
+{
+    var str = "";
+    for (var i = 0; i < rec.childData.length; ++i)
+    {
+        str += xtv_formatRecord (rec.childData[i], indent) + "\n";
+        if (recurse)
+        {
+            if ("childData" in rec.childData[i])
+                str += xtv_formatBranch(rec.childData[i], indent + "  ",
+                                        --recurse);
+        }
+    }
+
+    return str;
+}
+    
diff --git a/extensions/top/install.rdf b/extensions/top/install.rdf
new file mode 100644
--- /dev/null
+++ b/extensions/top/install.rdf
@@ -0,0 +1,64 @@
+<?xml version="1.0"?>
+<!-- vim: set shiftwidth=4 tabstop=4 noexpandtab copyindent: -->
+<!-- ***** BEGIN LICENSE BLOCK *****
+   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
+   -
+   - The contents of this file are subject to the Mozilla Public License Version
+   - 1.1 (the "License"); you may not use this file except in compliance with
+   - the License. You may obtain a copy of the License at
+   - http://www.mozilla.org/MPL/
+   -
+   - Software distributed under the License is distributed on an "AS IS" basis,
+   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+   - for the specific language governing rights and limitations under the
+   - License.
+   -
+   - The Original Code is about:accessibilityenabled.
+   -
+   - The Initial Developer of the Original Code is the Mozilla Foundation.
+   - Portions created by the Initial Developer are Copyright (C) 2006
+   - the Initial Developer. All Rights Reserved.
+   -
+   - Contributor(s):
+   -   L. David Baron <dbaron@dbaron.org> (original author)
+   -
+   - Alternatively, the contents of this file may be used under the terms of
+   - either the GNU General Public License Version 2 or later (the "GPL"), or
+   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+   - in which case the provisions of the GPL or the LGPL are applicable instead
+   - of those above. If you wish to allow use of your version of this file only
+   - under the terms of either the GPL or the LGPL, and not to allow others to
+   - use your version of this file under the terms of the MPL, indicate your
+   - decision by deleting the provisions above and replace them with the notice
+   - and other provisions required by the LGPL or the GPL. If you do not delete
+   - the provisions above, a recipient may use your version of this file under
+   - the terms of any one of the MPL, the GPL or the LGPL.
+   -
+   - ***** END LICENSE BLOCK ***** -->
+
+<RDF xmlns="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+     xmlns:em="http://www.mozilla.org/2004/em-rdf#">
+
+	<Description about="urn:mozilla:install-manifest">
+#expand 		<em:id>__INSTALL_EXTENSION_ID__</em:id>
+#expand 		<em:version>__EXTENSION_VERSION__</em:version>
+
+		<!-- Firefox -->
+		<em:targetApplication>
+			<Description>
+				<em:id>{ec8030f7-c20a-464f-9b0e-13a3a9e97384}</em:id>
+#expand				<em:minVersion>__FIREFOX_VERSION</em:minVersion>
+#expand				<em:maxVersion>__FIREFOX_VERSION</em:maxVersion>
+			</Description>
+		</em:targetApplication>
+
+		<em:type>2</em:type>
+
+#expand 		<em:targetPlatform>__TARGET_PLATFORM__</em:targetPlatform>
+
+		<em:name>Top</em:name>
+		<em:description>This extension shows some of the memory used by various pages.</em:description>
+		<em:creator>L. David Baron</em:creator>
+		<em:homepageURL>http://dbaron.org/mozilla/top/</em:homepageURL>
+	</Description>
+</RDF>
diff --git a/extensions/top/jar.mn b/extensions/top/jar.mn
new file mode 100644
--- /dev/null
+++ b/extensions/top/jar.mn
@@ -0,0 +1,44 @@
+# vim: set shiftwidth=45 tabstop=45 autoindent noexpandtab copyindent:
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the leak-monitor extension.
+#
+# The Initial Developer of the Original Code is the Mozilla Foundation.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+leakmon.jar:
+% content leakmonitor %content/
+% locale leakmonitor en-US %locale/en-US/
+  content/top.xul
+  content/top.js
+  content/tree-utils.js
+  locale/en-US/top.dtd
diff --git a/extensions/top/locale/en-US/top.dtd b/extensions/top/locale/en-US/top.dtd
new file mode 100644
--- /dev/null
+++ b/extensions/top/locale/en-US/top.dtd
@@ -0,0 +1,47 @@
+<!-- vim: set shiftwidth=8 tabstop=8 autoindent noexpandtab: -->
+<!-- ***** BEGIN LICENSE BLOCK *****
+   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
+   -
+   - The contents of this file are subject to the Mozilla Public License Version
+   - 1.1 (the "License"); you may not use this file except in compliance with
+   - the License. You may obtain a copy of the License at
+   - http://www.mozilla.org/MPL/
+   -
+   - Software distributed under the License is distributed on an "AS IS" basis,
+   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+   - for the specific language governing rights and limitations under the
+   - License.
+   -
+   - The Original Code is the leak-monitor extension.
+   -
+   - The Initial Developer of the Original Code is the Mozilla Foundation.
+   - Portions created by the Initial Developer are Copyright (C) 2006
+   - the Initial Developer. All Rights Reserved.
+   -
+   - Contributor(s):
+   -   L. David Baron <dbaron@dbaron.org> (original author)
+   -
+   - Alternatively, the contents of this file may be used under the terms of
+   - either the GNU General Public License Version 2 or later (the "GPL"), or
+   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+   - in which case the provisions of the GPL or the LGPL are applicable instead
+   - of those above. If you wish to allow use of your version of this file only
+   - under the terms of either the GPL or the LGPL, and not to allow others to
+   - use your version of this file under the terms of the MPL, indicate your
+   - decision by deleting the provisions above and replace them with the notice
+   - and other provisions required by the LGPL or the GPL. If you do not delete
+   - the provisions above, a recipient may use your version of this file under
+   - the terms of any one of the MPL, the GPL or the LGPL.
+   -
+   - ***** END LICENSE BLOCK ***** -->
+<!ENTITY leakAlert.title "New Leak Alert">
+<!ENTITY leakAlert.explanation "The following JavaScript objects from a window that was recently closed are still held by native code.">
+<!ENTITY leakAlert.reclaimed.title "Reclaimed Leak Alert">
+<!ENTITY leakAlert.reclaimed.explanation "JavaScript objects from this window were previously reported as having leaked, but some of the memory has been reclaimed.  The following objects are still leaked.">
+<!ENTITY leakAlert.copyReport "Copy Report to Clipboard">
+
+<!ENTITY leakAlert.lwjstree.columnLabel.name "Name">
+<!ENTITY leakAlert.lwjstree.columnLabel.filename "File Name">
+<!ENTITY leakAlert.lwjstree.columnLabel.linestart "Start">
+<!ENTITY leakAlert.lwjstree.columnLabel.lineend "End">
+<!ENTITY leakAlert.lwjstree.columnLabel.string "String Representation">
diff --git a/extensions/top/makefiles.sh b/extensions/top/makefiles.sh
new file mode 100755
--- /dev/null
+++ b/extensions/top/makefiles.sh
@@ -0,0 +1,43 @@
+#! /bin/sh
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla Build System
+#
+# The Initial Developer of the Original Code is
+# Ben Turner <mozilla@songbirdnest.com>
+#
+# Portions created by the Initial Developer are Copyright (C) 2007
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (for leak-monitor)
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+add_makefiles "
+  extensions/leak-monitor/Makefile
+  extensions/leak-monitor/src/Makefile
+"
diff --git a/extensions/top/src/Makefile.in b/extensions/top/src/Makefile.in
new file mode 100644
--- /dev/null
+++ b/extensions/top/src/Makefile.in
@@ -0,0 +1,81 @@
+# vim: set shiftwidth=8 tabstop=8 autoindent noexpandtab copyindent:
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= top
+LIBRARY_NAME	= top
+XPI_NAME	= $(MODULE)
+IS_COMPONENT	= 1
+
+# bug 376041 doesn't have much info, but mfinkle says this is recommended
+USE_STATIC_LIBS	= 1
+
+REQUIRES	= \
+		  xpcom \
+		  js \
+		  xpconnect \
+		  embedcomponents \
+		  dom \
+		  xulapp \
+		  $(NULL)
+
+DEFINES		+= -DMOZILLA_STRICT_API
+
+XPIDLSRCS	= \
+		topIService.idl \
+		$(NULL)
+
+CPPSRCS		= \
+		topModule.cpp \
+		topService.cpp \
+		$(NULL)
+
+# Should I need $(OS_LIBS) ?
+EXTRA_DSO_LDOPTS += \
+		$(XPCOM_GLUE_LDOPTS) \
+		$(MOZ_JS_LIBS) \
+		$(MOZ_COMPONENT_NSPR_LIBS) \
+		$(NULL)
+
+include $(topsrcdir)/config/rules.mk
diff --git a/extensions/top/src/topIReport.idl b/extensions/top/src/topIReport.idl
new file mode 100644
--- /dev/null
+++ b/extensions/top/src/topIReport.idl
@@ -0,0 +1,43 @@
+/* vim: set shiftwidth=4 tabstop=4 autoindent cindent noexpandtab copyindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the leak-monitor extension.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+[scriptable, uuid(89b0dd37-07a2-4b27-a575-009777c3feb3)]
+interface topIReport : nsISupports
+{
+};
diff --git a/extensions/top/src/topModule.cpp b/extensions/top/src/topModule.cpp
new file mode 100644
--- /dev/null
+++ b/extensions/top/src/topModule.cpp
@@ -0,0 +1,67 @@
+/* vim: set shiftwidth=4 tabstop=4 autoindent cindent noexpandtab copyindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the leak-monitor extension.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+// Internal includes
+#include "topReport.h"
+
+// XPCOM glue APIs
+#include "nsIGenericFactory.h"
+
+// 55db7898-5d92-4f69-8e4c-ccee92acfb58
+#define NS_TOP_REPORT_CID \
+{ 0x55db7898, 0x5d92, 0x4f69, \
+  { 0x8e, 0x4c, 0xcc, 0xee, 0x92, 0xac, 0xfb, 0x58 } }
+
+#define NS_TOP_REPORT_CONTRACTID \
+	"@dbaron.org/top-service;1"
+
+#define NS_TOP_REPORT_ENTRY_NAME \
+	"topReport"
+
+NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(topReport, Init)
+
+static const nsModuleComponentInfo components[] =
+{
+	{
+		NS_TOP_REPORT_ENTRY_NAME,
+		NS_TOP_REPORT_CID,
+		NS_TOP_REPORT_CONTRACTID,
+		topReportConstructor
+	}
+};
+
+NS_IMPL_NSGETMODULE(leakmonModule, components)
diff --git a/extensions/top/src/topReport.cpp b/extensions/top/src/topReport.cpp
new file mode 100644
--- /dev/null
+++ b/extensions/top/src/topReport.cpp
@@ -0,0 +1,263 @@
+/* vim: set shiftwidth=4 tabstop=4 autoindent cindent noexpandtab copyindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the leak-monitor extension.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * service that monitors the state of wrapped JS objects at each GC,
+ * particularly to find those in closed windows
+ */
+
+// Internal includes
+#include "topReport.h"
+
+// Frozen APIs
+#include "nsIObserverService.h"
+#include "nsIWindowWatcher.h"
+#include "nsIDOMWindow.h"
+#include "nsIXULAppInfo.h"
+
+// Frozen APIs that require linking against NSPR.
+#include "plstr.h"
+
+// XPCOM glue APIs
+#include "nsDebug.h"
+#include "nsMemory.h"
+#include "nsComponentManagerUtils.h"
+#include "nsServiceManagerUtils.h"
+#include "nsStringAPI.h"
+
+topReport::topReport()
+	: mJSRuntime(nsnull)
+{
+	mJSScopeInfo.ops = nsnull;
+}
+
+topReport::~topReport()
+{
+	if (mJSScopeInfo.ops) {
+		PL_DHashTableFinish(&mJSScopeInfo);
+		mJSScopeInfo.ops = nsnull;
+	}
+
+	if (mJSContext) {
+		JS_DestroyContext(mJSContext);
+		mJSContext = nsnull;
+	}
+
+	mJSRuntimeService = nsnull;
+}
+
+NS_IMPL_ISUPPORTS1(topReport,
+                   topIService)
+
+nsresult
+topReport::Init()
+{
+	NS_ASSERTION(!mJSRuntimeService, "Init being called twice");
+
+	nsresult rv;
+
+	mJSRuntimeService =
+		do_GetService("@mozilla.org/js/xpc/RuntimeService;1", &rv);
+	NS_ENSURE_SUCCESS(rv, rv);
+
+	rv = mJSRuntimeService->GetRuntime(&mJSRuntime);
+	NS_ENSURE_SUCCESS(rv, rv);
+
+	mJSContext = JS_NewContext(mJSRuntime, 256);
+	NS_ENSURE_TRUE(mJSContext, NS_ERROR_OUT_OF_MEMORY);
+
+	return NS_OK;
+}
+
+// Only create entries if they don't have a Components object.
+struct JSScopeInfoEntry : public PLDHashEntryHdr {
+	JSObject *global; // key must be first to match PLDHashEntryStub
+	PLDHashTable roots;
+	PRUint32 prevRootCount;
+	PRPackedBool generation; // we let it wrap at one bit
+	PRPackedBool notified;
+};
+
+struct RootsEntry : public PLDHashEntryHdr {
+	void *key; // key must be first to match PLDHashEntryStub
+};
+
+void
+topReport::HandleRoot(JSObject *aRoot, PRBool *aHaveLeaks)
+{
+	JSObject *global, *parent = aRoot;
+	do {
+		global = parent;
+		parent = JS_GetParent(mJSContext, global);
+	} while (parent);
+
+	JSClass *clazz = JS_GET_CLASS(mJSContext, global);
+
+	if (PL_strcmp(clazz->name, "Window") != 0 &&
+	    PL_strcmp(clazz->name, "ChromeWindow") != 0) {
+	    // Global is not a window.
+	    return;
+	}
+
+	jsval comp;
+	PRBool hasComponents =
+		JS_GetProperty(mJSContext, global, "Components", &comp) &&
+		JS_TypeOfValue(mJSContext, comp) == JSTYPE_OBJECT;
+
+	if (hasComponents) {
+		// It's still live, so don't worry about leaks.
+		return;
+	}
+
+	JSScopeInfoEntry *entry = static_cast<JSScopeInfoEntry*>(
+		PL_DHashTableOperate(&mJSScopeInfo, global, PL_DHASH_ADD));
+	if (!entry) {
+		NS_WARNING("out of memory");
+		return;
+	}
+
+	if (!entry->global) {
+		entry->global = global;
+		entry->prevRootCount = PR_UINT32_MAX;
+		PL_DHashTableInit(&entry->roots, PL_DHashGetStubOps(), nsnull,
+		                  sizeof(RootsEntry), 16);
+	}
+	entry->generation = mGeneration;
+
+	RootsEntry *rootEntry = static_cast<RootsEntry*>(
+		PL_DHashTableOperate(&entry->roots, aRoot, PL_DHASH_ADD));
+	if (!rootEntry) {
+		NS_WARNING("out of memory");
+		return;
+	}
+	NS_ASSERTION(rootEntry->key == nsnull || rootEntry->key == aRoot,
+	             "wrong entry");
+	rootEntry->key = aRoot;
+	if (!entry->notified) {
+		*aHaveLeaks = PR_TRUE;
+	}
+}
+
+struct FindGCRootData {
+	topReport *service;
+	PRBool haveLeaks;
+};
+
+#ifndef DEBUG
+typedef void
+(* JS_DLL_CALLBACK JSTraceNamePrinter)(JSTracer *trc, char *buf,
+                                       size_t bufsize);
+#endif
+
+struct TracerWithData : public JSTracer {
+#ifndef DEBUG
+	/*
+	 * Include the DEBUG-only tail of JSTracer in non-DEBUG builds so we
+	 * can be binary-compatible with both.
+	 */
+	JSTraceNamePrinter  debugPrinter;
+	const void          *debugPrintArg;
+	size_t              debugPrintIndex;
+#endif
+	FindGCRootData *data;
+};
+
+/* static */ void JS_DLL_CALLBACK
+topReport::GCRootTracer(JSTracer *trc, void *thing, uint32 kind)
+{
+	FindGCRootData *data = static_cast<TracerWithData*>(trc)->data;
+
+	if (kind == 0 /* JSTRACE_OBJECT */ ||
+	    kind == 4 /* JSTRACE_NAMESPACE */ ||
+	    kind == 5 /* JSTRACE_QNAME */ ||
+	    kind == 6 /* JSTRACE_XML */)
+		data->service->HandleRoot(static_cast<JSObject*>(thing),
+		                          &data->haveLeaks);
+}
+
+/* static */ intN JS_DLL_CALLBACK
+topReport::GCRootMapper(void *rp, const char *name, void *aData)
+{
+	FindGCRootData *data = static_cast<FindGCRootData*>(aData);
+
+	jsval *vp = static_cast<jsval*>(rp);
+	jsval v = *vp;
+	if (!JSVAL_IS_PRIMITIVE(v))
+		data->service->HandleRoot(JSVAL_TO_OBJECT(v), &data->haveLeaks);
+
+	return JS_MAP_GCROOT_NEXT;
+}
+
+nsresult
+topReport::BuildContextInfo()
+{
+	if (!mJSScopeInfo.ops) {
+		PRBool ok = PL_DHashTableInit(&mJSScopeInfo, PL_DHashGetStubOps(),
+		                              nsnull, sizeof(JSScopeInfoEntry), 32);
+		NS_ENSURE_TRUE(ok, NS_ERROR_OUT_OF_MEMORY);
+	}
+
+	mGeneration = !mGeneration;
+
+	PL_DHashTableEnumerate(&mJSScopeInfo, ResetRootedLists, nsnull);
+
+	// Find all GC roots in closed windows.
+	FindGCRootData data;
+	data.service = this;
+	data.haveLeaks = PR_FALSE;
+	{
+		JSAutoRequest ar(mJSContext);
+
+		TracerWithData trc;
+		/*
+		 * We want to be binary-compatible with DEBUG and non-DEBUG builds,
+		 * so manually expand JS_TRACER_INIT here.
+		 */
+		trc.context = mJSContext;
+		trc.callback = GCRootTracer;
+		trc.debugPrinter = NULL;
+		trc.debugPrintArg = NULL;
+		trc.debugPrintIndex = (size_t)-1;
+
+		trc.data = &data;
+		JS_TraceRuntime(&trc);
+	}
+
+	PL_DHashTableEnumerate(&mJSScopeInfo, RemoveDeadScopes, this);
+
+	return NS_OK;
+}
diff --git a/extensions/top/src/topReport.h b/extensions/top/src/topReport.h
new file mode 100644
--- /dev/null
+++ b/extensions/top/src/topReport.h
@@ -0,0 +1,100 @@
+/* vim: set shiftwidth=4 tabstop=4 autoindent cindent noexpandtab copyindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the leak-monitor extension.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * service that monitors the state of wrapped JS objects at each GC,
+ * particularly to find those in closed windows
+ */
+
+#ifndef topReport_h_
+#define topReport_h_
+
+// Code within this extension
+#include "topIService.h"
+
+// Frozen APIs
+#include "nsISupports.h"
+#include "nsIObserver.h"
+
+// Frozen APIs that require linking against JS.
+#include "jsapi.h"
+
+// Frozen APIs that require linking against NSPR.
+#include "prthread.h"
+
+// Unfrozen APIs (XXX should unroll these, per-version)
+#include "nsIJSRuntimeService.h"
+#include "nsITimer.h"
+
+// XPCOM glue APIs in 1.8
+#include "nsCOMPtr.h"
+#include "pldhash.h"
+#include "nsWeakReference.h"
+
+// XPCOM glue APIs in 1.9
+#include "nsVoidArray.h"
+
+class topReport : public topIReport
+{
+public:
+	topReport() NS_HIDDEN;
+	~topReport() NS_HIDDEN;
+
+	// For topModule
+	NS_HIDDEN_(nsresult) Init();
+
+	NS_DECL_ISUPPORTS
+	NS_DECL_TOPIREPORT
+
+private:
+	void HandleRoot(JSObject *aRoot, PRBool *aHaveLeaks);
+	JS_STATIC_DLL_CALLBACK(void)
+		GCRootTracer(JSTracer *trc, void *thing, uint32 kind);
+	JS_STATIC_DLL_CALLBACK(intN)
+		GCRootMapper(void *rp, const char *name, void *data);
+
+	NS_HIDDEN_(nsresult) BuildContextInfo();
+
+	nsCOMPtr<nsIJSRuntimeService> mJSRuntimeService;
+	JSRuntime *mJSRuntime;
+	JSContext *mJSContext; // some JS API functions require a context, and
+	                       // it seems safer to have our own than pass
+	                       // somebody else's.
+	PLDHashTable mJSScopeInfo;
+};
+
+#endif /* !defined(topReport_h_) */
