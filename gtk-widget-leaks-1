Fix shutdown leak of GtkInvisible in GTK nsLookAndFeel implementation, and shorten lifetime of that GtkInvisible by copying its style.  (Bug 487955)

diff --git a/widget/src/gtk2/nsLookAndFeel.cpp b/widget/src/gtk2/nsLookAndFeel.cpp
--- a/widget/src/gtk2/nsLookAndFeel.cpp
+++ b/widget/src/gtk2/nsLookAndFeel.cpp
@@ -65,29 +65,30 @@ float     nsLookAndFeel::sCaretRatio = 0
 
 //-------------------------------------------------------------------------
 //
 // Query interface implementation
 //
 //-------------------------------------------------------------------------
 nsLookAndFeel::nsLookAndFeel() : nsXPLookAndFeel()
 {
+    mStyle = nsnull;
     InitWidget();
 
     static PRBool sInitialized = PR_FALSE;
 
     if (!sInitialized) {
         sInitialized = PR_TRUE;
         InitLookAndFeel();
     }
 }
 
 nsLookAndFeel::~nsLookAndFeel()
 {
-    g_object_unref(mWidget);
+    g_object_unref(mStyle);
 }
 
 nsresult nsLookAndFeel::NativeGetColor(const nsColorID aID, nscolor& aColor)
 {
     nsresult res = NS_OK;
 
     switch (aID) {
         // These colors don't seem to be used for anything anymore in Mozilla
@@ -810,16 +811,16 @@ nsLookAndFeel::GetPasswordCharacter()
     return sInvisibleCharacter;
 }
 
 NS_IMETHODIMP
 nsLookAndFeel::LookAndFeelChanged()
 {
     nsXPLookAndFeel::LookAndFeelChanged();
 
-    if (mWidget)
-        g_object_unref(mWidget);
+    g_object_unref(mStyle);
+    mStyle = nsnull;
  
     InitWidget();
     InitLookAndFeel();
 
     return NS_OK;
 }
diff --git a/widget/src/gtk2/nsLookAndFeel.h b/widget/src/gtk2/nsLookAndFeel.h
--- a/widget/src/gtk2/nsLookAndFeel.h
+++ b/widget/src/gtk2/nsLookAndFeel.h
@@ -51,17 +51,16 @@ public:
     nsresult NativeGetColor(const nsColorID aID, nscolor &aColor);
     NS_IMETHOD GetMetric(const nsMetricID aID, PRInt32 & aMetric);
     NS_IMETHOD GetMetric(const nsMetricFloatID aID, float & aMetric);
     NS_IMETHOD LookAndFeelChanged();
     virtual PRUnichar GetPasswordCharacter();
 
 protected:
     GtkStyle *mStyle;
-    GtkWidget *mWidget;
 
     // Cached colors, we have to create a dummy widget to actually
     // get the style
 
     static nscolor sInfoBackground;
     static nscolor sInfoText;
     static nscolor sMenuBackground;
     static nscolor sMenuText;
@@ -75,16 +74,32 @@ protected:
     static nscolor sNativeHyperLinkText;
     static nscolor sComboBoxText;
     static nscolor sComboBoxBackground;
     static PRUnichar sInvisibleCharacter;
     static float   sCaretRatio;
 
     static void InitLookAndFeel();
     void InitWidget() {
-        mWidget = gtk_invisible_new();
-        g_object_ref_sink(GTK_OBJECT(mWidget));
-        gtk_widget_ensure_style(mWidget);
-        mStyle = gtk_widget_get_style(mWidget);
+        NS_ASSERTION(!mStyle, "already initialized");
+        // GtkInvisibles come with a refcount that is not floating
+        // (since their initialization code calls g_object_ref_sink) and
+        // their destroy code releases that reference (which means they
+        // have to be explicitly destroyed, since calling unref enough
+        // to cause destruction would lead to *another* unref).
+        // However, this combination means that it's actually still ok
+        // to use the normal pattern, which is to g_object_ref_sink
+        // after construction, and then destroy *and* unref when we're
+        // done.  (Though we could skip the g_object_ref_sink and the
+        // corresponding g_object_unref, but that's particular to
+        // GtkInvisibles.)
+        GtkWidget *widget = gtk_invisible_new();
+        g_object_ref_sink(widget); // effectively g_object_ref (see above)
+
+        gtk_widget_ensure_style(widget);
+        mStyle = gtk_style_copy(gtk_widget_get_style(widget));
+
+        gtk_widget_destroy(widget);
+        g_object_unref(widget);
     }
 };
 
 #endif
