From: L. David Baron <dbaron@dbaron.org>

Bug 847287 patch 12 - Check mWinsInCascade for all callers of GetAnimationOfProperty/HasAnimationOfProperty.

This patch (after stepping through the call graph) affects the following
places:
 * CommonAnimationManager::GetAnimationsForCompositor, which is used
   only by nsDisplayListBuilder::AddAnimationsAndTransitionsToLayer,
   which already checks the individual animations (so really no change)
 * AnimationPlayerCollection::CanThrottleAnimation
 * ActiveLayerTracker::IsStyleAnimated
 * nsLayoutUtils::HasAnimationsForCompositor
 * nsLayoutUtils::HasAnimations (which is used only to check whether we
   can make the 0-opacity optimization)
I believe it makes sense to change all of these locations (although in
the long term we want to throttle (or similar) more animations).

Without this patch, I believe we're forcing the creation of an opacity
layer because we think we have animations to send to it.

diff --git a/dom/animation/Animation.cpp b/dom/animation/Animation.cpp
--- a/dom/animation/Animation.cpp
+++ b/dom/animation/Animation.cpp
@@ -267,17 +267,21 @@ Animation::IsInEffect() const
 }
 
 const AnimationProperty*
 Animation::GetAnimationOfProperty(nsCSSProperty aProperty) const
 {
   for (size_t propIdx = 0, propEnd = mProperties.Length();
        propIdx != propEnd; ++propIdx) {
     if (aProperty == mProperties[propIdx].mProperty) {
-      return &mProperties[propIdx];
+      const AnimationProperty* result = &mProperties[propIdx];
+      if (!result->mWinsInCascade) {
+        result = nullptr;
+      }
+      return result;
     }
   }
   return nullptr;
 }
 
 void
 Animation::ComposeStyle(nsRefPtr<css::AnimValuesStyleRule>& aStyleRule,
                         nsCSSPropertySet& aSetProperties)
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -421,27 +421,27 @@ AddAnimationsForProperty(nsIFrame* aFram
     dom::Animation* anim = player->GetSource();
     MOZ_ASSERT(anim, "A playing player should have a source animation");
     const AnimationProperty* property =
       anim->GetAnimationOfProperty(aProperty);
     if (!property) {
       continue;
     }
 
-    if (!property->mWinsInCascade) {
-      // We have an animation or transition, but it isn't actually
-      // winning in the CSS cascade, so we don't want to send it to the
-      // compositor.
-      // I believe that anything that changes mWinsInCascade should
-      // trigger this code again, either because of a restyle that
-      // changes the properties in question, or because of the
-      // main-thread style update that results when an animation stops
-      // filling.
-      continue;
-    }
+    // Note that if mWinsInCascade on property was  false,
+    // GetAnimationOfProperty returns null instead.
+    // This is what we want, since if we have an animation or transition
+    // that isn't actually winning in the CSS cascade, we don't want to
+    // send it to the compositor.
+    // I believe that anything that changes mWinsInCascade should
+    // trigger this code again, either because of a restyle that changes
+    // the properties in question, or because of the main-thread style
+    // update that results when an animation stops filling.
+    MOZ_ASSERT(property->mWinsInCascade,
+               "GetAnimationOfProperty already tested mWinsInCascade");
 
     // Don't add animations that are pending when their corresponding
     // refresh driver is under test control. This is because any pending
     // animations on layers will have their start time updated with the
     // current timestamp but when the refresh driver is under test control
     // its refresh times are unrelated to timestamp values.
     //
     // Instead we leave the animation running on the main thread and the
diff --git a/layout/style/test/test_animations_omta.html b/layout/style/test/test_animations_omta.html
--- a/layout/style/test/test_animations_omta.html
+++ b/layout/style/test/test_animations_omta.html
@@ -2157,35 +2157,35 @@ addAsyncAnimTest(function *() {
 // overridden work correctly.
 addAsyncAnimTest(function *() {
   advance_clock(0);
 
   // anim2 and anim3 are both animations from opacity 0 to 1
 
   new_div("animation: anim2 1s linear forwards; opacity: 0.5 ! important");
   yield waitForPaintsFlushed();
-  omta_is("opacity", 0.5, RunningOn.TodoMainThread,
+  omta_is("opacity", 0.5, RunningOn.MainThread,
           "opacity overriding animation at start (0s)");
   advance_clock(750);
-  omta_is("opacity", 0.5, RunningOn.TodoMainThread,
+  omta_is("opacity", 0.5, RunningOn.MainThread,
           "opacity overriding animation while running (750ms)");
   advance_clock(1000);
-  omta_is("opacity", 0.5, RunningOn.TodoMainThread,
+  omta_is("opacity", 0.5, RunningOn.MainThread,
           "opacity overriding animation while filling (1750ms)");
   done_div();
 
   new_div("animation: anim2 1s linear; opacity: 0.5 ! important");
   yield waitForPaintsFlushed();
-  omta_is("opacity", 0.5, RunningOn.TodoMainThread,
+  omta_is("opacity", 0.5, RunningOn.MainThread,
           "opacity overriding animation at start (0s)");
   advance_clock(750);
-  omta_is("opacity", 0.5, RunningOn.TodoMainThread,
+  omta_is("opacity", 0.5, RunningOn.MainThread,
           "opacity overriding animation while running (750ms)");
   advance_clock(1000);
-  omta_is("opacity", 0.5, RunningOn.TodoMainThread,
+  omta_is("opacity", 0.5, RunningOn.MainThread,
           "opacity overriding animation after complete (1750ms)");
   done_div();
 
   // One animation overriding another, and then not.
   new_div("animation: anim2 1s linear, anim3 500ms linear reverse");
   yield waitForPaintsFlushed();
   omta_is("opacity", 1, RunningOn.Compositor,
           "anim3 overriding anim2 at start (0s)");
