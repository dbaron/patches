From: L. David Baron <dbaron@dbaron.org>

Bug 847287 patch 8 - Check mWinsInCascade even more.

FIXME: Need to figure out what I should really do here.

diff --git a/dom/animation/Animation.cpp b/dom/animation/Animation.cpp
--- a/dom/animation/Animation.cpp
+++ b/dom/animation/Animation.cpp
@@ -253,17 +253,21 @@ Animation::IsInEffect() const
 }
 
 const AnimationProperty*
 Animation::GetAnimationOfProperty(nsCSSProperty aProperty) const
 {
   for (size_t propIdx = 0, propEnd = mProperties.Length();
        propIdx != propEnd; ++propIdx) {
     if (aProperty == mProperties[propIdx].mProperty) {
-      return &mProperties[propIdx];
+      const AnimationProperty* result = &mProperties[propIdx];
+      if (!result->mWinsInCascade) {
+        result = nullptr;
+      }
+      return result;
     }
   }
   return nullptr;
 }
 
 void
 Animation::ComposeStyle(nsRefPtr<css::AnimValuesStyleRule>& aStyleRule,
                         nsCSSPropertySet& aSetProperties)
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -362,16 +362,18 @@ TextAlignTrueEnabledPrefChangeCallback(c
   MOZ_ASSERT(sIndexOfTrueInTextAlignTable >= 0);
   nsCSSProps::kTextAlignKTable[sIndexOfTrueInTextAlignTable] =
     isTextAlignTrueEnabled ? eCSSKeyword_true : eCSSKeyword_UNKNOWN;
   MOZ_ASSERT(sIndexOfTrueInTextAlignLastTable >= 0);
   nsCSSProps::kTextAlignLastKTable[sIndexOfTrueInTextAlignLastTable] =
     isTextAlignTrueEnabled ? eCSSKeyword_true : eCSSKeyword_UNKNOWN;
 }
 
+// FIXME: There are way too many subtly-different variants below;
+// probably many of the differences represent bugs.
 static AnimationPlayerCollection*
 GetAnimationsOrTransitionsForCompositor(nsIContent* aContent,
                                         nsIAtom* aAnimationProperty,
                                         nsCSSProperty aProperty)
 {
   AnimationPlayerCollection* collection =
     static_cast<AnimationPlayerCollection*>(
       aContent->GetProperty(aAnimationProperty));
diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -639,16 +639,18 @@ AnimationPlayerCollection::CanPerformOnC
   // No properties to animate
   if (!existsProperty) {
     return false;
   }
 
   return true;
 }
 
+// FIXME: Why would a caller ever want this rather than
+// HasCurrentAnimationsForProperty?
 bool
 AnimationPlayerCollection::HasAnimationOfProperty(
   nsCSSProperty aProperty) const
 {
   for (size_t playerIdx = mPlayers.Length(); playerIdx-- != 0; ) {
     const Animation* anim = mPlayers[playerIdx]->GetSource();
     if (anim && anim->HasAnimationOfProperty(aProperty) &&
         !anim->IsFinishedTransition()) {
diff --git a/layout/style/test/test_animations_omta.html b/layout/style/test/test_animations_omta.html
--- a/layout/style/test/test_animations_omta.html
+++ b/layout/style/test/test_animations_omta.html
@@ -2151,35 +2151,35 @@ addAsyncAnimTest(function *() {
 // overridden work correctly.
 addAsyncAnimTest(function *() {
   advance_clock(0);
 
   // anim2 and anim3 are both animations from opacity 0 to 1
 
   new_div("animation: anim2 1s linear forwards; opacity: 0.5 ! important");
   yield waitForPaintsFlushed();
-  omta_is("opacity", 0.5, RunningOn.TodoMainThread,
+  omta_is("opacity", 0.5, RunningOn.MainThread,
           "opacity overriding animation at start (0s)");
   advance_clock(750);
-  omta_is("opacity", 0.5, RunningOn.TodoMainThread,
+  omta_is("opacity", 0.5, RunningOn.MainThread,
           "opacity overriding animation while running (750ms)");
   advance_clock(1000);
-  omta_is("opacity", 0.5, RunningOn.TodoMainThread,
+  omta_is("opacity", 0.5, RunningOn.MainThread,
           "opacity overriding animation while filling (1750ms)");
   done_div();
 
   new_div("animation: anim2 1s linear; opacity: 0.5 ! important");
   yield waitForPaintsFlushed();
-  omta_is("opacity", 0.5, RunningOn.TodoMainThread,
+  omta_is("opacity", 0.5, RunningOn.MainThread,
           "opacity overriding animation at start (0s)");
   advance_clock(750);
-  omta_is("opacity", 0.5, RunningOn.TodoMainThread,
+  omta_is("opacity", 0.5, RunningOn.MainThread,
           "opacity overriding animation while running (750ms)");
   advance_clock(1000);
-  omta_is("opacity", 0.5, RunningOn.TodoMainThread,
+  omta_is("opacity", 0.5, RunningOn.MainThread,
           "opacity overriding animation after complete (1750ms)");
   done_div();
 
   // One animation overriding another, and then not.
   new_div("animation: anim2 1s linear, anim3 500ms linear reverse");
   yield waitForPaintsFlushed();
   omta_is("opacity", 1, RunningOn.Compositor,
           "anim3 overriding anim2 at start (0s)");
