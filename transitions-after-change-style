From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Get a style that is the correct "after-change style" for once we stop using animation phases.

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -195,16 +195,26 @@ nsTransitionManager::StyleContextChanged
     return nullptr;
   }
 
   NS_WARN_IF_FALSE(!nsLayoutUtils::AreAsyncAnimationsEnabled() ||
                      mPresContext->RestyleManager()->
                        ThrottledAnimationStyleIsUpToDate(),
                    "throttled animations not up to date");
 
+  nsRefPtr<nsStyleContext> newStyleContextWithoutTransitions;
+  if (collection) {
+    newStyleContextWithoutTransitions =
+      aNewStyleContext->PresContext()->StyleSet()->
+        ResolveStyleWithoutAnimation(aElement, aNewStyleContext,
+                                     eRestyleHint_CSSTransitions);
+  } else {
+    newStyleContextWithoutTransitions = aNewStyleContext;
+  }
+
   // Per http://lists.w3.org/Archives/Public/www-style/2009Aug/0109.html
   // I'll consider only the transitions from the number of items in
   // 'transition-property' on down, and later ones will override earlier
   // ones (tracked using |whichStarted|).
   bool startedAny = false;
   nsCSSPropertySet whichStarted;
   for (uint32_t i = disp->mTransitionPropertyCount; i-- != 0; ) {
     const StyleTransition& t = disp->mTransitions[i];
@@ -220,28 +230,31 @@ nsTransitionManager::StyleContextChanged
           property == eCSSPropertyExtra_variable ||
           property == eCSSProperty_UNKNOWN) {
         // Nothing to do, but need to exclude this from cases below.
       } else if (property == eCSSPropertyExtra_all_properties) {
         for (nsCSSProperty p = nsCSSProperty(0);
              p < eCSSProperty_COUNT_no_shorthands;
              p = nsCSSProperty(p + 1)) {
           ConsiderStartingTransition(p, t, aElement, collection,
-                                     aOldStyleContext, aNewStyleContext,
+                                     aOldStyleContext,
+                                     newStyleContextWithoutTransitions,
                                      &startedAny, &whichStarted);
         }
       } else if (nsCSSProps::IsShorthand(property)) {
         CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(subprop, property) {
           ConsiderStartingTransition(*subprop, t, aElement, collection,
-                                     aOldStyleContext, aNewStyleContext,
+                                     aOldStyleContext,
+                                     newStyleContextWithoutTransitions,
                                      &startedAny, &whichStarted);
         }
       } else {
         ConsiderStartingTransition(property, t, aElement, collection,
-                                   aOldStyleContext, aNewStyleContext,
+                                   aOldStyleContext,
+                                   newStyleContextWithoutTransitions,
                                    &startedAny, &whichStarted);
       }
     }
   }
 
   // Stop any transitions for properties that are no longer in
   // 'transition-property'.
   // Also stop any transitions for properties that just changed (and are
@@ -291,17 +304,18 @@ nsTransitionManager::StyleContextChanged
                  "Animation property should have one segment for a transition");
       const AnimationProperty& prop = anim->Properties()[0];
       const AnimationPropertySegment& segment = prop.mSegments[0];
           // properties no longer in 'transition-property'
       if ((checkProperties &&
            !allTransitionProperties.HasProperty(prop.mProperty)) ||
           // properties whose computed values changed but delay and
           // duration are both zero
-          !ExtractComputedValueForTransition(prop.mProperty, aNewStyleContext,
+          !ExtractComputedValueForTransition(prop.mProperty,
+                                             newStyleContextWithoutTransitions,
                                              currentValue) ||
           currentValue != segment.mToValue) {
         // stop the transition
         players.RemoveElementAt(i);
         collection->UpdateAnimationGeneration(mPresContext);
       }
     } while (i != 0);
 
