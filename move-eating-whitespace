From: L. David Baron <dbaron@dbaron.org>

Move the consumption of beginning whitespace (for all forms) and ending whitespace (for the string form) inside url() into the tokenizer.  (Bug 604179, patch 3)  r=bzbarsky

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -1311,22 +1311,20 @@ CSSParserImpl::GetToken(PRBool aSkipWS)
   }
   return PR_FALSE;
 }
 
 PRBool
 CSSParserImpl::GetURLInParens(nsString& aURL)
 {
   NS_ASSERTION(!mHavePushBack, "mustn't have pushback at this point");
-  do {
-    if (! mScanner.NextURL(mToken)) {
-      // EOF
-      return PR_FALSE;
-    }
-  } while (eCSSToken_WhiteSpace == mToken.mType);
+  if (! mScanner.NextURL(mToken)) {
+    // EOF
+    return PR_FALSE;
+  }
 
   aURL = mToken.mIdent;
 
   if ((eCSSToken_String != mToken.mType && eCSSToken_URL != mToken.mType) ||
       !ExpectSymbol(')', PR_TRUE)) {
     // in the failure case, we do not have to match parentheses, since
     // this is now an invalid URL token.
     SkipUntil(')');
diff --git a/layout/style/nsCSSScanner.cpp b/layout/style/nsCSSScanner.cpp
--- a/layout/style/nsCSSScanner.cpp
+++ b/layout/style/nsCSSScanner.cpp
@@ -883,31 +883,38 @@ nsCSSScanner::Next(nsCSSToken& aToken)
     aToken.mSymbol = ch;
     return PR_TRUE;
   }
 }
 
 PRBool
 nsCSSScanner::NextURL(nsCSSToken& aToken)
 {
+  EatWhiteSpace();
+
   PRInt32 ch = Read();
   if (ch < 0) {
     return PR_FALSE;
   }
 
   // STRING
   if ((ch == '"') || (ch == '\'')) {
-    return ParseString(ch, aToken);
-  }
+#ifdef DEBUG
+    PRBool ok =
+#endif
+      ParseString(ch, aToken);
+    NS_ABORT_IF_FALSE(ok, "ParseString should never fail, "
+                          "since there's always something read");
 
-  // WS
-  if (IsWhitespace(ch)) {
-    aToken.mType = eCSSToken_WhiteSpace;
-    aToken.mIdent.Assign(PRUnichar(ch));
-    EatWhiteSpace();
+    NS_ABORT_IF_FALSE(aToken.mType == eCSSToken_String ||
+                      aToken.mType == eCSSToken_Bad_String,
+                      "unexpected token type");
+    if (NS_LIKELY(aToken.mType == eCSSToken_String)) {
+      EatWhiteSpace();
+    }
     return PR_TRUE;
   }
 
   // Process a url lexical token. A CSS1 url token can contain
   // characters beyond identifier characters (e.g. '/', ':', etc.)
   // Because of this the normal rules for tokenizing the input don't
   // apply very well. To simplify the parser and relax some of the
   // requirements on the scanner we parse url's here. If we find a
diff --git a/layout/style/nsCSSScanner.h b/layout/style/nsCSSScanner.h
--- a/layout/style/nsCSSScanner.h
+++ b/layout/style/nsCSSScanner.h
@@ -186,17 +186,17 @@ class nsCSSScanner {
 #endif
 
   PRUint32 GetLineNumber() { return mLineNumber; }
 
   // Get the next token. Return PR_FALSE on EOF. aTokenResult
   // is filled in with the data for the token.
   PRBool Next(nsCSSToken& aTokenResult);
 
-  // Get the next token that may be a string or unquoted URL or whitespace
+  // Get the next token that may be a string or unquoted URL
   PRBool NextURL(nsCSSToken& aTokenResult);
 
   // It's really ugly that we have to expose this, but it's the easiest
   // way to do :nth-child() parsing sanely.  (In particular, in
   // :nth-child(2n-1), "2n-1" is a dimension, and we need to push the
   // "-1" back so we can read it again as a number.)
   void Pushback(PRUnichar aChar);
 
