Rebuild all style data when the user font set changes so that we recompute ex and ch units.  (Bug 458878)

diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1837,35 +1837,35 @@ nsPresContext::FlushUserFontSet()
 #endif
         rules.SwapElements(mFontFaceRules);
       NS_ASSERTION(success, "should never fail given both are heap arrays");
 
       if (mGetUserFontSetCalled && oldUserFontSet != mUserFontSet) {
         // If we've changed, created, or destroyed a user font set, we
         // need to trigger a style change reflow.
         // We need to enqueue a style change reflow (for later) to
-        // reflect that we're dropping @font-face rules.  This is the
-        // same thing nsFontFaceLoader does when font downloads
-        // complete.  (However, without a reflow, nothing will happen
-        // to start any downloads that are needed.)
-        mShell->StyleChangeReflow();
+        // reflect that we're dropping @font-face rules.  (However,
+        // without a reflow, nothing will happen to start any downloads
+        // that are needed.)
+        UserFontSetUpdated();
       }
     }
 
     mUserFontSetDirty = PR_FALSE;
   }
 }
 
 void
 nsPresContext::RebuildUserFontSet()
 {
   if (!mGetUserFontSetCalled) {
     // We want to lazily build the user font set the first time it's
     // requested (so we don't force creation of rule cascades too
     // early), so don't do anything now.
+    // See also the comment below in UserFontSetUpdated.
     return;
   }
 
   mUserFontSetDirty = PR_TRUE;
 
   // Somebody has already asked for the user font set, so we need to
   // post an event to rebuild it.  Setting the user font set to be dirty
   // and lazily rebuilding it isn't sufficient, since it is only the act
@@ -1876,16 +1876,46 @@ nsPresContext::RebuildUserFontSet()
   if (!mPostedFlushUserFontSet) {
     nsCOMPtr<nsIRunnable> ev =
       new nsRunnableMethod<nsPresContext>(this,
                                      &nsPresContext::HandleRebuildUserFontSet);
     if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
       mPostedFlushUserFontSet = PR_TRUE;
     }
   }    
+}
+
+void
+nsPresContext::UserFontSetUpdated()
+{
+  if (!mShell)
+    return;
+
+  // Changes to the set of available fonts can cause updates to layout by:
+  //
+  //   1. Changing the font used for text, which changes anything that
+  //      depends on text measurement, including line breaking and
+  //      intrinsic widths, and any other parts of layout that depend on
+  //      font metrics.  This requires a style change reflow to update.
+  //
+  //   2. Changing the value of the 'ex' and 'ch' units in style data,
+  //      which also depend on font metrics.  Updating this information
+  //      requires rebuilding the rule tree from the top, avoiding the
+  //      reuse of cached data even when no style rules have changed.
+
+  // Calling PostRebuildAllStyleDataEvent will (synchronously, via
+  // nsIPresShell::ReconstructStyleDataInternal) call RebuildUserFontSet
+  // above.  Temporarily suppress its effects by swapping out
+  // mGetUserFontSetCalled.
+  unsigned realGetUserFontSetCalled = mGetUserFontSetCalled;
+  mGetUserFontSetCalld = PR_FALSE;
+
+  PostRebuildAllStyleDataEvent(NS_STYLE_HINT_REFLOW);
+
+  mGetUserFontSetCalld = realGetUserFontSetCalled;
 }
 
 void
 nsPresContext::FireDOMPaintEvent()
 {
   nsCOMPtr<nsPIDOMWindow> ourWindow = mDocument->GetWindow();
   if (!ourWindow)
     return;
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -756,16 +756,21 @@ public:
   }
 
   PRBool           SupressingResizeReflow() const { return mSupressResizeReflow; }
   
   gfxUserFontSet* GetUserFontSet();
   void FlushUserFontSet();
   void RebuildUserFontSet(); // asynchronously
 
+  // Should be called whenever the set of fonts available in the user
+  // font set changes (e.g., because a new font loads, or because the
+  // user font set is changed and fonts become unavailable).
+  void UserFontSetUpdated();
+
   void NotifyInvalidation(const nsRect& aRect, PRBool aIsCrossDoc);
   void FireDOMPaintEvent();
 
 protected:
   friend class nsRunnableMethod<nsPresContext>;
   NS_HIDDEN_(void) ThemeChangedInternal();
   NS_HIDDEN_(void) SysColorChangedInternal();
 
diff --git a/layout/style/nsFontFaceLoader.cpp b/layout/style/nsFontFaceLoader.cpp
--- a/layout/style/nsFontFaceLoader.cpp
+++ b/layout/style/nsFontFaceLoader.cpp
@@ -120,27 +120,20 @@ nsFontFaceLoader::OnStreamComplete(nsISt
                                                             aString, aStringLen,
                                                             aStatus);
 
   // when new font loaded, need to reflow
   if (fontUpdate) {
     nsFontFaceLoaderContext *loaderCtx 
                        = static_cast<nsFontFaceLoaderContext*> (mLoaderContext);
 
-    nsIPresShell *ps = loaderCtx->mPresContext->PresShell();
-    if (ps) {
-      // Update layout for the presence of the new font.  Since this is
-      // asynchronous, reflows will coalesce.
-      // nsPresContext::FlushUserFontSet does the same thing when we
-      // remove a user font set, for fonts becoming unavailable, or when
-      // we add one, because if we change it dynamically we need to
-      // trigger reflow to cause gfx to request the fonts.
-      ps->StyleChangeReflow();
-      LOG(("fontdownloader (%p) reflow\n", this));
-    }
+    // Update layout for the presence of the new font.  Since this is
+    // asynchronous, reflows will coalesce.
+    loaderCtx->mPresContext->UserFontSetUpdated();
+    LOG(("fontdownloader (%p) reflow\n", this));
   }
 
   return aStatus;
 }
 
 nsresult
 nsFontFaceLoader::CreateHandler(gfxFontEntry *aFontToLoad, 
                                 const gfxFontFaceSrc *aFontFaceSrc,
