Rebuild all style data when the user font set changes so that we recompute ex and ch units.  (Bug 458878)

diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1843,21 +1843,20 @@ nsPresContext::FlushUserFontSet()
 #endif
         rules.SwapElements(mFontFaceRules);
       NS_ASSERTION(success, "should never fail given both are heap arrays");
 
       if (mGetUserFontSetCalled && oldUserFontSet != mUserFontSet) {
         // If we've changed, created, or destroyed a user font set, we
         // need to trigger a style change reflow.
         // We need to enqueue a style change reflow (for later) to
-        // reflect that we're dropping @font-face rules.  This is the
-        // same thing nsFontFaceLoader does when font downloads
-        // complete.  (However, without a reflow, nothing will happen
-        // to start any downloads that are needed.)
-        mShell->StyleChangeReflow();
+        // reflect that we're dropping @font-face rules.  (However,
+        // without a reflow, nothing will happen to start any downloads
+        // that are needed.)
+        UserFontSetUpdated();
       }
     }
 
     mUserFontSetDirty = PR_FALSE;
   }
 }
 
 void
@@ -1882,16 +1881,37 @@ nsPresContext::RebuildUserFontSet()
   if (!mPostedFlushUserFontSet) {
     nsCOMPtr<nsIRunnable> ev =
       new nsRunnableMethod<nsPresContext>(this,
                                      &nsPresContext::HandleRebuildUserFontSet);
     if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
       mPostedFlushUserFontSet = PR_TRUE;
     }
   }    
+}
+
+void
+nsPresContext::UserFontSetUpdated()
+{
+  if (!mShell)
+    return;
+
+  // Changes to the set of available fonts can cause updates to layout by:
+  //
+  //   1. Changing the font used for text, which changes anything that
+  //      depends on text measurement, including line breaking and
+  //      intrinsic widths, and any other parts of layout that depend on
+  //      font metrics.  This requires a style change reflow to update.
+  //
+  //   2. Changing the value of the 'ex' and 'ch' units in style data,
+  //      which also depend on font metrics.  Updating this information
+  //      requires rebuilding the rule tree from the top, avoiding the
+  //      reuse of cached data even when no style rules have changed.
+
+  PostRebuildAllStyleDataEvent(NS_STYLE_HINT_REFLOW);
 }
 
 void
 nsPresContext::FireDOMPaintEvent()
 {
   nsCOMPtr<nsPIDOMWindow> ourWindow = mDocument->GetWindow();
   if (!ourWindow)
     return;
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -763,16 +763,21 @@ public:
   gfxUserFontSet* GetUserFontSet() { return GetUserFontSetInternal(); }
 #else
   gfxUserFontSet* GetUserFontSet() { return GetUserFontSetExternal(); }
 #endif
 
   void FlushUserFontSet();
   void RebuildUserFontSet(); // asynchronously
 
+  // Should be called whenever the set of fonts available in the user
+  // font set changes (e.g., because a new font loads, or because the
+  // user font set is changed and fonts become unavailable).
+  void UserFontSetUpdated();
+
   void NotifyInvalidation(const nsRect& aRect, PRBool aIsCrossDoc);
   void FireDOMPaintEvent();
 
 protected:
   friend class nsRunnableMethod<nsPresContext>;
   NS_HIDDEN_(void) ThemeChangedInternal();
   NS_HIDDEN_(void) SysColorChangedInternal();
 
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -4550,16 +4550,21 @@ PresShell::DoFlushPendingNotifications(m
     // notified on,
     mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
 
     // Process pending restyles, since any flush of the presshell wants
     // up-to-date style data.
     if (!mIsDestroying) {
       mPresContext->FlushPendingMediaFeatureValuesChanged();
 
+      // Flush any pending update of the user font set, since that could
+      // cause style changes (for updating ex/ch units, and to cause a
+      // reflow).
+      mPresContext->FlushUserFontSet();
+
       mFrameConstructor->ProcessPendingRestyles();
     }
 
     // Process whatever XBL constructors those restyles queued up.  This
     // ensures that onload doesn't fire too early and that we won't do extra
     // reflows after those constructors run.
     if (!mIsDestroying) {
       mDocument->BindingManager()->ProcessAttachedQueue();
@@ -4576,20 +4581,16 @@ PresShell::DoFlushPendingNotifications(m
     }
 
 
     // There might be more pending constructors now, but we're not going to
     // worry about them.  They can't be triggered during reflow, so we should
     // be good.
     
     if (aType >= Flush_Layout && !mIsDestroying) {
-      // Flush any pending update of the user font set, since that could
-      // post a style change reflow.
-      mPresContext->FlushUserFontSet();
-
       mFrameConstructor->RecalcQuotesAndCounters();
       mViewManager->FlushDelayedResize();
       ProcessReflowCommands(aInterruptibleReflow);
     }
 
     PRUint32 updateFlags = NS_VMREFRESH_NO_SYNC;
     if (aType >= Flush_Display) {
       // Flushing paints, so perform the invalidates and drawing
diff --git a/layout/reftests/font-face/ex-unit-1-dynamic.html b/layout/reftests/font-face/ex-unit-1-dynamic.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/font-face/ex-unit-1-dynamic.html
@@ -0,0 +1,20 @@
+<!DOCTYPE HTML>
+<html class="reftest-wait">
+<title>ex unit with Ahem font</title>
+<style type="text/css">
+html { background: white; }
+body { font-family: Ahhhem; font-size: 50px;
+       height: 2ex; width: 2ex; position: relative;
+       background: blue;  }
+</style>
+<script type="application/ecmascript">
+function run() {
+  document.getElementsByTagName("iframe")[0].contentWindow.arm();
+  document.getElementsByTagName("style")[0].sheet.insertRule(
+    '@font-face { font-family: "Ahhhem"; src: url(../fonts/Ahem.ttf); }',
+    0);
+}
+</script>
+<body onload="setTimeout(run, 0)">
+<iframe style="visibility:hidden;position:absolute;height:100%;width:100%" src="resize-detector-iframe.html"></iframe></p>
+</body>
diff --git a/layout/reftests/font-face/ex-unit-1-ref.html b/layout/reftests/font-face/ex-unit-1-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/font-face/ex-unit-1-ref.html
@@ -0,0 +1,7 @@
+<!DOCTYPE HTML>
+<title>ex unit with Ahem font</title>
+<style type="text/css">
+html { background: white; }
+div { height: 80px; width: 80px; background: blue;  }
+</style>
+<div></div>
diff --git a/layout/reftests/font-face/ex-unit-1.html b/layout/reftests/font-face/ex-unit-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/font-face/ex-unit-1.html
@@ -0,0 +1,7 @@
+<!DOCTYPE HTML>
+<title>ex unit with Ahem font</title>
+<style type="text/css">
+@font-face { font-family: "Ahhhem"; src: url(../fonts/Ahem.ttf); }
+html { background: white; }
+body { font-family: Ahhhem; font-size: 50px; height: 2ex; width: 2ex; background: blue;  }
+</style>
diff --git a/layout/reftests/font-face/reftest.list b/layout/reftests/font-face/reftest.list
--- a/layout/reftests/font-face/reftest.list
+++ b/layout/reftests/font-face/reftest.list
@@ -51,8 +51,10 @@ HTTP(..) == sheet-set-switch-1.html shee
 HTTP(..) == sheet-set-switch-1.html sheet-set-switch-1-ref.html
 HTTP(..) == insert-rule-1.html insert-rule-1-ref.html
 HTTP(..) == delete-rule-1.html delete-rule-1-ref.html
 HTTP(..) == media-query-add-1.html media-query-add-1-ref.html
 HTTP(..) == media-query-remove-1.html media-query-remove-1-ref.html
 HTTP(..) != media-query-add-1-ref.html media-query-remove-1-ref.html
 
 HTTP(..) == ahem-metrics-1.html ahem-metrics-1-ref.html
+HTTP(..) == ex-unit-1.html ex-unit-1-ref.html
+HTTP(..) == ex-unit-1-dynamic.html ex-unit-1-ref.html
diff --git a/layout/style/nsFontFaceLoader.cpp b/layout/style/nsFontFaceLoader.cpp
--- a/layout/style/nsFontFaceLoader.cpp
+++ b/layout/style/nsFontFaceLoader.cpp
@@ -120,27 +120,20 @@ nsFontFaceLoader::OnStreamComplete(nsISt
                                                             aString, aStringLen,
                                                             aStatus);
 
   // when new font loaded, need to reflow
   if (fontUpdate) {
     nsFontFaceLoaderContext *loaderCtx 
                        = static_cast<nsFontFaceLoaderContext*> (mLoaderContext);
 
-    nsIPresShell *ps = loaderCtx->mPresContext->PresShell();
-    if (ps) {
-      // Update layout for the presence of the new font.  Since this is
-      // asynchronous, reflows will coalesce.
-      // nsPresContext::FlushUserFontSet does the same thing when we
-      // remove a user font set, for fonts becoming unavailable, or when
-      // we add one, because if we change it dynamically we need to
-      // trigger reflow to cause gfx to request the fonts.
-      ps->StyleChangeReflow();
-      LOG(("fontdownloader (%p) reflow\n", this));
-    }
+    // Update layout for the presence of the new font.  Since this is
+    // asynchronous, reflows will coalesce.
+    loaderCtx->mPresContext->UserFontSetUpdated();
+    LOG(("fontdownloader (%p) reflow\n", this));
   }
 
   return aStatus;
 }
 
 nsresult
 nsFontFaceLoader::CreateHandler(gfxFontEntry *aFontToLoad, 
                                 const gfxFontFaceSrc *aFontFaceSrc,
