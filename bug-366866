Make PushStackMemory never fail to simplify callers, and deCOMtaminate the stack memory API.  b=366866

diff -r 7627baaab426 layout/base/nsIPresShell.h
--- a/layout/base/nsIPresShell.h	Tue Jan 16 16:31:52 2007 -0800
+++ b/layout/base/nsIPresShell.h	Tue Jan 16 18:52:39 2007 -0800
@@ -172,10 +172,24 @@ public:
   virtual void* AllocateFrame(size_t aSize) = 0;
   virtual void  FreeFrame(size_t aSize, void* aFreeChunk) = 0;
 
-  // Dynamic stack memory allocation
-  NS_IMETHOD PushStackMemory() = 0;
-  NS_IMETHOD PopStackMemory() = 0;
-  NS_IMETHOD AllocateStackMemory(size_t aSize, void** aResult) = 0;
+  /**
+   * Stack memory allocation:
+   *
+   * Callers who wish to allocate memory whose lifetime corresponds to
+   * the lifetime of a stack-allocated object can use this API.  The
+   * caller must use a pair of calls to PushStackMemory and
+   * PopStackMemory, such that all stack object lifetimes are either
+   * entirely between the calls or containing both calls.
+   *
+   * Then, between the calls, the caller can call AllocateStackMemory to
+   * allocate memory from an arena pool that will be freed by the call
+   * to PopStackMemory.
+   *
+   * The allocations cannot be for more than 4044 bytes.
+   */
+  virtual void PushStackMemory() = 0;
+  virtual void PopStackMemory() = 0;
+  virtual void* AllocateStackMemory(size_t aSize) = 0;
   
   nsIDocument* GetDocument() { return mDocument; }
 
diff -r 7627baaab426 layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp	Tue Jan 16 16:31:52 2007 -0800
+++ b/layout/base/nsPresShell.cpp	Tue Jan 16 18:53:41 2007 -0800
@@ -442,10 +442,12 @@ public:
   StackArena();
   ~StackArena();
 
+  nsresult Init() { return mBlocks ? NS_OK : NS_ERROR_OUT_OF_MEMORY; }
+
   // Memory management functions
-  nsresult  Allocate(size_t aSize, void** aResult);
-  nsresult  Push();
-  nsresult  Pop();
+  void* Allocate(size_t aSize);
+  void Push();
+  void Pop();
 
 private:
   // our current position in memory
@@ -472,9 +474,8 @@ private:
 
 StackArena::StackArena()
 {
-  // allocate the marks array
-  mMarkLength = MARK_INCREMENT;
-  mMarks = new StackMark[mMarkLength];
+  mMarkLength = 0;
+  mMarks = nsnull;
 
   // allocate our stack memory
   mBlocks = new StackBlock();
@@ -496,34 +497,45 @@ StackArena::~StackArena()
   }
 } 
 
-nsresult
+void
 StackArena::Push()
 {
-  // if the we overrun our mark array. Resize it.
-  if (mStackTop + 1 >= mMarkLength)
+  // Resize the mark array if we overrun it.  Failure to allocate the
+  // mark array is not fatal; we just won't free to that mark.  This
+  // allows callers to not worry about error checking.
+  if (mStackTop >= mMarkLength)
   {
-    StackMark* oldMarks = mMarks;
-    PRUint32 oldLength = mMarkLength;
-    mMarkLength += MARK_INCREMENT;
-    mMarks = new StackMark[mMarkLength];
-    memcpy(mMarks, oldMarks, sizeof(StackMark)*oldLength);
-
-    delete[] oldMarks;
-  }
-
-  // set a mark at the top
-  mMarks[mStackTop].mBlock = mCurBlock;
-  mMarks[mStackTop].mPos = mPos;
+    PRUint32 newLength = mStackTop + MARK_INCREMENT;
+    StackMark* newMarks = new StackMark[newLength];
+    if (newMarks) {
+      if (mMarkLength)
+        memcpy(newMarks, mMarks, sizeof(StackMark)*mMarkLength);
+      // Fill in any marks that we couldn't allocate.
+      for (; mMarkLength < mStackTop; ++mMarkLength) {
+        NS_NOTREACHED("should only hit this on out-of-memory");
+        newMarks[mMarkLength].mBlock = mCurBlock;
+        newMarks[mMarkLength].mPos = mPos;
+      }
+      delete [] mMarks;
+      mMarks = newMarks;
+      mMarkLength = newLength;
+    }
+  }
+
+  // set a mark at the top (if we can)
+  NS_ASSERTION(mStackTop < mMarkLength, "out of memory");
+  if (mStackTop < mMarkLength) {
+    mMarks[mStackTop].mBlock = mCurBlock;
+    mMarks[mStackTop].mPos = mPos;
+  }
 
   mStackTop++;
-
-  return NS_OK;
-}
-
-nsresult
-StackArena::Allocate(size_t aSize, void** aResult)
-{
-  NS_ASSERTION(mStackTop > 0, "Error allocate called before push!!!");
+}
+
+void*
+StackArena::Allocate(size_t aSize)
+{
+  NS_ASSERTION(mStackTop > 0, "Allocate called without Push");
 
   // make sure we are aligned. Beard said 8 was safer then 4. 
   // Round size to multiple of 8
@@ -541,18 +553,24 @@ StackArena::Allocate(size_t aSize, void*
   }
 
   // return the chunk they need.
-  *aResult = mCurBlock->mBlock + mPos;
+  void *result = mCurBlock->mBlock + mPos;
   mPos += aSize;
 
-  return NS_OK;
-}
-
-nsresult
+  return result;
+}
+
+void
 StackArena::Pop()
 {
   // pop off the mark
-  NS_ASSERTION(mStackTop > 0, "Error Pop called 1 too many times");
+  NS_ASSERTION(mStackTop > 0, "unmatched pop");
   mStackTop--;
+
+  if (mStackTop >= mMarkLength) {
+    // We couldn't allocate the marks array at the time of the push, so
+    // we don't know where we're freeing to.
+    return;
+  }
 
 #ifdef DEBUG
   // Mark the "freed" memory with 0xdd to help with debugging of memory
@@ -569,8 +587,6 @@ StackArena::Pop()
 
   mCurBlock = mMarks[mStackTop].mBlock;
   mPos      = mMarks[mStackTop].mPos;
-
-  return NS_OK;
 }
 
 // Uncomment this to disable the frame arena.
@@ -803,9 +819,9 @@ public:
   virtual NS_HIDDEN_(void)  FreeFrame(size_t aSize, void* aFreeChunk);
 
   // Dynamic stack memory allocation
-  NS_IMETHOD PushStackMemory();
-  NS_IMETHOD PopStackMemory();
-  NS_IMETHOD AllocateStackMemory(size_t aSize, void** aResult);
+  virtual NS_HIDDEN_(void) PushStackMemory();
+  virtual NS_HIDDEN_(void) PopStackMemory();
+  virtual NS_HIDDEN_(void*) AllocateStackMemory(size_t aSize);
 
   NS_IMETHOD SetPreferenceStyleRules(PRBool aForceReflow);
   
@@ -1142,7 +1158,7 @@ protected:
   PRPackedBool                  mBatchReflows;  // When set to true, the pres shell batches reflow commands.
   PresShellViewEventListener    *mViewEventListener;
   FrameArena                    mFrameArena;
-  StackArena*                   mStackArena;
+  StackArena                    mStackArena;
   nsCOMPtr<nsIDragService>      mDragService;
   
   nsRevocableEventPtr<ReflowEvent> mReflowEvent;
@@ -1184,8 +1200,6 @@ private:
   nsresult RetargetEventToParent(nsGUIEvent* aEvent,
                                  nsEventStatus*  aEventStatus);
 
-  void FreeDynamicStack();
-
   //helper funcs for event handling
 protected:
   //protected because nsPresShellEventCB needs this.
@@ -1425,9 +1439,6 @@ PresShell::~PresShell()
 
   mCurrentEventContent = nsnull;
 
-  // if we allocated any stack memory free it.
-  FreeDynamicStack();
-
   NS_IF_RELEASE(mPresContext);
   NS_IF_RELEASE(mDocument);
   NS_IF_RELEASE(mSelection);
@@ -1447,6 +1458,7 @@ PresShell::Init(nsIDocument* aDocument,
   NS_PRECONDITION(nsnull != aDocument, "null ptr");
   NS_PRECONDITION(nsnull != aPresContext, "null ptr");
   NS_PRECONDITION(nsnull != aViewManager, "null ptr");
+  nsresult result;
 
   if ((nsnull == aDocument) || (nsnull == aPresContext) ||
       (nsnull == aViewManager)) {
@@ -1456,6 +1468,8 @@ PresShell::Init(nsIDocument* aDocument,
     NS_WARNING("PresShell double init'ed");
     return NS_ERROR_ALREADY_INITIALIZED;
   }
+  result = mStackArena.Init();
+  NS_ENSURE_SUCCESS(result, result);
 
   mDocument = aDocument;
   NS_ADDREF(mDocument);
@@ -1474,7 +1488,7 @@ PresShell::Init(nsIDocument* aDocument,
   aPresContext->SetShell(this);
 
   // Now we can initialize the style set.
-  nsresult result = aStyleSet->Init(aPresContext);
+  result = aStyleSet->Init(aPresContext);
   NS_ENSURE_SUCCESS(result, result);
 
   // From this point on, any time we return an error we need to make
@@ -1707,47 +1721,23 @@ PresShell::Destroy()
 }
 
                   // Dynamic stack memory allocation
-NS_IMETHODIMP
+/* virtual */ void
 PresShell::PushStackMemory()
 {
-  if (!mStackArena) {
-    mStackArena = new StackArena();
-    if (!mStackArena)
-      return NS_ERROR_OUT_OF_MEMORY;
-  }
-
-  return mStackArena->Push();
-}
-
-NS_IMETHODIMP
+  mStackArena.Push();
+}
+
+/* virtual */ void
 PresShell::PopStackMemory()
 {
-  NS_ENSURE_TRUE(mStackArena, NS_ERROR_UNEXPECTED);
-
-  return mStackArena->Pop();
-}
-
-NS_IMETHODIMP
-PresShell::AllocateStackMemory(size_t aSize, void** aResult)
-{
-  if (!mStackArena) {
-    mStackArena = new StackArena();
-    if (!mStackArena)
-      return NS_ERROR_OUT_OF_MEMORY;
-  }
-
-  return mStackArena->Allocate(aSize, aResult);
-}
-
-void
-PresShell::FreeDynamicStack()
-{
-  if (mStackArena) {
-    delete mStackArena;
-    mStackArena = nsnull;
-  }
-}
- 
+  mStackArena.Pop();
+}
+
+/* virtual */ void*
+PresShell::AllocateStackMemory(size_t aSize)
+{
+  return mStackArena.Allocate(aSize);
+}
 
 void
 PresShell::FreeFrame(size_t aSize, void* aPtr)
diff -r 7627baaab426 layout/tables/SpanningCellSorter.cpp
--- a/layout/tables/SpanningCellSorter.cpp	Tue Jan 16 16:31:52 2007 -0800
+++ b/layout/tables/SpanningCellSorter.cpp	Tue Jan 16 18:49:51 2007 -0800
@@ -107,9 +107,8 @@ SpanningCellSorter::AddCell(PRInt32 aCol
     NS_ASSERTION(mState == ADDING, "cannot call AddCell after GetNext");
     NS_ASSERTION(aColSpan >= ARRAY_BASE, "cannot add cells with colspan<2");
 
-    Item *i;
-    nsresult rv = mPresShell->AllocateStackMemory(sizeof(Item), (void**)&i);
-    NS_ENSURE_SUCCESS(rv, PR_FALSE);
+    Item *i = (Item*) mPresShell->AllocateStackMemory(sizeof(Item));
+    NS_ENSURE_TRUE(i != nsnull, PR_FALSE);
 
     i->row = aRow;
     i->col = aCol;
diff -r 7627baaab426 layout/xul/base/src/nsBoxLayoutState.h
--- a/layout/xul/base/src/nsBoxLayoutState.h	Tue Jan 16 16:31:52 2007 -0800
+++ b/layout/xul/base/src/nsBoxLayoutState.h	Tue Jan 16 18:46:56 2007 -0800
@@ -78,10 +78,10 @@ public:
   // doing box layout or intrinsic size calculation will cause bugs.
   nsIRenderingContext* GetRenderingContext() const { return mRenderingContext; }
 
-  nsresult PushStackMemory() { return PresShell()->PushStackMemory(); }
-  nsresult PopStackMemory()  { return PresShell()->PopStackMemory(); }
-  nsresult AllocateStackMemory(size_t aSize, void** aResult)
-  { return PresShell()->AllocateStackMemory(aSize, aResult); }
+  void PushStackMemory() { PresShell()->PushStackMemory(); }
+  void PopStackMemory()  { PresShell()->PopStackMemory(); }
+  void* AllocateStackMemory(size_t aSize)
+  { return PresShell()->AllocateStackMemory(aSize); }
 
 private:
   nsCOMPtr<nsPresContext> mPresContext;
diff -r 7627baaab426 layout/xul/base/src/nsSprocketLayout.cpp
--- a/layout/xul/base/src/nsSprocketLayout.cpp	Tue Jan 16 16:31:52 2007 -0800
+++ b/layout/xul/base/src/nsSprocketLayout.cpp	Tue Jan 16 18:54:24 2007 -0800
@@ -1763,9 +1763,7 @@ void*
 void* 
 nsBoxSize::operator new(size_t sz, nsBoxLayoutState& aState) CPP_THROW_NEW
 {
-   void* mem = 0;
-   aState.AllocateStackMemory(sz,&mem);
-   return mem;
+   return aState.AllocateStackMemory(sz);
 }
 
 
@@ -1778,10 +1776,7 @@ void*
 void* 
 nsComputedBoxSize::operator new(size_t sz, nsBoxLayoutState& aState) CPP_THROW_NEW
 {
-  
-   void* mem = 0;
-   aState.AllocateStackMemory(sz,&mem);
-   return mem;
+   return aState.AllocateStackMemory(sz);
 }
 
 void 
