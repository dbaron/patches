Reverse the boolean meaning of inherited/aInherited.  (This patch, without the next patch to rename things, makes the code make less sense.)  (Bug 476598)

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -192,17 +192,17 @@ static nscoord CalcLengthWith(const nsCS
   if (aValue.IsFixedLengthUnit()) {
     return aPresContext->TwipsToAppUnits(aValue.GetLengthTwips());
   }
   nsCSSUnit unit = aValue.GetUnit();
   if (unit == eCSSUnit_Pixel) {
     return nsPresContext::CSSPixelsToAppUnits(aValue.GetFloatValue());
   }
   // Common code for all units other than pixels:
-  aInherited = PR_TRUE;
+  aInherited = PR_FALSE;
   if (!aStyleFont) {
     aStyleFont = aStyleContext->GetStyleFont();
   }
   if (aFontSize == -1) {
     // XXX Should this be aStyleFont->mSize instead to avoid taking minfontsize
     // prefs into account?
     aFontSize = aStyleFont->mFont.size;
   }
@@ -354,17 +354,17 @@ static PRBool SetCoord(const nsCSSValue&
   } 
   else if (((aMask & SETCOORD_AUTO) != 0) && 
            (aValue.GetUnit() == eCSSUnit_Auto)) {
     aCoord.SetAutoValue();
   } 
   else if (((aMask & SETCOORD_INHERIT) != 0) && 
            (aValue.GetUnit() == eCSSUnit_Inherit)) {
     aCoord = aParentCoord;  // just inherit value from parent
-    aInherited = PR_TRUE;
+    aInherited = PR_FALSE;
   }
   else if (((aMask & SETCOORD_NORMAL) != 0) && 
            (aValue.GetUnit() == eCSSUnit_Normal)) {
     aCoord.SetNormalValue();
   }
   else if (((aMask & SETCOORD_NONE) != 0) && 
            (aValue.GetUnit() == eCSSUnit_None)) {
     aCoord.SetNoneValue();
@@ -461,30 +461,30 @@ static PRBool SetColor(const nsCSSValue&
           aResult = aPresContext->DefaultVisitedLinkColor();
           break;
         case NS_COLOR_MOZ_ACTIVEHYPERLINKTEXT:
           aResult = aPresContext->DefaultActiveLinkColor();
           break;
         case NS_COLOR_CURRENTCOLOR:
           // The data computed from this can't be shared in the rule tree 
           // because they could be used on a node with a different color
-          aInherited = PR_TRUE;
+          aInherited = PR_FALSE;
           aResult = aContext->GetStyleColor()->mColor;
           break;
         default:
           NS_NOTREACHED("Should never have an unknown negative colorID.");
           break;
       }
       result = PR_TRUE;
     }
   }
   else if (eCSSUnit_Inherit == unit) {
     aResult = aParentColor;
     result = PR_TRUE;
-    aInherited = PR_TRUE;
+    aInherited = PR_FALSE;
   }
   return result;
 }
 
 // flags for SetDiscrete - align values with SETCOORD_* constants
 // where possible
 
 #define SETDSC_NORMAL                 0x01   // N
@@ -509,17 +509,17 @@ SetDiscrete(const nsCSSValue& aValue, Fi
 {
   switch (aValue.GetUnit()) {
   case eCSSUnit_Null:
     return;
 
     // every caller of SetDiscrete provides inherit and initial
     // alternatives, so we don't require them to say so in the mask
   case eCSSUnit_Inherit:
-    aInherited = PR_TRUE;
+    aInherited = PR_FALSE;
     aField = aParentValue;
     return;
 
   case eCSSUnit_Initial:
     aField = aInitialValue;
     return;
 
     // every caller provides one or other of these alternatives,
@@ -598,17 +598,17 @@ SetFactor(const nsCSSValue& aValue, floa
       if (aField < 0.0f)
         aField = 0.0f;
       if (aField > 1.0f)
         aField = 1.0f;
     }
     return;
 
   case eCSSUnit_Inherit:
-    aInherited = PR_TRUE;
+    aInherited = PR_FALSE;
     aField = aParentValue;
     return;
 
   case eCSSUnit_Initial:
     aField = aInitialValue;
     return;
 
   case eCSSUnit_None:
@@ -1808,17 +1808,17 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
       return SetDefaultOnRoot(aSID, aContext);
   }
 
   // We need to compute the data from the information that the rules specified.
   const void* res;
 #define STYLE_STRUCT_TEST aSID
 #define STYLE_STRUCT(name, checkdata_cb, ctor_args)                           \
   res = Compute##name##Data(startStruct, *aSpecificData, aContext,            \
-                      highestNode, detail, !aRuleData->mCanStoreInRuleTree);
+                      highestNode, detail, aRuleData->mCanStoreInRuleTree);
 #include "nsStyleStructList.h"
 #undef STYLE_STRUCT
 #undef STYLE_STRUCT_TEST
 
   // If we have a post-resolve callback, handle that now.
   if (aRuleData->mPostResolveCallback && (NS_LIKELY(res != nsnull)))
     (*aRuleData->mPostResolveCallback)(const_cast<void*>(res), aRuleData);
 
@@ -2074,17 +2074,17 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
   PRBool LTRlogical = aLTRSource.GetUnit() == eCSSUnit_Enumerated &&
                       aLTRSource.GetIntValue() == NS_BOXPROP_SOURCE_LOGICAL;
   PRBool RTLlogical = aRTLSource.GetUnit() == eCSSUnit_Enumerated &&
                       aRTLSource.GetIntValue() == NS_BOXPROP_SOURCE_LOGICAL;
   if (LTRlogical || RTLlogical) {
     // We can't cache anything on the rule tree if we use any data from
     // the style context, since data cached in the rule tree could be
     // used with a style context with a different value.
-    aInherited = PR_TRUE;
+    aInherited = PR_FALSE;
     PRUint8 dir = aContext->GetStyleVisibility()->mDirection;
 
     if (dir == NS_STYLE_DIRECTION_LTR) {
       if (LTRlogical)
         aValueRect.*(nsCSSRect::sides[aSide]) = aLTRLogicalValue;
     } else {
       if (RTLlogical)
         aValueRect.*(nsCSSRect::sides[aSide]) = aRTLLogicalValue;
@@ -2127,17 +2127,17 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
     /* We only need to compute the delta between this computed data and */    \
     /* our computed data. */                                                  \
     data_ = new (mPresContext)                                                \
             nsStyle##type_(*static_cast<nsStyle##type_*>(aStartStruct));      \
   else {                                                                      \
     if (aRuleDetail != eRuleFullMixed && aRuleDetail != eRuleFullReset) {     \
       /* No question. We will have to inherit. Go ahead and init */           \
       /* with inherited vals from parent. */                                  \
-      inherited = PR_TRUE;                                                    \
+      inherited = PR_FALSE;                                                    \
       if (parentdata_)                                                        \
         data_ = new (mPresContext) nsStyle##type_(*parentdata_);              \
       else                                                                    \
         data_ = new (mPresContext) nsStyle##type_ ctorargs_;                  \
     }                                                                         \
     else                                                                      \
       data_ = new (mPresContext) nsStyle##type_ ctorargs_;                    \
   }                                                                           \
@@ -2198,17 +2198,17 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
 
 /**
  * Begin an nsRuleNode::Compute*Data function for an inherited struct.
  *
  * @param type_ The nsStyle* type this function computes.
  * @param data_ Variable holding the result of this function.
  */
 #define COMPUTE_END_INHERITED(type_, data_)                                   \
-  if (inherited)                                                              \
+  if (!inherited)                                                             \
     /* We inherited, and therefore can't be cached in the rule node.  We */   \
     /* have to be put right on the style context. */                          \
     aContext->SetStyle(eStyleStruct_##type_, data_);                          \
   else {                                                                      \
     /* We were fully specified and can therefore be cached right on the */    \
     /* rule node. */                                                          \
     if (!aHighestNode->mStyleData.mInheritedData) {                           \
       aHighestNode->mStyleData.mInheritedData =                               \
@@ -2227,17 +2227,17 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
 
 /**
  * Begin an nsRuleNode::Compute*Data function for a reset struct.
  *
  * @param type_ The nsStyle* type this function computes.
  * @param data_ Variable holding the result of this function.
  */
 #define COMPUTE_END_RESET(type_, data_)                                       \
-  if (inherited)                                                              \
+  if (!inherited)                                                             \
     /* We inherited, and therefore can't be cached in the rule node.  We */   \
     /* have to be put right on the style context. */                          \
     aContext->SetStyle(eStyleStruct_##type_, data_);                          \
   else {                                                                      \
     /* We were fully specified and can therefore be cached right on the */    \
     /* rule node. */                                                          \
     if (!aHighestNode->mStyleData.mResetData) {                               \
       aHighestNode->mStyleData.mResetData =                                   \
@@ -2344,17 +2344,17 @@ nsRuleNode::SetFontSize(nsPresContext* a
     }
     else if (NS_STYLE_FONT_SIZE_XXXLARGE == value) {
       // <font size="7"> is not specified in CSS, so we don't use eFontSize_CSS.
       *aSize = nsStyleUtil::CalcFontPointSize(value, baseSize,
                        scaleFactor, aPresContext);
     }
     else if (NS_STYLE_FONT_SIZE_LARGER  == value ||
              NS_STYLE_FONT_SIZE_SMALLER == value) {
-      aInherited = PR_TRUE;
+      aInherited = PR_FALSE;
 
       // Un-zoom so we use the tables correctly.  We'll then rezoom due
       // to the |zoom = PR_TRUE| above.
       // Note that relative units here use the parent's size unadjusted
       // for scriptlevel changes. A scriptlevel change between us and the parent
       // is simply ignored.
       nscoord parentSize =
         nsStyleFont::UnZoomText(aPresContext, aParentSize);
@@ -2381,31 +2381,31 @@ nsRuleNode::SetFontSize(nsPresContext* a
     // for scriptlevel changes. A scriptlevel change between us and the parent
     // is simply ignored.
     *aSize = CalcLengthWith(aFontData.mSize, aParentSize, aParentFont, nsnull,
                             aPresContext, aAtRoot, PR_TRUE, aInherited);
     zoom = aFontData.mSize.IsFixedLengthUnit() ||
            aFontData.mSize.GetUnit() == eCSSUnit_Pixel;
   }
   else if (eCSSUnit_Percent == aFontData.mSize.GetUnit()) {
-    aInherited = PR_TRUE;
+    aInherited = PR_FALSE;
     // Note that % units use the parent's size unadjusted for scriptlevel
     // changes. A scriptlevel change between us and the parent is simply
     // ignored.
     *aSize = NSToCoordRound(aParentSize *
                             aFontData.mSize.GetPercentValue());
     zoom = PR_FALSE;
   }
   else if (eCSSUnit_System_Font == aFontData.mSize.GetUnit()) {
     // this becomes our cascading size
     *aSize = aSystemFont.size;
     zoom = PR_TRUE;
   }
   else if (eCSSUnit_Inherit == aFontData.mSize.GetUnit()) {
-    aInherited = PR_TRUE;
+    aInherited = PR_FALSE;
     // We apply scriptlevel change for this case, because the default is
     // to inherit and we don't want explicit "inherit" to differ from the
     // default.
     *aSize = aScriptLevelAdjustedParentSize;
     zoom = PR_FALSE;
   }
   else if (eCSSUnit_Initial == aFontData.mSize.GetUnit()) {
     // The initial value is 'medium', which has magical sizing based on
@@ -2419,17 +2419,17 @@ nsRuleNode::SetFontSize(nsPresContext* a
     // if aUsedStartStruct is true, then every single property in the
     // font struct is being set all at once. This means scriptlevel is not
     // going to have any influence on the font size; there is no need to
     // do anything here.
     if (!aUsedStartStruct && aParentSize != aScriptLevelAdjustedParentSize) {
       // There was no rule affecting the size but the size has been
       // affected by the parent's size via scriptlevel change. So treat
       // this as inherited.
-      aInherited = PR_TRUE;
+      aInherited = PR_FALSE;
       *aSize = aScriptLevelAdjustedParentSize;
     }
 #endif
   }
 
   // We want to zoom the cascaded size so that em-based measurements,
   // line-heights, etc., work.
   if (zoom) {
@@ -2546,17 +2546,17 @@ nsRuleNode::SetFont(nsPresContext* aPres
   }
   else if (eCSSUnit_System_Font == aFontData.mFamily.GetUnit()) {
     aFont->mFont.name = systemFont.name;
     aFont->mFont.familyNameQuirks = PR_FALSE;
     aFont->mFont.systemFont = PR_TRUE;
     aFont->mGenericID = kGenericFont_NONE;
   }
   else if (eCSSUnit_Inherit == aFontData.mFamily.GetUnit()) {
-    aInherited = PR_TRUE;
+    aInherited = PR_FALSE;
     aFont->mFont.name = aParentFont->mFont.name;
     aFont->mFont.familyNameQuirks = aParentFont->mFont.familyNameQuirks;
     aFont->mFont.systemFont = aParentFont->mFont.systemFont;
     aFont->mGenericID = aParentFont->mGenericID;
   }
   else if (eCSSUnit_Initial == aFontData.mFamily.GetUnit()) {
     aFont->mFont.name = defaultVariableFont->name;
     aFont->mFont.familyNameQuirks = PR_FALSE;
@@ -2596,17 +2596,17 @@ nsRuleNode::SetFont(nsPresContext* aPres
     PRInt32 value = aFontData.mWeight.GetIntValue();
     switch (value) {
       case NS_STYLE_FONT_WEIGHT_NORMAL:
       case NS_STYLE_FONT_WEIGHT_BOLD:
         aFont->mFont.weight = value;
         break;
       case NS_STYLE_FONT_WEIGHT_BOLDER:
       case NS_STYLE_FONT_WEIGHT_LIGHTER:
-        aInherited = PR_TRUE;
+        aInherited = PR_FALSE;
         aFont->mFont.weight = nsStyleUtil::ConstrainFontWeight(aParentFont->mFont.weight + value);
         break;
     }
   } else 
     SetDiscrete(aFontData.mWeight, aFont->mFont.weight, aInherited,
                 SETDSC_INTEGER | SETDSC_NORMAL | SETDSC_SYSTEM_FONT,
                 aParentFont->mFont.weight,
                 defaultVariableFont->weight,
@@ -2615,17 +2615,17 @@ nsRuleNode::SetFont(nsPresContext* aPres
                 systemFont.weight);
 
   // font-stretch: enum, normal, inherit
   if (eCSSUnit_Enumerated == aFontData.mStretch.GetUnit()) {
     PRInt32 value = aFontData.mStretch.GetIntValue();
     switch (value) {
       case NS_FONT_STRETCH_WIDER:
       case NS_FONT_STRETCH_NARROWER:
-        aInherited = PR_TRUE;
+        aInherited = PR_FALSE;
         aFont->mFont.stretch = aParentFont->mFont.stretch + value;
         break;
       default:
         aFont->mFont.stretch = value;
         break;
     }
   } else
     SetDiscrete(aFontData.mStretch, aFont->mFont.stretch, aInherited,
@@ -2659,17 +2659,17 @@ nsRuleNode::SetFont(nsPresContext* aPres
     // "relative"
     aFont->mScriptLevel = ClampTo8Bit(aParentFont->mScriptLevel + aFontData.mScriptLevel.GetIntValue());
   }
   else if (eCSSUnit_Number == aFontData.mScriptLevel.GetUnit()) {
     // "absolute"
     aFont->mScriptLevel = ClampTo8Bit(PRInt32(aFontData.mScriptLevel.GetFloatValue()));
   }
   else if (eCSSUnit_Inherit == aFontData.mScriptSizeMultiplier.GetUnit()) {
-    aInherited = PR_TRUE;
+    aInherited = PR_FALSE;
     aFont->mScriptLevel = aParentFont->mScriptLevel;
   }
   else if (eCSSUnit_Initial == aFontData.mScriptSizeMultiplier.GetUnit()) {
     aFont->mScriptLevel = 0;
   }
 #endif
 
   // font-size: enum, length, percent, inherit
@@ -2896,17 +2896,17 @@ nsRuleNode::ComputeFontData(void* aStart
   if (generic == kGenericFont_NONE) {
     // continue the normal processing
     nsRuleNode::SetFont(mPresContext, aContext, minimumFontSize, generic,
                         fontData, parentFont, font,
                         aStartStruct != nsnull, inherited);
   }
   else {
     // re-calculate the font as a generic font
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     nsRuleNode::SetGenericFont(mPresContext, aContext, generic,
                                minimumFontSize, font);
   }
 
   COMPUTE_END_INHERITED(Font, font)
 }
 
 already_AddRefed<nsCSSShadowArray>
@@ -2993,27 +2993,27 @@ nsRuleNode::ComputeTextData(void* aStart
   // text-shadow: none, list, inherit, initial
   nsCSSValueList* list = textData.mTextShadow;
   if (list) {
     text->mTextShadow = nsnull;
 
     // Don't need to handle none/initial explicitly: The above assignment
     // takes care of that
     if (eCSSUnit_Inherit == list->mValue.GetUnit()) {
-      inherited = PR_TRUE;
+      inherited = PR_FALSE;
       text->mTextShadow = parentText->mTextShadow;
     } else if (eCSSUnit_Array == list->mValue.GetUnit()) {
       // List of arrays
       text->mTextShadow = GetShadowData(list, aContext, PR_FALSE, inherited);
     }
   }
 
   // line-height: normal, number, length, percent, inherit
   if (eCSSUnit_Percent == textData.mLineHeight.GetUnit()) {
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     // Use |mFont.size| to pick up minimum font size.
     text->mLineHeight.SetCoordValue(
         nscoord(float(aContext->GetStyleFont()->mFont.size) *
                 textData.mLineHeight.GetPercentValue()));
   }
   else if (eCSSUnit_Initial == textData.mLineHeight.GetUnit() ||
            eCSSUnit_System_Font == textData.mLineHeight.GetUnit()) {
     text->mLineHeight.SetNormalValue();
@@ -3028,17 +3028,17 @@ nsRuleNode::ComputeTextData(void* aStart
                                          text->mLineHeight.GetCoordValue());
       nscoord minimumFontSize =
         mPresContext->GetCachedIntPref(kPresContext_MinimumFontSize);
 
       if (minimumFontSize > 0 && !mPresContext->IsChrome()) {
         // If we applied a minimum font size, scale the line height by
         // the same ratio.  (If we *might* have applied a minimum font
         // size, we can't cache in the rule tree.)
-        inherited = PR_TRUE;
+        inherited = PR_FALSE;
         const nsStyleFont *font = aContext->GetStyleFont();
         if (font->mSize != 0) {
           lh = nscoord(float(lh) * float(font->mFont.size) / float(font->mSize));
         } else {
           lh = minimumFontSize;
         }
       }
       text->mLineHeight.SetCoordValue(lh);
@@ -3165,17 +3165,17 @@ nsRuleNode::ComputeUserInterfaceData(voi
   // cursor: enum, auto, url, inherit
   nsCSSValueList*  list = uiData.mCursor;
   if (nsnull != list) {
     delete [] ui->mCursorArray;
     ui->mCursorArray = nsnull;
     ui->mCursorArrayLength = 0;
 
     if (eCSSUnit_Inherit == list->mValue.GetUnit()) {
-      inherited = PR_TRUE;
+      inherited = PR_FALSE;
       ui->mCursor = parentUI->mCursor;
       ui->CopyCursorArrayFrom(*parentUI);
     }
     else if (eCSSUnit_Initial == list->mValue.GetUnit()) {
       ui->mCursor = NS_STYLE_CURSOR_AUTO;
     }
     else {
       // The parser will never create a list that is *all* URL values --
@@ -3298,17 +3298,17 @@ nsRuleNode::ComputeUIResetData(void* aSt
 }
 
 /* Given a -moz-transform token stream, accumulates them into an
  * nsStyleTransformMatrix
  *
  * @param aList The nsCSSValueList of arrays to read into transform functions.
  * @param aContext The style context to use for unit conversion.
  * @param aPresContext The presentation context to use for unit conversion
- * @param aInherited If the value is inherited, this is set to PR_TRUE.
+ * @param aInherited If the value is inherited, this is set to PR_FALSE.
  * @return An nsStyleTransformMatrix corresponding to the net transform.
  */
 static nsStyleTransformMatrix ReadTransforms(const nsCSSValueList* aList,
                                              nsStyleContext* aContext,
                                              nsPresContext* aPresContext,
                                              PRBool &aInherited)
 {
   nsStyleTransformMatrix result;
@@ -3367,17 +3367,17 @@ nsRuleNode::ComputeDisplayData(void* aSt
       display->mBinding = nsnull;
     }
   }
   else if (eCSSUnit_None == displayData.mBinding.GetUnit() ||
            eCSSUnit_Initial == displayData.mBinding.GetUnit()) {
     display->mBinding = nsnull;
   }
   else if (eCSSUnit_Inherit == displayData.mBinding.GetUnit()) {
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     display->mBinding = parentDisplay->mBinding;
   }
 
   // position: enum, inherit, initial
   SetDiscrete(displayData.mPosition, display->mPosition, inherited,
               SETDSC_ENUMERATED, parentDisplay->mPosition,
               NS_STYLE_POSITION_STATIC, 0, 0, 0, 0);
 
@@ -3395,29 +3395,29 @@ nsRuleNode::ComputeDisplayData(void* aSt
   if (eCSSUnit_Enumerated == displayData.mBreakBefore.GetUnit()) {
     display->mBreakBefore = (NS_STYLE_PAGE_BREAK_AVOID != displayData.mBreakBefore.GetIntValue());
   }
   else if (eCSSUnit_Auto == displayData.mBreakBefore.GetUnit() ||
            eCSSUnit_Initial == displayData.mBreakBefore.GetUnit()) {
     display->mBreakBefore = PR_FALSE;
   }
   else if (eCSSUnit_Inherit == displayData.mBreakBefore.GetUnit()) {
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     display->mBreakBefore = parentDisplay->mBreakBefore;
   }
 
   if (eCSSUnit_Enumerated == displayData.mBreakAfter.GetUnit()) {
     display->mBreakAfter = (NS_STYLE_PAGE_BREAK_AVOID != displayData.mBreakAfter.GetIntValue());
   }
   else if (eCSSUnit_Auto == displayData.mBreakAfter.GetUnit() ||
            eCSSUnit_Initial == displayData.mBreakAfter.GetUnit()) {
     display->mBreakAfter = PR_FALSE;
   }
   else if (eCSSUnit_Inherit == displayData.mBreakAfter.GetUnit()) {
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     display->mBreakAfter = parentDisplay->mBreakAfter;
   }
   // end temp fix
 
   // float: enum, none, inherit, initial
   SetDiscrete(displayData.mFloat, display->mFloats, inherited,
               SETDSC_ENUMERATED | SETDSC_NONE, parentDisplay->mFloats,
               NS_STYLE_FLOAT_NONE, 0,
@@ -3444,17 +3444,17 @@ nsRuleNode::ComputeDisplayData(void* aSt
   // meaningful only when used in both dimensions.
   if (display->mOverflowX != display->mOverflowY &&
       (display->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE ||
        display->mOverflowX == NS_STYLE_OVERFLOW_CLIP ||
        display->mOverflowY == NS_STYLE_OVERFLOW_VISIBLE ||
        display->mOverflowY == NS_STYLE_OVERFLOW_CLIP)) {
     // We can't store in the rule tree since a more specific rule might
     // change these conditions.
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
 
     // NS_STYLE_OVERFLOW_CLIP is a deprecated value, so if it's specified
     // in only one dimension, convert it to NS_STYLE_OVERFLOW_HIDDEN.
     if (display->mOverflowX == NS_STYLE_OVERFLOW_CLIP)
       display->mOverflowX = NS_STYLE_OVERFLOW_HIDDEN;
     if (display->mOverflowY == NS_STYLE_OVERFLOW_CLIP)
       display->mOverflowY = NS_STYLE_OVERFLOW_HIDDEN;
 
@@ -3463,17 +3463,17 @@ nsRuleNode::ComputeDisplayData(void* aSt
     if (display->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE)
       display->mOverflowX = NS_STYLE_OVERFLOW_AUTO;
     if (display->mOverflowY == NS_STYLE_OVERFLOW_VISIBLE)
       display->mOverflowY = NS_STYLE_OVERFLOW_AUTO;
   }
 
   // clip property: length, auto, inherit
   if (eCSSUnit_Inherit == displayData.mClip.mTop.GetUnit()) { // if one is inherit, they all are
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     display->mClipFlags = parentDisplay->mClipFlags;
     display->mClip = parentDisplay->mClip;
   }
   // if one is initial or auto (rect), they all are
   else if (eCSSUnit_Initial == displayData.mClip.mTop.GetUnit() ||
            eCSSUnit_RectIsAuto == displayData.mClip.mTop.GetUnit()) {
     display->mClipFlags = NS_STYLE_CLIP_AUTO;
     display->mClip.SetRect(0,0,0,0);
@@ -3529,44 +3529,44 @@ nsRuleNode::ComputeDisplayData(void* aSt
     if (nsCSSPseudoElements::firstLetter == aContext->GetPseudoType()) {
       // a non-floating first-letter must be inline
       // XXX this fix can go away once bug 103189 is fixed correctly
       display->mDisplay = NS_STYLE_DISPLAY_INLINE;
 
       // We can't cache the data in the rule tree since if a more specific
       // rule has 'float: left' we'll end up with the wrong 'display'
       // property.
-      inherited = PR_TRUE;
+      inherited = PR_FALSE;
     }
 
     if (display->IsAbsolutelyPositioned()) {
       // 1) if position is 'absolute' or 'fixed' then display must be
       // block-level and float must be 'none'
 
       // Backup original display value for calculation of a hypothetical
       // box (CSS2 10.6.4/10.6.5).
       // See nsHTMLReflowState::CalculateHypotheticalBox
       display->mOriginalDisplay = display->mDisplay;
       EnsureBlockDisplay(display->mDisplay);
       display->mFloats = NS_STYLE_FLOAT_NONE;
 
       // We can't cache the data in the rule tree since if a more specific
       // rule has 'position: static' we'll end up with problems with the
       // 'display' and 'float' properties.
-      inherited = PR_TRUE;
+      inherited = PR_FALSE;
     } else if (display->mFloats != NS_STYLE_FLOAT_NONE) {
       // 2) if float is not none, and display is not none, then we must
       // set a block-level 'display' type per CSS2.1 section 9.7.
 
       EnsureBlockDisplay(display->mDisplay);
 
       // We can't cache the data in the rule tree since if a more specific
       // rule has 'float: none' we'll end up with the wrong 'display'
       // property.
-      inherited = PR_TRUE;
+      inherited = PR_FALSE;
     }
 
   }
   
   /* Convert the nsCSSValueList into an nsTArray<nsTransformFunction *>. */
   const nsCSSValueList *head = displayData.mTransform;
   
   if (head != nsnull) {
@@ -3579,17 +3579,17 @@ nsRuleNode::ComputeDisplayData(void* aSt
     if (head->mValue.GetUnit() == eCSSUnit_None)
       display->mTransformPresent = PR_FALSE;
     
     /* If we need to inherit, do so by making a full deep-copy. */
     else if (head->mValue.GetUnit() == eCSSUnit_Inherit)  {
       display->mTransformPresent = parentDisplay->mTransformPresent;
       if (parentDisplay->mTransformPresent)
         display->mTransform = parentDisplay->mTransform;
-      inherited = PR_TRUE;
+      inherited = PR_FALSE;
     }
     /* If it's 'initial', then we reset to empty. */
     else if (head->mValue.GetUnit() == eCSSUnit_Initial)
       display->mTransformPresent = PR_FALSE;
     
     /* Otherwise, we are looking at a list of CSS tokens.  We'll read each of
      * them in as an array of nsTransformFunction objects, then will accumulate
      * them all together to form the final transform matrix.
@@ -3702,17 +3702,17 @@ nsRuleNode::ComputeColorData(void* aStar
                           Color, colorData)
 
   // color: color, string, inherit
   // Special case for currentColor.  According to CSS3, setting color to 'currentColor'
   // should behave as if it is inherited
   if (colorData.mColor.GetUnit() == eCSSUnit_EnumColor && 
       colorData.mColor.GetIntValue() == NS_COLOR_CURRENTCOLOR) {
     color->mColor = parentColor->mColor;
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
   }
   else if (colorData.mColor.GetUnit() == eCSSUnit_Initial) {
     color->mColor = mPresContext->DefaultColor();
   }
   else {
     SetColor(colorData.mColor, parentColor->mColor, mPresContext, aContext, color->mColor, 
              inherited);
   }
@@ -3898,17 +3898,17 @@ nsRuleNode::ComputeBorderData(void* aSta
   // -moz-box-shadow: none, list, inherit, initial
   {
     nsCSSValueList* list = marginData.mBoxShadow;
     if (list) {
       // This handles 'none' and 'initial'
       border->mBoxShadow = nsnull;
 
       if (eCSSUnit_Inherit == list->mValue.GetUnit()) {
-        inherited = PR_TRUE;
+        inherited = PR_FALSE;
         border->mBoxShadow = parentBorder->mBoxShadow;
       } else if (eCSSUnit_Array == list->mValue.GetUnit()) {
         // List of arrays
         border->mBoxShadow = GetShadowData(list, aContext, PR_TRUE, inherited);
       }
     }
   }
 
@@ -3948,17 +3948,17 @@ nsRuleNode::ComputeBorderData(void* aSta
       }
       // OK to pass bad aParentCoord since we're not passing SETCOORD_INHERIT
       else if (SetCoord(value, coord, nsStyleCoord(), SETCOORD_LENGTH,
                         aContext, mPresContext, inherited)) {
         NS_ASSERTION(coord.GetUnit() == eStyleUnit_Coord, "unexpected unit");
         border->SetBorderWidth(side, coord.GetCoordValue());
       }
       else if (eCSSUnit_Inherit == value.GetUnit()) {
-        inherited = PR_TRUE;
+        inherited = PR_FALSE;
         border->SetBorderWidth(side,
                                parentBorder->GetComputedBorder().side(side));
       }
       else if (eCSSUnit_Initial == value.GetUnit()) {
         border->SetBorderWidth(side,
           (mPresContext->GetBorderWidthTable())[NS_STYLE_BORDER_WIDTH_MEDIUM]);
       }
       else {
@@ -3986,17 +3986,17 @@ nsRuleNode::ComputeBorderData(void* aSta
       nsCSSUnit unit = value.GetUnit();
       if (eCSSUnit_Enumerated == unit) {
         border->SetBorderStyle(side, value.GetIntValue());
       }
       else if (eCSSUnit_None == unit || eCSSUnit_Initial == unit) {
         border->SetBorderStyle(side, NS_STYLE_BORDER_STYLE_NONE);
       }
       else if (eCSSUnit_Inherit == unit) {
-        inherited = PR_TRUE;
+        inherited = PR_FALSE;
         border->SetBorderStyle(side, parentBorder->GetBorderStyle(side));
       }
     }
   }
 
   // -moz-border-*-colors: color, string, enum, none, inherit/initial
   nscolor borderColor;
   nscolor unused = NS_RGB(0,0,0);
@@ -4055,17 +4055,17 @@ nsRuleNode::ComputeBorderData(void* aSta
                        marginData.mBorderRightColorRTLSource,
                        marginData.mBorderEndColor, marginData.mBorderStartColor,
                        NS_SIDE_RIGHT, ourBorderColor, inherited);
   { // scope for compilers with broken |for| loop scoping
     NS_FOR_CSS_SIDES(side) {
       const nsCSSValue &value = ourBorderColor.*(nsCSSRect::sides[side]);
       if (eCSSUnit_Inherit == value.GetUnit()) {
         if (parentContext) {
-          inherited = PR_TRUE;
+          inherited = PR_FALSE;
           parentBorder->GetBorderColor(side, borderColor, foreground);
           if (foreground) {
             // We want to inherit the color from the parent, not use the
             // color on the element where this chunk of style data will be
             // used.  We can ensure that the data for the parent are fully
             // computed (unlike for the element where this will be used, for
             // which the color could be specified on a more specific rule).
             border->SetBorderColor(side, parentContext->GetStyleColor()->mColor);
@@ -4254,17 +4254,17 @@ nsRuleNode::ComputeOutlineData(void* aSt
                  "unexpected unit");
   }
 
   // outline-color: color, string, enum, inherit
   nscolor outlineColor;
   nscolor unused = NS_RGB(0,0,0);
   if (eCSSUnit_Inherit == marginData.mOutlineColor.GetUnit()) {
     if (parentContext) {
-      inherited = PR_TRUE;
+      inherited = PR_FALSE;
       if (parentOutline->GetOutlineColor(outlineColor))
         outline->SetOutlineColor(outlineColor);
       else {
 #ifdef GFX_HAS_INVERT
         outline->SetOutlineInitialColor();
 #else
         // We want to inherit the color from the parent, not use the
         // color on the element where this chunk of style data will be
@@ -4303,17 +4303,17 @@ nsRuleNode::ComputeOutlineData(void* aSt
   if (eCSSUnit_Enumerated == marginData.mOutlineStyle.GetUnit())
     outline->SetOutlineStyle(marginData.mOutlineStyle.GetIntValue());
   else if (eCSSUnit_None == marginData.mOutlineStyle.GetUnit() ||
            eCSSUnit_Initial == marginData.mOutlineStyle.GetUnit())
     outline->SetOutlineStyle(NS_STYLE_BORDER_STYLE_NONE);
   else if (eCSSUnit_Auto == marginData.mOutlineStyle.GetUnit()) {
     outline->SetOutlineStyle(NS_STYLE_BORDER_STYLE_AUTO);
   } else if (eCSSUnit_Inherit == marginData.mOutlineStyle.GetUnit()) {
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     outline->SetOutlineStyle(parentOutline->GetOutlineStyle());
   }
 
   outline->RecalcData(mPresContext);
   COMPUTE_END_RESET(Outline, outline)
 }
 
 const void* 
@@ -4336,28 +4336,28 @@ nsRuleNode::ComputeListData(void* aStart
   if (eCSSUnit_Image == listData.mImage.GetUnit()) {
     list->mListStyleImage = listData.mImage.GetImageValue();
   }
   else if (eCSSUnit_None == listData.mImage.GetUnit() ||
            eCSSUnit_Initial == listData.mImage.GetUnit()) {
     list->mListStyleImage = nsnull;
   }
   else if (eCSSUnit_Inherit == listData.mImage.GetUnit()) {
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     list->mListStyleImage = parentList->mListStyleImage;
   }
 
   // list-style-position: enum, inherit, initial
   SetDiscrete(listData.mPosition, list->mListStylePosition, inherited,
               SETDSC_ENUMERATED, parentList->mListStylePosition,
               NS_STYLE_LIST_STYLE_POSITION_OUTSIDE, 0, 0, 0, 0);
 
   // image region property: length, auto, inherit
   if (eCSSUnit_Inherit == listData.mImageRegion.mTop.GetUnit()) { // if one is inherit, they all are
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     list->mImageRegion = parentList->mImageRegion;
   }
   // if one is -moz-initial or auto (rect), they all are
   else if (eCSSUnit_Initial == listData.mImageRegion.mTop.GetUnit() ||
            eCSSUnit_RectIsAuto == listData.mImageRegion.mTop.GetUnit()) {
     list->mImageRegion.Empty();
   }
   else if (eCSSUnit_Null != listData.mImageRegion.mTop.GetUnit()) {
@@ -4434,17 +4434,17 @@ nsRuleNode::ComputePositionData(void* aS
               NS_STYLE_BOX_SIZING_CONTENT, 0, 0, 0, 0);
 
   // z-index
   if (! SetCoord(posData.mZIndex, pos->mZIndex, parentPos->mZIndex,
                  SETCOORD_IA | SETCOORD_INITIAL_AUTO, aContext,
                  nsnull, inherited)) {
     if (eCSSUnit_Inherit == posData.mZIndex.GetUnit()) {
       // handle inherit, because it's ok to inherit 'auto' here
-      inherited = PR_TRUE;
+      inherited = PR_FALSE;
       pos->mZIndex = parentPos->mZIndex;
     }
   }
 
   COMPUTE_END_RESET(Position, pos)
 }
 
 const void* 
@@ -4558,17 +4558,17 @@ nsRuleNode::ComputeContentData(void* aSt
   if (contentValue) {
     if (eCSSUnit_Normal == contentValue->mValue.GetUnit() ||
         eCSSUnit_None == contentValue->mValue.GetUnit() ||
         eCSSUnit_Initial == contentValue->mValue.GetUnit()) {
       // "normal", "none", and "initial" all mean no content
       content->AllocateContents(0);
     }
     else if (eCSSUnit_Inherit == contentValue->mValue.GetUnit()) {
-      inherited = PR_TRUE;
+      inherited = PR_FALSE;
       count = parentContent->ContentCount();
       if (NS_SUCCEEDED(content->AllocateContents(count))) {
         while (0 < count--) {
           content->ContentAt(count) = parentContent->ContentAt(count);
         }
       }
     }
     else {
@@ -4637,17 +4637,17 @@ nsRuleNode::ComputeContentData(void* aSt
   // counter-increment: [string [int]]+, none, inherit
   nsCSSValuePairList* ourIncrement = contentData.mCounterIncrement;
   if (ourIncrement) {
     if (eCSSUnit_None == ourIncrement->mXValue.GetUnit() ||
         eCSSUnit_Initial == ourIncrement->mXValue.GetUnit()) {
       content->AllocateCounterIncrements(0);
     }
     else if (eCSSUnit_Inherit == ourIncrement->mXValue.GetUnit()) {
-      inherited = PR_TRUE;
+      inherited = PR_FALSE;
       count = parentContent->CounterIncrementCount();
       if (NS_SUCCEEDED(content->AllocateCounterIncrements(count))) {
         while (0 < count--) {
           const nsStyleCounterData *data =
             parentContent->GetCounterIncrementAt(count);
           content->SetCounterIncrementAt(count, data->mCounter, data->mValue);
         }
       }
@@ -4680,17 +4680,17 @@ nsRuleNode::ComputeContentData(void* aSt
   // counter-reset: [string [int]]+, none, inherit
   nsCSSValuePairList* ourReset = contentData.mCounterReset;
   if (ourReset) {
     if (eCSSUnit_None == ourReset->mXValue.GetUnit() ||
         eCSSUnit_Initial == ourReset->mXValue.GetUnit()) {
       content->AllocateCounterResets(0);
     }
     else if (eCSSUnit_Inherit == ourReset->mXValue.GetUnit()) {
-      inherited = PR_TRUE;
+      inherited = PR_FALSE;
       count = parentContent->CounterResetCount();
       if (NS_SUCCEEDED(content->AllocateCounterResets(count))) {
         while (0 < count--) {
           const nsStyleCounterData *data =
             parentContent->GetCounterResetAt(count);
           content->SetCounterResetAt(count, data->mCounter, data->mValue);
         }
       }
@@ -4738,17 +4738,17 @@ nsRuleNode::ComputeQuotesData(void* aSta
 {
   COMPUTE_START_INHERITED(Quotes, (), quotes, parentQuotes,
                           Content, contentData)
 
   // quotes: inherit, initial, none, [string string]+
   nsCSSValuePairList* ourQuotes = contentData.mQuotes;
   if (ourQuotes) {
     if (eCSSUnit_Inherit == ourQuotes->mXValue.GetUnit()) {
-      inherited = PR_TRUE;
+      inherited = PR_FALSE;
       quotes->CopyFrom(*parentQuotes);
     }
     else if (eCSSUnit_Initial == ourQuotes->mXValue.GetUnit()) {
       quotes->SetInitial();
     }
     else if (eCSSUnit_None == ourQuotes->mXValue.GetUnit()) {
       quotes->AllocateQuotes(0);
     }
@@ -4814,17 +4814,17 @@ nsRuleNode::ComputeXULData(void* aStartS
               NS_STYLE_BOX_PACK_START, 0, 0, 0, 0);
 
   // box-ordinal-group: integer, inherit, initial
   SetDiscrete(xulData.mBoxOrdinal, xul->mBoxOrdinal, inherited,
               SETDSC_INTEGER, parentXUL->mBoxOrdinal, 1,
               0, 0, 0, 0);
 
   if (eCSSUnit_Inherit == xulData.mStackSizing.GetUnit()) {
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     xul->mStretchStack = parentXUL->mStretchStack;
   } else if (eCSSUnit_Initial == xulData.mStackSizing.GetUnit()) {
     xul->mStretchStack = PR_TRUE;
   } else if (eCSSUnit_Enumerated == xulData.mStackSizing.GetUnit()) {
     xul->mStretchStack = xulData.mStackSizing.GetIntValue() ==
       NS_STYLE_STACK_SIZING_STRETCH_TO_FIT;
   }
 
@@ -4857,17 +4857,17 @@ nsRuleNode::ComputeColumnData(void* aSta
   if (eCSSUnit_Auto == columnData.mColumnCount.GetUnit() ||
       eCSSUnit_Initial == columnData.mColumnCount.GetUnit()) {
     column->mColumnCount = NS_STYLE_COLUMN_COUNT_AUTO;
   } else if (eCSSUnit_Integer == columnData.mColumnCount.GetUnit()) {
     column->mColumnCount = columnData.mColumnCount.GetIntValue();
     // Max 1000 columns - wallpaper for bug 345583.
     column->mColumnCount = PR_MIN(column->mColumnCount, 1000);
   } else if (eCSSUnit_Inherit == columnData.mColumnCount.GetUnit()) {
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     column->mColumnCount = parent->mColumnCount;
   }
 
   // column-rule-width: length, enum, inherit
   const nsCSSValue& widthValue = columnData.mColumnRuleWidth;
   if (eCSSUnit_Initial == widthValue.GetUnit()) {
     column->SetColumnRuleWidth(
         (mPresContext->GetBorderWidthTable())[NS_STYLE_BORDER_WIDTH_MEDIUM]);
@@ -4877,41 +4877,41 @@ nsRuleNode::ComputeColumnData(void* aSta
                  widthValue.GetIntValue() == NS_STYLE_BORDER_WIDTH_MEDIUM ||
                  widthValue.GetIntValue() == NS_STYLE_BORDER_WIDTH_THICK,
                  "Unexpected enum value");
     column->SetColumnRuleWidth(
         (mPresContext->GetBorderWidthTable())[widthValue.GetIntValue()]);
   }
   else if (eCSSUnit_Inherit == widthValue.GetUnit()) {
     column->SetColumnRuleWidth(parent->GetComputedColumnRuleWidth());
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
   }
   else if (widthValue.IsLengthUnit()) {
     column->SetColumnRuleWidth(CalcLength(widthValue, aContext,
                                           mPresContext, inherited));
   }
 
   // column-rule-style: enum, none, inherit
   const nsCSSValue& styleValue = columnData.mColumnRuleStyle;
   if (eCSSUnit_Enumerated == styleValue.GetUnit()) {
     column->mColumnRuleStyle = styleValue.GetIntValue();
   }
   else if (eCSSUnit_None == styleValue.GetUnit() ||
            eCSSUnit_Initial == styleValue.GetUnit()) {
     column->mColumnRuleStyle = NS_STYLE_BORDER_STYLE_NONE;
   }
   else if (eCSSUnit_Inherit == styleValue.GetUnit()) {
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     column->mColumnRuleStyle = parent->mColumnRuleStyle;
   }
 
   // column-rule-color: color, inherit
   const nsCSSValue& colorValue = columnData.mColumnRuleColor;
   if (eCSSUnit_Inherit == colorValue.GetUnit()) {
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     column->mColumnRuleColorIsForeground = PR_FALSE;
     if (parent->mColumnRuleColorIsForeground) {
       column->mColumnRuleColor = parentContext->GetStyleColor()->mColor;
     } else {
       column->mColumnRuleColor = parent->mColumnRuleColor;
     }
   }
   else if (eCSSUnit_Initial == colorValue.GetUnit()) {
@@ -4930,17 +4930,17 @@ SetSVGPaint(const nsCSSValuePair& aValue
             nsPresContext* aPresContext, nsStyleContext *aContext, 
             nsStyleSVGPaint& aResult, nsStyleSVGPaintType aInitialPaintType,
             PRBool& aInherited)
 {
   nscolor color;
 
   if (aValue.mXValue.GetUnit() == eCSSUnit_Inherit) {
     aResult = parentPaint;
-    aInherited = PR_TRUE;
+    aInherited = PR_FALSE;
   } else if (aValue.mXValue.GetUnit() == eCSSUnit_None) {
     aResult.SetType(eStyleSVGPaintType_None);
   } else if (aValue.mXValue.GetUnit() == eCSSUnit_Initial) {
     aResult.SetType(aInitialPaintType);
     aResult.mPaint.mColor = NS_RGB(0, 0, 0);
     aResult.mFallbackColor = NS_RGB(0, 0, 0);
   } else if (aValue.mXValue.GetUnit() == eCSSUnit_URL) {
     aResult.SetType(eStyleSVGPaintType_Server);
@@ -5003,39 +5003,39 @@ nsRuleNode::ComputeSVGData(void* aStartS
 
   // marker-end: url, none, inherit
   if (eCSSUnit_URL == SVGData.mMarkerEnd.GetUnit()) {
     svg->mMarkerEnd = SVGData.mMarkerEnd.GetURLValue();
   } else if (eCSSUnit_None == SVGData.mMarkerEnd.GetUnit() ||
              eCSSUnit_Initial == SVGData.mMarkerEnd.GetUnit()) {
     svg->mMarkerEnd = nsnull;
   } else if (eCSSUnit_Inherit == SVGData.mMarkerEnd.GetUnit()) {
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     svg->mMarkerEnd = parentSVG->mMarkerEnd;
   }
 
   // marker-mid: url, none, inherit
   if (eCSSUnit_URL == SVGData.mMarkerMid.GetUnit()) {
     svg->mMarkerMid = SVGData.mMarkerMid.GetURLValue();
   } else if (eCSSUnit_None == SVGData.mMarkerMid.GetUnit() ||
              eCSSUnit_Initial == SVGData.mMarkerMid.GetUnit()) {
     svg->mMarkerMid = nsnull;
   } else if (eCSSUnit_Inherit == SVGData.mMarkerMid.GetUnit()) {
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     svg->mMarkerMid = parentSVG->mMarkerMid;
   }
 
   // marker-start: url, none, inherit
   if (eCSSUnit_URL == SVGData.mMarkerStart.GetUnit()) {
     svg->mMarkerStart = SVGData.mMarkerStart.GetURLValue();
   } else if (eCSSUnit_None == SVGData.mMarkerStart.GetUnit() ||
              eCSSUnit_Initial == SVGData.mMarkerStart.GetUnit()) {
     svg->mMarkerStart = nsnull;
   } else if (eCSSUnit_Inherit == SVGData.mMarkerStart.GetUnit()) {
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     svg->mMarkerStart = parentSVG->mMarkerStart;
   }
 
   // pointer-events: enum, none, inherit, initial
   SetDiscrete(SVGData.mPointerEvents, svg->mPointerEvents, inherited,
               SETDSC_ENUMERATED | SETDSC_NONE, parentSVG->mPointerEvents,
               NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED, 0,
               NS_STYLE_POINTER_EVENTS_NONE, 0, 0);
@@ -5053,17 +5053,17 @@ nsRuleNode::ComputeSVGData(void* aStartS
 
   // stroke-dasharray: <dasharray>, none, inherit
   nsCSSValueList *list = SVGData.mStrokeDasharray;
   if (list) {
     if (eCSSUnit_Inherit == list->mValue.GetUnit()) {
       // only do the copy if weren't already set up by the copy constructor
       // FIXME Bug 389408: This is broken when aStartStruct is non-null!
       if (!svg->mStrokeDasharray) {
-        inherited = PR_TRUE;
+        inherited = PR_FALSE;
         svg->mStrokeDasharrayLength = parentSVG->mStrokeDasharrayLength;
         if (svg->mStrokeDasharrayLength) {
           svg->mStrokeDasharray = new nsStyleCoord[svg->mStrokeDasharrayLength];
           if (svg->mStrokeDasharray)
             memcpy(svg->mStrokeDasharray,
                    parentSVG->mStrokeDasharray,
                    svg->mStrokeDasharrayLength * sizeof(nsStyleCoord));
           else
@@ -5189,17 +5189,17 @@ nsRuleNode::ComputeSVGResetData(void* aS
 
   // clip-path: url, none, inherit
   if (eCSSUnit_URL == SVGData.mClipPath.GetUnit()) {
     svgReset->mClipPath = SVGData.mClipPath.GetURLValue();
   } else if (eCSSUnit_None == SVGData.mClipPath.GetUnit() ||
              eCSSUnit_Initial == SVGData.mClipPath.GetUnit()) {
     svgReset->mClipPath = nsnull;
   } else if (eCSSUnit_Inherit == SVGData.mClipPath.GetUnit()) {
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     svgReset->mClipPath = parentSVGReset->mClipPath;
   }
 
   // stop-opacity:
   SetFactor(SVGData.mStopOpacity, svgReset->mStopOpacity, inherited,
             parentSVGReset->mStopOpacity, 1.0f, SETFCT_OPACITY);
 
   // flood-opacity:
@@ -5216,28 +5216,28 @@ nsRuleNode::ComputeSVGResetData(void* aS
 
   // filter: url, none, inherit
   if (eCSSUnit_URL == SVGData.mFilter.GetUnit()) {
     svgReset->mFilter = SVGData.mFilter.GetURLValue();
   } else if (eCSSUnit_None == SVGData.mFilter.GetUnit() ||
              eCSSUnit_Initial == SVGData.mFilter.GetUnit()) {
     svgReset->mFilter = nsnull;
   } else if (eCSSUnit_Inherit == SVGData.mFilter.GetUnit()) {
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     svgReset->mFilter = parentSVGReset->mFilter;
   }
 
   // mask: url, none, inherit
   if (eCSSUnit_URL == SVGData.mMask.GetUnit()) {
     svgReset->mMask = SVGData.mMask.GetURLValue();
   } else if (eCSSUnit_None == SVGData.mMask.GetUnit() ||
              eCSSUnit_Initial == SVGData.mMask.GetUnit()) {
     svgReset->mMask = nsnull;
   } else if (eCSSUnit_Inherit == SVGData.mMask.GetUnit()) {
-    inherited = PR_TRUE;
+    inherited = PR_FALSE;
     svgReset->mMask = parentSVGReset->mMask;
   }
   
   COMPUTE_END_RESET(SVGReset, svgReset)
 }
 #endif
 
 inline const void* 
