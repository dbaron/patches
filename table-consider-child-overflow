From: L. David Baron <dbaron@dbaron.org>

Make a few places in the table code use ConsiderChildOverflow.

diff --git a/layout/generic/nsAbsoluteContainingBlock.cpp b/layout/generic/nsAbsoluteContainingBlock.cpp
--- a/layout/generic/nsAbsoluteContainingBlock.cpp
+++ b/layout/generic/nsAbsoluteContainingBlock.cpp
@@ -485,16 +485,17 @@ nsAbsoluteContainingBlock::ReflowAbsolut
       printf("%s ", NS_LossyConvertUTF16toASCII(name).get());
     }
     printf("%p rect=%d,%d,%d,%d\n", static_cast<void*>(aKidFrame),
            rect.x, rect.y, rect.width, rect.height);
   }
 #endif
 
   if (aOverflowAreas) {
+    // FIXME: This should use nsFrame::ConsiderChildOverflow!
     aOverflowAreas->UnionWith(kidDesiredSize.mOverflowAreas + rect.TopLeft());
   }
 
   return rv;
 }
 
 #ifdef DEBUG
  void nsAbsoluteContainingBlock::PrettyUC(nscoord aSize,
diff --git a/layout/generic/nsCanvasFrame.cpp b/layout/generic/nsCanvasFrame.cpp
--- a/layout/generic/nsCanvasFrame.cpp
+++ b/layout/generic/nsCanvasFrame.cpp
@@ -478,16 +478,17 @@ nsCanvasFrame::Reflow(nsPresContext*    
     if (aReflowState.ComputedHeight() == NS_UNCONSTRAINEDSIZE) {
       aDesiredSize.height = kidFrame->GetRect().height +
         kidReflowState.mComputedMargin.TopBottom();
     } else {
       aDesiredSize.height = aReflowState.ComputedHeight();
     }
 
     aDesiredSize.SetOverflowAreasToDesiredBounds();
+    // FIXME: Should use nsFrame::ConsiderChildOverflow
     aDesiredSize.mOverflowAreas.UnionWith(
       kidDesiredSize.mOverflowAreas + kidPt);
 
     // Handle invalidating fixed-attachment backgrounds propagated to the
     // canvas when the canvas size (and therefore the background positioning
     // area's size) changes.  Such backgrounds are not invalidated in the
     // normal manner because the size of the original frame for that background
     // may not have changed.
diff --git a/layout/tables/nsTableFrame.cpp b/layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp
+++ b/layout/tables/nsTableFrame.cpp
@@ -3075,16 +3075,17 @@ void ResizeCells(nsTableFrame& aTableFra
 
     nsTableRowFrame* rowFrame = rgFrame->GetFirstRow();
     while (rowFrame) {
       rowFrame->DidResize();
       rgFrame->ConsiderChildOverflow(groupDesiredSize.mOverflowAreas, rowFrame);
       rowFrame = rowFrame->GetNextRow();
     }
     rgFrame->FinishAndStoreOverflow(&groupDesiredSize);
+    // FIXME: use ConsiderChildOverflow?
     tableDesiredSize.mOverflowAreas.UnionWith(groupDesiredSize.mOverflowAreas +
                                               rgFrame->GetPosition());
   }
   aTableFrame.FinishAndStoreOverflow(&tableDesiredSize);
 }
 
 void
 nsTableFrame::DistributeHeightToRows(const nsHTMLReflowState& aReflowState,
