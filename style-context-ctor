From: L. David Baron <dbaron@dbaron.org>

Remove aPresContext parameter to nsStyleContext constructor and document parameters to constructor.  (Bug 791416)

diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -28,18 +28,17 @@
 using namespace mozilla;
 
 //----------------------------------------------------------------------
 
 
 nsStyleContext::nsStyleContext(nsStyleContext* aParent,
                                nsIAtom* aPseudoTag,
                                nsCSSPseudoElements::Type aPseudoType,
-                               nsRuleNode* aRuleNode,
-                               nsPresContext* aPresContext)
+                               nsRuleNode* aRuleNode)
   : mParent(aParent),
     mChild(nullptr),
     mEmptyChild(nullptr),
     mPseudoTag(aPseudoTag),
     mRuleNode(aRuleNode),
     mAllocations(nullptr),
     mCachedResetData(nullptr),
     mBits(((uint32_t)aPseudoType) << NS_STYLE_CONTEXT_TYPE_SHIFT),
@@ -61,17 +60,17 @@ nsStyleContext::nsStyleContext(nsStyleCo
     while (r1->GetParent())
       r1 = r1->GetParent();
     while (r2->GetParent())
       r2 = r2->GetParent();
     NS_ASSERTION(r1 == r2, "must be in the same rule tree as parent");
 #endif
   }
 
-  ApplyStyleFixups(aPresContext);
+  ApplyStyleFixups();
 
   #define eStyleStruct_LastItem (nsStyleStructID_Length - 1)
   NS_ASSERTION(NS_STYLE_INHERIT_MASK & NS_STYLE_INHERIT_BIT(LastItem),
                "NS_STYLE_INHERIT_MASK must be bigger, and other bits shifted");
   #undef eStyleStruct_LastItem
 
   mRuleNode->AddRef();
 }
@@ -293,17 +292,17 @@ nsStyleContext::SetStyle(nsStyleStructID
     dataSlot = &mCachedInheritedData.mStyleStructs[aSID];
   }
   NS_ASSERTION(!*dataSlot || (mBits & nsCachedStyleData::GetBitForSID(aSID)),
                "Going to leak style data");
   *dataSlot = aStruct;
 }
 
 void
-nsStyleContext::ApplyStyleFixups(nsPresContext* aPresContext)
+nsStyleContext::ApplyStyleFixups()
 {
   // See if we have any text decorations.
   // First see if our parent has text decorations.  If our parent does, then we inherit the bit.
   if (mParent && mParent->HasTextDecorationLines()) {
     mBits |= NS_STYLE_HAS_TEXT_DECORATION_LINES;
   } else {
     // We might have defined a decoration.
     const nsStyleTextReset* text = GetStyleTextReset();
@@ -671,22 +670,21 @@ nsStyleContext::Destroy()
   // instead. Don't call the global operator delete.
   presContext->PresShell()->FreeByObjectID(nsPresArena::nsStyleContext_id, this);
 }
 
 already_AddRefed<nsStyleContext>
 NS_NewStyleContext(nsStyleContext* aParentContext,
                    nsIAtom* aPseudoTag,
                    nsCSSPseudoElements::Type aPseudoType,
-                   nsRuleNode* aRuleNode,
-                   nsPresContext* aPresContext)
+                   nsRuleNode* aRuleNode)
 {
   nsStyleContext* context =
-    new (aPresContext) nsStyleContext(aParentContext, aPseudoTag, aPseudoType,
-                                      aRuleNode, aPresContext);
+    new (aRuleNode->GetPresContext())
+      nsStyleContext(aParentContext, aPseudoTag, aPseudoType, aRuleNode);
   if (context)
     context->AddRef();
   return context;
 }
 
 static inline void
 ExtractAnimationValue(nsCSSProperty aProperty,
                       nsStyleContext* aStyleContext,
diff --git a/layout/style/nsStyleContext.h b/layout/style/nsStyleContext.h
--- a/layout/style/nsStyleContext.h
+++ b/layout/style/nsStyleContext.h
@@ -34,19 +34,36 @@ class nsPresContext;
  *     expectation, but it makes sense in this case)
  * Style contexts participate in the mark phase of rule node garbage
  * collection.
  */
 
 class nsStyleContext
 {
 public:
+  /**
+   * Create a new style context.
+   * @param aParent  The parent of a style context is used for CSS
+   *                 inheritance.  When the element or pseudo-element
+   *                 this style context represents the style data of
+   *                 inherits a CSS property, the value comes from the
+   *                 parent style context.  This means style context
+   *                 parentage must match the definitions of inheritance
+   *                 in the CSS specification.
+   * @param aPseudoTag  The pseudo-element or anonymous box for which
+   *                    this style context represents style.
+   * @param aPseudoType  Must match aPseudoTag.
+   * @param aRuleNode  A rule node representing the ordered sequence of
+   *                   rules that any element, pseudo-element, or
+   *                   anonymous box that this style context is for
+   *                   matches.  See |nsRuleNode| and |nsIStyleRule|.
+   */
   nsStyleContext(nsStyleContext* aParent, nsIAtom* aPseudoTag,
                  nsCSSPseudoElements::Type aPseudoType,
-                 nsRuleNode* aRuleNode, nsPresContext* aPresContext);
+                 nsRuleNode* aRuleNode);
   ~nsStyleContext();
 
   void* operator new(size_t sz, nsPresContext* aPresContext) CPP_THROW_NEW;
   void Destroy();
 
   nsrefcnt AddRef() {
     if (mRefCnt == PR_UINT32_MAX) {
       NS_WARNING("refcount overflow, leaking object");
@@ -318,17 +335,17 @@ public:
 #ifdef DEBUG
   void List(FILE* out, int32_t aIndent);
 #endif
 
 protected:
   void AddChild(nsStyleContext* aChild);
   void RemoveChild(nsStyleContext* aChild);
 
-  void ApplyStyleFixups(nsPresContext* aPresContext);
+  void ApplyStyleFixups();
 
   void FreeAllocations(nsPresContext* aPresContext);
 
   // Helper function that GetStyleData and GetUniqueStyleData use.  Only
   // returns the structs we cache ourselves; never consults the ruletree.
   inline const void* GetCachedStyleData(nsStyleStructID aSID);
 
   // Helper functions for GetStyle* and PeekStyle*
@@ -411,11 +428,10 @@ protected:
                                  // parent context or owned by mRuleNode.
   uint32_t                mRefCnt;
 };
 
 already_AddRefed<nsStyleContext>
 NS_NewStyleContext(nsStyleContext* aParentContext,
                    nsIAtom* aPseudoTag,
                    nsCSSPseudoElements::Type aPseudoType,
-                   nsRuleNode* aRuleNode,
-                   nsPresContext* aPresContext);
+                   nsRuleNode* aRuleNode);
 #endif
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -569,23 +569,23 @@ nsStyleSet::GetContext(nsStyleContext* a
   if (result)
     fprintf(stdout, "--- SharedSC %d ---\n", ++gSharedCount);
   else
     fprintf(stdout, "+++ NewSC %d +++\n", ++gNewCount);
 #endif
 
   if (!result) {
     result = NS_NewStyleContext(aParentContext, aPseudoTag, aPseudoType,
-                                aRuleNode, PresContext());
+                                aRuleNode);
     if (!result)
       return nullptr;
     if (aVisitedRuleNode) {
       nsRefPtr<nsStyleContext> resultIfVisited =
         NS_NewStyleContext(parentIfVisited, aPseudoTag, aPseudoType,
-                           aVisitedRuleNode, PresContext());
+                           aVisitedRuleNode);
       if (!resultIfVisited) {
         return nullptr;
       }
       if (!parentIfVisited) {
         mRoots.AppendElement(resultIfVisited);
       }
       resultIfVisited->SetIsStyleIfVisited();
       result->SetStyleIfVisited(resultIfVisited.forget());
