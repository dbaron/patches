From: L. David Baron <dbaron@dbaron.org>

diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -368,25 +368,23 @@ nsStyleAnimation::AddWeighted(double aCo
     }
     case eUnit_Shadow: {
       // This is implemented according to:
       // http://dev.w3.org/csswg/css3-transitions/#animation-of-property-types-
       // and the third item in the summary of:
       // http://lists.w3.org/Archives/Public/www-style/2009Jul/0050.html
       const nsCSSValueList *shadow1 = aValue1.GetCSSValueListValue();
       const nsCSSValueList *shadow2 = aValue2.GetCSSValueListValue();
-      nsCSSValueList *result = nsnull;
-      nsCSSValueList **resultTail = &result;
+      nsAutoPtr<nsCSSValueList> result;
+      nsCSSValueList **resultTail = getter_Transfers(result);
       while (shadow1 && shadow2) {
         if (!AddShadowItems(aCoeff1, shadow1->mValue,
                             aCoeff2, shadow2->mValue,
                             resultTail)) {
-          delete result;
-          success = PR_FALSE;
-          break;
+          return PR_FALSE;
         }
         shadow1 = shadow1->mNext;
         shadow2 = shadow2->mNext;
       }
       if (shadow1 || shadow2) {
         const nsCSSValueList *longShadow;
         double longCoeff;
         if (shadow1) {
@@ -399,25 +397,25 @@ nsStyleAnimation::AddWeighted(double aCo
 
         while (longShadow) {
           // Passing coefficients that add to less than 1 produces the
           // desired result of interpolating "0 0 0 transparent" with
           // the current shadow.
           if (!AddShadowItems(longCoeff, longShadow->mValue,
                               0.0, longShadow->mValue,
                               resultTail)) {
-            delete result;
-            success = PR_FALSE;
+            return PR_FALSE;
             break;
           }
 
           longShadow = longShadow->mNext;
         }
       }
-      aResultValue.SetCSSValueListValue(result, eUnit_Shadow, PR_TRUE);
+      aResultValue.SetCSSValueListValue(result.forget(), eUnit_Shadow,
+                                        PR_TRUE);
       break;
     }
     case eUnit_Null:
       success = PR_FALSE;
       break;
     default:
       NS_NOTREACHED("Can't interpolate using the given common unit");
       success = PR_FALSE;
@@ -811,18 +809,18 @@ nsStyleAnimation::ExtractComputedValue(n
     case eStyleAnimType_Shadow: {
       const nsCSSShadowArray *shadowArray =
         *static_cast<const nsRefPtr<nsCSSShadowArray>*>(
           StyleDataAtOffset(styleStruct, ssOffset));
       if (!shadowArray) {
         aComputedValue.SetCSSValueListValue(nsnull, eUnit_Shadow, PR_TRUE);
         return PR_TRUE;
       }
-      nsCSSValueList *result = nsnull;
-      nsCSSValueList **resultTail = &result;
+      nsAutoPtr<nsCSSValueList> result;
+      nsCSSValueList **resultTail = getter_Transfers(result);
       for (PRUint32 i = 0, i_end = shadowArray->Length(); i < i_end; ++i) {
         const nsCSSShadowItem *shadow = shadowArray->ShadowAt(i);
         // X, Y, Radius, Spread, Color, Inset
         nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(6);
         arr->Item(0).SetFloatValue(
           nsPresContext::AppUnitsToFloatCSSPixels(shadow->mXOffset),
           eCSSUnit_Pixel);
         arr->Item(1).SetFloatValue(
@@ -841,24 +839,24 @@ nsStyleAnimation::ExtractComputedValue(n
         }
         if (shadow->mInset) {
           arr->Item(5).SetIntValue(NS_STYLE_BOX_SHADOW_INSET,
                                    eCSSUnit_Enumerated);
         }
 
         nsCSSValueList *resultItem = new nsCSSValueList;
         if (!resultItem) {
-          delete result;
           return PR_FALSE;
         }
         resultItem->mValue.SetArrayValue(arr, eCSSUnit_Array);
         *resultTail = resultItem;
         resultTail = &resultItem->mNext;
       }
-      aComputedValue.SetCSSValueListValue(result, eUnit_Shadow, PR_TRUE);
+      aComputedValue.SetCSSValueListValue(result.forget(), eUnit_Shadow,
+                                          PR_TRUE);
       return PR_TRUE;
     }
     case eStyleAnimType_None:
       NS_NOTREACHED("shouldn't use on non-animatable properties");
   }
   return PR_FALSE;
 }
 
