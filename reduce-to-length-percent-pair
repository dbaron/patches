From: L. David Baron <dbaron@dbaron.org>

Add method to nsRuleNode for reducing nsStyleCoord calc expression to a length-percent pair.  (Bug 363249)

diff --git a/layout/style/CSSCalc.h b/layout/style/CSSCalc.h
--- a/layout/style/CSSCalc.h
+++ b/layout/style/CSSCalc.h
@@ -326,16 +326,62 @@ struct NumbersAlreadyNormalizedOps : pub
 {
   float ComputeNumber(const nsCSSValue& aValue)
   {
     NS_ABORT_IF_FALSE(aValue.GetUnit() == eCSSUnit_Number, "unexpected unit");
     return aValue.GetFloatValue();
   }
 };
 
+struct LengthPercentPairOutputOps
+{
+  typedef LengthPercentPair result_type;
+
+  result_type
+  MergeAdditive(nsCSSUnit aCalcFunction,
+                result_type aValue1, result_type aValue2)
+  {
+    if (aCalcFunction == eCSSUnit_Calc_Plus) {
+      return result_type(NSCoordSaturatingAdd(aValue1.mLength,
+                                              aValue2.mLength),
+                         aValue1.mPercent + aValue2.mPercent);
+    }
+    NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Minus,
+                      "min() and max() are not allowed in calc() on "
+                      "transform");
+    return result_type(NSCoordSaturatingSubtract(aValue1.mLength,
+                                                 aValue2.mLength, 0),
+                       aValue1.mPercent - aValue2.mPercent);
+  }
+
+  result_type
+  MergeMultiplicativeL(nsCSSUnit aCalcFunction,
+                       float aValue1, result_type aValue2)
+  {
+    NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Times_L,
+                      "unexpected unit");
+    return result_type(NSCoordSaturatingMultiply(aValue2.mLength, aValue1),
+                       aValue1 * aValue2.mPercent);
+  }
+
+  result_type
+  MergeMultiplicativeR(nsCSSUnit aCalcFunction,
+                       result_type aValue1, float aValue2)
+  {
+    NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Times_R ||
+                      aCalcFunction == eCSSUnit_Calc_Divided,
+                      "unexpected unit");
+    if (aCalcFunction == eCSSUnit_Calc_Divided) {
+      aValue2 = 1.0f / aValue2;
+    }
+    return result_type(NSCoordSaturatingMultiply(aValue1.mLength, aValue2),
+                       aValue1.mPercent * aValue2);
+  }
+};
+
 /**
  * SerializeCalc appends the serialization of aValue to a string.
  *
  * It is templatized over a CalcOps class that is expected to provide:
  *
  *   // input_type and input_array_type have a bunch of very specific
  *   // expectations (which happen to be met by two classes (nsCSSValue
  *   // and nsStyleCoord).  There must be methods (roughly):
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -540,16 +540,36 @@ struct ComputeComputedCalcCalcOps : publ
 /* static */ nscoord
 nsRuleNode::ComputeComputedCalc(const nsStyleCoord& aValue,
                                 nscoord aPercentageBasis)
 {
   ComputeComputedCalcCalcOps ops(aPercentageBasis);
   return css::ComputeCalc(aValue, ops);
 }
 
+struct CoordToLengthPercentPairCalcOps : public css::StyleCoordInputCalcOps,
+                                         public css::LengthPercentPairOutputOps
+{
+  result_type ComputeLeafValue(const nsStyleCoord& aValue)
+  {
+    if (aValue.GetUnit() == eStyleUnit_Percent) {
+      return result_type(0, aValue.GetPercentValue());
+    } else {
+      return result_type(aValue.GetCoordValue(), 0.0f);
+    }
+  }
+};
+
+/* static */ css::LengthPercentPair
+nsRuleNode::ReduceComputedCalc(const nsStyleCoord& aValue)
+{
+  CoordToLengthPercentPairCalcOps ops;
+  return css::ComputeCalc(aValue, ops);
+}
+
 #define SETCOORD_NORMAL                 0x01   // N
 #define SETCOORD_AUTO                   0x02   // A
 #define SETCOORD_INHERIT                0x04   // H
 #define SETCOORD_PERCENT                0x08   // P
 #define SETCOORD_FACTOR                 0x10   // F
 #define SETCOORD_LENGTH                 0x20   // L
 #define SETCOORD_INTEGER                0x40   // I
 #define SETCOORD_ENUMERATED             0x80   // E
diff --git a/layout/style/nsRuleNode.h b/layout/style/nsRuleNode.h
--- a/layout/style/nsRuleNode.h
+++ b/layout/style/nsRuleNode.h
@@ -768,16 +768,20 @@ public:
   // percent, or a calc expression.
   static nscoord ComputeCoordPercentCalc(const nsStyleCoord& aCoord,
                                          nscoord aPercentageBasis)
   {
     // ComputeComputedCalc will handle coords and percents correctly
     return ComputeComputedCalc(aCoord, aPercentageBasis);
   }
 
+  // Reduce a calc() expression, a coord, or a percent to a LengthPercentPair.
+  static mozilla::css::LengthPercentPair
+    ReduceComputedCalc(const nsStyleCoord& aValue);
+
   // Return whether the rule tree for which this node is the root has
   // cached data such that we need to do dynamic change handling for
   // changes that change the results of media queries or require
   // rebuilding all style data.
   PRBool TreeHasCachedData() const {
     NS_ASSERTION(IsRoot(), "should only be called on root of rule tree");
     return HaveChildren() || mStyleData.mInheritedData || mStyleData.mResetData;
   }
diff --git a/layout/style/nsStyleCoord.h b/layout/style/nsStyleCoord.h
--- a/layout/style/nsStyleCoord.h
+++ b/layout/style/nsStyleCoord.h
@@ -148,16 +148,33 @@ public:
   void  SetNoneValue();
   void  SetArrayValue(Array* aValue, nsStyleUnit aUnit);
 
 public: // FIXME: private!
   nsStyleUnit   mUnit;
   nsStyleUnion  mValue;
 };
 
+namespace mozilla {
+namespace css {
+
+  // This is not used by nsStyleCoord, but it's a convenient place for
+  // this type to live.
+
+  struct LengthPercentPair {
+    nscoord mLength;
+    float mPercent;
+
+    LengthPercentPair(nscoord aLength, float aPercent)
+      : mLength(aLength), mPercent(aPercent) {}
+  };
+
+}
+}
+
 // A fixed-size array, that, like everything else in nsStyleCoord,
 // doesn't require that its destructors be called.
 struct nsStyleCoord::Array {
   static Array* Create(nsStyleContext *aAllocationContext,
                        PRBool& aCanStoreInRuleTree,
                        size_t aCount);
 
   size_t Count() const { return mCount; }
diff --git a/layout/style/nsStyleTransformMatrix.cpp b/layout/style/nsStyleTransformMatrix.cpp
--- a/layout/style/nsStyleTransformMatrix.cpp
+++ b/layout/style/nsStyleTransformMatrix.cpp
@@ -259,26 +259,19 @@ static void ProcessMatrix(float aMain[4]
    */
   if (aData->Item(6).GetUnit() == eCSSUnit_Percent)
     aY[1] = aData->Item(6).GetPercentValue();
   else
     aDelta[1] = CalcLength(aData->Item(6), aContext, aPresContext,
                            aCanStoreInRuleTree);
 }
 
-struct LengthPercentPairCalcOps : public css::NumbersAlreadyNormalizedOps
+struct LengthPercentPairCalcOps : public css::NumbersAlreadyNormalizedOps,
+                                  public css::LengthPercentPairOutputOps
 {
-  struct result_type {
-    nscoord mLength;
-    float mPercent;
-
-    result_type(nscoord aLength, float aPercent)
-      : mLength(aLength), mPercent(aPercent) {}
-  };
-
   LengthPercentPairCalcOps(nsStyleContext* aContext,
                            nsPresContext* aPresContext,
                            PRBool& aCanStoreInRuleTree)
     : mContext(aContext),
       mPresContext(aPresContext),
       mCanStoreInRuleTree(aCanStoreInRuleTree) {}
 
   nsStyleContext* mContext;
@@ -290,58 +283,16 @@ struct LengthPercentPairCalcOps : public
     if (aValue.GetUnit() == eCSSUnit_Percent) {
       return result_type(0, aValue.GetPercentValue());
     } else {
       return result_type(CalcLength(aValue, mContext, mPresContext,
                                     mCanStoreInRuleTree),
                          0.0f);
     }
   }
-
-  result_type
-  MergeAdditive(nsCSSUnit aCalcFunction,
-                result_type aValue1, result_type aValue2)
-  {
-    if (aCalcFunction == eCSSUnit_Calc_Plus) {
-      return result_type(NSCoordSaturatingAdd(aValue1.mLength,
-                                              aValue2.mLength),
-                         aValue1.mPercent + aValue2.mPercent);
-    }
-    NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Minus,
-                      "min() and max() are not allowed in calc() on "
-                      "transform");
-    return result_type(NSCoordSaturatingSubtract(aValue1.mLength,
-                                                 aValue2.mLength, 0),
-                       aValue1.mPercent - aValue2.mPercent);
-  }
-
-  result_type
-  MergeMultiplicativeL(nsCSSUnit aCalcFunction,
-                       float aValue1, result_type aValue2)
-  {
-    NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Times_L,
-                      "unexpected unit");
-    return result_type(NSCoordSaturatingMultiply(aValue2.mLength, aValue1),
-                       aValue1 * aValue2.mPercent);
-  }
-
-  result_type
-  MergeMultiplicativeR(nsCSSUnit aCalcFunction,
-                       result_type aValue1, float aValue2)
-  {
-    NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Times_R ||
-                      aCalcFunction == eCSSUnit_Calc_Divided,
-                      "unexpected unit");
-    if (aCalcFunction == eCSSUnit_Calc_Divided) {
-      aValue2 = 1.0f / aValue2;
-    }
-    return result_type(NSCoordSaturatingMultiply(aValue1.mLength, aValue2),
-                       aValue1.mPercent * aValue2);
-  }
-
 };
 
 static void ProcessTranslatePart(nscoord& aOffset, float& aPercent,
                                  const nsCSSValue& aValue,
                                  nsStyleContext* aContext,
                                  nsPresContext* aPresContext,
                                  PRBool& aCanStoreInRuleTree)
 {
