From: L. David Baron <dbaron@dbaron.org>

Propagate whether we have a relevant link from rule processors to style set.  (Bug 147777)

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -2251,16 +2251,20 @@ static void ContentEnumFunc(nsICSSStyleR
       NS_ASSERTION(static_cast<nsIStyleRule*>(aRule) == iRule.get(),
                    "Please fix QI so this performance optimization is valid");
 #endif
       aRule->RuleMatched();
       data->mRuleWalker->Forward(static_cast<nsIStyleRule*>(aRule));
       // nsStyleSet will deal with the !important rule
     }
   }
+
+  if (treeContext.mHaveRelevantLink) {
+    data->mRuleWalker->SetHaveRelevantLink();
+  }
 }
 
 NS_IMETHODIMP
 nsCSSRuleProcessor::RulesMatching(ElementRuleProcessorData *aData)
 {
   NS_PRECONDITION(aData->mContent->IsNodeOfType(nsINode::eELEMENT),
                   "content must be element");
 
diff --git a/layout/style/nsHTMLStyleSheet.cpp b/layout/style/nsHTMLStyleSheet.cpp
--- a/layout/style/nsHTMLStyleSheet.cpp
+++ b/layout/style/nsHTMLStyleSheet.cpp
@@ -236,19 +236,21 @@ nsHTMLStyleSheet::RulesMatching(ElementR
       nsIAtom* tag = aData->mContentTag;
 
       // if we have anchor colors, check if this is an anchor with an href
       if (tag == nsGkAtoms::a) {
         if (mLinkRule || mVisitedRule || mActiveRule) {
           PRUint32 state = aData->ContentState();
           if (mLinkRule && (state & NS_EVENT_STATE_UNVISITED)) {
             ruleWalker->Forward(mLinkRule);
+            ruleWalker->SetHaveRelevantLink();
           }
           else if (mVisitedRule && (state & NS_EVENT_STATE_VISITED)) {
             ruleWalker->Forward(mVisitedRule);
+            ruleWalker->SetHaveRelevantLink();
           }
 
           // No need to add to the active rule if it's not a link
           if (mActiveRule && aData->IsLink() &&
               (state & NS_EVENT_STATE_ACTIVE)) {
             ruleWalker->Forward(mActiveRule);
           }
         } // end link/visited/active rules
