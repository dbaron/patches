Switch away from nsBlockReflowState::mAvailSpaceRect in bullet reflow (for which flow around floats is a complete mess).  (Bug 25888)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -6641,32 +6641,49 @@ nsBlockFrame::ReflowBullet(nsBlockReflow
   // XXXwaterson Should this look just like the logic in
   // nsBlockReflowContext::ReflowBlock and nsLineLayout::ReflowFrame?
   nsHTMLReflowState reflowState(aState.mPresContext, rs,
                                 mBullet, availSize);
   nsReflowStatus  status;
   mBullet->WillReflow(aState.mPresContext);
   mBullet->Reflow(aState.mPresContext, aMetrics, reflowState, status);
 
+  // Calculate what used to be mOutsideBulletX
+  nsRect floatAvailSpaceAtTop;
+  aState.GetFloatAvailableSpace(aState.BorderPadding().top, PR_FALSE,
+                                floatAvailSpaceAtTop);
+  // Maybe calculate what used to be in mAvailSpaceRect, but it's really
+  // quite unclear and perhaps different for different callers.
+  // FIXME:  This code needs to be rewritten!
+  nsRect floatAvailSpace;
+  aState.GetFloatAvailableSpace(floatAvailSpace);
+
+  // FIXME (bug 25888): need to check the entire region that the first
+  // line overlaps, not just the top pixel.
+  // FIXME: We should probably use aLineTop in this calculation (and
+  // make aLineTop correct).
+
   // Place the bullet now, separate it from mOutsideBulletX by its margin.
   // If the mAvailSpaceRect position is outside the mOutsideBulletX
   // position it means the line didn't care about the float edge and we
   // use that position instead (there cannot be any floats at the start
   // of the line this case since that would violate CSS 2.1 float rules).
   // XXX we need to take floats inside the principal block that clears
   // outside floats into account also (bug 428810).
-  nscoord x = rs.mStyleVisibility->mDirection == NS_STYLE_DIRECTION_LTR ?
-    PR_MIN(aState.mOutsideBulletX, aState.mAvailSpaceRect.x)
-      - reflowState.mComputedMargin.right - aMetrics.width :
-    PR_MAX(aState.mOutsideBulletX, aState.mAvailSpaceRect.XMost())
-      + reflowState.mComputedMargin.left;
-
-  // FIXME: come up with rules for when mAvailSpaceRect is valid so we
-  // don't need to do this.
-  aState.GetAvailableSpace();
+  nscoord x;
+  if (rs.mStyleVisibility->mDirection == NS_STYLE_DIRECTION_LTR) {
+    x = PR_MIN(floatAvailSpaceAtTop.x, floatAvailSpace.x)
+      - reflowState.mComputedMargin.right - aMetrics.width;
+  } else {
+    nscoord offsetAtTop = 
+      PR_MIN(rs.ComputedWidth(), floatAvailSpaceAtTop.XMost()) +
+        rs.mComputedBorderPadding.LeftRight();
+    x = PR_MAX(offsetAtTop, floatAvailSpace.XMost())
+          + reflowState.mComputedMargin.left;
+  }
 
   // Approximate the bullets position; vertical alignment will provide
   // the final vertical location.
   const nsMargin& bp = aState.BorderPadding();
   nscoord y = bp.top;
   mBullet->SetRect(nsRect(x, y, aMetrics.width, aMetrics.height));
   mBullet->DidReflow(aState.mPresContext, &aState.mReflowState, NS_FRAME_REFLOW_FINISHED);
 }
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -134,26 +134,16 @@ nsBlockReflowState::nsBlockReflowState(c
   }
 
   mY = borderPadding.top;
 
   mPrevChild = nsnull;
   mCurrentLine = aFrame->end_lines();
 
   mMinLineHeight = nsHTMLReflowState::CalcLineHeight(aReflowState.frame);
-
-  // Calculate mOutsideBulletX
-  GetAvailableSpace();
-  // FIXME (bug 25888): need to check the entire region that the first
-  // line overlaps, not just the top pixel.
-  mOutsideBulletX =
-    mReflowState.mStyleVisibility->mDirection == NS_STYLE_DIRECTION_LTR ?
-      mAvailSpaceRect.x :
-      PR_MIN(mReflowState.ComputedWidth(), mAvailSpaceRect.XMost()) +
-        mReflowState.mComputedBorderPadding.LeftRight();
 }
 
 void
 nsBlockReflowState::SetupOverflowPlaceholdersProperty()
 {
   if (mReflowState.availableHeight != NS_UNCONSTRAINEDSIZE ||
       !mOverflowPlaceholders.IsEmpty()) {
     mBlock->SetProperty(nsGkAtoms::overflowPlaceholdersProperty,
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -211,23 +211,16 @@ public:
   // padding. This, therefore, represents the inner "content area" (in
   // spacemanager coordinates) where child frames will be placed,
   // including child blocks and floats.
   nscoord mFloatManagerX, mFloatManagerY;
 
   // XXX get rid of this
   nsReflowStatus mReflowStatus;
 
-  // The x-position we should place an outside bullet relative to.
-  // This is the border-box edge of the principal box.  However, if a line box
-  // would be displaced by floats, we want to displace it by the same amount.
-  // That is, we act as though the edge of the floats is the content-edge of
-  // the block, displaced by the block's padding and border.
-  nscoord mOutsideBulletX;
-
   nscoord mBottomEdge;
 
   // The content area to reflow child frames within. The x/y
   // coordinates are known to be mBorderPadding.left and
   // mBorderPadding.top. The width/height may be NS_UNCONSTRAINEDSIZE
   // if the container reflowing this frame has given the frame an
   // unconstrained area.
   nsSize mContentArea;
