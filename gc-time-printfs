From: L. David Baron <dbaron@dbaron.org>

Printfs of elapsed time for cycle collection and JS GC.

diff --git a/js/src/jsgc.cpp b/js/src/jsgc.cpp
--- a/js/src/jsgc.cpp
+++ b/js/src/jsgc.cpp
@@ -3426,16 +3426,20 @@ GCUntilDone(JSContext *cx, JSGCInvocatio
     bool scanGCThreadStack = (rt->state != JSRTS_LANDING);
 #ifdef JS_THREADSAFE
     scanGCThreadStack &= !!cx->thread->requestContext;
 #endif
     if (scanGCThreadStack)
         JS_THREAD_DATA(cx)->conservativeGC.enable(true);
     bool firstRun = true;
     do {
+#ifdef DEBUG_dbaron
+        fprintf(stderr, "  Doing JS GC iteration.\n");
+#endif
+
         rt->gcPoke = false;
 
         AutoUnlockGC unlock(rt);
         if (firstRun) {
             PreGCCleanup(cx, gckind);
             TIMESTAMP(startMark);
             firstRun = false;
         }
@@ -3470,16 +3474,20 @@ js_GC(JSContext *cx, JSGCInvocationKind 
      * context in the runtime.  The last context must force a GC, and nothing
      * should suppress that final collection or there may be shutdown leaks,
      * or runtime bloat until the next context is created.
      */
     if (rt->state != JSRTS_UP && gckind != GC_LAST_CONTEXT)
         return;
 
     GCTIMER_BEGIN();
+#ifdef DEBUG_dbaron
+    fprintf(stderr, "Doing JS GC number %u...\n", unsigned(rt->gcNumber));
+    int64 start = JS_Now();
+#endif
 
     do {
         /*
          * Let the API user decide to defer a GC if it wants to (unless this
          * is the last context).  Invoke the callback regardless. Sample the
          * callback in case we are freely racing with a JS_SetGCCallback{,RT}
          * on another thread.
          */
@@ -3504,16 +3512,20 @@ js_GC(JSContext *cx, JSGCInvocationKind 
         }
 
         /*
          * On shutdown, iterate until the JSGC_END callback stops creating
          * garbage.
          */
     } while (gckind == GC_LAST_CONTEXT && rt->gcPoke);
 
+#ifdef DEBUG_dbaron
+    int64 diff = (JS_Now() - start) / 1000;
+    fprintf(stderr, "... JS_GC took %ld milliseconds.\n", (long)diff);
+#endif
     GCTIMER_END(gckind == GC_LAST_CONTEXT);
 }
 
 namespace js {
 
 bool
 SetProtoCheckingForCycles(JSContext *cx, JSObject *obj, JSObject *proto)
 {
diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -141,16 +141,17 @@
 #include "mozilla/FunctionTimer.h"
 #include "nsIObserverService.h"
 #include "nsIConsoleService.h"
 #include "nsServiceManagerUtils.h"
 #include "nsThreadUtils.h"
 #include "nsTPtrArray.h"
 #include "nsTArray.h"
 #include "mozilla/Services.h"
+#include "prinrval.h"
 
 #include <stdio.h>
 #include <string.h>
 #ifdef WIN32
 #include <io.h>
 #include <process.h>
 #endif
 
@@ -3160,17 +3161,27 @@ NS_CycleCollectorForget2(nsPurpleBufferE
 {
     return sCollector ? sCollector->Forget2(e) : PR_TRUE;
 }
 
 
 PRUint32
 nsCycleCollector_collect()
 {
-    return sCollector ? sCollector->Collect() : 0;
+#ifdef DEBUG_dbaron
+    fprintf(stderr, "Starting nsCycleCollector_collect\n");
+    PRIntervalTime start = PR_IntervalNow();
+#endif
+    PRUint32 result = sCollector ? sCollector->Collect() : 0;
+#ifdef DEBUG_dbaron
+    PRIntervalTime end = PR_IntervalNow();
+    fprintf(stderr, "...nsCycleCollector_collect took %d milliseconds.\n",
+                    PR_IntervalToMilliseconds(end - start));
+#endif
+    return result;
 }
 
 PRUint32
 nsCycleCollector_suspectedCount()
 {
     return sCollector ? sCollector->SuspectedCount() : 0;
 }
 
