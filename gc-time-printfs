From: L. David Baron <dbaron@dbaron.org>

Printfs of elapsed time for cycle collection and JS GC.

diff --git a/js/src/jsgc.cpp b/js/src/jsgc.cpp
--- a/js/src/jsgc.cpp
+++ b/js/src/jsgc.cpp
@@ -3118,16 +3118,21 @@ GC(JSContext *cx  GCTIMER_PARAM)
  */
 static void
 GCUntilDone(JSContext *cx, JSGCInvocationKind gckind  GCTIMER_PARAM)
 {
     JS_ASSERT_NOT_ON_TRACE(cx);
     JSRuntime *rt = cx->runtime;
     bool firstRun = true;
 
+#ifdef DEBUG_dbaron
+    fprintf(stderr, "Doing JS GC...\n");
+    int64 start = JS_Now();
+#endif
+
     do {
         rt->gcLevel = 1;
         rt->gcPoke = JS_FALSE;
 
         AutoUnlockGC unlock(rt);
         if (firstRun) {
             PreGCCleanup(cx, gckind);
             TIMESTAMP(startMark);
@@ -3135,16 +3140,21 @@ GCUntilDone(JSContext *cx, JSGCInvocatio
         }
         GC(cx  GCTIMER_ARG);
 
         // GC again if:
         //   - another thread, not in a request, called js_GC
         //   - js_GC was called recursively
         //   - a finalizer called js_RemoveRoot or js_UnlockGCThingRT.
     } while (rt->gcLevel > 1 || rt->gcPoke);
+
+#ifdef DEBUG_dbaron
+    int64 diff = (JS_Now() - start) / 1000;
+    fprintf(stderr, "... JS_GC took %ld milliseconds.\n", (long)diff);
+#endif
 }
 
 #ifdef JS_THREADSAFE
 
 /*
  * Either this thread is doing GC and has reentered js_GC; or another thread is
  * the GC thread. If the former, schedule another GC cycle after the current one.
  * If the latter, wait for the other thread to finish with GC.
@@ -3429,16 +3439,20 @@ js_GC(JSContext *cx, JSGCInvocationKind 
 {
     JSRuntime *rt = cx->runtime;
 
 #ifdef JS_THREADSAFE
     JS_ASSERT(CURRENT_THREAD_IS_ME(cx->thread));
     JS_ASSERT(!JS_IS_RUNTIME_LOCKED(rt));
 #endif
 
+#ifdef DEBUG_dbaron
+    fprintf(stderr, "  Doing JS GC iteration.\n");
+#endif
+
     /*
      * Don't collect garbage if the runtime isn't up, and cx is not the last
      * context in the runtime.  The last context must force a GC, and nothing
      * should suppress that final collection or there may be shutdown leaks,
      * or runtime bloat until the next context is created.
      */
     if (rt->state != JSRTS_UP && gckind != GC_LAST_CONTEXT)
         return;
diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -141,16 +141,17 @@
 #include "mozilla/FunctionTimer.h"
 #include "nsIObserverService.h"
 #include "nsIConsoleService.h"
 #include "nsServiceManagerUtils.h"
 #include "nsThreadUtils.h"
 #include "nsTPtrArray.h"
 #include "nsTArray.h"
 #include "mozilla/Services.h"
+#include "prinrval.h"
 
 #include <stdio.h>
 #include <string.h>
 #ifdef WIN32
 #include <io.h>
 #include <process.h>
 #endif
 
@@ -3212,17 +3213,27 @@ NS_CycleCollectorForget2(nsPurpleBufferE
 {
     return sCollector ? sCollector->Forget2(e) : PR_TRUE;
 }
 
 
 PRUint32
 nsCycleCollector_collect()
 {
-    return sCollector ? sCollector->Collect() : 0;
+#ifdef DEBUG_dbaron
+    fprintf(stderr, "Starting nsCycleCollector_collect\n");
+    PRIntervalTime start = PR_IntervalNow();
+#endif
+    PRUint32 result = sCollector ? sCollector->Collect() : 0;
+#ifdef DEBUG_dbaron
+    PRIntervalTime end = PR_IntervalNow();
+    fprintf(stderr, "...nsCycleCollector_collect took %d milliseconds.\n",
+                    PR_IntervalToMilliseconds(end - start));
+#endif
+    return result;
 }
 
 PRUint32
 nsCycleCollector_suspectedCount()
 {
     return sCollector ? sCollector->SuspectedCount() : 0;
 }
 
