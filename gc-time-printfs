From: L. David Baron <dbaron@dbaron.org>

Printfs of elapsed time for cycle collection and JS GC.

diff --git a/js/src/jsgc.cpp b/js/src/jsgc.cpp
--- a/js/src/jsgc.cpp
+++ b/js/src/jsgc.cpp
@@ -2947,17 +2947,26 @@ js_GC(JSContext *cx, JSCompartment *comp
         JS_ASSERT(gckind != GC_LAST_CONTEXT);
         return;
     }
 
     RecordNativeStackTopForGC(cx);
 
     gcstats::AutoGC agc(rt->gcStats, comp, reason);
 
+#ifdef DEBUG_dbaron
+    fprintf(stderr, "Doing JS GC number %u...\n", unsigned(rt->gcNumber));
+    int64 start = JS_Now();
+#endif
+
     do {
+#ifdef DEBUG_dbaron
+        fprintf(stderr, "  Doing JS GC iteration.\n");
+#endif
+
         /*
          * Let the API user decide to defer a GC if it wants to (unless this
          * is the last context).  Invoke the callback regardless. Sample the
          * callback in case we are freely racing with a JS_SetGCCallback{,RT}
          * on another thread.
          */
         if (JSGCCallback callback = rt->gcCallback) {
             if (!callback(cx, JSGC_BEGIN) && gckind != GC_LAST_CONTEXT)
@@ -2979,16 +2988,21 @@ js_GC(JSContext *cx, JSCompartment *comp
          * On shutdown, iterate until finalizers or the JSGC_END callback
          * stop creating garbage.
          */
     } while (gckind == GC_LAST_CONTEXT && rt->gcPoke);
 
     rt->gcNextFullGCTime = PRMJ_Now() + GC_IDLE_FULL_SPAN;
 
     rt->gcChunkAllocationSinceLastGC = false;
+
+#ifdef DEBUG_dbaron
+    int64 diff = (JS_Now() - start) / 1000;
+    fprintf(stderr, "... JS_GC took %ld milliseconds.\n", (long)diff);
+#endif
 }
 
 namespace js {
 
 class AutoCopyFreeListToArenas {
     JSRuntime *rt;
 
   public:
