Printfs of elapsed time for cycle collection and JS GC.

diff --git a/js/src/jsgc.c b/js/src/jsgc.c
--- a/js/src/jsgc.c
+++ b/js/src/jsgc.c
@@ -2459,6 +2459,7 @@ js_GC(JSContext *cx, JSGCInvocationKind 
     JSGCArenaStats *listStats;
     size_t nfree;
 #endif
+    int64 start, diff;
 
     rt = cx->runtime;
 #ifdef JS_THREADSAFE
@@ -2639,6 +2640,7 @@ js_GC(JSContext *cx, JSGCInvocationKind 
         rt->requestCount += requestDebit;
 #endif
         gckind = GC_LOCK_HELD;
+        printf("Restarting JS GC\n");
         goto restart_at_beginning;
     }
 
@@ -2692,6 +2694,9 @@ js_GC(JSContext *cx, JSGCInvocationKind 
     rt->gcNumber++;
     JS_ASSERT(!rt->gcUntracedArenaStackTop);
     JS_ASSERT(rt->gcTraceLaterCount == 0);
+
+    printf("Doing JS GC...\n");
+    start = JS_Now();
 
     /* Reset the property cache's type id generator so we can compress ids. */
     rt->shapeGen = 0;
@@ -2922,6 +2927,9 @@ js_GC(JSContext *cx, JSGCInvocationKind 
   }
 #endif /* JS_SCOPE_DEPTH_METER */
 
+    diff = (JS_Now() - start) / 1000;
+    printf("... JS_GC took %ld milliseconds.\n", (long)diff);
+
     JS_LOCK_GC(rt);
 
     /*
@@ -2932,6 +2940,7 @@ js_GC(JSContext *cx, JSGCInvocationKind 
         rt->gcLevel = 1;
         rt->gcPoke = JS_FALSE;
         JS_UNLOCK_GC(rt);
+        printf("Restarting JS GC.\n");
         goto restart;
     }
 
@@ -2998,6 +3007,7 @@ js_GC(JSContext *cx, JSGCInvocationKind 
              * On shutdown iterate until JSGC_END callback stops creating
              * garbage.
              */
+            printf("Restarting JS GC for GC_LAST_CONTEXT.\n");
             goto restart_at_beginning;
         }
     }
diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -143,6 +143,7 @@
 #include "nsServiceManagerUtils.h"
 #include "nsThreadUtils.h"
 #include "nsTPtrArray.h"
+#include "prinrval.h"
 
 #include <stdio.h>
 #ifdef WIN32
@@ -2780,7 +2781,13 @@ PRBool
 PRBool
 nsCycleCollector_collect()
 {
-    return sCollector ? sCollector->Collect() : PR_FALSE;
+    printf("Starting nsCycleCollector_collect\n");
+    PRIntervalTime start = PR_IntervalNow();
+    PRBool result = sCollector ? sCollector->Collect() : PR_FALSE;
+    PRIntervalTime end = PR_IntervalNow();
+    printf("...nsCycleCollector_collect took %d milliseconds.\n",
+           PR_IntervalToMilliseconds(end - start));
+    return result;
 }
 
 PRBool 
