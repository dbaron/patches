From: L. David Baron <dbaron@dbaron.org>

Printfs of elapsed time for cycle collection and JS GC.

diff --git a/js/src/jsgc.cpp b/js/src/jsgc.cpp
--- a/js/src/jsgc.cpp
+++ b/js/src/jsgc.cpp
@@ -3306,16 +3306,19 @@ js_GC(JSContext *cx, JSGCInvocationKind 
     JSGCArenaList *arenaList;
     JSBool allClear;
 #ifdef JS_THREADSAFE
     uint32 requestDebit;
 #endif
 #ifdef JS_GCMETER
     uint32 nlivearenas, nkilledarenas, nthings;
 #endif
+#ifdef DEBUG_dbaron
+    int64 start, diff;
+#endif
 
     JS_ASSERT_IF(gckind == GC_LAST_DITCH, !JS_ON_TRACE(cx));
     rt = cx->runtime;
 
 #ifdef JS_THREADSAFE
     /*
      * We allow js_GC calls outside a request but the context must be bound
      * to the current thread.
@@ -3474,16 +3477,19 @@ js_GC(JSContext *cx, JSGCInvocationKind 
 
         rt->gcLevel = 0;
         rt->gcPoke = JS_FALSE;
         rt->gcRunning = JS_FALSE;
 #ifdef JS_THREADSAFE
         rt->gcThread = NULL;
 #endif
         gckind = GC_LOCK_HELD;
+#ifdef DEBUG_dbaron
+        fprintf(stderr, "Restarting JS GC\n");
+#endif
         goto restart_at_beginning;
     }
 
     JS_UNLOCK_GC(rt);
 
 #ifdef JS_TRACER
     if (JS_ON_TRACE(cx))
         goto out;
@@ -3507,16 +3513,21 @@ js_GC(JSContext *cx, JSGCInvocationKind 
 #endif
     js_PurgeThreads(cx);
 
   restart:
     rt->gcNumber++;
     JS_ASSERT(!rt->gcUntracedArenaStackTop);
     JS_ASSERT(rt->gcTraceLaterCount == 0);
 
+#ifdef DEBUG_dbaron
+    fprintf(stderr, "Doing JS GC...\n");
+    start = JS_Now();
+#endif
+
     /* Reset the property cache's type id generator so we can compress ids. */
     rt->shapeGen = 0;
 
     /*
      * Mark phase.
      */
     JS_TRACER_INIT(&trc, cx, NULL);
     rt->gcMarkingTracer = &trc;
@@ -3755,16 +3766,21 @@ js_GC(JSContext *cx, JSGCInvocationKind 
         JS_DumpBasicStats(&rt->lexicalScopeDepthStats, "lexical scope depth", fp);
 
         putc('\n', fp);
         fflush(fp);
     }
   }
 #endif /* JS_SCOPE_DEPTH_METER */
 
+#ifdef DEBUG_dbaron
+    diff = (JS_Now() - start) / 1000;
+    fprintf(stderr, "... JS_GC took %ld milliseconds.\n", (long)diff);
+#endif
+    
 #ifdef JS_DUMP_LOOP_STATS
   { static FILE *lsfp;
     if (!lsfp)
         lsfp = fopen("/tmp/loopstats", "w");
     if (lsfp) {
         JS_DumpBasicStats(&rt->loopStats, "loops", lsfp);
         fflush(lsfp);
     }
@@ -3780,16 +3796,19 @@ out:
      * We want to restart GC if js_GC was called recursively or if any of the
      * finalizers called js_RemoveRoot or js_UnlockGCThingRT.
      */
     if (!JS_ON_TRACE(cx) && (rt->gcLevel > 1 || rt->gcPoke)) {
         VOUCH_HAVE_STACK();
         rt->gcLevel = 1;
         rt->gcPoke = JS_FALSE;
         JS_UNLOCK_GC(rt);
+#ifdef DEBUG_dbaron
+        fprintf(stderr, "Restarting JS GC.\n");
+#endif
         goto restart;
     }
 
     rt->gcLastBytes = rt->gcBytes;
   done_running:
     rt->gcLevel = 0;
     rt->gcRunning = JS_FALSE;
 
@@ -3831,16 +3850,19 @@ out:
             JS_LOCK_GC(rt);
             JS_UNKEEP_ATOMS(rt);
             JS_POP_TEMP_ROOT(cx, &tvr);
         } else if (gckind == GC_LAST_CONTEXT && rt->gcPoke) {
             /*
              * On shutdown iterate until JSGC_END callback stops creating
              * garbage.
              */
+#ifdef DEBUG_dbaron
+            fprintf(stderr, "Restarting JS GC for GC_LAST_CONTEXT.\n");
+#endif
             goto restart_at_beginning;
         }
     }
 }
 
 void
 js_UpdateMallocCounter(JSContext *cx, size_t nbytes)
 {
diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -139,16 +139,17 @@
 #include "nsPrintfCString.h"
 #include "nsTArray.h"
 #include "nsIObserverService.h"
 #include "nsIConsoleService.h"
 #include "nsServiceManagerUtils.h"
 #include "nsThreadUtils.h"
 #include "nsTPtrArray.h"
 #include "nsTArray.h"
+#include "prinrval.h"
 
 #include <stdio.h>
 #include <string.h>
 #ifdef WIN32
 #include <io.h>
 #include <process.h>
 #endif
 
@@ -2939,17 +2940,27 @@ NS_CycleCollectorForget(nsISupports *n)
 {
     return sCollector ? sCollector->Forget(n) : PR_TRUE;
 }
 
 
 PRUint32
 nsCycleCollector_collect()
 {
-    return sCollector ? sCollector->Collect() : 0;
+#ifdef DEBUG_dbaron
+    fprintf(stderr, "Starting nsCycleCollector_collect\n");
+    PRIntervalTime start = PR_IntervalNow();
+#endif
+    PRUint32 result = sCollector ? sCollector->Collect() : 0;
+#ifdef DEBUG_dbaron
+    PRIntervalTime end = PR_IntervalNow();
+    fprintf(stderr, "...nsCycleCollector_collect took %d milliseconds.\n",
+                    PR_IntervalToMilliseconds(end - start));
+#endif
+    return result;
 }
 
 PRUint32
 nsCycleCollector_suspectedCount()
 {
     return sCollector ? sCollector->SuspectedCount() : 0;
 }
 
