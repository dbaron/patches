From: Mike Hommey <mh+mozilla@glandium.org>

Bug 628283 - Make elfhack handle GNU_RELRO segments better

diff --git a/build/unix/elfhack/elf.cpp b/build/unix/elfhack/elf.cpp
--- a/build/unix/elfhack/elf.cpp
+++ b/build/unix/elfhack/elf.cpp
@@ -346,16 +346,24 @@ ElfSection *Elf::getSectionAt(unsigned i
         ElfSection *section = getSection(i);
         if ((section != NULL) && (section->getFlags() & SHF_ALLOC) && !(section->getFlags() & SHF_TLS) &&
             (offset >= section->getAddr()) && (offset < section->getAddr() + section->getSize()))
             return section;
     }
     return NULL;
 }
 
+ElfSegment *Elf::getSegmentByType(unsigned int type)
+{
+    for (std::vector<ElfSegment *>::iterator seg = segments.begin(); seg != segments.end(); seg++)
+        if ((*seg)->getType() == type)
+            return *seg;
+    return NULL;
+}
+
 ElfDynamic_Section *Elf::getDynSection()
 {
     for (std::vector<ElfSegment *>::iterator seg = segments.begin(); seg != segments.end(); seg++)
         if (((*seg)->getType() == PT_DYNAMIC) && ((*seg)->getFirstSection() != NULL) &&
             (*seg)->getFirstSection()->getType() == SHT_DYNAMIC)
             return (ElfDynamic_Section *)(*seg)->getFirstSection();
 
     return NULL;
@@ -558,25 +566,38 @@ unsigned int ElfSegment::getFileSize()
     if (sections.empty())
         return 0;
     // Search the last section that is not SHT_NOBITS
     std::list<ElfSection *>::reverse_iterator i;
     for (i = sections.rbegin(); (i != sections.rend()) && ((*i)->getType() == SHT_NOBITS); ++i);
     // All sections are SHT_NOBITS
     if (i == sections.rend())
         return 0;
-    return ((*i)->getAddr() - sections.front()->getAddr()) + (*i)->getSize();
+
+    unsigned int end = (*i)->getAddr() + (*i)->getSize();
+
+    // GNU_RELRO segment end is page aligned.
+    if (type == PT_GNU_RELRO)
+        end = (end + 4095) & ~4095;
+
+    return end - sections.front()->getAddr();
 }
 
 unsigned int ElfSegment::getMemSize()
 {
     if (sections.empty())
         return 0;
-    return (sections.back()->getAddr() - sections.front()->getAddr()) +
-           (sections.back()->getSize());
+
+    unsigned int end = sections.back()->getAddr() + sections.back()->getSize();
+
+    // GNU_RELRO segment end is page aligned.
+    if (type == PT_GNU_RELRO)
+        end = (end + 4095) & ~4095;
+
+    return end - sections.front()->getAddr();
 }
 
 ElfSegment *ElfSegment::splitBefore(ElfSection *section)
 {
     std::list<ElfSection *>::iterator i, rm;
     for (i = sections.begin(); (*i != section) && (i != sections.end()); ++i);
     if (i == sections.end())
         return NULL;
diff --git a/build/unix/elfhack/elfhack.cpp b/build/unix/elfhack/elfhack.cpp
--- a/build/unix/elfhack/elfhack.cpp
+++ b/build/unix/elfhack/elfhack.cpp
@@ -297,16 +297,18 @@ template <typename Rel_Type>
 int do_relocation_section(Elf *elf, unsigned int rel_type)
 {
     ElfDynamic_Section *dyn = elf->getDynSection();
     if (dyn ==NULL) {
         fprintf(stderr, "Couldn't find SHT_DYNAMIC section\n");
         return -1;
     }
 
+    ElfSegment *relro = elf->getSegmentByType(PT_GNU_RELRO);
+
     ElfRel_Section<Rel_Type> *section = (ElfRel_Section<Rel_Type> *)dyn->getSectionForType(Rel_Type::d_tag);
     assert(section->getType() == Rel_Type::sh_type);
 
     Elf32_Shdr relhack32_section =
         { 0, SHT_PROGBITS, SHF_ALLOC, 0, -1, 0, SHN_UNDEF, 0,
           Elf_RelHack::size(elf->getClass()), Elf_RelHack::size(elf->getClass()) }; // TODO: sh_addralign should be an alignment, not size
     Elf32_Shdr relhackcode32_section =
         { 0, SHT_PROGBITS, SHF_ALLOC | SHF_EXECINSTR, 0, -1, 0, SHN_UNDEF, 0, 1, 0 };
@@ -321,17 +323,19 @@ int do_relocation_section(Elf *elf, unsi
     Elf_RelHack relhack_entry;
     relhack_entry.r_offset = relhack_entry.r_info = 0;
     int entry_sz = (elf->getClass() == ELFCLASS32) ? 4 : 8;
     for (typename std::vector<Rel_Type>::iterator i = section->rels.begin();
          i != section->rels.end(); i++) {
         // Don't pack relocations happening in non writable sections.
         // Our injected code is likely not to be allowed to write there.
         ElfSection *section = elf->getSectionAt(i->r_offset);
-        if (!(section->getFlags() & SHF_WRITE) || (ELF32_R_TYPE(i->r_info) != rel_type))
+        if (!(section->getFlags() & SHF_WRITE) || (ELF32_R_TYPE(i->r_info) != rel_type) ||
+            (relro && (i->r_offset >= relro->getFirstSection()->getAddr()) &&
+                      (i->r_offset < relro->getFirstSection()->getAddr() + relro->getMemSize())))
             new_rels.push_back(*i);
         else {
             // TODO: check that i->r_addend == *i->r_offset
             if (i->r_offset == relhack_entry.r_offset + relhack_entry.r_info * entry_sz) {
                 relhack_entry.r_info++;
             } else {
                 if (relhack_entry.r_offset)
                     relhack->push_back(relhack_entry);
diff --git a/build/unix/elfhack/elfxx.h b/build/unix/elfhack/elfxx.h
--- a/build/unix/elfhack/elfxx.h
+++ b/build/unix/elfhack/elfxx.h
@@ -260,16 +260,18 @@ public:
     Elf(std::ifstream &file);
     ~Elf();
 
     /* index == -1 is treated as index == ehdr.e_shstrndx */
     ElfSection *getSection(int index);
 
     ElfSection *getSectionAt(unsigned int offset);
 
+    ElfSegment *getSegmentByType(unsigned int type);
+
     ElfDynamic_Section *getDynSection();
 
     void write(std::ofstream &file);
 
     char getClass();
     char getData();
     char getType();
     char getMachine();
