Rebuild the user font set when style sheets are enabled/disabled/added/removed, rules are modified/added/removed, or media changes change which style sheets apply, and fix cascading bugs with @font-face rules, by accumulating the @font-face rules across rule processors through the style set.  (Bug 457821)

diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -225,16 +225,17 @@ nsPresContext::nsPresContext(nsIDocument
     mImageAnimationMode = imgIContainer::kDontAnimMode;
     mNeverAnimate = PR_TRUE;
   } else {
     mImageAnimationMode = imgIContainer::kNormalAnimMode;
     mNeverAnimate = PR_FALSE;
   }
   NS_ASSERTION(mDocument, "Null document");
   mUserFontSet = nsnull;
+  mUserFontSetDirty = PR_TRUE;
 }
 
 nsPresContext::~nsPresContext()
 {
   mImageLoaders.Enumerate(destroy_loads, nsnull);
   mBorderImageLoaders.Enumerate(destroy_loads, nsnull);
 
   NS_PRECONDITION(!mShell, "Presshell forgot to clear our mShell pointer");
@@ -1602,18 +1603,167 @@ nsPresContext::IsChrome() const
 
 /* virtual */ PRBool
 nsPresContext::HasAuthorSpecifiedRules(nsIFrame *aFrame, PRUint32 ruleTypeMask) const
 {
   return nsRuleNode::
     HasAuthorSpecifiedRules(aFrame->GetStyleContext(), ruleTypeMask);
 }
 
+static void
+InsertFontFaceRule(nsCSSFontFaceRule *aRule, gfxUserFontSet* aFontSet)
+{
+  PRInt32 type;
+  NS_ABORT_IF_FALSE(NS_SUCCEEDED(aRule->GetType(type)) 
+                    && type == nsICSSRule::FONT_FACE_RULE, 
+                    "InsertFontFaceRule passed a non-fontface CSS rule");
+  
+  // aRule->List();
+  
+  nsAutoString fontfamily, valueString;
+  nsCSSValue val;
+  
+  PRUint32 unit;
+  PRUint32 weight = NS_STYLE_FONT_WEIGHT_NORMAL;
+  PRUint32 stretch = NS_STYLE_FONT_STRETCH_NORMAL;
+  PRUint32 italicStyle = FONT_STYLE_NORMAL;
+  
+  // set up family name
+  aRule->GetDesc(eCSSFontDesc_Family, val);
+  unit = val.GetUnit();
+  if (unit == eCSSUnit_String) {
+    val.GetStringValue(fontfamily);
+    fontfamily.Trim("\"");
+  } else {
+    NS_ASSERTION(unit == eCSSUnit_String, 
+                 "@font-face family name has non-string unit type");
+    return;
+  }
+  
+  // set up weight
+  aRule->GetDesc(eCSSFontDesc_Weight, val);
+  unit = val.GetUnit();
+  if (unit != eCSSUnit_Null) {
+    if (unit == eCSSUnit_Normal) {
+      weight = NS_STYLE_FONT_WEIGHT_NORMAL;
+    } else {
+      weight = val.GetIntValue();
+    }
+  }
+  
+  // set up stretch
+  aRule->GetDesc(eCSSFontDesc_Stretch, val);
+  unit = val.GetUnit();
+  if (unit != eCSSUnit_Null) {
+    if (unit == eCSSUnit_Normal) {
+      stretch = NS_STYLE_FONT_STRETCH_NORMAL;
+    } else {
+      stretch = val.GetIntValue();
+    }
+  }
+  
+  // set up font style
+  aRule->GetDesc(eCSSFontDesc_Style, val);
+  if (val.GetUnit() != eCSSUnit_Null) {
+    if (val.GetUnit() == eCSSUnit_Normal) {
+      italicStyle = FONT_STYLE_NORMAL;
+    } else {
+      italicStyle = val.GetIntValue();
+    }
+  }
+  
+  // set up src array
+  nsTArray<gfxFontFaceSrc> srcArray;
+
+  aRule->GetDesc(eCSSFontDesc_Src, val);
+  unit = val.GetUnit();
+  if (unit == eCSSUnit_Array) {
+    nsCSSValue::Array *srcArr = val.GetArrayValue();
+    PRUint32 i, numSrc = srcArr->Count(), faceIndex = 0;
+    
+    for (i = 0; i < numSrc; i++) {
+      val = srcArr->Item(i);
+      unit = val.GetUnit();
+      gfxFontFaceSrc *face = srcArray.AppendElements(1);
+      if (!face)
+        return;
+            
+      switch (unit) {
+       
+      case eCSSUnit_Local_Font:
+        val.GetStringValue(face->mLocalName);
+        face->mIsLocal = PR_TRUE;
+        face->mURI = nsnull;
+        face->mFormatFlags = 0;
+        break;
+      case eCSSUnit_URL:
+        face->mIsLocal = PR_FALSE;
+        face->mURI = val.GetURLValue();
+        face->mLocalName.Truncate();
+        face->mFormatFlags = 0;
+        while (i + 1 < numSrc && (val = srcArr->Item(i+1), 
+                 val.GetUnit() == eCSSUnit_Font_Format)) {
+          nsDependentString valueString(val.GetStringBufferValue());
+          if (valueString.LowerCaseEqualsASCII("opentype")) {
+            face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_OPENTYPE; 
+          } else if (valueString.LowerCaseEqualsASCII("truetype")) {
+            face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_TRUETYPE; 
+          } else if (valueString.LowerCaseEqualsASCII("truetype-aat")) {
+            face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_TRUETYPE_AAT; 
+          } else if (valueString.LowerCaseEqualsASCII("embedded-opentype")) {
+            face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_EOT;   
+          } else if (valueString.LowerCaseEqualsASCII("svg")) {
+            face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_SVG;   
+          }
+          i++;
+        }
+        break;
+      default:
+        NS_ASSERTION(unit == eCSSUnit_Local_Font || unit == eCSSUnit_URL,
+                     "strange unit type in font-face src array");
+        break;
+      }
+     }
+  }
+  
+  if (!fontfamily.IsEmpty() && srcArray.Length() > 0) {
+    aFontSet->AddFontFace(fontfamily, srcArray, weight, stretch, italicStyle);
+  }
+}
+
 gfxUserFontSet* 
-nsPresContext::GetUserFontSet() {
+nsPresContext::GetUserFontSet()
+{
+  if (mUserFontSetDirty) {
+    NS_IF_RELEASE(mUserFontSet);
+
+    if (gfxPlatform::GetPlatform()->DownloadableFontsEnabled()) {
+      nsFontFaceLoaderContext *loaderCtx =
+        new nsFontFaceLoaderContext(presContext);
+      if (!loaderCtx)
+        return nsnull;
+      gfxUserFontSet *fs = new gfxUserFontSet(loaderCtx);
+      // user font set owns loader context
+      if (!fs) {
+        delete loaderCtx;
+        return nsnull;
+      }
+      mUserFontSet = fs;
+      NS_ADDREF(mUserFontSet);
+
+      nsTArray< nsRefPtr<nsCSSFontFaceRule> > rules;
+      if (!mShell->StyleSet()->AppendFontFaceRules(this, rules))
+        return nsnull;
+      for (PRUint32 i = 0, i_end = rules.Length(); i < i_end; ++i) {
+        InsertFontFaceRule(rules[i], fs);
+      }
+    }
+
+    mUserFontSetDirty = PR_FALSE;
+  }
   return mUserFontSet;
 }
 
 void 
 nsPresContext::SetUserFontSet(gfxUserFontSet *aUserFontSet)
 {
   NS_IF_RELEASE(mUserFontSet);
   mUserFontSet = aUserFontSet;
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -881,16 +881,17 @@ protected:
   unsigned              mIsRootPaginatedDocument : 1;
   unsigned              mPrefBidiDirection : 1;
   unsigned              mPrefScrollbarSide : 2;
   unsigned              mPendingSysColorChanged : 1;
   unsigned              mPendingThemeChanged : 1;
   unsigned              mPendingMediaFeatureValuesChanged : 1;
   unsigned              mPrefChangePendingNeedsReflow : 1;
   unsigned              mRenderedPositionVaryingContent : 1;
+  unsigned              mUserFontSetDirty : 1;
 
   // resize reflow is supressed when the only change has been to zoom
   // the document rather than to change the document's dimensions
   unsigned              mSupressResizeReflow : 1;
 
 #ifdef IBMBIDI
   unsigned              mIsVisual : 1;
 
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -78,19 +78,17 @@
 #include "nsAttrName.h"
 #include "nsILookAndFeel.h"
 #include "nsWidgetsCID.h"
 #include "nsServiceManagerUtils.h"
 #include "nsTArray.h"
 #include "nsContentUtils.h"
 #include "nsIMediaList.h"
 #include "gfxPlatform.h"
-#include "gfxUserFontSet.h"
 #include "nsCSSRules.h"
-#include "nsFontFaceLoader.h"
 
 #define VISITED_PSEUDO_PREF "layout.css.visited_links_enabled"
 
 static PRBool gSupportVisitedPseudo = PR_TRUE;
 
 static NS_DEFINE_CID(kLookAndFeelCID, NS_LOOKANDFEEL_CID);
 static nsTArray< nsCOMPtr<nsIAtom> >* sSystemMetrics = 0;
 
@@ -703,16 +701,18 @@ struct RuleCascadeData {
   {
     PL_DHashTableFinish(&mAttributeSelectors);
   }
   RuleHash          mRuleHash;
   nsVoidArray       mStateSelectors;
   nsVoidArray       mClassSelectors;
   nsVoidArray       mIDSelectors;
   PLDHashTable      mAttributeSelectors; // nsIAtom* -> nsVoidArray*
+
+  nsTArray< nsRefPtr<nsCSSFontFaceRule> > mFontFaceRules;
 
   // Looks up or creates the appropriate list in |mAttributeSelectors|.
   // Returns null only on allocation failure.
   nsVoidArray* AttributeListFor(nsIAtom* aAttribute);
 
   nsMediaQueryResultCacheKey mCacheKey;
   RuleCascadeData*  mNext; // for a different medium
 };
@@ -2142,16 +2142,33 @@ nsCSSRuleProcessor::MediumFeaturesChange
   // anything changed.  See bug 448281.
   if (old) {
     RefreshRuleCascade(aPresContext);
   }
   *aRulesChanged = (old != mRuleCascades);
   return NS_OK;
 }
 
+// Append all the currently-active font face rules to aArray.  Return
+// true for success and false for failure.
+PRBool
+nsCSSRuleProcessor::AppendFontFaceRules(
+                              nsPresContext *aPresContext,
+                              nsTArray< nsRefPtr<nsCSSFontFaceRule> >& aArray)
+{
+  RuleCascadeData* cascade = GetRuleCascade(aPresContext);
+
+  if (cascade) {
+    if (!aArray.AppendElements(cascade->mRuleHash.mFontFaceRules))
+      return PR_FALSE;
+  }
+  
+  return PR_TRUE;
+}
+
 nsresult
 nsCSSRuleProcessor::ClearRuleCascades()
 {
   RuleCascadeData *data = mRuleCascades;
   mRuleCascades = nsnull;
   while (data) {
     RuleCascadeData *next = data->mNext;
     delete data;
@@ -2283,19 +2300,21 @@ static PLDHashTableOps gRulesByWeightOps
     PL_DHashMoveEntryStub,
     PL_DHashClearEntryStub,
     PL_DHashFinalizeStub,
     NULL
 };
 
 struct CascadeEnumData {
   CascadeEnumData(nsPresContext* aPresContext,
+                  nsTArray< nsRefPtr<nsCSSFontFaceRule> >& aFontFaceRules,
                   nsMediaQueryResultCacheKey& aKey,
                   PLArenaPool& aArena)
     : mPresContext(aPresContext),
+      mFontFaceRules(aFontFaceRules),
       mCacheKey(aKey),
       mArena(aArena)
   {
     if (!PL_DHashTableInit(&mRulesByWeight, &gRulesByWeightOps, nsnull,
                           sizeof(RuleByWeightEntry), 64))
       mRulesByWeight.ops = nsnull;
   }
 
@@ -2308,141 +2327,25 @@ struct CascadeEnumData {
   nsPresContext* mPresContext;
   nsMediaQueryResultCacheKey& mCacheKey;
   // Hooray, a manual PLDHashTable since nsClassHashtable doesn't
   // provide a getter that gives me a *reference* to the value.
   PLDHashTable mRulesByWeight; // of RuleValue* linked lists (?)
   PLArenaPool& mArena;
 };
 
-static void
-InsertFontFaceRule(nsICSSRule* aRule, gfxUserFontSet* fs)
-{
-  nsCSSFontFaceRule *fontFace = static_cast<nsCSSFontFaceRule*> (aRule);
-  PRInt32 type;
-  NS_ASSERTION(NS_SUCCEEDED(aRule->GetType(type)) 
-               && type == nsICSSRule::FONT_FACE_RULE, 
-               "InsertFontFaceRule passed a non-fontface CSS rule");
-  
-  // fontFace->List();
-  
-  nsAutoString fontfamily, valueString;
-  nsCSSValue val;
-  
-  PRUint32 unit;
-  PRUint32 weight = NS_STYLE_FONT_WEIGHT_NORMAL;
-  PRUint32 stretch = NS_STYLE_FONT_STRETCH_NORMAL;
-  PRUint32 italicStyle = FONT_STYLE_NORMAL;
-  
-  // set up family name
-  fontFace->GetDesc(eCSSFontDesc_Family, val);
-  unit = val.GetUnit();
-  if (unit == eCSSUnit_String) {
-    val.GetStringValue(fontfamily);
-    fontfamily.Trim("\"");
-  } else {
-    NS_ASSERTION(unit == eCSSUnit_String, 
-                 "@font-face family name has non-string unit type");
-    return;
-  }
-  
-  // set up weight
-  fontFace->GetDesc(eCSSFontDesc_Weight, val);
-  unit = val.GetUnit();
-  if (unit != eCSSUnit_Null) {
-    if (unit == eCSSUnit_Normal) {
-      weight = NS_STYLE_FONT_WEIGHT_NORMAL;
-    } else {
-      weight = val.GetIntValue();
-    }
-  }
-  
-  // set up stretch
-  fontFace->GetDesc(eCSSFontDesc_Stretch, val);
-  unit = val.GetUnit();
-  if (unit != eCSSUnit_Null) {
-    if (unit == eCSSUnit_Normal) {
-      stretch = NS_STYLE_FONT_STRETCH_NORMAL;
-    } else {
-      stretch = val.GetIntValue();
-    }
-  }
-  
-  // set up font style
-  fontFace->GetDesc(eCSSFontDesc_Style, val);
-  if (val.GetUnit() != eCSSUnit_Null) {
-    if (val.GetUnit() == eCSSUnit_Normal) {
-      italicStyle = FONT_STYLE_NORMAL;
-    } else {
-      italicStyle = val.GetIntValue();
-    }
-  }
-  
-  // set up src array
-  nsTArray<gfxFontFaceSrc> srcArray;
-
-  fontFace->GetDesc(eCSSFontDesc_Src, val);
-  unit = val.GetUnit();
-  if (unit == eCSSUnit_Array) {
-    nsCSSValue::Array *srcArr = val.GetArrayValue();
-    PRUint32 i, numSrc = srcArr->Count(), faceIndex = 0;
-    
-    for (i = 0; i < numSrc; i++) {
-      val = srcArr->Item(i);
-      unit = val.GetUnit();
-      gfxFontFaceSrc *face = srcArray.AppendElements(1);
-      if (!face)
-        return;
-            
-      switch (unit) {
-       
-      case eCSSUnit_Local_Font:
-        val.GetStringValue(face->mLocalName);
-        face->mIsLocal = PR_TRUE;
-        face->mURI = nsnull;
-        face->mFormatFlags = 0;
-        break;
-      case eCSSUnit_URL:
-        face->mIsLocal = PR_FALSE;
-        face->mURI = val.GetURLValue();
-        face->mLocalName.Truncate();
-        face->mFormatFlags = 0;
-        while (i + 1 < numSrc && (val = srcArr->Item(i+1), 
-                 val.GetUnit() == eCSSUnit_Font_Format)) {
-          nsDependentString valueString(val.GetStringBufferValue());
-          if (valueString.LowerCaseEqualsASCII("opentype")) {
-            face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_OPENTYPE; 
-          } else if (valueString.LowerCaseEqualsASCII("truetype")) {
-            face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_TRUETYPE; 
-          } else if (valueString.LowerCaseEqualsASCII("truetype-aat")) {
-            face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_TRUETYPE_AAT; 
-          } else if (valueString.LowerCaseEqualsASCII("embedded-opentype")) {
-            face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_EOT;   
-          } else if (valueString.LowerCaseEqualsASCII("svg")) {
-            face->mFormatFlags |= gfxUserFontSet::FLAG_FORMAT_SVG;   
-          }
-          i++;
-        }
-        break;
-      default:
-        NS_ASSERTION(unit == eCSSUnit_Local_Font || unit == eCSSUnit_URL,
-                     "strange unit type in font-face src array");
-        break;
-      }
-     }
-  }
-  
-  if (!fontfamily.IsEmpty() && srcArray.Length() > 0) {
-    fs->AddFontFace(fontfamily, srcArray, weight, stretch, italicStyle);
-  }
-  
-}
-
+/*
+ * This enumerates style rules in a sheet (and recursively into any
+ * grouping rules) in order to:
+ *  (1) Add any style rules, in order, into data->mRulesByWeight (for
+ *      the primary CSS cascade)
+ *  (2) Add any @font-face rules, in order, into XXX WRITE ME
+ */
 static PRBool
-InsertRuleByWeight(nsICSSRule* aRule, void* aData)
+CascadeRuleEnumFunc(nsICSSRule* aRule, void* aData)
 {
   CascadeEnumData* data = (CascadeEnumData*)aData;
   PRInt32 type = nsICSSRule::UNKNOWN_RULE;
   aRule->GetType(type);
 
   if (nsICSSRule::STYLE_RULE == type) {
     nsICSSStyleRule* styleRule = (nsICSSStyleRule*)aRule;
 
@@ -2461,59 +2364,49 @@ InsertRuleByWeight(nsICSSRule* aRule, vo
       info->mNext = entry->data.mRules;
       entry->data.mRules = info;
     }
   }
   else if (nsICSSRule::MEDIA_RULE == type ||
            nsICSSRule::DOCUMENT_RULE == type) {
     nsICSSGroupRule* groupRule = (nsICSSGroupRule*)aRule;
     if (groupRule->UseForPresentation(data->mPresContext, data->mCacheKey))
-      if (!groupRule->EnumerateRulesForwards(InsertRuleByWeight, aData))
+      if (!groupRule->EnumerateRulesForwards(CascadeRuleEnumFunc, aData))
         return PR_FALSE;
   }
-  else if (nsICSSRule::FONT_FACE_RULE == type 
-             && gfxPlatform::GetPlatform()->DownloadableFontsEnabled()) {
-    nsPresContext *presContext = data->mPresContext;
-    gfxUserFontSet *fs = presContext->GetUserFontSet();
-    if (!fs) {
-      nsFontFaceLoaderContext *loaderCtx = new nsFontFaceLoaderContext(presContext);
-      if (!loaderCtx)
-        return PR_FALSE;
-      fs = new gfxUserFontSet(loaderCtx); // user font set owns loader context
-      if (!fs) {
-        delete loaderCtx;
-        return PR_FALSE;
-      }
-      presContext->SetUserFontSet(fs);
-    }
-    
-    InsertFontFaceRule(aRule, fs);
+  else if (nsICSSRule::FONT_FACE_RULE == type) {
+    nsCSSFontFaceRule *fontFaceRule = static_cast<nsCSSFontFaceRule*>(aRule);
+    nsRefPtr<nsCSSFontFaceRule> *ptr = data->mFontFaceRules.AppendElement();
+    if (!ptr)
+      return PR_FALSE;
+    *ptr = fontFaceRule;
   }
 
   return PR_TRUE;
 }
 
 /* static */ PRBool
-nsCSSRuleProcessor::CascadeSheetRulesInto(nsICSSStyleSheet* aSheet, void* aData)
+nsCSSRuleProcessor::CascadeSheetEnumFunc(nsICSSStyleSheet* aSheet, void* aData)
 {
   nsCSSStyleSheet*  sheet = static_cast<nsCSSStyleSheet*>(aSheet);
   CascadeEnumData* data = static_cast<CascadeEnumData*>(aData);
   PRBool bSheetApplicable = PR_TRUE;
   sheet->GetApplicable(bSheetApplicable);
 
   if (bSheetApplicable &&
       sheet->UseForPresentation(data->mPresContext, data->mCacheKey) &&
       sheet->mInner) {
     nsCSSStyleSheet* child = sheet->mInner->mFirstChild;
     while (child) {
-      CascadeSheetRulesInto(child, data);
+      CascadeSheetEnumFunc(child, data);
       child = child->mNext;
     }
 
-    if (!sheet->mInner->mOrderedRules.EnumerateForwards(InsertRuleByWeight, data))
+    if (!sheet->mInner->mOrderedRules.EnumerateForwards(CascadeRuleEnumFunc,
+                                                        data))
       return PR_FALSE;
   }
   return PR_TRUE;
 }
 
 static int CompareWeightData(const void* aArg1, const void* aArg2,
                              void* closure)
 {
@@ -2585,21 +2478,22 @@ nsCSSRuleProcessor::RefreshRuleCascade(n
     }
   }
 
   if (mSheets.Count() != 0) {
     nsAutoPtr<RuleCascadeData> newCascade(
       new RuleCascadeData(aPresContext->Medium(),
                           eCompatibility_NavQuirks == aPresContext->CompatibilityMode()));
     if (newCascade) {
-      CascadeEnumData data(aPresContext, newCascade->mCacheKey,
+      CascadeEnumData data(aPresContext, newCascade->mFontFaceRules,
+                           newCascade->mCacheKey,
                            newCascade->mRuleHash.Arena());
       if (!data.mRulesByWeight.ops)
         return; /* out of memory */
-      if (!mSheets.EnumerateForwards(CascadeSheetRulesInto, &data))
+      if (!mSheets.EnumerateForwards(CascadeSheetEnumFunc, &data))
         return; /* out of memory */
 
       // Sort the hash table of per-weight linked lists by weight.
       PRUint32 weightCount = data.mRulesByWeight.entryCount;
       nsAutoArrayPtr<PerWeightData> weightArray(new PerWeightData[weightCount]);
       FillWeightArrayData fwData(weightArray);
       PL_DHashTableEnumerate(&data.mRulesByWeight, FillWeightArray, &fwData);
       NS_QuickSort(weightArray, weightCount, sizeof(PerWeightData),
diff --git a/layout/style/nsCSSRuleProcessor.h b/layout/style/nsCSSRuleProcessor.h
--- a/layout/style/nsCSSRuleProcessor.h
+++ b/layout/style/nsCSSRuleProcessor.h
@@ -92,25 +92,30 @@ public:
                                     nsReStyleHint* aResult);
 
   NS_IMETHOD HasAttributeDependentStyle(AttributeRuleProcessorData* aData,
                                         nsReStyleHint* aResult);
 
   NS_IMETHOD MediumFeaturesChanged(nsPresContext* aPresContext,
                                    PRBool* aRulesChanged);
 
+  // Append all the currently-active font face rules to aArray.  Return
+  // true for success and false for failure.
+  PRBool AppendFontFaceRules(nsPresContext* aPresContext,
+                             nsTArray< nsRefPtr<nsCSSFontFaceRule> >& aArray);
+
 #ifdef DEBUG
   void AssertQuirksChangeOK() {
     NS_ASSERTION(!mRuleCascades, 
                  "can't quirks style sheet without clearing rule cascades");
   }
 #endif
 
 private:
-  static PRBool CascadeSheetRulesInto(nsICSSStyleSheet* aSheet, void* aData);
+  static PRBool CascadeSheetEnumFunc(nsICSSStyleSheet* aSheet, void* aData);
 
   RuleCascadeData* GetRuleCascade(nsPresContext* aPresContext);
   void RefreshRuleCascade(nsPresContext* aPresContext);
 
   // The sheet order here is the same as in nsStyleSet::mSheets
   nsCOMArray<nsICSSStyleSheet> mSheets;
 
   // active first, then cached (most recent first)
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -52,16 +52,23 @@
 #include "nsStyleContext.h"
 #include "nsICSSStyleRule.h"
 #include "nsCSSAnonBoxes.h"
 #include "nsCSSPseudoElements.h"
 #include "nsCSSRuleProcessor.h"
 #include "nsIContent.h"
 #include "nsIFrame.h"
 #include "nsContentUtils.h"
+
+static const nsStyleSet::sheetType gCSSSheetTypes[] = {
+  nsStyleSet::eAgentSheet,
+  nsStyleSet::eUserSheet,
+  nsStyleSet::eDocSheet,
+  nsStyleSet::eOverrideSheet
+};
 
 nsIURI *nsStyleSet::gQuirkURI = 0;
 
 nsStyleSet::nsStyleSet()
   : mRuleTree(nsnull),
     mRuleWalker(nsnull),
     mDestroyedCount(0),
     mBatching(0),
@@ -804,16 +811,31 @@ nsStyleSet::ProbePseudoStyleFor(nsIConte
       result->Release();
       result = nsnull;
     }
   }
   
   return result;
 }
 
+PRBool
+nsStyleSet::AppendFontFaceRules(nsPresContext* aPresContext,
+                                nsTArray< nsRefPtr<nsCSSFontFaceRule> >& aArray)
+{
+  NS_ENSURE_FALSE(mInShutdown, PR_FALSE);
+
+  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gCSSSheetTypes); ++i) {
+    nsCSSRuleProcessor *ruleProc =
+      static_cast<nsCSSRuleProcessor*>(mRuleProcessors[gCSSSheetTypes[i]]);
+    if (!ruleProc->AppendFontFaceRules(aPresContext, aArray))
+      return PR_FALSE;
+  }
+  return PR_TRUE;
+}
+
 void
 nsStyleSet::BeginShutdown(nsPresContext* aPresContext)
 {
   mInShutdown = 1;
   mRoots.Clear(); // no longer valid, since we won't keep it up to date
 }
 
 void
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -48,18 +48,20 @@
 #define nsStyleSet_h_
 
 #include "nsIStyleRuleProcessor.h"
 #include "nsICSSStyleSheet.h"
 #include "nsBindingManager.h"
 #include "nsRuleNode.h"
 #include "nsTArray.h"
 #include "nsCOMArray.h"
+#include "nsAutoPtr.h"
 
 class nsIURI;
+class nsCSSFontFaceRule;
 
 // The style set object is created by the document viewer and ownership is
 // then handed off to the PresShell.  Only the PresShell should delete a
 // style set.
 
 class nsStyleSet
 {
  public:
@@ -107,16 +109,21 @@ class nsStyleSet
 
   // This functions just like ResolvePseudoStyleFor except that it will
   // return nsnull if there are no explicit style rules for that
   // pseudo element.  It should be used only for pseudo-elements.
   already_AddRefed<nsStyleContext>
   ProbePseudoStyleFor(nsIContent* aParentContent,
                       nsIAtom* aPseudoTag,
                       nsStyleContext* aParentContext);
+
+  // Append all the currently-active font face rules to aArray.  Return
+  // true for success and false for failure.
+  PRBool AppendFontFaceRules(nsPresContext* aPresContext,
+                             nsTArray< nsRefPtr<nsCSSFontFaceRule> >& aArray);
 
   // Begin ignoring style context destruction, to avoid lots of unnecessary
   // work on document teardown.
   void BeginShutdown(nsPresContext* aPresContext);
 
   // Free all of the data associated with this style set.
   void Shutdown(nsPresContext* aPresContext);
 
