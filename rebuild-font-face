Rebuild the user font set when style sheets are enabled/disabled/added/removed, rules are modified/added/removed, or media changes change which style sheets apply, and fix cascading bugs with @font-face rules, by accumulating the @font-face rules across rule processors through the style set.  (Bug 457821)

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -703,16 +703,18 @@ struct RuleCascadeData {
   {
     PL_DHashTableFinish(&mAttributeSelectors);
   }
   RuleHash          mRuleHash;
   nsVoidArray       mStateSelectors;
   nsVoidArray       mClassSelectors;
   nsVoidArray       mIDSelectors;
   PLDHashTable      mAttributeSelectors; // nsIAtom* -> nsVoidArray*
+
+  nsTArray< nsRefPtr<nsCSSFontFaceRule> > mFontFaceRules;
 
   // Looks up or creates the appropriate list in |mAttributeSelectors|.
   // Returns null only on allocation failure.
   nsVoidArray* AttributeListFor(nsIAtom* aAttribute);
 
   nsMediaQueryResultCacheKey mCacheKey;
   RuleCascadeData*  mNext; // for a different medium
 };
@@ -2142,16 +2144,33 @@ nsCSSRuleProcessor::MediumFeaturesChange
   // anything changed.  See bug 448281.
   if (old) {
     RefreshRuleCascade(aPresContext);
   }
   *aRulesChanged = (old != mRuleCascades);
   return NS_OK;
 }
 
+// Append all the currently-active font face rules to aArray.  Return
+// true for success and false for failure.
+PRBool
+nsCSSRuleProcessor::AppendFontFaceRules(
+                              nsPresContext *aPresContext,
+                              nsTArray< nsRefPtr<nsCSSFontFaceRule> >& aArray)
+{
+  RuleCascadeData* cascade = GetRuleCascade(aPresContext);
+
+  if (cascade) {
+    if (!aArray.AppendElements(cascade->mRuleHash.mFontFaceRules))
+      return PR_FALSE;
+  }
+  
+  return PR_TRUE;
+}
+
 nsresult
 nsCSSRuleProcessor::ClearRuleCascades()
 {
   RuleCascadeData *data = mRuleCascades;
   mRuleCascades = nsnull;
   while (data) {
     RuleCascadeData *next = data->mNext;
     delete data;
@@ -2283,19 +2302,21 @@ static PLDHashTableOps gRulesByWeightOps
     PL_DHashMoveEntryStub,
     PL_DHashClearEntryStub,
     PL_DHashFinalizeStub,
     NULL
 };
 
 struct CascadeEnumData {
   CascadeEnumData(nsPresContext* aPresContext,
+                  nsTArray< nsRefPtr<nsCSSFontFaceRule> >& aFontFaceRules,
                   nsMediaQueryResultCacheKey& aKey,
                   PLArenaPool& aArena)
     : mPresContext(aPresContext),
+      mFontFaceRules(aFontFaceRules),
       mCacheKey(aKey),
       mArena(aArena)
   {
     if (!PL_DHashTableInit(&mRulesByWeight, &gRulesByWeightOps, nsnull,
                           sizeof(RuleByWeightEntry), 64))
       mRulesByWeight.ops = nsnull;
   }
 
@@ -2307,16 +2328,35 @@ struct CascadeEnumData {
 
   nsPresContext* mPresContext;
   nsMediaQueryResultCacheKey& mCacheKey;
   // Hooray, a manual PLDHashTable since nsClassHashtable doesn't
   // provide a getter that gives me a *reference* to the value.
   PLDHashTable mRulesByWeight; // of RuleValue* linked lists (?)
   PLArenaPool& mArena;
 };
+
+// XXX Make member on nsCSSFontFaceRule?
+  if (gfxPlatform::GetPlatform()->DownloadableFontsEnabled()) {
+    nsPresContext *presContext = data->mPresContext;
+    gfxUserFontSet *fs = presContext->GetUserFontSet();
+    if (!fs) {
+      nsFontFaceLoaderContext *loaderCtx = new nsFontFaceLoaderContext(presContext);
+      if (!loaderCtx)
+        return PR_FALSE;
+      fs = new gfxUserFontSet(loaderCtx); // user font set owns loader context
+      if (!fs) {
+        delete loaderCtx;
+        return PR_FALSE;
+      }
+      presContext->SetUserFontSet(fs);
+    }
+    
+    InsertFontFaceRule(aRule, fs);
+  }
 
 static void
 InsertFontFaceRule(nsICSSRule* aRule, gfxUserFontSet* fs)
 {
   nsCSSFontFaceRule *fontFace = static_cast<nsCSSFontFaceRule*> (aRule);
   PRInt32 type;
   NS_ASSERTION(NS_SUCCEEDED(aRule->GetType(type)) 
                && type == nsICSSRule::FONT_FACE_RULE, 
@@ -2431,18 +2471,25 @@ InsertFontFaceRule(nsICSSRule* aRule, gf
   }
   
   if (!fontfamily.IsEmpty() && srcArray.Length() > 0) {
     fs->AddFontFace(fontfamily, srcArray, weight, stretch, italicStyle);
   }
   
 }
 
+/*
+ * This enumerates style rules in a sheet (and recursively into any
+ * grouping rules) in order to:
+ *  (1) Add any style rules, in order, into data->mRulesByWeight (for
+ *      the primary CSS cascade)
+ *  (2) Add any @font-face rules, in order, into XXX WRITE ME
+ */
 static PRBool
-InsertRuleByWeight(nsICSSRule* aRule, void* aData)
+CascadeRuleEnumFunc(nsICSSRule* aRule, void* aData)
 {
   CascadeEnumData* data = (CascadeEnumData*)aData;
   PRInt32 type = nsICSSRule::UNKNOWN_RULE;
   aRule->GetType(type);
 
   if (nsICSSRule::STYLE_RULE == type) {
     nsICSSStyleRule* styleRule = (nsICSSStyleRule*)aRule;
 
@@ -2461,59 +2508,49 @@ InsertRuleByWeight(nsICSSRule* aRule, vo
       info->mNext = entry->data.mRules;
       entry->data.mRules = info;
     }
   }
   else if (nsICSSRule::MEDIA_RULE == type ||
            nsICSSRule::DOCUMENT_RULE == type) {
     nsICSSGroupRule* groupRule = (nsICSSGroupRule*)aRule;
     if (groupRule->UseForPresentation(data->mPresContext, data->mCacheKey))
-      if (!groupRule->EnumerateRulesForwards(InsertRuleByWeight, aData))
+      if (!groupRule->EnumerateRulesForwards(CascadeRuleEnumFunc, aData))
         return PR_FALSE;
   }
-  else if (nsICSSRule::FONT_FACE_RULE == type 
-             && gfxPlatform::GetPlatform()->DownloadableFontsEnabled()) {
-    nsPresContext *presContext = data->mPresContext;
-    gfxUserFontSet *fs = presContext->GetUserFontSet();
-    if (!fs) {
-      nsFontFaceLoaderContext *loaderCtx = new nsFontFaceLoaderContext(presContext);
-      if (!loaderCtx)
-        return PR_FALSE;
-      fs = new gfxUserFontSet(loaderCtx); // user font set owns loader context
-      if (!fs) {
-        delete loaderCtx;
-        return PR_FALSE;
-      }
-      presContext->SetUserFontSet(fs);
-    }
-    
-    InsertFontFaceRule(aRule, fs);
+  else if (nsICSSRule::FONT_FACE_RULE == type) {
+    nsCSSFontFaceRule *fontFaceRule = static_cast<nsCSSFontFaceRule*>(aRule);
+    nsRefPtr<nsCSSFontFaceRule> *ptr = data->mFontFaceRules.AppendElement();
+    if (!ptr)
+      return PR_FALSE;
+    *ptr = fontFaceRule;
   }
 
   return PR_TRUE;
 }
 
 /* static */ PRBool
-nsCSSRuleProcessor::CascadeSheetRulesInto(nsICSSStyleSheet* aSheet, void* aData)
+nsCSSRuleProcessor::CascadeSheetEnumFunc(nsICSSStyleSheet* aSheet, void* aData)
 {
   nsCSSStyleSheet*  sheet = static_cast<nsCSSStyleSheet*>(aSheet);
   CascadeEnumData* data = static_cast<CascadeEnumData*>(aData);
   PRBool bSheetApplicable = PR_TRUE;
   sheet->GetApplicable(bSheetApplicable);
 
   if (bSheetApplicable &&
       sheet->UseForPresentation(data->mPresContext, data->mCacheKey) &&
       sheet->mInner) {
     nsCSSStyleSheet* child = sheet->mInner->mFirstChild;
     while (child) {
-      CascadeSheetRulesInto(child, data);
+      CascadeSheetEnumFunc(child, data);
       child = child->mNext;
     }
 
-    if (!sheet->mInner->mOrderedRules.EnumerateForwards(InsertRuleByWeight, data))
+    if (!sheet->mInner->mOrderedRules.EnumerateForwards(CascadeRuleEnumFunc,
+                                                        data))
       return PR_FALSE;
   }
   return PR_TRUE;
 }
 
 static int CompareWeightData(const void* aArg1, const void* aArg2,
                              void* closure)
 {
@@ -2585,21 +2622,22 @@ nsCSSRuleProcessor::RefreshRuleCascade(n
     }
   }
 
   if (mSheets.Count() != 0) {
     nsAutoPtr<RuleCascadeData> newCascade(
       new RuleCascadeData(aPresContext->Medium(),
                           eCompatibility_NavQuirks == aPresContext->CompatibilityMode()));
     if (newCascade) {
-      CascadeEnumData data(aPresContext, newCascade->mCacheKey,
+      CascadeEnumData data(aPresContext, newCascade->mFontFaceRules,
+                           newCascade->mCacheKey,
                            newCascade->mRuleHash.Arena());
       if (!data.mRulesByWeight.ops)
         return; /* out of memory */
-      if (!mSheets.EnumerateForwards(CascadeSheetRulesInto, &data))
+      if (!mSheets.EnumerateForwards(CascadeSheetEnumFunc, &data))
         return; /* out of memory */
 
       // Sort the hash table of per-weight linked lists by weight.
       PRUint32 weightCount = data.mRulesByWeight.entryCount;
       nsAutoArrayPtr<PerWeightData> weightArray(new PerWeightData[weightCount]);
       FillWeightArrayData fwData(weightArray);
       PL_DHashTableEnumerate(&data.mRulesByWeight, FillWeightArray, &fwData);
       NS_QuickSort(weightArray, weightCount, sizeof(PerWeightData),
diff --git a/layout/style/nsCSSRuleProcessor.h b/layout/style/nsCSSRuleProcessor.h
--- a/layout/style/nsCSSRuleProcessor.h
+++ b/layout/style/nsCSSRuleProcessor.h
@@ -92,25 +92,30 @@ public:
                                     nsReStyleHint* aResult);
 
   NS_IMETHOD HasAttributeDependentStyle(AttributeRuleProcessorData* aData,
                                         nsReStyleHint* aResult);
 
   NS_IMETHOD MediumFeaturesChanged(nsPresContext* aPresContext,
                                    PRBool* aRulesChanged);
 
+  // Append all the currently-active font face rules to aArray.  Return
+  // true for success and false for failure.
+  PRBool AppendFontFaceRules(nsPresContext* aPresContext,
+                             nsTArray< nsRefPtr<nsCSSFontFaceRule> >& aArray);
+
 #ifdef DEBUG
   void AssertQuirksChangeOK() {
     NS_ASSERTION(!mRuleCascades, 
                  "can't quirks style sheet without clearing rule cascades");
   }
 #endif
 
 private:
-  static PRBool CascadeSheetRulesInto(nsICSSStyleSheet* aSheet, void* aData);
+  static PRBool CascadeSheetEnumFunc(nsICSSStyleSheet* aSheet, void* aData);
 
   RuleCascadeData* GetRuleCascade(nsPresContext* aPresContext);
   void RefreshRuleCascade(nsPresContext* aPresContext);
 
   // The sheet order here is the same as in nsStyleSet::mSheets
   nsCOMArray<nsICSSStyleSheet> mSheets;
 
   // active first, then cached (most recent first)
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -52,16 +52,23 @@
 #include "nsStyleContext.h"
 #include "nsICSSStyleRule.h"
 #include "nsCSSAnonBoxes.h"
 #include "nsCSSPseudoElements.h"
 #include "nsCSSRuleProcessor.h"
 #include "nsIContent.h"
 #include "nsIFrame.h"
 #include "nsContentUtils.h"
+
+static const nsStyleSet::sheetType gCSSSheetTypes[] = {
+  nsStyleSet::eAgentSheet,
+  nsStyleSet::eUserSheet,
+  nsStyleSet::eDocSheet,
+  nsStyleSet::eOverrideSheet
+};
 
 nsIURI *nsStyleSet::gQuirkURI = 0;
 
 nsStyleSet::nsStyleSet()
   : mRuleTree(nsnull),
     mRuleWalker(nsnull),
     mDestroyedCount(0),
     mBatching(0),
@@ -804,16 +811,31 @@ nsStyleSet::ProbePseudoStyleFor(nsIConte
       result->Release();
       result = nsnull;
     }
   }
   
   return result;
 }
 
+PRBool
+nsStyleSet::AppendFontFaceRules(nsPresContext* aPresContext,
+                                nsTArray< nsRefPtr<nsCSSFontFaceRule> >& aArray)
+{
+  NS_ENSURE_FALSE(mInShutdown, PR_FALSE);
+
+  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gCSSSheetTypes); ++i) {
+    nsCSSRuleProcessor *ruleProc =
+      static_cast<nsCSSRuleProcessor*>(mRuleProcessors[gCSSSheetTypes[i]]);
+    if (!ruleProc->AppendFontFaceRules(aPresContext, aArray))
+      return PR_FALSE;
+  }
+  return PR_TRUE;
+}
+
 void
 nsStyleSet::BeginShutdown(nsPresContext* aPresContext)
 {
   mInShutdown = 1;
   mRoots.Clear(); // no longer valid, since we won't keep it up to date
 }
 
 void
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -48,18 +48,20 @@
 #define nsStyleSet_h_
 
 #include "nsIStyleRuleProcessor.h"
 #include "nsICSSStyleSheet.h"
 #include "nsBindingManager.h"
 #include "nsRuleNode.h"
 #include "nsTArray.h"
 #include "nsCOMArray.h"
+#include "nsAutoPtr.h"
 
 class nsIURI;
+class nsCSSFontFaceRule;
 
 // The style set object is created by the document viewer and ownership is
 // then handed off to the PresShell.  Only the PresShell should delete a
 // style set.
 
 class nsStyleSet
 {
  public:
@@ -107,16 +109,21 @@ class nsStyleSet
 
   // This functions just like ResolvePseudoStyleFor except that it will
   // return nsnull if there are no explicit style rules for that
   // pseudo element.  It should be used only for pseudo-elements.
   already_AddRefed<nsStyleContext>
   ProbePseudoStyleFor(nsIContent* aParentContent,
                       nsIAtom* aPseudoTag,
                       nsStyleContext* aParentContext);
+
+  // Append all the currently-active font face rules to aArray.  Return
+  // true for success and false for failure.
+  PRBool AppendFontFaceRules(nsPresContext* aPresContext,
+                             nsTArray< nsRefPtr<nsCSSFontFaceRule> >& aArray);
 
   // Begin ignoring style context destruction, to avoid lots of unnecessary
   // work on document teardown.
   void BeginShutdown(nsPresContext* aPresContext);
 
   // Free all of the data associated with this style set.
   void Shutdown(nsPresContext* aPresContext);
 
