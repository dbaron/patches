Rebuild the user font set when style sheets are enabled/disabled/added/removed, rules are modified/added/removed, or media changes change which style sheets apply.  (Bug 457821)  sr=bzbarsky  r=jdaggett

diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1452,16 +1452,19 @@ nsPresContext::SysColorChangedInternal()
 
 void
 nsPresContext::RebuildAllStyleData(nsChangeHint aExtraHint)
 {
   if (!mShell) {
     // We must have been torn down. Nothing to do here.
     return;
   }
+
+  RebuildUserFontSet();
+
   mShell->FrameConstructor()->RebuildAllStyleData(aExtraHint);
 }
 
 void
 nsPresContext::PostRebuildAllStyleDataEvent()
 {
   if (!mShell) {
     // We must have been torn down. Nothing to do here.
@@ -1728,50 +1731,144 @@ InsertFontFaceRule(nsCSSFontFaceRule *aR
      }
   }
   
   if (!fontfamily.IsEmpty() && srcArray.Length() > 0) {
     aFontSet->AddFontFace(fontfamily, srcArray, weight, stretch, italicStyle);
   }
 }
 
-gfxUserFontSet* 
+gfxUserFontSet*
 nsPresContext::GetUserFontSet()
 {
+  // We want to initialize the user font set lazily the first time the
+  // user asks for it, rather than building it too early and forcing
+  // rule cascade creation.  Thus we try to enforce the invariant that
+  // we *never* build the user font set until the first call to
+  // GetUserFontSet.  However, once it's been requested, we can't wait
+  // for somebody to call GetUserFontSet in order to rebuild it (see
+  // comments below in RebuildUserFontSet for why).
   if (mUserFontSetDirty) {
-    NS_IF_RELEASE(mUserFontSet);
+    // Reuse the FlushUserFontSet code by setting
+    // mUserFontSetNeedsRebuild.
+    mUserFontSetNeedsRebuild = PR_TRUE;
+    FlushUserFontSet();
+  }
 
+  return mUserFontSet;
+}
+
+void
+nsPresContext::FlushUserFontSet()
+{
+  if (!mShell)
+    return; // we've been torn down
+
+  // See above in GetUserFontSet for why we're testing
+  // mUserFontSetNeedsRebuild here.
+  NS_ASSERTION(!mUserFontSetNeedsRebuild || mUserFontSetDirty,
+               "if it needs rebuild, it better be dirty");
+  if (mUserFontSetNeedsRebuild) {
     if (gfxPlatform::GetPlatform()->DownloadableFontsEnabled()) {
+      nsRefPtr<gfxUserFontSet> oldUserFontSet = mUserFontSet;
+
       nsTArray< nsRefPtr<nsCSSFontFaceRule> > rules;
       if (!mShell->StyleSet()->AppendFontFaceRules(this, rules))
-        return nsnull;
+        return;
 
-      if (rules.Length() > 0) {
-        nsFontFaceLoaderContext *loaderCtx =
-          new nsFontFaceLoaderContext(this);
-        if (!loaderCtx)
-          return nsnull;
-        gfxUserFontSet *fs = new gfxUserFontSet(loaderCtx);
-        // user font set owns loader context
-        if (!fs) {
-          delete loaderCtx;
-          return nsnull;
+      PRBool differ;
+      if (rules.Length() == mFontFaceRules.Length()) {
+        differ = PR_FALSE;
+        for (PRUint32 i = 0, i_end = rules.Length(); i < i_end; ++i) {
+          if (rules[i] != mFontFaceRules[i]) {
+            differ = PR_TRUE;
+            break;
+          }
         }
-        mUserFontSet = fs;
-        NS_ADDREF(mUserFontSet);
+      } else {
+        differ = PR_TRUE;
+      }
 
-        for (PRUint32 i = 0, i_end = rules.Length(); i < i_end; ++i) {
-          InsertFontFaceRule(rules[i], fs);
+      // Only rebuild things if the set of @font-face rules is different.
+      if (differ) {
+        NS_IF_RELEASE(mUserFontSet);
+
+        if (rules.Length() > 0) {
+          nsFontFaceLoaderContext *loaderCtx =
+            new nsFontFaceLoaderContext(this);
+          if (!loaderCtx)
+            return;
+          gfxUserFontSet *fs = new gfxUserFontSet(loaderCtx);
+          // user font set owns loader context
+          if (!fs) {
+            delete loaderCtx;
+            return;
+          }
+          mUserFontSet = fs;
+          NS_ADDREF(mUserFontSet);
+
+          for (PRUint32 i = 0, i_end = rules.Length(); i < i_end; ++i) {
+            InsertFontFaceRule(rules[i], fs);
+          }
         }
+      }
+
+#ifdef DEBUG
+      PRBool success =
+#endif
+        rules.SwapElements(mFontFaceRules);
+      NS_ASSERTION(success, "should never fail given both are heap arrays");
+
+      if (mUserFontSetNeedsRebuild && oldUserFontSet != mUserFontSet) {
+        // If we've changed, created, or destroyed a user font set, we
+        // need to trigger a style change reflow.
+        // We need to enqueue a style change reflow (for later) to
+        // reflect that we're dropping @font-face rules.  This is the
+        // same thing nsFontFaceLoader does when font downloads
+        // complete.  (However, without a reflow, nothing will happen
+        // to start any downloads that are needed.)
+        mShell->StyleChangeReflow();
       }
     }
 
     mUserFontSetDirty = PR_FALSE;
+    mUserFontSetNeedsRebuild = PR_FALSE;
   }
-  return mUserFontSet;
+}
+
+void
+nsPresContext::RebuildUserFontSet()
+{
+  if (mUserFontSetDirty) {
+    // mUserFontSetDirty will be true in two cases:
+    //   (1) mUserFontSetNeedsRebuild is true, and we've already posted
+    //       the event we need (or something in the code below failed,
+    //       e.g., due to out-of-memory)
+    //   (2) GetUserFontSet has not yet been called on this pres
+    //       context, and thus we can build it lazily at first call
+    return;
+  }
+
+  mUserFontSetDirty = PR_TRUE;
+
+  // Somebody has already asked for the user font set, so we need to
+  // post an event to rebuild it.  Setting the user font set to be dirty
+  // and lazily rebuilding it isn't sufficient, since it is only the act
+  // of rebuilding it that will trigger the style change reflow that
+  // calls GetUserFontSet.  (This reflow causes rebuilding of text runs,
+  // which starts font loads, whose completion causes another style
+  // change reflow).
+  if (!mUserFontSetNeedsRebuild) {
+    nsCOMPtr<nsIRunnable> ev =
+      new nsRunnableMethod<nsPresContext>(this,
+                                          &nsPresContext::FlushUserFontSet);
+    if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
+      mUserFontSetNeedsRebuild = PR_TRUE;
+    }
+  }    
 }
 
 void
 nsPresContext::FireDOMPaintEvent()
 {
   nsCOMPtr<nsPIDOMWindow> ourWindow = mDocument->GetWindow();
   if (!ourWindow)
     return;
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -61,16 +61,18 @@
 #include "nsGkAtoms.h"
 #include "nsIDocument.h"
 #include "nsInterfaceHashtable.h"
 #include "nsCycleCollectionParticipant.h"
 #include "nsChangeHint.h"
 // This also pulls in gfxTypes.h, which we cannot include directly.
 #include "gfxRect.h"
 #include "nsRegion.h"
+#include "nsTArray.h"
+#include "nsAutoPtr.h"
 
 class nsImageLoader;
 #ifdef IBMBIDI
 class nsBidiPresUtils;
 #endif // IBMBIDI
 
 struct nsRect;
 
@@ -89,16 +91,17 @@ class nsILookAndFeel;
 class nsILookAndFeel;
 class nsICSSPseudoComparator;
 class nsIAtom;
 class nsIAnimationController;
 struct nsStyleBackground;
 template <class T> class nsRunnableMethod;
 class nsIRunnable;
 class gfxUserFontSet;
+class nsCSSFontFaceRule;
 
 #ifdef MOZ_REFLOW_PERF
 class nsIRenderingContext;
 #endif
 
 enum nsWidgetType {
   eWidgetType_Button  	= 1,
   eWidgetType_Checkbox	= 2,
@@ -750,25 +753,27 @@ public:
   // Is it OK to let the page specify colors and backgrounds?
   PRBool UseDocumentColors() const {
     return GetCachedBoolPref(kPresContext_UseDocumentColors) || IsChrome();
   }
 
   PRBool           SupressingResizeReflow() const { return mSupressResizeReflow; }
   
   gfxUserFontSet* GetUserFontSet();
+  void FlushUserFontSet();
+  void RebuildUserFontSet(); // asynchronously
 
   void NotifyInvalidation(const nsRect& aRect, PRBool aIsCrossDoc);
   void FireDOMPaintEvent();
 
 protected:
   friend class nsRunnableMethod<nsPresContext>;
   NS_HIDDEN_(void) ThemeChangedInternal();
   NS_HIDDEN_(void) SysColorChangedInternal();
-  
+
   NS_HIDDEN_(void) SetImgAnimations(nsIContent *aParent, PRUint16 aMode);
   NS_HIDDEN_(void) GetDocumentColorPreferences();
 
   NS_HIDDEN_(void) PreferenceChanged(const char* aPrefName);
   static NS_HIDDEN_(int) PrefChangedCallback(const char*, void*);
 
   NS_HIDDEN_(void) UpdateAfterPreferencesChanged();
   static NS_HIDDEN_(void) PrefChangedUpdateTimerCallback(nsITimer *aTimer, void *aClosure);
@@ -822,16 +827,18 @@ protected:
 
   nsPropertyTable       mPropertyTable;
 
   nsRegion              mSameDocDirtyRegion;
   nsRegion              mCrossDocDirtyRegion;
 
   // container for per-context fonts (downloadable, SVG, etc.)
   gfxUserFontSet* mUserFontSet;
+  // The list of @font-face rules that we put into mUserFontSet
+  nsTArray< nsRefPtr<nsCSSFontFaceRule> > mFontFaceRules;
   
   PRInt32               mFontScaler;
   nscoord               mMinimumFontSize;
 
   nsRect                mVisibleArea;
   nsSize                mPageSize;
   float                 mPageScale;
   float                 mPPScale;
@@ -880,17 +887,24 @@ protected:
   unsigned              mIsRootPaginatedDocument : 1;
   unsigned              mPrefBidiDirection : 1;
   unsigned              mPrefScrollbarSide : 2;
   unsigned              mPendingSysColorChanged : 1;
   unsigned              mPendingThemeChanged : 1;
   unsigned              mPendingMediaFeatureValuesChanged : 1;
   unsigned              mPrefChangePendingNeedsReflow : 1;
   unsigned              mRenderedPositionVaryingContent : 1;
+  // The following two variables differ only from when the pres context
+  // is initialized to when we first request the user font set;
+  // otherwise they are the same.  The first indicates that we have to
+  // rebuild the user font set; the second indicates that there is an
+  // event posted to do so and that we need to do a style change reflow
+  // if it changes.
   unsigned              mUserFontSetDirty : 1;
+  unsigned              mUserFontSetNeedsRebuild : 1;
 
   // resize reflow is supressed when the only change has been to zoom
   // the document rather than to change the document's dimensions
   unsigned              mSupressResizeReflow : 1;
 
 #ifdef IBMBIDI
   unsigned              mIsVisual : 1;
 
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -4553,21 +4553,26 @@ PresShell::DoFlushPendingNotifications(m
     // depends on style being completely up to date.  If it's not, then style
     // context reparenting, which can happen during reflow, might suddenly pick
     // up the new rules and we'll end up with frames whose style doesn't match
     // the frame type.
     if (!mIsDestroying) {
       mFrameConstructor->ProcessPendingRestyles();
     }
 
+
     // There might be more pending constructors now, but we're not going to
     // worry about them.  They can't be triggered during reflow, so we should
     // be good.
     
     if (aType >= Flush_Layout && !mIsDestroying) {
+      // Flush any pending update of the user font set, since that could
+      // post a style change reflow.
+      mPresContext->FlushUserFontSet();
+
       mFrameConstructor->RecalcQuotesAndCounters();
       mViewManager->FlushDelayedResize();
       ProcessReflowCommands(aInterruptibleReflow);
     }
 
     PRUint32 updateFlags = NS_VMREFRESH_NO_SYNC;
     if (aType >= Flush_Display) {
       // Flushing paints, so perform the invalidates and drawing
@@ -4772,27 +4777,31 @@ PresShell::ReconstructFrames(void)
   return rv;
 }
 
 void
 nsIPresShell::ReconstructStyleDataInternal()
 {
   mStylesHaveChanged = PR_FALSE;
 
+  if (mIsDestroying) {
+    // We don't want to mess with restyles at this point
+    return;
+  }
+
+  if (mPresContext) {
+    mPresContext->RebuildUserFontSet();
+  }
+
+  nsIContent* root = mDocument->GetRootContent();
   if (!mDidInitialReflow) {
     // Nothing to do here, since we have no frames yet
     return;
   }
 
-  if (mIsDestroying) {
-    // We don't want to mess with restyles at this point
-    return;
-  }
-
-  nsIContent* root = mDocument->GetRootContent();
   if (!root) {
     // No content to restyle
     return;
   }
   
   mFrameConstructor->PostRestyleEvent(root, eReStyle_Self, NS_STYLE_HINT_NONE);
 
 #ifdef ACCESSIBILITY
@@ -6236,16 +6245,18 @@ PresShell::WillDoReflow()
 PresShell::WillDoReflow()
 {
   // We just reflowed, tell the caret that its frame might have moved.
   // XXXbz that comment makes no sense
   if (mCaret) {
     mCaret->InvalidateOutsideCaret();
     mCaret->UpdateCaretPosition();
   }
+
+  mPresContext->FlushUserFontSet();
 
   mFrameConstructor->BeginUpdate();
 }
 
 void
 PresShell::DidDoReflow()
 {
   mFrameConstructor->EndUpdate();
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -2161,16 +2161,20 @@ nsCSSRuleProcessor::AppendFontFaceRules(
   }
   
   return PR_TRUE;
 }
 
 nsresult
 nsCSSRuleProcessor::ClearRuleCascades()
 {
+  // We rely on our caller (perhaps indirectly) to do something that
+  // will rebuild style data and the user font set (either
+  // nsIPresShell::ReconstructStyleData or
+  // nsPresContext::RebuildAllStyleData).
   RuleCascadeData *data = mRuleCascades;
   mRuleCascades = nsnull;
   while (data) {
     RuleCascadeData *next = data->mNext;
     delete data;
     data = next;
   }
   return NS_OK;
diff --git a/layout/style/nsFontFaceLoader.cpp b/layout/style/nsFontFaceLoader.cpp
--- a/layout/style/nsFontFaceLoader.cpp
+++ b/layout/style/nsFontFaceLoader.cpp
@@ -122,17 +122,22 @@ nsFontFaceLoader::OnStreamComplete(nsISt
 
   // when new font loaded, need to reflow
   if (fontUpdate) {
     nsFontFaceLoaderContext *loaderCtx 
                        = static_cast<nsFontFaceLoaderContext*> (mLoaderContext);
 
     nsIPresShell *ps = loaderCtx->mPresContext->PresShell();
     if (ps) {
-      // reflow async so that reflows coalesce
+      // Update layout for the presence of the new font.  Since this is
+      // asynchronous, reflows will coalesce.
+      // nsPresContext::FlushUserFontSet does the same thing when we
+      // remove a user font set, for fonts becoming unavailable, or when
+      // we add one, because if we change it dynamically we need to
+      // trigger reflow to cause gfx to request the fonts.
       ps->StyleChangeReflow();
       LOG(("fontdownloader (%p) reflow\n", this));
     }
   }
 
   return aStatus;
 }
 
