Rebuild the user font set when style sheets are enabled/disabled/added/removed, rules are modified/added/removed, or media changes change which style sheets apply.  (Bug 457821)

diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1452,16 +1452,19 @@ nsPresContext::SysColorChangedInternal()
 
 void
 nsPresContext::RebuildAllStyleData(nsChangeHint aExtraHint)
 {
   if (!mShell) {
     // We must have been torn down. Nothing to do here.
     return;
   }
+
+  UserFontSetNeedsRebuild();
+
   mShell->FrameConstructor()->RebuildAllStyleData(aExtraHint);
 }
 
 void
 nsPresContext::PostRebuildAllStyleDataEvent()
 {
   if (!mShell) {
     // We must have been torn down. Nothing to do here.
@@ -1730,46 +1733,106 @@ InsertFontFaceRule(nsCSSFontFaceRule *aR
     aFontSet->AddFontFace(fontfamily, srcArray, weight, stretch, italicStyle);
   }
 }
 
 gfxUserFontSet* 
 nsPresContext::GetUserFontSet()
 {
   if (mUserFontSetDirty) {
-    NS_IF_RELEASE(mUserFontSet);
-
     if (gfxPlatform::GetPlatform()->DownloadableFontsEnabled()) {
       nsTArray< nsRefPtr<nsCSSFontFaceRule> > rules;
       if (!mShell->StyleSet()->AppendFontFaceRules(this, rules))
         return nsnull;
 
-      if (rules.Length() > 0) {
-        nsFontFaceLoaderContext *loaderCtx =
-          new nsFontFaceLoaderContext(this);
-        if (!loaderCtx)
-          return nsnull;
-        gfxUserFontSet *fs = new gfxUserFontSet(loaderCtx);
-        // user font set owns loader context
-        if (!fs) {
-          delete loaderCtx;
-          return nsnull;
+      PRBool differ;
+      if (rules.Length() == mFontFaceRules.Length()) {
+        differ = PR_FALSE;
+        for (PRUint32 i = 0, i_end = rules.Length(); i < i_end; ++i) {
+          if (rules[i] != mFontFaceRules[i]) {
+            differ = PR_TRUE;
+            break;
+          }
         }
-        mUserFontSet = fs;
-        NS_ADDREF(mUserFontSet);
+      } else {
+        differ = PR_TRUE;
+      }
 
-        for (PRUint32 i = 0, i_end = rules.Length(); i < i_end; ++i) {
-          InsertFontFaceRule(rules[i], fs);
+      // Only rebuild things if the set of @font-face rules is different.
+      if (differ) {
+        if (mUserFontSet) {
+          NS_RELEASE(mUserFontSet);
+
+          // We need to enqueue a style change reflow (for later) to
+          // reflect that we're dropping @font-face rules.  This is
+          // the same thing nsFontFaceLoader does when new
+          // downloadable fonts become available.
+          if (mShell) {
+            mShell->StyleChangeReflow();
+          }
+        }
+
+        if (rules.Length() > 0) {
+          nsFontFaceLoaderContext *loaderCtx =
+            new nsFontFaceLoaderContext(this);
+          if (!loaderCtx)
+            return nsnull;
+          gfxUserFontSet *fs = new gfxUserFontSet(loaderCtx);
+          // user font set owns loader context
+          if (!fs) {
+            delete loaderCtx;
+            return nsnull;
+          }
+          mUserFontSet = fs;
+          NS_ADDREF(mUserFontSet);
+
+          for (PRUint32 i = 0, i_end = rules.Length(); i < i_end; ++i) {
+            InsertFontFaceRule(rules[i], fs);
+          }
         }
       }
+
+#ifdef DEBUG
+      PRBool success =
+#endif
+        rules.SwapElements(mFontFaceRules);
+      NS_ASSERTION(success, "should never fail given both are heap arrays");
     }
 
     mUserFontSetDirty = PR_FALSE;
   }
   return mUserFontSet;
+}
+
+void
+nsPresContext::UserFontSetNeedsRebuild()
+{
+  mUserFontSetDirty = PR_TRUE;
+
+  // Setting the user font set to be dirty isn't sufficient, since under
+  // normal conditions we only rebuild it lazily, and it is only the act
+  // of rebuilding it that will trigger the style change reflow that
+  // calls GetUserFontSet.
+  if (!mPendingRebuildUserFontSet) {
+    nsCOMPtr<nsIRunnable> ev =
+      new nsRunnableMethod<nsPresContext>(this,
+                               &nsPresContext::HandlePostedRebuildUserFontSet);
+    if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
+      mPendingRebuildUserFontSet = PR_TRUE;
+    }
+  }    
+}
+
+void
+nsPresContext::HandlePostedRebuildUserFontSet()
+{
+  mPendingRebuildUserFontSet = PR_FALSE;
+  // Get the user font set, which will update it and trigger a style
+  // change reflow if needed.
+  (void)GetUserFontSet();
 }
 
 void
 nsPresContext::FireDOMPaintEvent()
 {
   nsCOMPtr<nsPIDOMWindow> ourWindow = mDocument->GetWindow();
   if (!ourWindow)
     return;
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -61,16 +61,18 @@
 #include "nsGkAtoms.h"
 #include "nsIDocument.h"
 #include "nsInterfaceHashtable.h"
 #include "nsCycleCollectionParticipant.h"
 #include "nsChangeHint.h"
 // This also pulls in gfxTypes.h, which we cannot include directly.
 #include "gfxRect.h"
 #include "nsRegion.h"
+#include "nsTArray.h"
+#include "nsAutoPtr.h"
 
 class nsImageLoader;
 #ifdef IBMBIDI
 class nsBidiPresUtils;
 #endif // IBMBIDI
 
 struct nsRect;
 
@@ -89,16 +91,17 @@ class nsILookAndFeel;
 class nsILookAndFeel;
 class nsICSSPseudoComparator;
 class nsIAtom;
 class nsIAnimationController;
 struct nsStyleBackground;
 template <class T> class nsRunnableMethod;
 class nsIRunnable;
 class gfxUserFontSet;
+class nsCSSFontFaceRule;
 
 #ifdef MOZ_REFLOW_PERF
 class nsIRenderingContext;
 #endif
 
 enum nsWidgetType {
   eWidgetType_Button  	= 1,
   eWidgetType_Checkbox	= 2,
@@ -750,24 +753,27 @@ public:
   // Is it OK to let the page specify colors and backgrounds?
   PRBool UseDocumentColors() const {
     return GetCachedBoolPref(kPresContext_UseDocumentColors) || IsChrome();
   }
 
   PRBool           SupressingResizeReflow() const { return mSupressResizeReflow; }
   
   gfxUserFontSet* GetUserFontSet();
+  void UserFontSetNeedsRebuild();
 
   void NotifyInvalidation(const nsRect& aRect, PRBool aIsCrossDoc);
   void FireDOMPaintEvent();
 
 protected:
   friend class nsRunnableMethod<nsPresContext>;
   NS_HIDDEN_(void) ThemeChangedInternal();
   NS_HIDDEN_(void) SysColorChangedInternal();
+
+  NS_HIDDEN_(void) HandlePostedRebuildUserFontSet();
   
   NS_HIDDEN_(void) SetImgAnimations(nsIContent *aParent, PRUint16 aMode);
   NS_HIDDEN_(void) GetDocumentColorPreferences();
 
   NS_HIDDEN_(void) PreferenceChanged(const char* aPrefName);
   static NS_HIDDEN_(int) PrefChangedCallback(const char*, void*);
 
   NS_HIDDEN_(void) UpdateAfterPreferencesChanged();
@@ -822,16 +828,18 @@ protected:
 
   nsPropertyTable       mPropertyTable;
 
   nsRegion              mSameDocDirtyRegion;
   nsRegion              mCrossDocDirtyRegion;
 
   // container for per-context fonts (downloadable, SVG, etc.)
   gfxUserFontSet* mUserFontSet;
+  // The list of @font-face rules that we put into mUserFontSet
+  nsTArray< nsRefPtr<nsCSSFontFaceRule> > mFontFaceRules;
   
   PRInt32               mFontScaler;
   nscoord               mMinimumFontSize;
 
   nsRect                mVisibleArea;
   nsSize                mPageSize;
   float                 mPageScale;
   float                 mPPScale;
@@ -881,16 +889,17 @@ protected:
   unsigned              mPrefBidiDirection : 1;
   unsigned              mPrefScrollbarSide : 2;
   unsigned              mPendingSysColorChanged : 1;
   unsigned              mPendingThemeChanged : 1;
   unsigned              mPendingMediaFeatureValuesChanged : 1;
   unsigned              mPrefChangePendingNeedsReflow : 1;
   unsigned              mRenderedPositionVaryingContent : 1;
   unsigned              mUserFontSetDirty : 1;
+  unsigned              mPendingRebuildUserFontSet : 1;
 
   // resize reflow is supressed when the only change has been to zoom
   // the document rather than to change the document's dimensions
   unsigned              mSupressResizeReflow : 1;
 
 #ifdef IBMBIDI
   unsigned              mIsVisual : 1;
 
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -4554,21 +4554,26 @@ PresShell::DoFlushPendingNotifications(m
     // depends on style being completely up to date.  If it's not, then style
     // context reparenting, which can happen during reflow, might suddenly pick
     // up the new rules and we'll end up with frames whose style doesn't match
     // the frame type.
     if (!mIsDestroying) {
       mFrameConstructor->ProcessPendingRestyles();
     }
 
+
     // There might be more pending constructors now, but we're not going to
     // worry about them.  They can't be triggered during reflow, so we should
     // be good.
     
     if (aType >= Flush_Layout && !mIsDestroying) {
+      // Flush any pending update of the user font set, since that could
+      // post a style change reflow.
+      (void) mPresContext->GetUserFontSet();
+
       mFrameConstructor->RecalcQuotesAndCounters();
       mViewManager->FlushDelayedResize();
       ProcessReflowCommands(aInterruptibleReflow);
     }
 
     PRUint32 updateFlags = NS_VMREFRESH_NO_SYNC;
     if (aType >= Flush_Display) {
       // Flushing paints, so perform the invalidates and drawing
@@ -4773,27 +4778,31 @@ PresShell::ReconstructFrames(void)
   return rv;
 }
 
 void
 nsIPresShell::ReconstructStyleDataInternal()
 {
   mStylesHaveChanged = PR_FALSE;
 
+  if (mIsDestroying) {
+    // We don't want to mess with restyles at this point
+    return;
+  }
+
+  if (mPresContext) {
+    mPresContext->UserFontSetNeedsRebuild();
+  }
+
+  nsIContent* root = mDocument->GetRootContent();
   if (!mDidInitialReflow) {
     // Nothing to do here, since we have no frames yet
     return;
   }
 
-  if (mIsDestroying) {
-    // We don't want to mess with restyles at this point
-    return;
-  }
-
-  nsIContent* root = mDocument->GetRootContent();
   if (!root) {
     // No content to restyle
     return;
   }
   
   mFrameConstructor->PostRestyleEvent(root, eReStyle_Self, NS_STYLE_HINT_NONE);
 
 #ifdef ACCESSIBILITY
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -2161,16 +2161,20 @@ nsCSSRuleProcessor::AppendFontFaceRules(
   }
   
   return PR_TRUE;
 }
 
 nsresult
 nsCSSRuleProcessor::ClearRuleCascades()
 {
+  // We rely on our caller (perhaps indirectly) to do something that
+  // will rebuild style data and the user font set (either
+  // nsIPresShell::ReconstructStyleData or
+  // nsPresContext::RebuildAllStyleData).
   RuleCascadeData *data = mRuleCascades;
   mRuleCascades = nsnull;
   while (data) {
     RuleCascadeData *next = data->mNext;
     delete data;
     data = next;
   }
   return NS_OK;
diff --git a/layout/style/nsFontFaceLoader.cpp b/layout/style/nsFontFaceLoader.cpp
--- a/layout/style/nsFontFaceLoader.cpp
+++ b/layout/style/nsFontFaceLoader.cpp
@@ -143,17 +143,20 @@ nsFontFaceLoader::OnStreamComplete(nsISt
 
   // when new font loaded, need to reflow
   if (fontUpdate) {
     nsFontFaceLoaderContext *loaderCtx 
                        = static_cast<nsFontFaceLoaderContext*> (mLoaderContext);
 
     nsIPresShell *ps = loaderCtx->mPresContext->PresShell();
     if (ps) {
-      // reflow async so that reflows coalesce
+      // Update layout for the presence of the new font.  Since this is
+      // asynchronous, reflows will coalesce.
+      // nsPresContext::GetUserFontSet does the same thing when we
+      // remove a user font set, for fonts becoming unavailable.
       ps->StyleChangeReflow();
       LOG(("fontdownloader (%p) reflow\n", this));
     }
   }
 
   return aStatus;
 }
 
