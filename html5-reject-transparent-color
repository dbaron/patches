From: L. David Baron <dbaron@dbaron.org>

Implement the HTML5 algorithm for parsing a legacy color value:  reject 'transparent'.  (Bug 227072)

diff --git a/content/base/src/nsAttrValue.cpp b/content/base/src/nsAttrValue.cpp
--- a/content/base/src/nsAttrValue.cpp
+++ b/content/base/src/nsAttrValue.cpp
@@ -1131,36 +1131,44 @@ nsAttrValue::ParseColor(const nsAString&
     return PR_FALSE;
   }
 
   nscolor color;
   // No color names begin with a '#'; in standards mode, all acceptable
   // numeric colors do.
   if (colorStr.First() == '#') {
     colorStr.Cut(0, 1);
+    // FIXME: According to HTML5 we should only accept #rgb values
+    // here in the cases where we're following the "rules for parsing a
+    // legacy color value".  (Does that match the quirks mode check
+    // below?)
     if (NS_HexToRGB(colorStr, &color)) {
       SetColorValue(color, aString);
       return PR_TRUE;
     }
   } else {
     if (NS_ColorNameToRGB(colorStr, &color)) {
       SetColorValue(color, aString);
       return PR_TRUE;
     }
   }
 
-  if (aDocument->GetCompatibilityMode() != eCompatibility_NavQuirks) {
-    return PR_FALSE;
+  // In compatibility mode, try LooseHexToRGB as a fallback for either
+  // of the above two possibilities.
+  // FIXME: HTML5's algorithm for "rules for parsing a legacy color
+  // value" also says we should check CSS system colors.
+  // FIXME: Is quirks mode actually the case where HTML5 says we should
+  // follow the "rules for parsing a legacy color value"?
+  if (aDocument->GetCompatibilityMode() == eCompatibility_NavQuirks &&
+      NS_LooseHexToRGB(colorStr, &color)) {
+    SetColorValue(color, aString);
+    return PR_TRUE;
   }
 
-  // In compatibility mode, try LooseHexToRGB as a fallback for either
-  // of the above two possibilities.
-  NS_LooseHexToRGB(colorStr, &color);
-  SetColorValue(color, aString);
-  return PR_TRUE;
+  return PR_FALSE;
 }
 
 PRBool nsAttrValue::ParseFloatValue(const nsAString& aString)
 {
   ResetIfSet();
 
   PRInt32 ec;
   float val = PromiseFlatString(aString).ToFloat(&ec);
diff --git a/gfx/src/nsColor.cpp b/gfx/src/nsColor.cpp
--- a/gfx/src/nsColor.cpp
+++ b/gfx/src/nsColor.cpp
@@ -163,16 +163,20 @@ NS_GFX_(PRBool) NS_HexToRGB(const nsStri
 
   // Improperly formatted color value
   return PR_FALSE;
 }
 
 // compatible with legacy Nav behavior
 NS_GFX_(PRBool) NS_LooseHexToRGB(const nsString& aColorSpec, nscolor* aResult)
 {
+  if (aColorSpec.EqualsLiteral("transparent")) {
+    return PR_FALSE;
+  }
+
   int nameLen = aColorSpec.Length();
   const PRUnichar* colorSpec = aColorSpec.get();
   if ('#' == colorSpec[0]) {
     ++colorSpec;
     --nameLen;
   }
 
   if (3 < nameLen) {
