From: L. David Baron <dbaron@dbaron.org>

Make non-box frames with 'height:auto' respect min-height from overridable nsITheme::GetMinimumWidgetSize.  (Bug 369581)

diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -2386,16 +2386,40 @@ nsHTMLReflowState::ComputeMinMaxValues(n
          maxHeight.IsCalcUnit())) {
       mComputedMaxHeight = NS_UNCONSTRAINEDSIZE;
     } else {
       mComputedMaxHeight = nsLayoutUtils::
         ComputeHeightValue(aContainingBlockHeight, maxHeight);
     }
   }
 
+  // The use of nsITheme::GetMinimumWidgetSize in nsFrame::ComputeSize
+  // isn't sufficient in the case of heights that can grow, when the
+  // style height is 'auto'.
+  const nsStyleDisplay *disp = frame->GetStyleDisplay();
+  if (frame->IsThemed(disp)) {
+    nsIntSize size(0, 0);
+    bool canOverride = true;
+    nsPresContext *presContext = frame->PresContext();
+    presContext->GetTheme()->
+      GetMinimumWidgetSize(rendContext, frame, disp->mAppearance,
+                           &size, &canOverride);
+
+    if (canOverride) {
+      // The only case where we need to bother.
+
+      // GMWS() returns border-box size in device pixels; we need
+      // content box size in app units
+      nscoord height = presContext->DevPixelsToAppUnits(size.height) -
+                       mComputedBorderPadding.TopBottom();
+      if (height > mComputedMinHeight)
+        mComputedMinHeight = height;
+    }
+  }
+
   // If the computed value of 'min-height' is greater than the value of
   // 'max-height', 'max-height' is set to the value of 'min-height'
   if (mComputedMinHeight > mComputedMaxHeight) {
     mComputedMaxHeight = mComputedMinHeight;
   }
 }
 
 void
