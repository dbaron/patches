From: L. David Baron <dbaron@dbaron.org>

Bug 978648:  Handle dynamic changes to @keyframes rules and keyframe rules better.

diff --git a/layout/style/nsCSSRules.cpp b/layout/style/nsCSSRules.cpp
--- a/layout/style/nsCSSRules.cpp
+++ b/layout/style/nsCSSRules.cpp
@@ -2213,17 +2213,17 @@ nsCSSKeyframeStyleDeclaration::SetCSSDec
   NS_ABORT_IF_FALSE(aDecl, "must be non-null");
   mRule->ChangeDeclaration(aDecl);
   return NS_OK;
 }
 
 nsIDocument*
 nsCSSKeyframeStyleDeclaration::DocToUpdate()
 {
-  return nullptr;
+  return mRule ? mRule->GetDocument() : nullptr;
 }
 
 nsINode*
 nsCSSKeyframeStyleDeclaration::GetParentObject()
 {
   return mRule ? mRule->GetDocument() : nullptr;
 }
 
@@ -2379,25 +2379,33 @@ nsCSSKeyframeRule::DoGetKeyText(nsAStrin
 
 NS_IMETHODIMP
 nsCSSKeyframeRule::SetKeyText(const nsAString& aKeyText)
 {
   nsCSSParser parser;
 
   InfallibleTArray<float> newSelectors;
   // FIXME: pass filename and line number
-  if (parser.ParseKeyframeSelectorString(aKeyText, nullptr, 0, newSelectors)) {
-    newSelectors.SwapElements(mKeys);
-  } else {
+  if (!parser.ParseKeyframeSelectorString(aKeyText, nullptr, 0, newSelectors)) {
     // for now, we don't do anything if the parse fails
+    return;
   }
 
+  nsIDocument* doc = GetDocument();
+  mozAutoDocConditionalContentUpdateBatch autoUpdate(doc, true);
+
+  newSelectors.SwapElements(mKeys);
+
   nsCSSStyleSheet* sheet = GetStyleSheet();
   if (sheet) {
     sheet->SetModifiedByChildRule();
+
+    if (doc) {
+      doc->StyleRuleChanged(sheet, this, this);
+    }
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSKeyframeRule::GetStyle(nsIDOMCSSStyleDeclaration** aStyle)
 {
@@ -2415,16 +2423,21 @@ nsCSSKeyframeRule::ChangeDeclaration(css
   // the thing it already holds.
   if (aDeclaration != mDeclaration) {
     mDeclaration = aDeclaration;
   }
 
   nsCSSStyleSheet* sheet = GetStyleSheet();
   if (sheet) {
     sheet->SetModifiedByChildRule();
+
+    nsIDocument* doc = GetDocument();
+    if (doc) {
+      doc->StyleRuleChanged(sheet, this, this);
+    }
   }
 }
 
 /* virtual */ size_t
 nsCSSKeyframeRule::SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const
 {
   return aMallocSizeOf(this);
 
@@ -2538,21 +2551,32 @@ nsCSSKeyframesRule::GetName(nsAString& a
 {
   aName = mName;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSKeyframesRule::SetName(const nsAString& aName)
 {
+  if (mName == aName) {
+    return;
+  }
+
+  nsIDocument* doc = GetDocument();
+  mozAutoDocConditionalContentUpdateBatch autoUpdate(doc, true);
+
   mName = aName;
 
   nsCSSStyleSheet* sheet = GetStyleSheet();
   if (sheet) {
     sheet->SetModifiedByChildRule();
+
+    if (doc) {
+      doc->StyleRuleChanged(sheet, this, this);
+    }
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSKeyframesRule::GetCssRules(nsIDOMCSSRuleList* *aRuleList)
 {
@@ -2566,17 +2590,29 @@ nsCSSKeyframesRule::AppendRule(const nsA
   // which also turns out to match WebKit:
   // http://lists.w3.org/Archives/Public/www-style/2011Apr/0034.html
   nsCSSParser parser;
 
   // FIXME: pass filename and line number
   nsRefPtr<nsCSSKeyframeRule> rule =
     parser.ParseKeyframeRule(aRule, nullptr, 0);
   if (rule) {
+    nsIDocument* doc = GetDocument();
+    mozAutoDocConditionalContentUpdateBatch autoUpdate(doc, true);
+
     AppendStyleRule(rule);
+
+    nsCSSStyleSheet* sheet = GetStyleSheet();
+    if (sheet) {
+      sheet->SetModifiedByChildRule();
+
+      if (doc) {
+        doc->StyleRuleChanged(sheet, this, this);
+      }
+    }
   }
 
   return NS_OK;
 }
 
 static const uint32_t RULE_NOT_FOUND = uint32_t(-1);
 
 uint32_t
@@ -2600,22 +2636,30 @@ nsCSSKeyframesRule::FindRuleIndexForKey(
   }
 
   return RULE_NOT_FOUND;
 }
 
 NS_IMETHODIMP
 nsCSSKeyframesRule::DeleteRule(const nsAString& aKey)
 {
+  nsIDocument* doc = GetDocument();
+  mozAutoDocConditionalContentUpdateBatch autoUpdate(doc, true);
+
   uint32_t index = FindRuleIndexForKey(aKey);
   if (index != RULE_NOT_FOUND) {
     mRules.RemoveObjectAt(index);
+
     nsCSSStyleSheet* sheet = GetStyleSheet();
     if (sheet) {
       sheet->SetModifiedByChildRule();
+
+      if (doc) {
+        doc->StyleRuleChanged(sheet, this, this);
+      }
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCSSKeyframesRule::FindRule(const nsAString& aKey,
                              nsIDOMMozCSSKeyframeRule** aResult)
diff --git a/layout/style/test/test_animations.html b/layout/style/test/test_animations.html
--- a/layout/style/test/test_animations.html
+++ b/layout/style/test/test_animations.html
@@ -1492,14 +1492,44 @@ new_div("animation-name: anim2, anim3; a
 is(cs.marginRight, "25px", "animation-name list length is the length that matters");
 is(cs.marginTop, "25px", "animation-name list length is the length that matters");
 done_div();
 new_div("animation-name: anim2, anim3, anim2; animation-duration: 1s; animation-timing-function: linear; animation-delay: -250ms, -250ms, -750ms, -500ms;");
 is(cs.marginRight, "75px", "animation-name list length is the length that matters, and the last occurrence of a name wins");
 is(cs.marginTop, "25px", "animation-name list length is the length that matters");
 done_div();
 
+var dyn_sheet_elt = document.createElement("style");
+document.documentElement.firstChildElement.appendChild(dyn_sheet_elt);
+var dyn_sheet = dyn_sheet_elt.sheet;
+dyn_sheet.appendRule("@keyframes dyn1 { from { margin-left: 0 } 50% { margin-left: 50px } to { margin-left: 100px } }");
+dyn_sheet.appendRule("@keyframes dyn2 { from { margin-left: 100px } to { margin-left: 200px } }");
+var dyn1 = dyn_sheet.cssRules[0];
+var dyn2 = dyn_sheet.cssRules[1];
+new_div("animation: dyn1 1s linear");
+is(cs.marginLeft, "0px", "dynamic rule change test, initial state");
+advance_clock(250);
+is(cs.marginLeft, "25px", "dynamic rule change test, 250ms");
+dyn2.name = "dyn1";
+is(cs.marginLeft, "125px", "dynamic rule change test, change in @keyframes name applies");
+dyn2.appendRule("50% { margin-left: 0px }");
+is(cs.marginLeft, "50px", "dynamic rule change test, @keyframes appendRule");
+var dyn2_kf1 = dyn2.cssRules[0]; // currently 0% { margin-left: 100px }
+dyn2_kf1.style.marginLeft = "-100px";
+is(cs.marginLeft, "-50px", "dynamic rule change test, keyframe style set");
+dyn2.name = "dyn2";
+is(cs.marginLeft, "25px", "dynamic rule change test, change in @keyframes name applies (second time)");
+var dyn1_kf2 = dyn1.cssRules[1]; // currently 50% { margin-left: 50px }
+dyn1_kf2.keyText = "25%";
+is(cs.marginLeft, "50px", "dynamic rule change test, change in keyframe keyText");
+dyn1.deleteRule("25%");
+is(cs.marginLeft, "25px", "dynamic rule change test, @keyframes deleteRule");
+done_div();
+dyn_sheet_elt.parentNode.removeChild(dyn_sheet_elt);
+dyn_sheet_elt = null;
+dyn_sheet = null;
+
 SpecialPowers.DOMWindowUtils.restoreNormalRefresh();
 
 </script>
 </pre>
 </body>
 </html>
