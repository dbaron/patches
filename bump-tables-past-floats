Push scrollframes, tables, and other blocks that don't participate in float formatting down when they don't fit next to floats.  b=134706,349255

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -2816,6 +2816,10 @@ nsBlockFrame::ReflowBlockFrame(nsBlockRe
     aLine->ClearHasClearance();
   }
   PRBool treatWithClearance = aLine->HasClearance();
+  // Change breakType checks to mightClear checks, that are ||ed with
+  // being a block that gets bumped.
+  // Change ClearFloats to do the clearing (after it handles the breakType).
+
   // If our top margin was counted as part of some parents top-margin
   // collapse and we are being speculatively reflowed assuming this
   // frame DID NOT need clearance, then we need to check that
@@ -6708,6 +6712,15 @@ nsBlockFrame::BlockNeedsSpaceManager(nsI
   return (aBlock->GetStateBits() & NS_BLOCK_SPACE_MGR) ||
     (parent && !parent->IsFloatContainingBlock());
 }
+
+/* static */
+PRBool
+nsBlockFrame::BlockCanIntersectFloats(nsIFrame* aFrame)
+{
+  return aFrame->IsFrameOfType(nsIFrame::eBlockFrame) &&
+         !aFrame->IsFrameOfType(nsIFrame::eReplaced) &&
+         !(aFrame->GetStateBits() & NS_BLOCK_SPACE_MGR);
+}
  
 /* static */
 nsBlockFrame*
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -192,7 +192,8 @@ public:
   virtual PRBool IsFrameOfType(PRUint32 aFlags) const
   {
     return nsContainerFrame::IsFrameOfType(aFlags &
-             ~(nsIFrame::eCanContainOverflowContainers));
+             ~(nsIFrame::eCanContainOverflowContainers |
+               nsIFrame::eBlockFrame));
   }
 
 #ifdef DEBUG
@@ -290,6 +291,14 @@ public:
 
   static PRBool BlockIsMarginRoot(nsIFrame* aBlock);
   static PRBool BlockNeedsSpaceManager(nsIFrame* aBlock);
+
+  /*
+   * Returns whether aFrame is a block frame that will wrap its contents
+   * around floats intruding on it from the outside.  (aFrame need not
+   * be a block frame, but if it's not, the result will be false.)
+   */
+  static PRBool BlockCanIntersectFloats(nsIFrame* aFrame);
+
   /**
    * Walks up the frame tree, starting with aCandidate, and returns the first
    * block frame that it encounters.
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -210,15 +210,7 @@ nsBlockReflowState::ComputeBlockAvailSpa
 
   const nsMargin& borderPadding = BorderPadding();
 
-  // text controls are not splittable
-  // XXXldb Why not just set the frame state bit?
-
-  nsSplittableType splitType = aFrame->GetSplittableType();
-  if ((NS_FRAME_SPLITTABLE_NON_RECTANGULAR == splitType ||     // normal blocks 
-       NS_FRAME_NOT_SPLITTABLE == splitType) &&                // things like images mapped to display: block
-      !(aFrame->IsFrameOfType(nsIFrame::eReplaced)) &&         // but not replaced elements
-      aFrame->GetType() != nsGkAtoms::scrollFrame)         // or scroll frames
-  {
+  if (nsBlockFrame::BlockCanIntersectFloats(aFrame)) {
     if (mBand.GetFloatCount()) {
       // Use the float-edge property to determine how the child block
       // will interact with the float.
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -1556,7 +1556,7 @@ public:
     eLineParticipant =                  1 << 6,
     eXULBox =                           1 << 7,
     eCanContainOverflowContainers =     1 << 8,
-
+    eBlockFrame =                       1 << 9,
 
     // These are to allow nsFrame::Init to assert that IsFrameOfType
     // implementations all call the base class method.  They are only
