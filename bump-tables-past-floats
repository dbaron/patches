Push scrollframes, tables, and other blocks that don't participate in float formatting down when they don't fit next to floats.  b=134706,349255

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1675,8 +1675,11 @@ static void PlaceFrameView(nsIFrame* aFr
 static void PlaceFrameView(nsIFrame* aFrame);
 
 static PRBool LineHasClear(nsLineBox* aLine) {
-  return aLine->GetBreakTypeBefore() || aLine->HasFloatBreakAfter()
-    || (aLine->IsBlock() && (aLine->mFirstChild->GetStateBits() & NS_BLOCK_HAS_CLEAR_CHILDREN));
+  return aLine->IsBlock()
+    ? (aLine->GetBreakTypeBefore() ||
+       (aLine->mFirstChild->GetStateBits() & NS_BLOCK_HAS_CLEAR_CHILDREN) ||
+       !nsBlockFrame::BlockCanIntersectFloats(aLine->mFirstChild))
+    : aLine->HasFloatBreakAfter();
 }
 
 
@@ -1776,9 +1779,16 @@ nsBlockFrame::ReflowDirtyLines(nsBlockRe
       line->MarkDirty();
     }
 
+    nscoord replacedWidth = 0;
+    if (line->IsBlock() && !nsBlockFrame::BlockCanIntersectFloats(frame)) {
+      replacedWidth = nsBlockFrame::WidthToClearPastFloats(aState, frame);
+    }
+
     // We have to reflow the line if it's a block whose clearance
     // might have changed, so detect that.
-    if (!line->IsDirty() && line->GetBreakTypeBefore() != NS_STYLE_CLEAR_NONE) {
+    if (!line->IsDirty() &&
+        (line->GetBreakTypeBefore() != NS_STYLE_CLEAR_NONE ||
+         replacedWidth != 0)) {
       nscoord curY = aState.mY;
       // See where we would be after applying any clearance due to
       // BRs.
@@ -1786,7 +1796,8 @@ nsBlockFrame::ReflowDirtyLines(nsBlockRe
         curY = aState.ClearFloats(curY, inlineFloatBreakType);
       }
 
-      nscoord newY = aState.ClearFloats(curY, line->GetBreakTypeBefore());
+      nscoord newY =
+        aState.ClearFloats(curY, line->GetBreakTypeBefore(), replacedWidth);
       
       if (line->HasClearance()) {
         // Reflow the line if it might not have clearance anymore.
@@ -2816,14 +2827,22 @@ nsBlockFrame::ReflowBlockFrame(nsBlockRe
     aLine->ClearHasClearance();
   }
   PRBool treatWithClearance = aLine->HasClearance();
+
+  PRBool mightClearFloats = breakType != NS_STYLE_CLEAR_NONE;
+  nscoord replacedWidth = 0;
+  if (!nsBlockFrame::BlockCanIntersectFloats(frame)) {
+    mightClearFloats = PR_TRUE;
+    replacedWidth = nsBlockFrame::WidthToClearPastFloats(aState, frame);
+  }
+
   // If our top margin was counted as part of some parents top-margin
   // collapse and we are being speculatively reflowed assuming this
   // frame DID NOT need clearance, then we need to check that
   // assumption.
-  if (!treatWithClearance && !applyTopMargin && breakType != NS_STYLE_CLEAR_NONE &&
+  if (!treatWithClearance && !applyTopMargin && mightClearFloats &&
       aState.mReflowState.mDiscoveredClearance) {
     nscoord curY = aState.mY + aState.mPrevBottomMargin.get();
-    nscoord clearY = aState.ClearFloats(curY, breakType);
+    nscoord clearY = aState.ClearFloats(curY, breakType, replacedWidth);
     if (clearY != curY) {
       // Looks like that assumption was invalid, we do need
       // clearance. Tell our ancestor so it can reflow again. It is
@@ -2894,7 +2913,7 @@ nsBlockFrame::ReflowBlockFrame(nsBlockRe
         mayNeedRetry = PR_FALSE;
       }
       
-      if (!treatWithClearance && !clearanceFrame && breakType != NS_STYLE_CLEAR_NONE) {
+      if (!treatWithClearance && !clearanceFrame && mightClearFloats) {
         // We don't know if we need clearance and this is the first,
         // optimistic pass.  So determine whether *this block* needs
         // clearance. Note that we do not allow the decision for whether
@@ -2902,7 +2921,7 @@ nsBlockFrame::ReflowBlockFrame(nsBlockRe
         // decision is only allowed to be made under the optimistic
         // first pass.
         nscoord curY = aState.mY + aState.mPrevBottomMargin.get();
-        nscoord clearY = aState.ClearFloats(curY, breakType);
+        nscoord clearY = aState.ClearFloats(curY, breakType, replacedWidth);
         if (clearY != curY) {
           // Looks like we need clearance and we didn't know about it already. So
           // recompute collapsed margin
@@ -2930,7 +2949,7 @@ nsBlockFrame::ReflowBlockFrame(nsBlockRe
       if (treatWithClearance) {
         nscoord currentY = aState.mY;
         // advance mY to the clear position.
-        aState.mY = aState.ClearFloats(aState.mY, breakType);
+        aState.mY = aState.ClearFloats(aState.mY, breakType, replacedWidth);
         
         // Compute clearance. It's the amount we need to add to the top
         // border-edge of the frame, after applying collapsed margins
@@ -3491,6 +3510,7 @@ nsBlockFrame::DoReflowInlineFrames(nsBlo
     NS_ASSERTION(NS_UNCONSTRAINEDSIZE != aState.mAvailSpaceRect.height,
                  "unconstrained height on totally empty line");
 
+    // See the analogous code for blocks in nsBlockReflowState::ClearFloats.
     if (aState.mAvailSpaceRect.height > 0) {
       NS_ASSERTION(aState.IsImpactedByFloat(),
                    "redo line on totally empty line with non-empty band...");
@@ -6708,6 +6728,25 @@ nsBlockFrame::BlockNeedsSpaceManager(nsI
   return (aBlock->GetStateBits() & NS_BLOCK_SPACE_MGR) ||
     (parent && !parent->IsFloatContainingBlock());
 }
+
+/* static */
+PRBool
+nsBlockFrame::BlockCanIntersectFloats(nsIFrame* aFrame)
+{
+  return aFrame->IsFrameOfType(nsIFrame::eBlockFrame) &&
+         !aFrame->IsFrameOfType(nsIFrame::eReplaced) &&
+         !(aFrame->GetStateBits() & NS_BLOCK_SPACE_MGR);
+}
+
+/* static */
+nscoord
+nsBlockFrame::WidthToClearPastFloats(nsBlockReflowState& aState,
+                                     nsIFrame* aFrame)
+{
+  // XXX handle % widths
+  return nsLayoutUtils::IntrinsicForContainer(aState.mReflowState.rendContext,
+                                              frame, nsLayoutUtils::MIN_WIDTH);
+}
  
 /* static */
 nsBlockFrame*
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -192,7 +192,8 @@ public:
   virtual PRBool IsFrameOfType(PRUint32 aFlags) const
   {
     return nsContainerFrame::IsFrameOfType(aFlags &
-             ~(nsIFrame::eCanContainOverflowContainers));
+             ~(nsIFrame::eCanContainOverflowContainers |
+               nsIFrame::eBlockFrame));
   }
 
 #ifdef DEBUG
@@ -290,6 +291,21 @@ public:
 
   static PRBool BlockIsMarginRoot(nsIFrame* aBlock);
   static PRBool BlockNeedsSpaceManager(nsIFrame* aBlock);
+
+  /**
+   * Returns whether aFrame is a block frame that will wrap its contents
+   * around floats intruding on it from the outside.  (aFrame need not
+   * be a block frame, but if it's not, the result will be false.)
+   */
+  static PRBool BlockCanIntersectFloats(nsIFrame* aFrame);
+
+  /**
+   * Returns the width that needs to be cleared past floats for blocks
+   * that cannot intersect floats.
+   */
+  static nscoord WidthToClearPastFloats(nsBlockReflowState& aState,
+                                        nsIFrame* aFrame);
+
   /**
    * Walks up the frame tree, starting with aCandidate, and returns the first
    * block frame that it encounters.
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -210,15 +210,19 @@ nsBlockReflowState::ComputeBlockAvailSpa
 
   const nsMargin& borderPadding = BorderPadding();
 
-  // text controls are not splittable
-  // XXXldb Why not just set the frame state bit?
-
-  nsSplittableType splitType = aFrame->GetSplittableType();
-  if ((NS_FRAME_SPLITTABLE_NON_RECTANGULAR == splitType ||     // normal blocks 
-       NS_FRAME_NOT_SPLITTABLE == splitType) &&                // things like images mapped to display: block
-      !(aFrame->IsFrameOfType(nsIFrame::eReplaced)) &&         // but not replaced elements
-      aFrame->GetType() != nsGkAtoms::scrollFrame)         // or scroll frames
-  {
+  // XXX Do we really want this condition to be this restrictive (i.e.,
+  // more restrictive than it used to be)?  The |else| here is allowed
+  // by the CSS spec, but only out of desperation given implementations,
+  // and the behavior it leads to is quite undesirable (it can cause
+  // things to become extremely narrow when they'd fit quite well a
+  // little bit lower).  Should the else be a quirk or something that
+  // applies to a specific set of frame classes and no new ones?
+  // If we did that, then for those frames where the condition below is
+  // true but nsBlockFrame::BlockCanIntersectFloats is false,
+  // nsBlockFrame::WidthToClearPastFloats would need to use the
+  // shrink-wrap formula, max(MIN_WIDTH, min(avail width, PREF_WIDTH))
+  // rather than just using MIN_WIDTH.
+  if (nsBlockFrame::BlockCanIntersectFloats(aFrame)) {
     if (mBand.GetFloatCount()) {
       // Use the float-edge property to determine how the child block
       // will interact with the float.
@@ -1035,7 +1039,8 @@ nsBlockReflowState::PlaceBelowCurrentLin
 }
 
 nscoord
-nsBlockReflowState::ClearFloats(nscoord aY, PRUint8 aBreakType)
+nsBlockReflowState::ClearFloats(nscoord aY, PRUint8 aBreakType,
+                                nscoord aReplacedWidth)
 {
 #ifdef DEBUG
   if (nsBlockFrame::gNoisyReflow) {
@@ -1052,8 +1057,38 @@ nsBlockReflowState::ClearFloats(nscoord 
 #endif
   
   const nsMargin& bp = BorderPadding();
-  nscoord newY = mSpaceManager->ClearFloats(aY - bp.top, aBreakType);
-  newY += bp.top;
+  nscoord newY = aY;
+
+  if (aBreakType != NS_STYLE_CLEAR_NONE) {
+    newY = bp.top + mSpaceManager->ClearFloats(newY - bp.top, aBreakType);
+  }
+
+  if (aReplacedWidth > 0) {
+    for (;;) {
+      GetAvailableSpace(newY, PR_FALSE);
+      if (mAvailSpaceRect.width >= aReplacedWidth || mBand.GetFloatCount() == 0) {
+        break;
+      }
+      // See the analogous code for inlines in nsBlockFrame::DoReflowInlineFrames
+      if (mAvailSpaceRect.height > 0) {
+        // See if there's room in the next band.
+        newY += mAvailSpaceRect.height;
+      } else {
+        if (mReflowState.availableHeight != NS_UNCONSTRAINEDSIZE) {
+          // Stop trying to clear here; we'll just get pushed to the
+          // next column or page and try again there.
+          break;
+        }
+        NS_NOTREACHED("avail space rect with zero height!");
+        newY += 1;
+      }
+    }
+    // Restore mBand and mAvailSpaceRect to the way they were.  This may
+    // well not be needed, and we should probably come up with
+    // well-defined rules about when these members are valid so that
+    // it's clearly not needed.
+    GetAvailableSpace();
+  }
 
 #ifdef DEBUG
   if (nsBlockFrame::gNoisyReflow) {
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -109,8 +109,9 @@ public:
   PRBool PlaceBelowCurrentLineFloats(nsFloatCacheFreeList& aFloats, PRBool aForceFit);
 
   // Returns the first coordinate >= aY that clears the
-  // indicated floats.
-  nscoord ClearFloats(nscoord aY, PRUint8 aBreakType);
+  // floats indicated by aBreakType and has enough width between floats
+  // (or no floats remaining) to accomodate aReplacedWidth.
+  nscoord ClearFloats(nscoord aY, PRUint8 aBreakType, nscoord aReplacedWidth = 0);
 
   PRBool IsAdjacentWithTop() const {
     return mY ==
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -1556,7 +1556,7 @@ public:
     eLineParticipant =                  1 << 6,
     eXULBox =                           1 << 7,
     eCanContainOverflowContainers =     1 << 8,
-
+    eBlockFrame =                       1 << 9,
 
     // These are to allow nsFrame::Init to assert that IsFrameOfType
     // implementations all call the base class method.  They are only
