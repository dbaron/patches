Implement :nth-child(), :nth-last-child(), :nth-of-type(), :nth-last-of-type().  Patch by Daniel Glazman <daniel@glazman.org> and me.  b=75375

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -276,6 +276,10 @@ protected:
   nsSelectorParsingStatus ParsePseudoClassWithIdentArg(nsCSSSelector& aSelector,
                                                        nsIAtom*       aPseudo,
                                                        nsresult&      aErrorCode);
+
+  nsSelectorParsingStatus ParsePseudoClassWithIntPairArg(nsCSSSelector& aSelector,
+                                                         nsIAtom*       aPseudo,
+                                                         nsresult&      aErrorCode);
 
   nsSelectorParsingStatus ParseNegatedSimpleSelector(PRInt32&       aDataMask,
                                                      nsCSSSelector& aSelector,
@@ -2564,7 +2568,8 @@ CSSParserImpl::ParsePseudoSelector(PRInt
        isTree ||
 #endif
        nsCSSPseudoClasses::notPseudo == pseudo ||
-       nsCSSPseudoClasses::HasStringArg(pseudo))) {
+       nsCSSPseudoClasses::HasStringArg(pseudo)) ||
+       nsCSSPseudoClasses::HasIntPairArg(pseudo)) {
     // There are no other function pseudos
     REPORT_UNEXPECTED_TOKEN(PEPseudoSelNonFunc);
     UngetToken();
@@ -2602,7 +2607,13 @@ CSSParserImpl::ParsePseudoSelector(PRInt
         return parsingStatus;
       }
     }
-    // XXX are there more pseudo classes which accept arguments ?
+    else if (nsCSSPseudoClasses::HasIntParArg(pseudo)) {
+      nsSelectorParsingStatus parsingStatus =
+        ParsePseudoClassWithIntPairArg(aSelector, pseudo, aErrorCode);
+      if (eSelectorParsingStatus_Continue != parsingStatus) {
+        return parsingStatus;
+      }
+    }
     else {
       aSelector.AddPseudoClass(pseudo);
     }
@@ -2781,6 +2792,45 @@ CSSParserImpl::ParsePseudoClassWithIdent
 
   return eSelectorParsingStatus_Continue;
 }
+
+CSSParserImpl::nsSelectorParsingStatus
+CSSParserImpl::ParsePseudoClassWithIntPairArg(nsCSSSelector& aSelector,
+                                              nsIAtom*       aPseudo,
+                                              nsresult&      aErrorCode)
+{
+#error WRITE ME!
+#if 0
+  // Check if we have the first parenthesis
+  if (!ExpectSymbol(aErrorCode, '(', PR_FALSE)) {
+    REPORT_UNEXPECTED_TOKEN(PEPseudoClassNoArg);
+    return eSelectorParsingStatus_Error;
+  }
+
+  if (! GetToken(aErrorCode, PR_TRUE)) { // premature eof
+    REPORT_UNEXPECTED_EOF(PEPseudoClassArgEOF);
+    return eSelectorParsingStatus_Error;
+  }
+  // We expect an identifier with a language abbreviation
+  if (eCSSToken_Ident != mToken.mType) {
+    REPORT_UNEXPECTED_TOKEN(PEPseudoClassArgNotIdent);
+    UngetToken();
+    return eSelectorParsingStatus_Error;
+  }
+
+  // Add the pseudo with the language parameter
+  aSelector.AddPseudoClass(aPseudo, mToken.mIdent.get());
+
+  // close the parenthesis
+  if (!ExpectSymbol(aErrorCode, ')', PR_TRUE)) {
+    REPORT_UNEXPECTED_TOKEN(PEPseudoClassNoClose);
+    return eSelectorParsingStatus_Error;
+  }
+
+  return eSelectorParsingStatus_Continue;
+#endif
+// XXX
+}
+
 
 /**
  * This is the format for selectors:
diff --git a/layout/style/nsCSSPseudoClassList.h b/layout/style/nsCSSPseudoClassList.h
--- a/layout/style/nsCSSPseudoClassList.h
+++ b/layout/style/nsCSSPseudoClassList.h
@@ -78,6 +78,10 @@ CSS_PSEUDO_CLASS(lastChild, ":last-child
 CSS_PSEUDO_CLASS(lastChild, ":last-child")
 CSS_PSEUDO_CLASS(lastNode, ":-moz-last-node")
 CSS_PSEUDO_CLASS(onlyChild, ":only-child")
+CSS_PSEUDO_CLASS(nthChild, ":nth-child")
+CSS_PSEUDO_CLASS(nthLastChild, ":nth-last-child")
+CSS_PSEUDO_CLASS(nthOfType, ":nth-of-type")
+CSS_PSEUDO_CLASS(nthLastOfType, ":nth-last-of-type")
 
 // Image, object, etc state pseudo-classes
 CSS_PSEUDO_CLASS(mozBroken, ":-moz-broken")
