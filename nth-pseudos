Implement :nth-child(), :nth-last-child(), :nth-of-type(), :nth-last-of-type().  Patch by Daniel Glazman <daniel@glazman.org> and me.  b=75375

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -276,6 +276,10 @@ protected:
   nsSelectorParsingStatus ParsePseudoClassWithIdentArg(nsCSSSelector& aSelector,
                                                        nsIAtom*       aPseudo,
                                                        nsresult&      aErrorCode);
+
+  nsSelectorParsingStatus ParsePseudoClassWithNthPairArg(nsCSSSelector& aSelector,
+                                                         nsIAtom*       aPseudo,
+                                                         nsresult&      aErrorCode);
 
   nsSelectorParsingStatus ParseNegatedSimpleSelector(PRInt32&       aDataMask,
                                                      nsCSSSelector& aSelector,
@@ -2564,7 +2568,8 @@ CSSParserImpl::ParsePseudoSelector(PRInt
        isTree ||
 #endif
        nsCSSPseudoClasses::notPseudo == pseudo ||
-       nsCSSPseudoClasses::HasStringArg(pseudo))) {
+       nsCSSPseudoClasses::HasStringArg(pseudo) ||
+       nsCSSPseudoClasses::HasNthPairArg(pseudo))) {
     // There are no other function pseudos
     REPORT_UNEXPECTED_TOKEN(PEPseudoSelNonFunc);
     UngetToken();
@@ -2602,7 +2607,13 @@ CSSParserImpl::ParsePseudoSelector(PRInt
         return parsingStatus;
       }
     }
-    // XXX are there more pseudo classes which accept arguments ?
+    else if (nsCSSPseudoClasses::HasNthPairArg(pseudo)) {
+      nsSelectorParsingStatus parsingStatus =
+        ParsePseudoClassWithNthPairArg(aSelector, pseudo, aErrorCode);
+      if (eSelectorParsingStatus_Continue != parsingStatus) {
+        return parsingStatus;
+      }
+    }
     else {
       aSelector.AddPseudoClass(pseudo);
     }
@@ -2781,6 +2792,97 @@ CSSParserImpl::ParsePseudoClassWithIdent
 
   return eSelectorParsingStatus_Continue;
 }
+
+CSSParserImpl::nsSelectorParsingStatus
+CSSParserImpl::ParsePseudoClassWithNthPairArg(nsCSSSelector& aSelector,
+                                              nsIAtom*       aPseudo,
+                                              nsresult&      aErrorCode)
+{
+  PRInt32 numbers[2];
+  numbers[0] = 0;
+  numbers[1] = 0;
+  PRBool lookForB = PR_TRUE;
+  
+  // Check if we have the first parenthesis
+  if (!ExpectSymbol(aErrorCode, '(', PR_FALSE)) {
+    REPORT_UNEXPECTED_TOKEN(PEPseudoClassNoArg);
+    return eSelectorParsingStatus_Error;
+  }
+
+  // Prohibit internal whitespace for now, although the spec isn't clear.
+
+  if (! GetToken(aErrorCode, PR_FALSE)) {
+    REPORT_UNEXPECTED_EOF(PEPseudoClassArgEOF);
+    return eSelectorParsingStatus_Error;
+  }
+  
+  if (eCSSToken_Ident == mToken.mType) {
+    if (mToken.mIdent.EqualsIgnoreCase("odd")) {
+      numbers[0] = 2;
+      numbers[1] = 1;
+      lookForB = PR_FALSE;
+    }
+    else if (mToken.mIdent.EqualsIgnoreCase("even")) {
+      numbers[0] = 2;
+      numbers[1] = 0;
+      lookForB = PR_FALSE;
+    }
+    else if (mToken.mIdent.EqualsIgnoreCase("n")) {
+      numbers[0] = 1;
+    }
+    else if (mToken.mIdent.EqualsIgnoreCase("-n")) {
+      numbers[0] = -1;
+    }
+    else {
+      REPORT_UNEXPECTED_TOKEN(PEPseudoClassArgNotNth);
+      return eSelectorParsingStatus_Error;
+    }
+  }
+  else if (eCSSToken_Number == mToken.mType) {
+    if (!mToken.mIntegerValid) {
+      REPORT_UNEXPECTED_TOKEN(PEPseudoClassArgNotNth);
+      return eSelectorParsingStatus_Error;
+    }
+    numbers[1] = mToken.mInteger;
+    lookForB = PR_FALSE;
+  }
+  else if (eCSSToken_Dimension == mToken.mType) {
+    if (!mToken.mIntegerValid || !mToken.mIdent.EqualsIgnoreCase("n")) {
+      REPORT_UNEXPECTED_TOKEN(PEPseudoClassArgNotNth);
+      return eSelectorParsingStatus_Error;
+    }
+    numbers[0] = mToken.mInteger;
+  }
+  // XXX If it's a ')', is that valid?  (as 0n+0)
+  else {
+    REPORT_UNEXPECTED_TOKEN(PEPseudoClassArgNotNth);
+    return eSelectorParsingStatus_Error;
+  }
+
+  if (! GetToken(aErrorCode, PR_FALSE)) {
+    REPORT_UNEXPECTED_EOF(PEPseudoClassArgEOF);
+    return eSelectorParsingStatus_Error;
+  }
+  if (lookForB && !mToken.IsSymbol(')')) {
+    // XXX Need to check that it actually has a + or - sign!
+    if (eCSSToken_Number != mToken.mType || !mToken.mIntegerValid) {
+      REPORT_UNEXPECTED_TOKEN(PEPseudoClassArgNotNth);
+      return eSelectorParsingStatus_Error;
+    }
+    numbers[1] = mToken.mInteger;
+    if (! GetToken(aErrorCode, PR_FALSE)) {
+      REPORT_UNEXPECTED_EOF(PEPseudoClassArgEOF);
+      return eSelectorParsingStatus_Error;
+    }
+  }
+  if (!mToken.IsSymbol(')')) {
+    REPORT_UNEXPECTED_TOKEN(PEPseudoClassNoClose);
+    return eSelectorParsingStatus_Error;
+  }
+  aSelector.AddPseudoClass(aPseudo, numbers);
+  return eSelectorParsingStatus_Continue;
+}
+
 
 /**
  * This is the format for selectors:
diff --git a/layout/style/nsCSSPseudoClassList.h b/layout/style/nsCSSPseudoClassList.h
--- a/layout/style/nsCSSPseudoClassList.h
+++ b/layout/style/nsCSSPseudoClassList.h
@@ -78,6 +78,10 @@ CSS_PSEUDO_CLASS(lastChild, ":last-child
 CSS_PSEUDO_CLASS(lastChild, ":last-child")
 CSS_PSEUDO_CLASS(lastNode, ":-moz-last-node")
 CSS_PSEUDO_CLASS(onlyChild, ":only-child")
+CSS_PSEUDO_CLASS(nthChild, ":nth-child")
+CSS_PSEUDO_CLASS(nthLastChild, ":nth-last-child")
+CSS_PSEUDO_CLASS(nthOfType, ":nth-of-type")
+CSS_PSEUDO_CLASS(nthLastOfType, ":nth-last-of-type")
 
 // Image, object, etc state pseudo-classes
 CSS_PSEUDO_CLASS(mozBroken, ":-moz-broken")
diff --git a/layout/style/nsCSSPseudoClasses.cpp b/layout/style/nsCSSPseudoClasses.cpp
--- a/layout/style/nsCSSPseudoClasses.cpp
+++ b/layout/style/nsCSSPseudoClasses.cpp
@@ -79,5 +79,8 @@ PRBool
 PRBool
 nsCSSPseudoClasses::HasNthPairArg(nsIAtom* aAtom)
 {
-  return PR_FALSE;
+  return aAtom == nsCSSPseudoClasses::nthChild ||
+         aAtom == nsCSSPseudoClasses::nthLastChild ||
+         aAtom == nsCSSPseudoClasses::nthOfType ||
+         aAtom == nsCSSPseudoClasses::nthLastOfType;
 }
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -821,6 +821,10 @@ RuleProcessorData::RuleProcessorData(nsP
   mParentData = nsnull;
   mLanguage = nsnull;
   mClasses = nsnull;
+  mNthIndices[0][0] = 0;
+  mNthIndices[0][1] = 0;
+  mNthIndices[1][0] = 0;
+  mNthIndices[1][1] = 0;
 
   // get the compat. mode (unless it is provided)
   if (!aCompat) {
@@ -936,6 +940,53 @@ const nsString* RuleProcessorData::GetLa
     }
   }
   return mLanguage;
+}
+
+static inline PRInt32
+CSSNameSpaceID(nsIContent *aContent)
+{
+  return aContent->IsNodeOfType(nsINode::eHTML)
+           ? kNameSpaceID_XHTML
+           : aContent->GetNameSpaceID();
+}
+
+PRInt32
+RuleProcessorData::GetNthIndex(PRBool aIsOfType, PRBool aIsFromEnd)
+{
+  NS_ASSERTION(mParentContent, "caller should check mParentContent");
+
+  PRInt32 &slot = mNthIndices[aIsOfType][aIsFromEnd];
+  if (slot != 0)
+    return slot;
+
+  PRInt32 result = 1;
+  nsIContent* parent = mParentContent;
+
+  PRUint32 cur;
+  PRInt32 increment;
+  if (aIsFromEnd) {
+    cur = parent->GetChildCount() - 1;
+    increment = -1;
+  } else {
+    cur = 0;
+    increment = 1;
+  }
+
+  for (;;) {
+    nsIContent* child = parent->GetChildAt(cur);
+    NS_ASSERTION(child, "couldn't find node in its parent's child list");
+    cur += increment;
+    if (child == mContent)
+      break;
+    if (nsStyleUtil::IsSignificantChild(child, PR_FALSE, PR_FALSE) &&
+        (!aIsOfType ||
+         (child->Tag() == mContentTag &&
+          CSSNameSpaceID(child) == mNameSpaceID)))
+      ++result;
+  }
+
+  slot = result;
+  return result;
 }
 
 static const PRUnichar kNullCh = PRUnichar('\0');
@@ -1135,6 +1186,43 @@ static PRBool SelectorMatches(RuleProces
         }
       }
       result = (data.mContent == onlyChild && moreChild == nsnull);
+    }
+    else if (nsCSSPseudoClasses::nthChild == pseudoClass->mAtom ||
+             nsCSSPseudoClasses::nthLastChild == pseudoClass->mAtom ||
+             nsCSSPseudoClasses::nthOfType == pseudoClass->mAtom ||
+             nsCSSPseudoClasses::nthLastOfType == pseudoClass->mAtom) {
+      nsIContent *parent = data.mParentContent;
+      if (parent) {
+        PRBool isOfType =
+          nsCSSPseudoClasses::nthOfType == pseudoClass->mAtom ||
+          nsCSSPseudoClasses::nthLastOfType == pseudoClass->mAtom;
+        PRBool isFromEnd =
+          nsCSSPseudoClasses::nthLastChild == pseudoClass->mAtom ||
+          nsCSSPseudoClasses::nthLastOfType == pseudoClass->mAtom;
+        if (setNodeFlags) {
+          if (isFromEnd)
+            parent->SetFlags(NODE_HAS_SLOW_SELECTOR);
+          else
+            parent->SetFlags(NODE_HAS_SLOW_SELECTOR_NOAPPEND);
+        }
+
+        const PRInt32 index = data.GetNthIndex(isOfType, isFromEnd);
+        const PRInt32 a = pseudoClass->u.mNumbers[0];
+        const PRInt32 b = pseudoClass->u.mNumbers[1];
+        // result should be true if there exists n >= 0 such that
+        // a * n + b == index.
+        // Integer division in C does truncation towards 0.  So check
+        // that the result is nonnegative, and that there was no
+        // truncation.
+        if (a == 0) {
+          result = b == index;
+        } else {
+          const PRInt32 n = (index - b) / a;
+          result = n >= 0 && (a * n == index - b);
+        }
+      } else {
+        result = PR_FALSE;
+      }
     }
     else if (nsCSSPseudoClasses::empty == pseudoClass->mAtom ||
              nsCSSPseudoClasses::mozOnlyWhitespace == pseudoClass->mAtom) {
diff --git a/layout/style/nsCSSScanner.cpp b/layout/style/nsCSSScanner.cpp
--- a/layout/style/nsCSSScanner.cpp
+++ b/layout/style/nsCSSScanner.cpp
@@ -1006,11 +1006,18 @@ PRBool nsCSSScanner::ParseNumber(nsresul
   PRInt32 ec;
   float value = ident.ToFloat(&ec);
 
+  // Set mIntegerValid for all cases (except %, below) because we need
+  // it for the "2n" in :nth-child(2n).
+  aToken.mIntegerValid = PR_FALSE;
+  if (!gotDot) {
+    aToken.mInteger = ident.ToInteger(&ec);
+    aToken.mIntegerValid = PR_TRUE;
+  }
+  ident.SetLength(0);
+
   // Look at character that terminated the number
-  aToken.mIntegerValid = PR_FALSE;
   if (c >= 0) {
     if (StartsIdent(c, Peek(aErrorCode))) {
-      ident.SetLength(0);
       if (!GatherIdent(aErrorCode, c, ident)) {
         return PR_FALSE;
       }
@@ -1018,23 +1025,11 @@ PRBool nsCSSScanner::ParseNumber(nsresul
     } else if ('%' == c) {
       type = eCSSToken_Percentage;
       value = value / 100.0f;
-      ident.SetLength(0);
+      aToken.mIntegerValid = PR_FALSE;
     } else {
       // Put back character that stopped numeric scan
       Pushback(c);
-      if (!gotDot) {
-        aToken.mInteger = ident.ToInteger(&ec);
-        aToken.mIntegerValid = PR_TRUE;
-      }
-      ident.SetLength(0);
     }
-  }
-  else {  // stream ended
-    if (!gotDot) {
-      aToken.mInteger = ident.ToInteger(&ec);
-      aToken.mIntegerValid = PR_TRUE;
-    }
-    ident.SetLength(0);
   }
   aToken.mNumber = value;
   aToken.mType = type;
diff --git a/layout/style/nsIStyleRuleProcessor.h b/layout/style/nsIStyleRuleProcessor.h
--- a/layout/style/nsIStyleRuleProcessor.h
+++ b/layout/style/nsIStyleRuleProcessor.h
@@ -81,6 +81,7 @@ struct RuleProcessorData {
   }
 
   const nsString* GetLang();
+  PRInt32 GetNthIndex(PRBool aIsOfType, PRBool aIsFromEnd);
 
   nsPresContext*   mPresContext;
   nsIContent*       mContent;       // weak ref
@@ -106,6 +107,12 @@ struct RuleProcessorData {
 
 protected:
   nsAutoString *mLanguage; // NULL means we haven't found out the language yet
+
+  // This node's index for :nth-child(), :nth-last-child(),
+  // :nth-of-type(), :nth-last-of-type().  If 0, needs to be computed.
+  // The first subscript is 0 for -child and 1 for -of-type, the second
+  // subscript is 0 for nth- and 1 for nth-last-.
+  PRInt32 mNthIndices[2][2];
 };
 
 struct ElementRuleProcessorData : public RuleProcessorData {
diff --git a/layout/style/test/test_selectors.html b/layout/style/test/test_selectors.html
--- a/layout/style/test/test_selectors.html
+++ b/layout/style/test/test_selectors.html
@@ -64,6 +64,35 @@ function run() {
         style_text.data = "";
     }
 
+    function test_parseable(selector)
+    {
+        var zi = ++gCounter;
+        ifdoc.body.innerHTML = "<p></p>";
+        style_text.data = "p, " + selector + "{ z-index: " + zi + " }";
+        var should_match = ifdoc.getElementsByTagName("p")[0];
+        is(ifwin.getComputedStyle(should_match, "").zIndex, zi,
+           "selector " + selector + " was parsed");
+        ifdoc.body.innerHTML = "";
+        style_text.data = "";
+    }
+
+    function test_balanced_unparseable(selector)
+    {
+        var zi1 = ++gCounter;
+        var zi2 = ++gCounter;
+        ifdoc.body.innerHTML = "<p></p><div></div>";
+        style_text.data = "p, " + selector + "{ z-index: " + zi1 + " }" +
+                          "div { z-index: " + zi2 + " }";
+        var should_not_match = ifdoc.getElementsByTagName("p")[0];
+        var should_match = ifdoc.getElementsByTagName("div")[0];
+        is(ifwin.getComputedStyle(should_not_match, "").zIndex, "auto",
+           "selector " + selector + " was a parser error");
+        is(ifwin.getComputedStyle(should_match, "").zIndex, zi2,
+           "selector " + selector + " error was recovered from");
+        ifdoc.body.innerHTML = "";
+        style_text.data = "";
+    }
+
     // Bug 420814
     test_selector_in_html(
         "div ~ div p",
@@ -71,6 +100,19 @@ function run() {
         function(doc) { return doc.getElementsByTagName("p"); },
         function(doc) { return []; }
     );
+
+    // :nth-child(), etc.
+    // prohibit internal whitespace for now, although the spec isn't clear
+    test_balanced_unparseable(":nth-child()");
+    test_balanced_unparseable(":nth-of-type( )");
+    test_balanced_unparseable(":nth-last-child( odd)");
+    test_balanced_unparseable(":nth-last-of-type(even )");
+    test_balanced_unparseable(":nth-child(n )");
+    test_balanced_unparseable(":nth-of-type( 2n)");
+    test_balanced_unparseable(":nth-last-child( -n)");
+    test_balanced_unparseable(":nth-last-of-type(-2n )");
+    test_balanced_unparseable(":nth-child(- n)");
+    test_balanced_unparseable(":nth-of-type(-2 n)");
 
 
     SimpleTest.finish();
