From: L. David Baron <dbaron@dbaron.org>

Introduce NodeMatchContext for additional input into SelectorMatches.  (Bug 147777)  (TODO: fix 80th column violations)

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1214,33 +1214,59 @@ RuleProcessorData::GetNthIndex(PRBool aI
   slot = result;
   return result;
 }
 
 /**
  * A |TreeMatchContext| has data about matching a selector (containing
  * combinators) against a node and the tree that that node is in.  It
  * contains both input to and output from the matching.
- *
- * (In contrast, a RuleProcessorData has information needed to match a
- * selector (without combinators) against a single node; it only
- * has input to the matching.)
  */
 struct TreeMatchContext {
   // Is this matching operation for the creation of a style context?
   // (If it is, we need to set slow selector bits on nodes indicating
   // that certain restyling needs to happen.)
   const PRBool mForStyling;
 
   TreeMatchContext(PRBool aForStyling)
     : mForStyling(aForStyling)
   {
   }
 };
 
+/**
+ * A |NodeMatchContext| has data about matching a selector (without
+ * combinators) against a single node.  It contains only input to the
+ * matching.
+ *
+ * Unlike |RuleProcessorData|, which is similar, a |NodeMatchContext|
+ * can vary depending on the selector matching process.  In other words,
+ * a single node might have multiple value NodeMatchContext at one time,
+ * but only one possible RuleProcessorData.
+ */
+struct NodeMatchContext {
+  // In order to implement nsCSSRuleProcessor::HasStateDependentStyle,
+  // we need to be able to see if a node might match an
+  // event-state-dependent selector for any value of that event state.
+  // So mStateMask contains the states that should NOT be tested.
+  //
+  // NOTE: For |aStateMask| to work correctly, it's important that any
+  // change that changes multiple state bits include all those state
+  // bits in the notification.  Otherwise, if multiple states change but
+  // we do separate notifications then we might determine the style is
+  // not state-dependent when it really is (e.g., determining that a
+  // :hover:active rule no longer matches when both states are unset).
+  const PRInt32 mStateMask;
+
+  NodeMatchContext(PRInt32 aStateMask)
+    : mStateMask(aStateMask)
+  {
+  }
+};
+
 static PRBool ValueIncludes(const nsSubstring& aValueList,
                             const nsSubstring& aValue,
                             const nsStringComparator& aComparator)
 {
   const PRUnichar *p = aValueList.BeginReading(),
               *p_end = aValueList.EndReading();
 
   while (p < p_end) {
@@ -1818,31 +1844,24 @@ static const PseudoClassInfo sPseudoClas
   // Add more entries for our fake values to make sure we can't
   // index out of bounds into this array no matter what.
   { nsnull, 0 },
   { nsnull, 0 }
 };
 PR_STATIC_ASSERT(NS_ARRAY_LENGTH(sPseudoClassInfo) >
                    nsCSSPseudoClasses::ePseudoClass_NotPseudoClass);
 
-// NOTE: For |aStateMask| to work correctly, it's important that any change
-// that changes multiple state bits include all those state bits in the
-// notification.  Otherwise, if multiple states change but we do separate
-// notifications then we might determine the style is not state-dependent when
-// it really is (e.g., determining that a :hover:active rule no longer matches
-// when both states are unset).
-
 // |aDependence| has two functions:
 //  * when non-null, it indicates that we're processing a negation,
 //    which is done only when SelectorMatches calls itself recursively
 //  * what it points to should be set to true whenever a test is skipped
 //    because of aStateMask
 static PRBool SelectorMatches(RuleProcessorData &data,
                               nsCSSSelector* aSelector,
-                              PRInt32 aStateMask, // states NOT to test
+                              NodeMatchContext* aNodeMatchContext,
                               TreeMatchContext* aTreeMatchContext,
                               PRBool* const aDependence = nsnull) 
 
 {
   NS_PRECONDITION(!aSelector->IsPseudoElement(),
                   "Pseudo-element snuck into SelectorMatches?");
   // namespace/tag match
   // optimization : bail out early if we can
@@ -1913,17 +1932,18 @@ static PRBool SelectorMatches(RuleProces
   }
 
   const PRBool isNegated = (aDependence != nsnull);
   // The selectors for which we set node bits are, unfortunately, early
   // in this function (because they're pseudo-classes, which are
   // generally quick to test, and thus earlier).  If they were later,
   // we'd probably avoid setting those bits in more cases where setting
   // them is unnecessary.
-  NS_ASSERTION(aStateMask == 0 || !aTreeMatchContext->mForStyling,
+  NS_ASSERTION(aNodeMatchContext->mStateMask == 0 ||
+               !aTreeMatchContext->mForStyling,
                "mForStyling must be false if we're just testing for "
                "state-dependence");
 
   // test for pseudo class match
   for (nsPseudoClassList* pseudoClass = aSelector->mPseudoClassList;
        pseudoClass; pseudoClass = pseudoClass->mNext) {
     const PseudoClassInfo& info = sPseudoClassInfo[pseudoClass->mType];
     if (info.mFunc) {
@@ -1945,17 +1965,17 @@ static PRBool SelectorMatches(RuleProces
           !isNegated &&
           // important for |IsQuirkEventSensitive|:
           data.mIsHTMLContent && !data.IsLink() &&
           !IsQuirkEventSensitive(data.mContentTag)) {
         // In quirks mode, only make certain elements sensitive to
         // selectors ":hover" and ":active".
         return PR_FALSE;
       } else {
-        if (aStateMask & statesToCheck) {
+        if (aNodeMatchContext->mStateMask & statesToCheck) {
           if (aDependence)
             *aDependence = PR_TRUE;
         } else {
           if (!(data.ContentState() & statesToCheck)) {
             return PR_FALSE;
           }
         }
       }
@@ -2040,17 +2060,17 @@ static PRBool SelectorMatches(RuleProces
     }
   }
 
   // apply SelectorMatches to the negated selectors in the chain
   if (!isNegated) {
     for (nsCSSSelector *negation = aSelector->mNegations;
          result && negation; negation = negation->mNegations) {
       PRBool dependence = PR_FALSE;
-      result = !SelectorMatches(data, negation, aStateMask,
+      result = !SelectorMatches(data, negation, aNodeMatchContext,
                                 aTreeMatchContext, &dependence);
       // If the selector does match due to the dependence on aStateMask,
       // then we want to keep result true so that the final result of
       // SelectorMatches is true.  Doing so tells StateEnumFunc that
       // there is a dependence on the state.
       result = result || dependence;
     }
   }
@@ -2117,17 +2137,18 @@ static PRBool SelectorMatchesTree(RulePr
                                            prevdata->mCompatMode);
           prevdata->mParentData = data;
         }
       }
     }
     if (! data) {
       return PR_FALSE;
     }
-    if (SelectorMatches(*data, selector, 0, aTreeMatchContext)) {
+    NodeMatchContext nodeContext(0);
+    if (SelectorMatches(*data, selector, &nodeContext, aTreeMatchContext)) {
       // to avoid greedy matching, we need to recur if this is a
       // descendant or general sibling combinator and the next
       // combinator is different, but we can make an exception for
       // sibling, then parent, since a sibling's parent is always the
       // same.
       if (NS_IS_GREEDY_OPERATOR(selector->mOperator) &&
           selector->mNext &&
           selector->mNext->mOperator != selector->mOperator &&
@@ -2160,20 +2181,21 @@ static PRBool SelectorMatchesTree(RulePr
   return PR_TRUE; // all the selectors matched.
 }
 
 static void ContentEnumFunc(nsICSSStyleRule* aRule, nsCSSSelector* aSelector,
                             void* aData)
 {
   RuleProcessorData* data = (RuleProcessorData*)aData;
 
-  TreeMatchContext context(PR_TRUE);
-  if (SelectorMatches(*data, aSelector, 0, &context)) {
+  TreeMatchContext treeContext(PR_TRUE);
+  NodeMatchContext nodeContext(0);
+  if (SelectorMatches(*data, aSelector, &nodeContext, &treeContext)) {
     nsCSSSelector *next = aSelector->mNext;
-    if (!next || SelectorMatchesTree(*data, next, &context)) {
+    if (!next || SelectorMatchesTree(*data, next, &treeContext)) {
       // for performance, require that every implementation of
       // nsICSSStyleRule return the same pointer for nsIStyleRule (why
       // would anything multiply inherit nsIStyleRule anyway?)
 #ifdef DEBUG
       nsCOMPtr<nsIStyleRule> iRule = do_QueryInterface(aRule);
       NS_ASSERTION(static_cast<nsIStyleRule*>(aRule) == iRule.get(),
                    "Please fix QI so this performance optimization is valid");
 #endif
@@ -2311,20 +2333,21 @@ nsCSSRuleProcessor::HasStateDependentSty
       nsCSSSelector* selector = *iter;
 
       nsReStyleHint possibleChange = IsSiblingOperator(selector->mOperator) ?
         eReStyle_LaterSiblings : eReStyle_Self;
 
       // If hint already includes all the bits of possibleChange,
       // don't bother calling SelectorMatches, since even if it returns false
       // hint won't change.
-      TreeMatchContext context(PR_FALSE);
+      TreeMatchContext treeContext(PR_FALSE);
+      NodeMatchContext nodeContext(aData->mStateMask);
       if ((possibleChange & ~hint) &&
-          SelectorMatches(*aData, selector, aData->mStateMask, &context) &&
-          SelectorMatchesTree(*aData, selector->mNext, &context)) {
+          SelectorMatches(*aData, selector, &nodeContext, &treeContext) &&
+          SelectorMatchesTree(*aData, selector->mNext, &treeContext)) {
         hint = nsReStyleHint(hint | possibleChange);
       }
     }
   }
   return hint;
 }
 
 PRBool
@@ -2350,20 +2373,21 @@ AttributeEnumFunc(nsCSSSelector* aSelect
   AttributeRuleProcessorData *data = aData->data;
 
   nsReStyleHint possibleChange = IsSiblingOperator(aSelector->mOperator) ?
     eReStyle_LaterSiblings : eReStyle_Self;
 
   // If enumData->change already includes all the bits of possibleChange, don't
   // bother calling SelectorMatches, since even if it returns false
   // enumData->change won't change.
-  TreeMatchContext context(PR_FALSE);
+  TreeMatchContext treeContext(PR_FALSE);
+  NodeMatchContext nodeContext(0);
   if ((possibleChange & ~(aData->change)) &&
-      SelectorMatches(*data, aSelector, 0, &context) &&
-      SelectorMatchesTree(*data, aSelector->mNext, &context)) {
+      SelectorMatches(*data, aSelector, &nodeContext, &treeContext) &&
+      SelectorMatchesTree(*data, aSelector->mNext, &treeContext)) {
     aData->change = nsReStyleHint(aData->change | possibleChange);
   }
 }
 
 nsReStyleHint
 nsCSSRuleProcessor::HasAttributeDependentStyle(AttributeRuleProcessorData* aData)
 {
   NS_PRECONDITION(aData->mContent->IsNodeOfType(nsINode::eELEMENT),
@@ -2894,20 +2918,21 @@ nsCSSRuleProcessor::RefreshRuleCascade(n
 /* static */ PRBool
 nsCSSRuleProcessor::SelectorListMatches(RuleProcessorData& aData,
                                         nsCSSSelectorList* aSelectorList)
 {
   while (aSelectorList) {
     nsCSSSelector* sel = aSelectorList->mSelectors;
     NS_ASSERTION(sel, "Should have *some* selectors");
     NS_ASSERTION(!sel->IsPseudoElement(), "Shouldn't have been called");
-    TreeMatchContext context(PR_FALSE);
-    if (SelectorMatches(aData, sel, 0, &context)) {
+    TreeMatchContext treeContext(PR_FALSE);
+    NodeMatchContext nodeContext(0);
+    if (SelectorMatches(aData, sel, &nodeContext, &treeContext)) {
       nsCSSSelector* next = sel->mNext;
-      if (!next || SelectorMatchesTree(aData, next, &context)) {
+      if (!next || SelectorMatchesTree(aData, next, &treeContext)) {
         return PR_TRUE;
       }
     }
 
     aSelectorList = aSelectorList->mNext;
   }
 
   return PR_FALSE;
