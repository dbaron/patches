From: L. David Baron <dbaron@dbaron.org>

Bug 847287 patch 4 - Set mWinsInCascade for CSS Animations.

diff --git a/dom/animation/Animation.h b/dom/animation/Animation.h
--- a/dom/animation/Animation.h
+++ b/dom/animation/Animation.h
@@ -154,19 +154,22 @@ struct AnimationProperty
   // Does this property win in the CSS Cascade?
   //
   // For CSS transitions, this is true as long as a CSS animation on the
   // same property and element is not running, in which case we set this
   // to false so that the animation (lower in the cascade) can win.  We
   // then use this to decide whether to apply the style both in the CSS
   // cascade and for OMTA.
   //
-  // FIXME (bug 847287): For CSS Animations, which are overridden by
-  // !important rules in the cascade, we actually determine this from
-  // the CSS cascade computations, and then use it for OMTA.
+  // For CSS Animations, which are overridden by !important rules in the
+  // cascade, we actually determine this from the CSS cascade
+  // computations, and then use it for OMTA.
+  // **NOTE**: For CSS animations, we only bother setting mWinsInCascade
+  // accurately for properties that we can animate on the compositor.
+  // For other properties, we make it always be true.
   bool mWinsInCascade;
 
   InfallibleTArray<AnimationPropertySegment> mSegments;
 
   bool operator==(const AnimationProperty& aOther) const {
     return mProperty == aOther.mProperty &&
            mWinsInCascade == aOther.mWinsInCascade &&
            mSegments == aOther.mSegments;
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -378,16 +378,18 @@ nsAnimationManager::CheckAnimationRule(n
   collection->mNeedsRefreshes = true;
   collection->Tick();
 
   // Cancel removed animations
   for (size_t newPlayerIdx = newPlayers.Length(); newPlayerIdx-- != 0; ) {
     newPlayers[newPlayerIdx]->Cancel();
   }
 
+  UpdateCascadeResults(aStyleContext, collection);
+
   TimeStamp refreshTime = mPresContext->RefreshDriver()->MostRecentRefresh();
   UpdateStyleAndEvents(collection, refreshTime,
                        EnsureStyleRule_IsNotThrottled);
   // We don't actually dispatch the mPendingEvents now.  We'll either
   // dispatch them the next time we get a refresh driver notification
   // or the next time somebody calls
   // nsPresShell::FlushPendingNotifications.
   if (!mPendingEvents.IsEmpty()) {
@@ -693,16 +695,110 @@ nsAnimationManager::BuildSegment(Infalli
   } else {
     tf = &aAnimation.GetTimingFunction();
   }
   segment.mTimingFunction.Init(*tf);
 
   return true;
 }
 
+/* static */ void
+nsAnimationManager::UpdateCascadeResults(
+                      nsStyleContext* aStyleContext,
+                      AnimationPlayerCollection* aElementAnimations)
+{
+  /*
+   * Figure out which properties we need to examine.
+   */
+
+  // size of 2 since we only currently have 2 properties we animate on
+  // the compositor
+  nsAutoTArray<nsCSSProperty, 2> propertiesToTrack;
+
+  {
+    nsCSSPropertySet propertiesToTrackAsSet;
+
+    for (size_t playerIdx = aElementAnimations->mPlayers.Length();
+         playerIdx-- != 0; ) {
+      const AnimationPlayer* player = aElementAnimations->mPlayers[playerIdx];
+      const Animation* anim = player->GetSource();
+      if (!anim) {
+        continue;
+      }
+
+      for (size_t propIdx = 0, propEnd = anim->Properties().Length();
+           propIdx != propEnd; ++propIdx) {
+        const AnimationProperty& prop = anim->Properties()[propIdx];
+        // We only bother setting mWinsInCascade for properties that we
+        // can animate on the compositor.
+        if (nsCSSProps::PropHasFlags(prop.mProperty,
+                                     CSS_PROPERTY_CAN_ANIMATE_ON_COMPOSITOR)) {
+          if (!propertiesToTrackAsSet.HasProperty(prop.mProperty)) {
+            propertiesToTrack.AppendElement(prop.mProperty);
+            propertiesToTrackAsSet.AddProperty(prop.mProperty);
+          }
+        }
+      }
+    }
+  }
+
+  /*
+   * Determine whether those properties are set in things that
+   * override animations.
+   */
+
+  nsCSSPropertySet propertiesOverridden;
+  nsRuleNode::ComputePropertiesOverridingAnimation(propertiesToTrack,
+                                                   aStyleContext,
+                                                   propertiesOverridden);
+
+  /*
+   * Set mWinsInCascade based both on what is overridden at levels
+   * higher than animations and based on one animation overriding
+   * another.
+   *
+   * We iterate from the last animation to the first, just like we do
+   * when calling ComposeStyle from
+   * AnimationPlayerCollection::EnsureStyleRuleFor.  Later animations
+   * override earlier ones, so we add properties to the set of
+   * overridden properties as we encounter them, if the animation is
+   * currently filling.
+   */
+
+  for (size_t playerIdx = aElementAnimations->mPlayers.Length();
+       playerIdx-- != 0; ) {
+    AnimationPlayer* player = aElementAnimations->mPlayers[playerIdx];
+    Animation* anim = player->GetSource();
+    if (!anim) {
+      continue;
+    }
+
+    for (size_t propIdx = 0, propEnd = anim->Properties().Length();
+         propIdx != propEnd; ++propIdx) {
+      AnimationProperty& prop = anim->Properties()[propIdx];
+      // We only bother setting mWinsInCascade for properties that we
+      // can animate on the compositor.
+      if (nsCSSProps::PropHasFlags(prop.mProperty,
+                                   CSS_PROPERTY_CAN_ANIMATE_ON_COMPOSITOR)) {
+        prop.mWinsInCascade = !propertiesOverridden.HasProperty(prop.mProperty);
+
+        if (prop.mWinsInCascade) {
+          ComputedTiming computedTiming = anim->GetComputedTiming();
+          if (computedTiming.mTimeFraction !=
+              ComputedTiming::kNullTimeFraction) {
+            // This animation is filling right now, so it overrides
+            // earlier animations.
+            propertiesOverridden.AddProperty(prop.mProperty);
+          }
+        }
+      }
+    }
+  }
+}
+
 /* virtual */ void
 nsAnimationManager::WillRefresh(mozilla::TimeStamp aTime)
 {
   MOZ_ASSERT(mPresContext,
              "refresh driver should not notify additional observers "
              "after pres context has been destroyed");
   if (!mPresContext->GetPresShell()) {
     // Someone might be keeping mPresContext alive past the point
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -232,15 +232,19 @@ private:
   bool BuildSegment(InfallibleTArray<mozilla::AnimationPropertySegment>&
                       aSegments,
                     nsCSSProperty aProperty,
                     const mozilla::StyleAnimation& aAnimation,
                     float aFromKey, nsStyleContext* aFromContext,
                     mozilla::css::Declaration* aFromDeclaration,
                     float aToKey, nsStyleContext* aToContext);
 
+  static void UpdateCascadeResults(nsStyleContext* aStyleContext,
+                                   mozilla::AnimationPlayerCollection*
+                                     aElementAnimations);
+
   // The guts of DispatchEvents
   void DoDispatchEvents();
 
   mozilla::EventArray mPendingEvents;
 };
 
 #endif /* !defined(nsAnimationManager_h_) */
diff --git a/layout/style/test/test_animations_omta.html b/layout/style/test/test_animations_omta.html
--- a/layout/style/test/test_animations_omta.html
+++ b/layout/style/test/test_animations_omta.html
@@ -425,58 +425,52 @@ addAsyncAnimTest(function *() {
             "anim2 + anim1, translate at 2s");
     omta_is("opacity", 0.4, RunningOn.Compositor,
             "anim2 + anim1, opacity at 2s");
   // list anim2 twice, last duration wins, original start time still applies
   gDiv.style.animation = "anim2 linear 5s, anim1 linear 10s, anim2 linear 20s";
   yield waitForPaintsFlushed();
     omta_is("transform", { tx: 32 }, RunningOn.Compositor,
             "anim2 + anim1 + anim2, translate at 2s");
-    // Bug 980769
-    todo_is(SpecialPowers.DOMWindowUtils.getOMTAStyle(gDiv, "opacity"), "0.1",
-            "anim2 + anim1 + anim2, opacity at 2s");
+    is(SpecialPowers.DOMWindowUtils.getOMTAStyle(gDiv, "opacity"), "0.1",
+       "anim2 + anim1 + anim2, opacity at 2s");
   // drop one of the anim2, and list anim3 as well, which animates
   // the same property as anim2
   gDiv.style.animation = "anim1 linear 10s, anim2 linear 20s, anim3 linear 10s";
   yield waitForPaintsFlushed();
     omta_is("transform", { tx: 32 }, RunningOn.Compositor,
             "anim1 + anim2 + anim3, translate at 2s");
-    // Bug 980769
-    todo_is(SpecialPowers.DOMWindowUtils.getOMTAStyle(gDiv, "opacity"), "0",
-            "anim1 + anim2 + anim3, opacity at 2s");
+    is(SpecialPowers.DOMWindowUtils.getOMTAStyle(gDiv, "opacity"), "0",
+       "anim1 + anim2 + anim3, opacity at 2s");
   advance_clock(1000);
     omta_is("transform", { tx: 48 }, RunningOn.Compositor,
             "anim1 + anim2 + anim3, translate at 3s");
-    // Bug 980769
-    todo_is(SpecialPowers.DOMWindowUtils.getOMTAStyle(gDiv, "opacity"), "0.1",
-            "anim1 + anim2 + anim3, opacity at 3s");
+    is(SpecialPowers.DOMWindowUtils.getOMTAStyle(gDiv, "opacity"), "0.1",
+       "anim1 + anim2 + anim3, opacity at 3s");
   // now swap the anim3 and anim2 order
   gDiv.style.animation = "anim1 linear 10s, anim3 linear 10s, anim2 linear 20s";
   yield waitForPaintsFlushed();
     omta_is("transform", { tx: 48 }, RunningOn.Compositor,
             "anim1 + anim3 + anim2, translate at 3s");
-    // Bug 980769
-    todo_is(SpecialPowers.DOMWindowUtils.getOMTAStyle(gDiv, "opacity"), "0.15",
-            "anim1 + anim3 + anim2, opacity at 3s");
+    is(SpecialPowers.DOMWindowUtils.getOMTAStyle(gDiv, "opacity"), "0.15",
+       "anim1 + anim3 + anim2, opacity at 3s");
   advance_clock(2000); // (unlike test_animations.html, we seek 2s forwards here
                        // since at 4s anim2 and anim3 produce the same result so
                        // we can't tell which won.)
     omta_is("transform", { tx: 80 }, RunningOn.Compositor,
             "anim1 + anim3 + anim2, translate at 5s");
-    // Bug 980769
-    todo_is(SpecialPowers.DOMWindowUtils.getOMTAStyle(gDiv, "opacity"), "0.25",
-            "anim1 + anim3 + anim2, opacity at 5s");
+    is(SpecialPowers.DOMWindowUtils.getOMTAStyle(gDiv, "opacity"), "0.25",
+       "anim1 + anim3 + anim2, opacity at 5s");
   // swap anim3 and anim2 back
   gDiv.style.animation = "anim1 linear 10s, anim2 linear 20s, anim3 linear 10s";
   yield waitForPaintsFlushed();
     omta_is("transform", { tx: 80 }, RunningOn.Compositor,
             "anim1 + anim2 + anim3, translate at 5s");
-    // Bug 980769
-    todo_is(SpecialPowers.DOMWindowUtils.getOMTAStyle(gDiv, "opacity"), "0.3",
-            "anim1 + anim2 + anim3, opacity at 5s");
+    is(SpecialPowers.DOMWindowUtils.getOMTAStyle(gDiv, "opacity"), "0.3",
+       "anim1 + anim2 + anim3, opacity at 5s");
   // seek past end of anim1
   advance_clock(5100);
   yield waitForPaints();
     omta_is("transform", { tx: 0 }, RunningOn.MainThread,
             "anim1 + anim2 + anim3, translate at 10.1s");
   // Change the animation fill mode on the completed animation.
   gDiv.style.animation =
     "anim1 linear 10s forwards, anim2 linear 20s, anim3 linear 10s";
@@ -489,19 +483,18 @@ addAsyncAnimTest(function *() {
   // Change the animation duration on the completed animation, so it is
   // no longer completed.
   // XXX Not sure about this---there seems to be a bug in test_animations.html
   // in that it drops the fill mode but the test comment says it has a fill mode
   gDiv.style.animation = "anim1 linear 20s, anim2 linear 20s, anim3 linear 10s";
   yield waitForPaintsFlushed();
     omta_is("transform", { tx: 82 }, RunningOn.Compositor,
             "anim1 + anim2 + anim3, translate at 11s with fill mode");
-    // Bug 980769 - We should get 0.9 but instead 
-    todo_is(SpecialPowers.DOMWindowUtils.getOMTAStyle(gDiv, "opacity"), "0.9",
-            "anim1 + anim2 + anim3, opacity at 11s");
+    is(SpecialPowers.DOMWindowUtils.getOMTAStyle(gDiv, "opacity"), "0.9",
+       "anim1 + anim2 + anim3, opacity at 11s");
   done_div();
 });
 
 /*
  * css3-animations:  3. Keyframes
  * http://dev.w3.org/csswg/css3-animations/#keyframes
  */
 
@@ -1522,19 +1515,18 @@ addAsyncAnimTest(function *() {
           "transform: translate(200px)");
   yield waitForPaintsFlushed();
   omta_is("transform", { tx: 50 }, RunningOn.Compositor,
           "animations override regular author rules");
   done_div();
   new_div("animation: always_fifty 1s linear infinite; " +
           "transform: translate(200px) ! important;");
   yield waitForPaintsFlushed();
-  // Bug 847287 - off main thread animations don't cascade correctly
-  omta_todo_is("transform", { tx: 200 }, RunningOn.TodoMainThread,
-               "important author rules override animations");
+  omta_is("transform", { tx: 200 }, RunningOn.MainThread,
+          "important author rules override animations");
   done_div();
 });
 
 // Test interaction of animations and restyling (Bug 686656).
 // This test depends on kf3 getting its 0% and 100% values from the
 // rules below it in the cascade; we're checking that the animation
 // isn't rebuilt when the restyles happen.
 addAsyncAnimTest(function *() {
@@ -1716,21 +1708,19 @@ addAsyncAnimTest(function *() {
   omta_is("transform", { ty: 25 }, RunningOn.Compositor,
           "animation-name list length is the length that matters");
   done_div();
   new_div("animation-name: anim2, anim4, anim2; " +
           "animation-duration: 1s; " +
           "animation-timing-function: linear; " +
           "animation-delay: -250ms, -250ms, -750ms, -500ms;");
   yield waitForPaintsFlushed();
-  // Bug 980769 -  off main thread animations incorrectly handle multiple
-  // animations of the same property and element
-  omta_todo_is("opacity", 0.75, RunningOn.Compositor,
-               "animation-name list length is the length that matters, " +
-               "and the last occurrence of a name wins");
+  omta_is("opacity", 0.75, RunningOn.Compositor,
+          "animation-name list length is the length that matters, " +
+          "and the last occurrence of a name wins");
   omta_is("transform", { ty: 25 }, RunningOn.Compositor,
           "animation-name list length is the length that matters");
   done_div();
 });
 
 addAsyncAnimTest(function *() {
   var dyn_sheet_elt = document.createElement("style");
   document.head.appendChild(dyn_sheet_elt);
