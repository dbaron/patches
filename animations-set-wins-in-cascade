From: L. David Baron <dbaron@dbaron.org>

Bug 847287 patch 4 - Set mWinsInCascade for CSS Animations.

diff --git a/dom/animation/Animation.h b/dom/animation/Animation.h
--- a/dom/animation/Animation.h
+++ b/dom/animation/Animation.h
@@ -125,19 +125,22 @@ struct AnimationProperty
   // Does this property win in the CSS Cascade?
   //
   // For CSS transitions, this is true as long as a CSS animation on the
   // same property and element is not running, in which case we set this
   // to false so that the animation (lower in the cascade) can win.  We
   // then use this to decide whether to apply the style both in the CSS
   // cascade and for OMTA.
   //
-  // FIXME (bug 847287): For CSS Animations, which are overridden by
-  // !important rules in the cascade, we actually determine this from
-  // the CSS cascade computations, and then use it for OMTA.
+  // For CSS Animations, which are overridden by !important rules in the
+  // cascade, we actually determine this from the CSS cascade
+  // computations, and then use it for OMTA.
+  // **NOTE**: For CSS animations, we only bother setting mWinsInCascade
+  // accurately for properties that we can animate on the compositor.
+  // For other properties, we make it always be true.
   bool mWinsInCascade;
 
   InfallibleTArray<AnimationPropertySegment> mSegments;
 };
 
 struct ElementPropertyTransition;
 
 namespace dom {
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -360,16 +360,18 @@ nsAnimationManager::CheckAnimationRule(n
   collection->mNeedsRefreshes = true;
   collection->Tick();
 
   // Cancel removed animations
   for (size_t newPlayerIdx = newPlayers.Length(); newPlayerIdx-- != 0; ) {
     newPlayers[newPlayerIdx]->Cancel();
   }
 
+  // FIXME: Update mWinsInCascade for the properties that we need to update.
+
   TimeStamp refreshTime = mPresContext->RefreshDriver()->MostRecentRefresh();
   UpdateStyleAndEvents(collection, refreshTime,
                        EnsureStyleRule_IsNotThrottled);
   // We don't actually dispatch the mPendingEvents now.  We'll either
   // dispatch them the next time we get a refresh driver notification
   // or the next time somebody calls
   // nsPresShell::FlushPendingNotifications.
   if (!mPendingEvents.IsEmpty()) {
