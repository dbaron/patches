From: L. David Baron <dbaron@dbaron.org>

Bug 847287 patch 4 - Set mWinsInCascade for CSS Animations.

diff --git a/dom/animation/Animation.h b/dom/animation/Animation.h
--- a/dom/animation/Animation.h
+++ b/dom/animation/Animation.h
@@ -125,19 +125,22 @@ struct AnimationProperty
   // Does this property win in the CSS Cascade?
   //
   // For CSS transitions, this is true as long as a CSS animation on the
   // same property and element is not running, in which case we set this
   // to false so that the animation (lower in the cascade) can win.  We
   // then use this to decide whether to apply the style both in the CSS
   // cascade and for OMTA.
   //
-  // FIXME (bug 847287): For CSS Animations, which are overridden by
-  // !important rules in the cascade, we actually determine this from
-  // the CSS cascade computations, and then use it for OMTA.
+  // For CSS Animations, which are overridden by !important rules in the
+  // cascade, we actually determine this from the CSS cascade
+  // computations, and then use it for OMTA.
+  // **NOTE**: For CSS animations, we only bother setting mWinsInCascade
+  // accurately for properties that we can animate on the compositor.
+  // For other properties, we make it always be true.
   bool mWinsInCascade;
 
   InfallibleTArray<AnimationPropertySegment> mSegments;
 };
 
 struct ElementPropertyTransition;
 
 namespace dom {
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -360,16 +360,18 @@ nsAnimationManager::CheckAnimationRule(n
   collection->mNeedsRefreshes = true;
   collection->Tick();
 
   // Cancel removed animations
   for (size_t newPlayerIdx = newPlayers.Length(); newPlayerIdx-- != 0; ) {
     newPlayers[newPlayerIdx]->Cancel();
   }
 
+  UpdateCascadeResults(aStyleContext, collection);
+
   TimeStamp refreshTime = mPresContext->RefreshDriver()->MostRecentRefresh();
   UpdateStyleAndEvents(collection, refreshTime,
                        EnsureStyleRule_IsNotThrottled);
   // We don't actually dispatch the mPendingEvents now.  We'll either
   // dispatch them the next time we get a refresh driver notification
   // or the next time somebody calls
   // nsPresShell::FlushPendingNotifications.
   if (!mPendingEvents.IsEmpty()) {
@@ -675,16 +677,74 @@ nsAnimationManager::BuildSegment(Infalli
   } else {
     tf = &aAnimation.GetTimingFunction();
   }
   segment.mTimingFunction.Init(*tf);
 
   return true;
 }
 
+void
+nsAnimationManager::UpdateCascadeResults(
+                      nsStyleContext* aStyleContext,
+                      AnimationPlayerCollection* aElementAnimations)
+{
+  /*
+   * Figure out which properties we need to examine.
+   */
+
+  // size of 2 since we only currently have 2 properties we animate on
+  // the compositor
+  nsAutoTArray<nsCSSProperty, 2> propertiesToTrack;
+
+  {
+    nsCSSPropertySet propertiesToTrackAsSet;
+
+    for (size_t playerIdx = mPlayers.Length(); playerIdx-- != 0; ) {
+      const AnimationPlayer* player = mPlayers[playerIdx];
+      const Animation* anim = player->GetSource();
+      if (!anim) {
+        continue;
+      }
+
+      for (size_t propIdx = 0, propEnd = anim->Properties().Length();
+           propIdx != propEnd; ++propIdx) {
+        const AnimationProperty& prop = anim->Properties()[propIdx];
+        // We only bother setting mWinsInCascade for properties that we
+        // can animate on the compositor.
+        if (nsCSSProp::PropHasFlags(prop.mProperty,
+                                    CSS_PROPERTY_CAN_ANIMATE_ON_COMPOSITOR)) {
+          if (!propertiesToTrackAsSet.HasProperty(prop.mProperty)) {
+            propertiesToTrack.AppendElement(prop.mProperty);
+            propertiesToTrackAsSet.AddProperty(prop.mProperty);
+          }
+        }
+      }
+    }
+  }
+
+  /*
+   * Determine whether those properties are set in things that
+   * override animations.
+   */
+
+  nsCSSPropertySet propertiesOverridden;
+  nsRuleNode::ComputePropertiesOverridingAnimation(propertiesToTrack,
+                                                   aStyleContext,
+                                                   propertiesOverridden);
+
+  /*
+   * Set mWinsInCascade based both on what is overridden at levels
+   * higher than animations and based on one animation overriding
+   * another.
+   */
+
+  // FIXME: WRITE ME
+}
+
 /* virtual */ void
 nsAnimationManager::WillRefresh(mozilla::TimeStamp aTime)
 {
   MOZ_ASSERT(mPresContext,
              "refresh driver should not notify additional observers "
              "after pres context has been destroyed");
   if (!mPresContext->GetPresShell()) {
     // Someone might be keeping mPresContext alive past the point
