From: L. David Baron <dbaron@dbaron.org>

Bug 1125455 patch 4 - For main-thread application of transitions, don't apply transitions when animations are also running.

I've verified locally that this patch (not others in this series) fixes
the test failures that match the test changes in this patch.

diff --git a/dom/animation/Animation.cpp b/dom/animation/Animation.cpp
--- a/dom/animation/Animation.cpp
+++ b/dom/animation/Animation.cpp
@@ -292,16 +292,26 @@ Animation::ComposeStyle(nsRefPtr<css::An
     if (aSetProperties.HasProperty(prop.mProperty)) {
       // Animations are composed by AnimationPlayerCollection by iterating
       // from the last animation to first. For animations targetting the
       // same property, the later one wins. So if this property is already set,
       // we should not override it.
       continue;
     }
 
+    if (!prop.mWinsInCascade) {
+      // This isn't the winning declaration, so don't add it to style.
+      // For transitions, this is important, because it's how we
+      // implement the rule that CSS transitions don't run when a CSS
+      // animation is running on the same property and element.  For
+      // animations, this is only skipping this that will otherwise be
+      // overridden.
+      continue;
+    }
+
     aSetProperties.AddProperty(prop.mProperty);
 
     MOZ_ASSERT(prop.mSegments.Length() > 0,
                "property should not be in animations if it has no segments");
 
     // FIXME: Maybe cache the current segment?
     const AnimationPropertySegment *segment = prop.mSegments.Elements(),
                                 *segmentEnd = segment + prop.mSegments.Length();
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -643,28 +643,39 @@ nsTransitionManager::UpdateCascadeResult
   // transitions do not apply when the same property has a CSS Animation
   // on that element (even though animations are lower in the cascade).
   aAnimations->mStyleRule->AddPropertiesToSet(propertiesUsed);
 
   // Since we should never have more than one transition for the same
   // property, it doesn't matter what order we iterate the transitions.
   // But let's go the same way as animations.
   AnimationPlayerPtrArray& players = aTransitions->mPlayers;
+  bool changed = false;
   for (size_t playerIdx = players.Length(); playerIdx-- != 0; ) {
     MOZ_ASSERT(players[playerIdx]->GetSource() &&
                players[playerIdx]->GetSource()->Properties().Length() == 1,
                "Should have one animation property for a transition");
     AnimationProperty& prop = players[playerIdx]->GetSource()->Properties()[0];
-    prop.mWinsInCascade = !propertiesUsed.HasProperty(prop.mProperty);
+    bool newWinsInCascade = !propertiesUsed.HasProperty(prop.mProperty);
+    if (prop.mWinsInCascade != newWinsInCascade) {
+      changed = true;
+    }
+    prop.mWinsInCascade = newWinsInCascade;
 #ifdef DEBUG
     MOZ_ASSERT(!propertiesWithTransitions.HasProperty(prop.mProperty),
                "we're assuming we have only one transition per property");
     propertiesWithTransitions.AddProperty(prop.mProperty);
 #endif
   }
+
+  if (changed) {
+    // Invalidate our style rule.
+    aTransitions->mStyleRuleRefreshTime = TimeStamp();
+    aTransitions->mNeedsRefreshes = true;
+  }
 }
 
 /*
  * nsIStyleRuleProcessor implementation
  */
 
 /* virtual */ size_t
 nsTransitionManager::SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const
diff --git a/layout/style/test/test_animations.html b/layout/style/test/test_animations.html
--- a/layout/style/test/test_animations.html
+++ b/layout/style/test/test_animations.html
@@ -1980,19 +1980,19 @@ done_div();
 new_div("transition: opacity 2s linear; opacity: 0.8");
 advance_clock(0);
 is(cs.getPropertyValue("opacity"), "0.8", "initial opacity");
 div.style.opacity = "0.2";
 is(cs.getPropertyValue("opacity"), "0.8", "opacity transition at 0s");
 advance_clock(500);
 is(cs.getPropertyValue("opacity"), "0.65", "opacity transition at 0.5s");
 div.style.animation = "opacitymid 2s linear";
-todo_is(cs.getPropertyValue("opacity"), "0.2", "opacity animation overriding transition at 0s");
+is(cs.getPropertyValue("opacity"), "0.2", "opacity animation overriding transition at 0s");
 advance_clock(500);
-todo_is(cs.getPropertyValue("opacity"), "0.35", "opacity animation overriding transition at 0.5s");
+is(cs.getPropertyValue("opacity"), "0.35", "opacity animation overriding transition at 0.5s");
 done_div();
 
 SpecialPowers.DOMWindowUtils.restoreNormalRefresh();
 
 </script>
 </pre>
 </body>
 </html>
diff --git a/layout/style/test/test_animations_omta.html b/layout/style/test/test_animations_omta.html
--- a/layout/style/test/test_animations_omta.html
+++ b/layout/style/test/test_animations_omta.html
@@ -2082,22 +2082,18 @@ addAsyncAnimTest(function *() {
   yield waitForPaintsFlushed();
   omta_is("opacity", 0.8, RunningOn.Compositor,
           "opacity transition at 0s");
   advance_clock(500);
   omta_is("opacity", 0.65, RunningOn.Compositor,
           "opacity transition at 0.5s");
   gDiv.style.animation = "opacitymid 2s linear";
   yield waitForPaintsFlushed();
-  // FIXME: This omta_todo_is leads to a failure, since the compositor
-  // vs. main-thread check actually passes.
   omta_todo_is("opacity", 0.2, RunningOn.Compositor,
           "opacity animation overriding transition at 0s");
   advance_clock(500);
-  // FIXME: This omta_todo_is leads to a failure, since the compositor
-  // vs. main-thread check actually passes.
   omta_todo_is("opacity", 0.35, RunningOn.Compositor,
           "opacity animation overriding transition at 0.5s");
   done_div();
 });
 
 </script>
 </html>
