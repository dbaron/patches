Do Windows stack traces on the thread whose stack is being traced rather than creating a separate thread.

diff --git a/xpcom/base/nsStackFrameWin.cpp b/xpcom/base/nsStackFrameWin.cpp
--- a/xpcom/base/nsStackFrameWin.cpp
+++ b/xpcom/base/nsStackFrameWin.cpp
@@ -478,46 +478,15 @@ NS_StackWalk(NS_WalkStackCallback aCallb
     data.closure = aClosure;
     data.thread = myThread;
     data.process = myProcess;
-    walkerThread = ::CreateThread( NULL, 0, WalkStackThread, (LPVOID) &data, 0, NULL ) ;
-    if (walkerThread) {
-        walkerReturn = ::WaitForSingleObject(walkerThread, 2000); // no timeout is never a good idea
-        if (walkerReturn != WAIT_OBJECT_0) {
-            PrintError("ThreadWait");
-        }
-        ::CloseHandle(walkerThread);
-    }
-    else {
-        PrintError("ThreadCreate");
-    }
+
+    if (_StackWalk64)
+        WalkStackMain64(&data);
+    else
+        WalkStackMain(&data);
+
     ::CloseHandle(myThread);
     ::CloseHandle(myProcess);
     return NS_OK;
-}
-
-DWORD WINAPI
-WalkStackThread(LPVOID lpdata)
-{
-    struct WalkStackData *data = (WalkStackData *)lpdata;
-    DWORD ret ;
-
-    // Suspend the calling thread, dump his stack, and then resume him.
-    // He's currently waiting for us to finish so now should be a good time.
-    ret = ::SuspendThread( data->thread );
-    if (ret == -1) {
-        PrintError("ThreadSuspend");
-    }
-    else {
-        if (_StackWalk64)
-            WalkStackMain64(data);
-        else
-            WalkStackMain(data);
-        ret = ::ResumeThread(data->thread);
-        if (ret == -1) {
-            PrintError("ThreadResume");
-        }
-    }
-
-    return 0;
 }
 
 void
