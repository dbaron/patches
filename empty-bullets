From: L. David Baron <dbaron@dbaron.org>

Make empty bullets (i.e., those for list-style-type:none) not contribute to layout.  (Bug 512631)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1036,18 +1036,20 @@ nsBlockFrame::Reflow(nsPresContext*     
     // this line was its bullet (in terms of the size **and emptiness**
     // changes associated with all three ReflowBullet calls; see the
     // other patches in bug 179596).
     nsLayoutUtils::LinePosition position;
     PRBool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
     nscoord lineTop = havePosition ? position.mTop
                                    : aReflowState.mComputedBorderPadding.top;
     ReflowBullet(state, metrics, lineTop);
-
-    if (havePosition) {
+    NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,
+                 "empty bullet took up space");
+
+    if (havePosition && !BulletIsEmpty()) {
       // We have some lines to align the bullet with.  
 
       // Doing the alignment using the baseline will also cater for
       // bullets that are placed next to a child block (bug 92896)
     
       // Tall bullets won't look particularly nice here...
       nsRect bbox = mBullet->GetRect();
       bbox.y = position.mBaseline - metrics.ascent;
@@ -2204,40 +2206,44 @@ nsBlockFrame::ReflowDirtyLines(nsBlockRe
     } //XXXfr shouldn't set this flag when nextinflow has no lines
   }
 
   // Handle an odd-ball case: a list-item with no lines
   if (mBullet && HaveOutsideBullet() && mLines.empty()) {
     nsHTMLReflowMetrics metrics;
     ReflowBullet(aState, metrics,
                  aState.mReflowState.mComputedBorderPadding.top);
-
-    // There are no lines so we have to fake up some y motion so that
-    // we end up with *some* height.
-
-    if (metrics.ascent == nsHTMLReflowMetrics::ASK_FOR_BASELINE &&
-        !nsLayoutUtils::GetFirstLineBaseline(mBullet, &metrics.ascent)) {
-      metrics.ascent = metrics.height;
-    }
-
-    nsIRenderingContext *rc = aState.mReflowState.rendContext;
-    nsLayoutUtils::SetFontFromStyle(rc, GetStyleContext());
-    nsCOMPtr<nsIFontMetrics> fm;
-    rc->GetFontMetrics(*getter_AddRefs(fm));
-
-    nscoord minAscent =
-      nsLayoutUtils::GetCenteredFontBaseline(fm, aState.mMinLineHeight);
-    nscoord minDescent = aState.mMinLineHeight - minAscent;
-
-    aState.mY += PR_MAX(minAscent, metrics.ascent) +
-                 PR_MAX(minDescent, metrics.height - metrics.ascent);
-
-    nscoord offset = minAscent - metrics.ascent;
-    if (offset > 0) {
-      mBullet->SetRect(mBullet->GetRect() + nsPoint(0, offset));
+    NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,
+                 "empty bullet took up space");
+
+    if (!BulletIsEmpty()) {
+      // There are no lines so we have to fake up some y motion so that
+      // we end up with *some* height.
+
+      if (metrics.ascent == nsHTMLReflowMetrics::ASK_FOR_BASELINE &&
+          !nsLayoutUtils::GetFirstLineBaseline(mBullet, &metrics.ascent)) {
+        metrics.ascent = metrics.height;
+      }
+
+      nsIRenderingContext *rc = aState.mReflowState.rendContext;
+      nsLayoutUtils::SetFontFromStyle(rc, GetStyleContext());
+      nsCOMPtr<nsIFontMetrics> fm;
+      rc->GetFontMetrics(*getter_AddRefs(fm));
+
+      nscoord minAscent =
+        nsLayoutUtils::GetCenteredFontBaseline(fm, aState.mMinLineHeight);
+      nscoord minDescent = aState.mMinLineHeight - minAscent;
+
+      aState.mY += PR_MAX(minAscent, metrics.ascent) +
+                   PR_MAX(minDescent, metrics.height - metrics.ascent);
+
+      nscoord offset = minAscent - metrics.ascent;
+      if (offset > 0) {
+        mBullet->SetRect(mBullet->GetRect() + nsPoint(0, offset));
+      }
     }
   }
 
   if (foundAnyClears) {
     AddStateBits(NS_BLOCK_HAS_CLEAR_CHILDREN);
   } else {
     RemoveStateBits(NS_BLOCK_HAS_CLEAR_CHILDREN);
   }
@@ -2738,17 +2744,17 @@ nsBlockFrame::IsSelfEmpty()
       border->GetActualBorderWidth(NS_SIDE_BOTTOM) != 0 ||
       !IsPaddingZero(padding->mPadding.GetTopUnit(),
                      padding->mPadding.GetTop()) ||
       !IsPaddingZero(padding->mPadding.GetBottomUnit(),
                      padding->mPadding.GetBottom())) {
     return PR_FALSE;
   }
 
-  if (HaveOutsideBullet()) {
+  if (HaveOutsideBullet() && !BulletIsEmpty()) {
     return PR_FALSE;
   }
 
   return PR_TRUE;
 }
 
 PRBool
 nsBlockFrame::CachedIsEmpty()
@@ -4119,16 +4125,18 @@ nsBlockFrame::PlaceLine(nsBlockReflowSta
   if (mBullet && HaveOutsideBullet() &&
       ((aLine == mLines.front() &&
         (!aLineLayout.IsZeroHeight() || (aLine == mLines.back()))) ||
        (mLines.front() != mLines.back() &&
         0 == mLines.front()->mBounds.height &&
         aLine == mLines.begin().next()))) {
     nsHTMLReflowMetrics metrics;
     ReflowBullet(aState, metrics, aState.mY);
+    NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,
+                 "empty bullet took up space");
     aLineLayout.AddBulletFrame(mBullet, metrics);
     addedBullet = PR_TRUE;
   }
   aLineLayout.VerticalAlignLine();
 
   // We want to compare to the available space that we would have had in
   // the line's height *before* we placed any floats in the line itself.
   // Floats that are in the line are handled during line reflow (and may
@@ -6219,37 +6227,40 @@ NS_IMETHODIMP nsBlockFrame::GetAccessibl
 
   return accService->CreateHTMLLIAccessible(static_cast<nsIFrame*>(this), 
                                             static_cast<nsIFrame*>(mBullet), 
                                             bulletText,
                                             aAccessible);
 }
 #endif
 
-void nsBlockFrame::ClearLineCursor() {
+void nsBlockFrame::ClearLineCursor()
+{
   if (!(GetStateBits() & NS_BLOCK_HAS_LINE_CURSOR)) {
     return;
   }
 
   UnsetProperty(nsGkAtoms::lineCursorProperty);
   RemoveStateBits(NS_BLOCK_HAS_LINE_CURSOR);
 }
 
-void nsBlockFrame::SetupLineCursor() {
+void nsBlockFrame::SetupLineCursor()
+{
   if (GetStateBits() & NS_BLOCK_HAS_LINE_CURSOR
       || mLines.empty()) {
     return;
   }
    
   SetProperty(nsGkAtoms::lineCursorProperty,
               mLines.front(), nsnull);
   AddStateBits(NS_BLOCK_HAS_LINE_CURSOR);
 }
 
-nsLineBox* nsBlockFrame::GetFirstLineContaining(nscoord y) {
+nsLineBox* nsBlockFrame::GetFirstLineContaining(nscoord y)
+{
   if (!(GetStateBits() & NS_BLOCK_HAS_LINE_CURSOR)) {
     return nsnull;
   }
 
   nsLineBox* property = static_cast<nsLineBox*>
                                    (GetProperty(nsGkAtoms::lineCursorProperty));
   line_iterator cursor = mLines.begin(property);
   nsRect cursorArea = cursor->GetCombinedArea();
@@ -6421,16 +6432,27 @@ nsBlockFrame::SetInitialChildList(nsIAto
 
       mBullet = bullet;
     }
   }
 
   return NS_OK;
 }
 
+PRBool
+nsBlockFrame::BulletIsEmpty() const
+{
+  NS_ASSERTION(GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_LIST_ITEM &&
+               HaveOutsideBullet(),
+               "should only care when we have an outside bullet");
+  const nsStyleList* list = GetStyleList();
+  return list->mListStyleType == NS_STYLE_LIST_STYLE_NONE &&
+         !list->mListStyleImage;
+}
+
 // static
 PRBool
 nsBlockFrame::FrameStartsCounterScope(nsIFrame* aFrame)
 {
   nsIContent* content = aFrame->GetContent();
   if (!content || !content->IsNodeOfType(nsINode::eHTML))
     return PR_FALSE;
 
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -229,16 +229,21 @@ public:
 
   virtual void ChildIsDirty(nsIFrame* aChild);
   virtual PRBool IsVisibleInSelection(nsISelection* aSelection);
 
   virtual PRBool IsEmpty();
   virtual PRBool CachedIsEmpty();
   virtual PRBool IsSelfEmpty();
 
+  // Given that we have a bullet, does it actually draw something, i.e.,
+  // do we have either a 'list-style-type' or 'list-style-image' that is
+  // not 'none'?
+  PRBool BulletIsEmpty() const;
+
   virtual void MarkIntrinsicWidthsDirty();
   virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);
   virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext);
 
   virtual nsRect ComputeTightBounds(gfxContext* aContext) const;
   
   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
                     nsHTMLReflowMetrics&     aDesiredSize,
diff --git a/layout/generic/nsLineBox.h b/layout/generic/nsLineBox.h
--- a/layout/generic/nsLineBox.h
+++ b/layout/generic/nsLineBox.h
@@ -494,17 +494,17 @@ public:
     PRUint32 mBlock : 1;
     PRUint32 mImpactedByFloat : 1;
     PRUint32 mLineWrapped: 1;
     PRUint32 mInvalidateTextRuns : 1;
     PRUint32 mResizeReflowOptimizationDisabled: 1;  // default 0 = means that the opt potentially applies to this line. 1 = never skip reflowing this line for a resize reflow
     PRUint32 mEmptyCacheValid: 1;
     PRUint32 mEmptyCacheState: 1;
     // mHasBullet indicates that this is an inline line whose block's
-    // bullet is adjacent to this line.
+    // bullet is adjacent to this line and non-empty.
     PRUint32 mHasBullet : 1;
     PRUint32 mBreakType : 4;
 
     PRUint32 mChildCount : 17;
   };
 
   struct ExtraData {
     ExtraData(const nsRect& aBounds) : mCombinedArea(aBounds) {
diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -1327,18 +1327,24 @@ nsLineLayout::PlaceFrame(PerFrameData* p
 
 nsresult
 nsLineLayout::AddBulletFrame(nsIFrame* aFrame,
                              const nsHTMLReflowMetrics& aMetrics)
 {
   NS_ASSERTION(mCurrentSpan == mRootSpan, "bad linelayout user");
   NS_ASSERTION(GetFlag(LL_GOTLINEBOX), "must have line box");
 
-  SetFlag(LL_HASBULLET, PR_TRUE);
-  mLineBox->SetHasBullet();
+
+  nsIFrame *blockFrame = mBlockReflowState->frame;
+  NS_ASSERTION(blockFrame->IsFrameOfType(nsIFrame::eBlockFrame),
+               "must be for block");
+  if (!static_cast<nsBlockFrame*>(blockFrame)->BulletIsEmpty()) {
+    SetFlag(LL_HASBULLET, PR_TRUE);
+    mLineBox->SetHasBullet();
+  }
 
   PerFrameData* pfd;
   nsresult rv = NewPerFrameData(&pfd);
   if (NS_SUCCEEDED(rv)) {
     mRootSpan->AppendFrame(pfd);
     pfd->mFrame = aFrame;
     pfd->mMargin.SizeTo(0, 0, 0, 0);
     pfd->mBorderPadding.SizeTo(0, 0, 0, 0);
diff --git a/layout/reftests/bugs/512631-1-ref.html b/layout/reftests/bugs/512631-1-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/512631-1-ref.html
@@ -0,0 +1,25 @@
+<!DOCTYPE HTML>
+<html lang="en">
+<head>
+<style type="text/css">
+html {
+	color: rgb(10,10,10);
+	background: rgb(150,150,150);
+	
+	font-family:sans-serif;
+	}
+ul, li { display: block; }
+a {display:block; float:left; width:100px; height:50px; text-align:center; background: #ccc;}
+
+</style>
+
+<title>test</title>
+</head>
+<body>
+<ul>
+<li><a href="/">abc</a></li>
+<li><a href="/">abc</a></li>
+<li><a href="/">abc</a></li>
+</ul>
+</body>
+</html>
diff --git a/layout/reftests/bugs/512631-1.html b/layout/reftests/bugs/512631-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/512631-1.html
@@ -0,0 +1,25 @@
+<!DOCTYPE HTML>
+<html lang="en">
+<head>
+<style type="text/css">
+html {
+	color: rgb(10,10,10);
+	background: rgb(150,150,150);
+	
+	font-family:sans-serif;
+	}
+ul {list-style:none;}
+a {display:block; float:left; width:100px; height:50px; text-align:center; background: #ccc;}
+
+</style>
+
+<title>test</title>
+</head>
+<body>
+<ul>
+<li><a href="/">abc</a></li>
+<li><a href="/">abc</a></li>
+<li><a href="/">abc</a></li>
+</ul>
+</body>
+</html>
diff --git a/layout/reftests/bugs/reftest.list b/layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list
+++ b/layout/reftests/bugs/reftest.list
@@ -1316,13 +1316,14 @@ fails-if(MOZ_WIDGET_TOOLKIT!="cocoa") ==
 == 504032-1.html 504032-1-ref.html
 == 505743-1.html about:blank
 == 506481-1.html 506481-1-ref.html
 == 507187-1.html 507187-1-ref.html
 == 507487-1.html 507487-1-ref.html
 == 507487-2.xhtml 507487-2-ref.xhtml
 == 508919-1.xhtml 508919-1-ref.xhtml
 == 509155-1.xhtml 509155-1-ref.xhtml
+== 512410.html 512410-ref.html
+== 512631-1.html 512631-1-ref.html
 == 513153-1a.html 513153-1-ref.html
 == 513153-1b.html 513153-1-ref.html
 == 513153-2a.html 513153-2-ref.html
 == 513153-2b.html 513153-2-ref.html
-== 512410.html 512410-ref.html
