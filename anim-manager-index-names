From: L. David Baron <dbaron@dbaron.org>

Use saner index names in nsAnimationManager.

diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -181,18 +181,18 @@ ElementAnimations::EnsureStyleRuleFor(Ti
     mStyleRule = nsnull;
 
     // FIXME(spec): assume that properties in higher animations override
     // those in lower ones (and that our |HasProperty| check in
     // |BuildSegment| matches the definition of when they should do so.
     // Therefore, we iterate from last animation to first.
     nsCSSPropertySet properties;
 
-    for (PRUint32 i = mAnimations.Length(); i-- != 0; ) {
-      ElementAnimation &anim = mAnimations[i];
+    for (PRUint32 animIdx = mAnimations.Length(); animIdx-- != 0; ) {
+      ElementAnimation &anim = mAnimations[animIdx];
 
       if (anim.mSegments.Length() == 0 ||
           anim.mIterationDuration.ToMilliseconds() <= 0.0) {
         // No animation data.
         continue;
       }
 
       TimeDuration currentTimeDuration;
@@ -309,19 +309,19 @@ ElementAnimations::EnsureStyleRuleFor(Ti
         mStyleRule = new css::AnimValuesStyleRule();
       }
 
       double positionInSegment = (positionInIteration - segment->mFromKey) /
                                  (segment->mToKey - segment->mFromKey);
       double valuePosition =
         segment->mTimingFunction.GetValue(positionInSegment);
 
-      for (PRUint32 j = 0, j_end = segment->mProperties.Length();
-           j != j_end; ++j) {
-        const AnimationSegmentProperty &prop = segment->mProperties[j];
+      for (PRUint32 propIdx = 0, propEnd = segment->mProperties.Length();
+           propIdx != propEnd; ++propIdx) {
+        const AnimationSegmentProperty &prop = segment->mProperties[propIdx];
         if (properties.HasProperty(prop.mProperty)) {
           // A later animation already set this property.
           continue;
         }
         properties.AddProperty(prop.mProperty);
 
         nsStyleAnimation::Value *val =
           mStyleRule->AddEmptyValue(prop.mProperty);
@@ -471,31 +471,31 @@ nsAnimationManager::CheckAnimationRule(n
       // This means that we honor dynamic changes, which isn't what the
       // spec says to do, but WebKit seems to honor at least some of
       // them.  See
       // http://lists.w3.org/Archives/Public/www-style/2011Apr/0079.html
       // In order to honor what the spec said, we'd copy more data over
       // (or potentially optimize BuildAnimations to avoid rebuilding it
       // in the first place).
       if (!ea->mAnimations.IsEmpty()) {
-        for (PRUint32 i = 0, i_end = newAnimations.Length();
-             i != i_end; ++i) {
-          ElementAnimation *newAnim = &newAnimations[i];
+        for (PRUint32 newIdx = 0, newEnd = newAnimations.Length();
+             newIdx != newEnd; ++newIdx) {
+          ElementAnimation *newAnim = &newAnimations[newIdx];
 
           // Find the matching animation with this name in the old list
           // of animations.  Because of this code, they must all have
           // the same start time, though they might differ in pause
           // state.  So if a page uses multiple copies of the same
           // animation in one element's animation list, and gives them
           // different pause states, they, well, get what they deserve.
           // We'll use the last one since it's more likely to be the one
           // doing something.
           const ElementAnimation *oldAnim = nsnull;
-          for (PRUint32 j = ea->mAnimations.Length(); j-- != 0; ) {
-            const ElementAnimation *a = &ea->mAnimations[j];
+          for (PRUint32 oldIdx = ea->mAnimations.Length(); oldIdx-- != 0; ) {
+            const ElementAnimation *a = &ea->mAnimations[oldIdx];
             if (a->mName == newAnim->mName) {
               oldAnim = a;
               break;
             }
           }
           if (!oldAnim) {
             continue;
           }
@@ -628,18 +628,19 @@ nsAnimationManager::BuildAnimations(nsSt
                                     InfallibleTArray<ElementAnimation>& aAnimations)
 {
   NS_ABORT_IF_FALSE(aAnimations.IsEmpty(), "expect empty array");
 
   ResolvedStyleCache resolvedStyles;
 
   const nsStyleDisplay *disp = aStyleContext->GetStyleDisplay();
   TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
-  for (PRUint32 i = 0, i_end = disp->mAnimations.Length(); i != i_end; ++i) {
-    const nsAnimation& aSrc = disp->mAnimations[i];
+  for (PRUint32 animIdx = 0, animEnd = disp->mAnimations.Length();
+       animIdx != animEnd; ++animIdx) {
+    const nsAnimation& aSrc = disp->mAnimations[animIdx];
     ElementAnimation& aDest = *aAnimations.AppendElement();
 
     aDest.mName = aSrc.GetName();
     aDest.mIterationCount = aSrc.GetIterationCount();
     aDest.mDirection = aSrc.GetDirection();
     aDest.mFillMode = aSrc.GetFillMode();
     aDest.mPlayState = aSrc.GetPlayState();
 
@@ -658,26 +659,28 @@ nsAnimationManager::BuildAnimations(nsSt
       continue;
     }
 
     // Build the set of unique keyframes in the @keyframes rule.  Per
     // css3-animations, later keyframes with the same key replace
     // earlier ones (no cascading).
     nsDataHashtable<PercentageHashKey, nsCSSKeyframeRule*> keyframes;
     keyframes.Init(16); // FIXME: make infallible!
-    for (PRUint32 j = 0, j_end = rule->StyleRuleCount(); j != j_end; ++j) {
-      nsICSSRule* cssRule = rule->GetStyleRuleAt(j);
+    for (PRUint32 ruleIdx = 0, ruleEnd = rule->StyleRuleCount();
+         ruleIdx != ruleEnd; ++ruleIdx) {
+      nsICSSRule* cssRule = rule->GetStyleRuleAt(ruleIdx);
       NS_ABORT_IF_FALSE(cssRule, "must have rule");
       NS_ABORT_IF_FALSE(cssRule->GetType() == nsICSSRule::KEYFRAME_RULE,
                         "must be keyframe rule");
       nsCSSKeyframeRule *kfRule = static_cast<nsCSSKeyframeRule*>(cssRule);
 
       const nsTArray<float> &keys = kfRule->GetKeys();
-      for (PRUint32 k = 0, k_end = keys.Length(); k != k_end; ++k) {
-        float key = keys[k];
+      for (PRUint32 keyIdx = 0, keyEnd = keys.Length();
+           keyIdx != keyEnd; ++keyIdx) {
+        float key = keys[keyIdx];
         // FIXME (spec):  The spec doesn't say what to do with
         // out-of-range keyframes.  We'll ignore them.
         // (And PercentageHashKey currently assumes we either ignore or
         // clamp them.)
         if (0.0f <= key && key <= 1.0f) {
           keyframes.Put(key, kfRule);
         }
       }
@@ -700,18 +703,19 @@ nsAnimationManager::BuildAnimations(nsSt
     // If there's no rule for 0%, there's implicitly an empty rule.
     if (fromKeyframe.mKey != 0.0f) {
       BuildSegment(aDest.mSegments, aSrc,
                    0.0f, aStyleContext, nsnull,
                    fromKeyframe.mKey, fromContext,
                      fromKeyframe.mRule->Declaration());
     }
 
-    for (PRUint32 j = 1, j_end = sortedKeyframes.Length(); j != j_end; ++j) {
-      KeyframeData toKeyframe = sortedKeyframes[j];
+    for (PRUint32 kfIdx = 1, kfEnd = sortedKeyframes.Length();
+         kfIdx != kfEnd; ++kfIdx) {
+      KeyframeData toKeyframe = sortedKeyframes[kfIdx];
       nsRefPtr<nsStyleContext> toContext =
         resolvedStyles.Get(mPresContext, aStyleContext, toKeyframe.mRule);
 
       BuildSegment(aDest.mSegments, aSrc,
                    fromKeyframe.mKey, fromContext,
                    fromKeyframe.mRule->Declaration(),
                    toKeyframe.mKey, toContext,
                    toKeyframe.mRule->Declaration());
