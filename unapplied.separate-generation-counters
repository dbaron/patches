From: L. David Baron <dbaron@dbaron.org>

Bug 847286 - Use separate counters on the layer for the transition and animation generation.

TODO: Better names (since this means we now use mAnimationGeneration for
the general and the animation-specific cases

diff --git a/dom/animation/KeyframeEffect.cpp b/dom/animation/KeyframeEffect.cpp
--- a/dom/animation/KeyframeEffect.cpp
+++ b/dom/animation/KeyframeEffect.cpp
@@ -1797,17 +1797,17 @@ KeyframeEffectReadOnly::CanThrottle() co
 
     AnimationCollection* collection = GetCollection();
     MOZ_ASSERT(collection,
       "CanThrottle should be called on an effect associated with an animation");
     layers::Layer* layer =
       FrameLayerBuilder::GetDedicatedLayer(frame, record.mLayerType);
     // Unthrottle if the layer needs to be brought up to date with the animation.
     if (!layer ||
-        collection->mAnimationGeneration > layer->GetAnimationGeneration()) {
+        collection->mAnimationGeneration != (IsForTransitions() ? layer->GetTransitionGeneration() : layer->GetAnimationGeneration())) {
       return false;
     }
 
     // If this is a transform animation that affects the overflow region,
     // we should unthrottle the animation periodically.
     if (record.mProperty == eCSSProperty_transform &&
         !CanThrottleTransformChanges(*frame)) {
       return false;
diff --git a/gfx/layers/Layers.cpp b/gfx/layers/Layers.cpp
--- a/gfx/layers/Layers.cpp
+++ b/gfx/layers/Layers.cpp
@@ -247,17 +247,18 @@ Layer::Layer(LayerManager* aManager, voi
   mIsFixedPosition(false),
   mFixedPositionData(nullptr),
   mStickyPositionData(nullptr),
   mScrollbarTargetId(FrameMetrics::NULL_SCROLL_ID),
   mScrollbarDirection(ScrollDirection::NONE),
   mScrollbarThumbRatio(0.0f),
   mIsScrollbarContainer(false),
   mDebugColorIndex(0),
-  mAnimationGeneration(0)
+  mAnimationGeneration(0),
+  mTransitionGeneration(0)
 {
   MOZ_COUNT_CTOR(Layer);
 }
 
 Layer::~Layer()
 {
   MOZ_COUNT_DTOR(Layer);
 }
diff --git a/gfx/layers/Layers.h b/gfx/layers/Layers.h
--- a/gfx/layers/Layers.h
+++ b/gfx/layers/Layers.h
@@ -1320,16 +1320,18 @@ public:
 
   // Note that all lengths in animation data are either in CSS pixels or app
   // units and must be converted to device pixels by the compositor.
   AnimationArray& GetAnimations() { return mAnimations; }
   InfallibleTArray<AnimData>& GetAnimationData() { return mAnimationData; }
 
   uint64_t GetAnimationGeneration() { return mAnimationGeneration; }
   void SetAnimationGeneration(uint64_t aCount) { mAnimationGeneration = aCount; }
+  uint64_t GetTransitionGeneration() { return mTransitionGeneration; }
+  void SetTransitionGeneration(uint64_t aCount) { mTransitionGeneration = aCount; }
 
   bool HasTransformAnimation() const;
 
   /**
    * Returns the local transform for this layer: either mTransform or,
    * for shadow layers, GetShadowTransform()
    */
   const gfx::Matrix4x4 GetLocalTransform();
@@ -1815,16 +1817,17 @@ protected:
   // pixels of the scrollframe's parent's space) to the scroll position (in the
   // CSS pixels of the scrollframe's space).
   float mScrollbarThumbRatio;
   bool mIsScrollbarContainer;
   DebugOnly<uint32_t> mDebugColorIndex;
   // If this layer is used for OMTA, then this counter is used to ensure we
   // stay in sync with the animation manager
   uint64_t mAnimationGeneration;
+  uint64_t mTransitionGeneration;
 #ifdef MOZ_DUMP_PAINTING
   nsTArray<nsCString> mExtraDumpInfo;
 #endif
   // Store display list log.
   nsCString mDisplayListLog;
 };
 
 /**
diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1320,37 +1320,16 @@ RestyleManager::AttributeChanged(Element
                                                          aAttribute,
                                                          aModType,
                                                          true,
                                                          aOldValue,
                                                          rsdata);
   PostRestyleEvent(aElement, rshint, hint, &rsdata);
 }
 
-/* static */ uint64_t
-RestyleManager::GetMaxAnimationGenerationForFrame(nsIFrame* aFrame)
-{
-  nsIContent* content = aFrame->GetContent();
-  if (!content || !content->IsElement()) {
-    return 0;
-  }
-
-  nsCSSPseudoElements::Type pseudoType =
-    aFrame->StyleContext()->GetPseudoType();
-  AnimationCollection* transitions =
-    aFrame->PresContext()->TransitionManager()->GetAnimations(
-      content->AsElement(), pseudoType, false /* don't create */);
-  AnimationCollection* animations =
-    aFrame->PresContext()->AnimationManager()->GetAnimations(
-      content->AsElement(), pseudoType, false /* don't create */);
-
-  return std::max(transitions ? transitions->mAnimationGeneration : 0,
-                  animations ? animations->mAnimationGeneration : 0);
-}
-
 void
 RestyleManager::RestyleForEmptyChange(Element* aContainer)
 {
   // In some cases (:empty + E, :empty ~ E), a change in the content of
   // an element requires restyling its parent's siblings.
   nsRestyleHint hint = eRestyle_Subtree;
   nsIContent* grandparent = aContainer->GetParent();
   if (grandparent &&
@@ -2702,28 +2681,23 @@ ElementRestyler::ElementRestyler(nsPresC
   , mVisibleKidsOfHiddenElement(aVisibleKidsOfHiddenElement)
 #endif
 {
 }
 
 void
 ElementRestyler::AddLayerChangesForAnimation()
 {
-  // Bug 847286 - We should have separate animation generation counters
-  // on layers for transitions and animations and use != comparison below
-  // rather than a > comparison.
-  uint64_t frameGeneration =
-    RestyleManager::GetMaxAnimationGenerationForFrame(mFrame);
-
   nsChangeHint hint = nsChangeHint(0);
   for (const LayerAnimationInfo::Record& layerInfo :
          LayerAnimationInfo::sRecords) {
     Layer* layer =
       FrameLayerBuilder::GetDedicatedLayer(mFrame, layerInfo.mLayerType);
-    if (layer && frameGeneration > layer->GetAnimationGeneration()) {
+    // FIXME: Pass boolean for transitions vs. animations!
+    if (layer && frameGeneration != layer->GetAnimationGeneration()) {
       // If we have a transform layer but don't have any transform style, we
       // probably just removed the transform but haven't destroyed the layer
       // yet. In this case we will add the appropriate change hint
       // (nsChangeHint_UpdateContainingBlock) when we compare style contexts
       // so we can skip adding any change hint here. (If we *were* to add
       // nsChangeHint_UpdateTransformLayer, ApplyRenderingChangeToTree would
       // complain that we're updating a transform layer without a transform).
       if (layerInfo.mLayerType == nsDisplayItem::TYPE_TRANSFORM &&
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -95,21 +95,16 @@ public:
   // Get an integer that increments every time there is a style change
   // as a result of a change to the :hover content state.
   uint32_t GetHoverGeneration() const { return mHoverGeneration; }
 
   // Get a counter that increments on every style change, that we use to
   // track whether off-main-thread animations are up-to-date.
   uint64_t GetAnimationGeneration() const { return mAnimationGeneration; }
 
-  // A workaround until bug 847286 lands that gets the maximum of the animation
-  // generation counters stored on the set of animations and transitions
-  // respectively for |aFrame|.
-  static uint64_t GetMaxAnimationGenerationForFrame(nsIFrame* aFrame);
-
   // Update the animation generation count to mark that animation state
   // has changed.
   //
   // This is normally performed automatically by ProcessPendingRestyles
   // but it is also called when we have out-of-band changes to animations
   // such as changes made through the Web Animations API.
   void IncrementAnimationGeneration() { ++mAnimationGeneration; }
 
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -502,40 +502,43 @@ nsDisplayListBuilder::AddAnimationsAndTr
   bool pending = !aBuilder;
 
   if (pending) {
     aLayer->ClearAnimationsForNextTransaction();
   } else {
     aLayer->ClearAnimations();
   }
 
-  // Update the animation generation on the layer. We need to do this before
-  // any early returns since even if we don't add any animations to the
-  // layer, we still need to mark it as up-to-date with regards to animations.
-  // Otherwise, in RestyleManager we'll notice the discrepancy between the
-  // animation generation numbers and update the layer indefinitely.
-  uint64_t animationGeneration =
-    RestyleManager::GetMaxAnimationGenerationForFrame(aFrame);
-  aLayer->SetAnimationGeneration(animationGeneration);
-
   nsPresContext* presContext = aFrame->PresContext();
   presContext->TransitionManager()->ClearIsRunningOnCompositor(aFrame,
                                                                aProperty);
   presContext->AnimationManager()->ClearIsRunningOnCompositor(aFrame,
                                                               aProperty);
   AnimationCollection* transitions =
     presContext->TransitionManager()->GetAnimationsForCompositor(aFrame,
                                                                  aProperty);
   AnimationCollection* animations =
     presContext->AnimationManager()->GetAnimationsForCompositor(aFrame,
                                                                 aProperty);
   if (!animations && !transitions) {
     return;
   }
 
+  // Update the animation generation on the layer. We need to do this before
+  // any early returns since even if we don't add any animations to the
+  // layer, we still need to mark it as up-to-date with regards to animations.
+  // Otherwise, in RestyleManager we'll notice the discrepancy between the
+  // animation generation numbers and update the layer indefinitely.
+  if (animations) {
+    aLayer->SetAnimationGeneration(animations->mAnimationGeneration);
+  }
+  if (transitions) {
+    aLayer->SetTransitionGeneration(transitions->mAnimationGeneration);
+  }
+
   // If the frame is not prerendered, bail out.
   // Do this check only during layer construction; during updating the
   // caller is required to check it appropriately.
   if (aItem && !aItem->CanUseAsyncAnimations(aBuilder)) {
     // AnimationManager or TransitionManager need to know that we refused to
     // run this animation asynchronously so that they will not throttle the
     // main thread animation.
     aFrame->Properties().Set(nsIFrame::RefusedAsyncAnimationProperty(),
