From: L. David Baron <dbaron@dbaron.org>

Assert when we're about to hit bug 703133.

diff --git a/content/base/src/nsImageLoadingContent.cpp b/content/base/src/nsImageLoadingContent.cpp
--- a/content/base/src/nsImageLoadingContent.cpp
+++ b/content/base/src/nsImageLoadingContent.cpp
@@ -79,16 +79,17 @@ nsImageLoadingContent::nsImageLoadingCon
     mLoadingEnabled(true),
     mIsImageStateForced(false),
     mLoading(false),
     // mBroken starts out true, since an image without a URI is broken....
     mBroken(true),
     mUserDisabled(false),
     mSuppressed(false),
     mNewRequestsWillNeedAnimationReset(false),
+    mCurrentlyNotifying(nullptr),
     mStateChangerDepth(0),
     mCurrentRequestRegistered(false),
     mPendingRequestRegistered(false)
 {
   if (!nsContentUtils::GetImgLoaderForChannel(nullptr)) {
     mLoadingEnabled = false;
   }
 }
@@ -112,17 +113,19 @@ nsImageLoadingContent::~nsImageLoadingCo
 // Macro to call some func on each observer.  This handles observers
 // removing themselves.
 #define LOOP_OVER_OBSERVERS(func_)                                       \
   PR_BEGIN_MACRO                                                         \
     for (ImageObserver* observer = &mObserverList, *next; observer;      \
          observer = next) {                                              \
       next = observer->mNext;                                            \
       if (observer->mObserver) {                                         \
+        mCurrentlyNotifying = observer->mObserver;                       \
         observer->mObserver->func_;                                      \
+        mCurrentlyNotifying = nullptr;                                    \
       }                                                                  \
     }                                                                    \
   PR_END_MACRO
 
 /*
  * imgINotificationObserver impl
  */
 NS_IMETHODIMP
@@ -279,16 +282,18 @@ nsImageLoadingContent::GetImageBlockingS
 
 NS_IMETHODIMP
 nsImageLoadingContent::AddObserver(imgINotificationObserver* aObserver)
 {
   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
 
   NS_ENSURE_ARG_POINTER(aObserver);
 
+  NS_ASSERTION(!mCurrentlyNotifying, "adding observer during notification");
+
   if (!mObserverList.mObserver) {
     mObserverList.mObserver = aObserver;
     // Don't touch the linking of the list!
     return NS_OK;
   }
 
   // otherwise we have to create a new entry
 
@@ -307,16 +312,19 @@ nsImageLoadingContent::AddObserver(imgIN
 
 NS_IMETHODIMP
 nsImageLoadingContent::RemoveObserver(imgINotificationObserver* aObserver)
 {
   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
 
   NS_ENSURE_ARG_POINTER(aObserver);
 
+  NS_ASSERTION(!mCurrentlyNotifying || mCurrentlyNotifying == aObserver,
+               "removing observer during notification");
+
   if (mObserverList.mObserver == aObserver) {
     mObserverList.mObserver = nullptr;
     // Don't touch the linking of the list!
     return NS_OK;
   }
 
   // otherwise have to find it and splice it out
   ImageObserver* observer = &mObserverList;
diff --git a/content/base/src/nsImageLoadingContent.h b/content/base/src/nsImageLoadingContent.h
--- a/content/base/src/nsImageLoadingContent.h
+++ b/content/base/src/nsImageLoadingContent.h
@@ -398,16 +398,18 @@ protected:
    * reset when they are ready. mNewRequestsWillNeedAnimationReset is set to
    * true while preparing such requests (as a hack around needing to change an
    * interface), and the other two booleans store which of the current
    * and pending requests are of the sort that need their animation restarted.
    */
   bool mNewRequestsWillNeedAnimationReset : 1;
 
 private:
+  imgINotificationObserver *mCurrentlyNotifying;
+
   /* The number of nested AutoStateChangers currently tracking our state. */
   uint8_t mStateChangerDepth;
 
   // Flags to indicate whether each of the current and pending requests are
   // registered with the refresh driver.
   bool mCurrentRequestRegistered;
   bool mPendingRequestRegistered;
 };
