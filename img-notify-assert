From: L. David Baron <dbaron@dbaron.org>

Assert when we're about to hit bug 703133.

diff --git a/dom/base/nsImageLoadingContent.cpp b/dom/base/nsImageLoadingContent.cpp
--- a/dom/base/nsImageLoadingContent.cpp
+++ b/dom/base/nsImageLoadingContent.cpp
@@ -91,16 +91,17 @@ nsImageLoadingContent::nsImageLoadingCon
     mIsImageStateForced(false),
     mLoading(false),
     // mBroken starts out true, since an image without a URI is broken....
     mBroken(true),
     mUserDisabled(false),
     mSuppressed(false),
     mNewRequestsWillNeedAnimationReset(false),
     mUseUrgentStartForChannel(false),
+    mCurrentlyNotifying(nullptr),
     mStateChangerDepth(0),
     mCurrentRequestRegistered(false),
     mPendingRequestRegistered(false),
     mIsStartingImageLoad(false)
 {
   if (!nsContentUtils::GetImgLoaderForChannel(nullptr, nullptr)) {
     mLoadingEnabled = false;
   }
@@ -162,17 +163,19 @@ nsImageLoadingContent::Notify(imgIReques
       if (observer->mObserver) {
         observers.AppendElement(observer->mObserver);
       }
     }
 
     nsAutoScriptBlocker scriptBlocker;
 
     for (auto& observer : observers) {
-        observer->Notify(aRequest, aType, aData);
+      mCurrentlyNotifying = observer;
+      observer->Notify(aRequest, aType, aData);
+      mCurrentlyNotifying = nullptr;
     }
   }
 
   if (aType == imgINotificationObserver::SIZE_AVAILABLE) {
     // Have to check for state changes here, since we might have been in
     // the LOADING state before.
     UpdateImageState(true);
   }
@@ -388,16 +391,18 @@ ReplayImageStatus(imgIRequest* aRequest,
   }
 }
 
 NS_IMETHODIMP
 nsImageLoadingContent::AddNativeObserver(imgINotificationObserver* aObserver)
 {
   NS_ENSURE_ARG_POINTER(aObserver);
 
+  NS_ASSERTION(!mCurrentlyNotifying, "adding observer during notification");
+
   if (!mObserverList.mObserver) {
     // Don't touch the linking of the list!
     mObserverList.mObserver = aObserver;
 
     ReplayImageStatus(mCurrentRequest, aObserver);
     ReplayImageStatus(mPendingRequest, aObserver);
 
     return NS_OK;
@@ -417,16 +422,19 @@ nsImageLoadingContent::AddNativeObserver
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsImageLoadingContent::RemoveNativeObserver(imgINotificationObserver* aObserver)
 {
   NS_ENSURE_ARG_POINTER(aObserver);
 
+  NS_ASSERTION(!mCurrentlyNotifying || mCurrentlyNotifying == aObserver,
+               "removing observer during notification");
+
   if (mObserverList.mObserver == aObserver) {
     mObserverList.mObserver = nullptr;
     // Don't touch the linking of the list!
     return NS_OK;
   }
 
   // otherwise have to find it and splice it out
   ImageObserver* observer = &mObserverList;
diff --git a/dom/base/nsImageLoadingContent.h b/dom/base/nsImageLoadingContent.h
--- a/dom/base/nsImageLoadingContent.h
+++ b/dom/base/nsImageLoadingContent.h
@@ -507,16 +507,18 @@ protected:
   /**
    * Flag to indicate whether the channel should be mark as urgent-start.
    * It should be set in *Element and passed to nsContentUtils::LoadImage.
    * True if we want to set nsIClassOfService::UrgentStart to the channel to
    * get the response ASAP for better user responsiveness.
    */
   bool mUseUrgentStartForChannel;
 private:
+  imgINotificationObserver *mCurrentlyNotifying;
+
   /* The number of nested AutoStateChangers currently tracking our state. */
   uint8_t mStateChangerDepth;
 
   // Flags to indicate whether each of the current and pending requests are
   // registered with the refresh driver.
   bool mCurrentRequestRegistered;
   bool mPendingRequestRegistered;
 
