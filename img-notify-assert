From: L. David Baron <dbaron@dbaron.org>

Assert when we're about to hit bug 703133.

diff --git a/content/base/src/nsImageLoadingContent.cpp b/content/base/src/nsImageLoadingContent.cpp
--- a/content/base/src/nsImageLoadingContent.cpp
+++ b/content/base/src/nsImageLoadingContent.cpp
@@ -112,16 +112,17 @@ nsImageLoadingContent::nsImageLoadingCon
     // mBroken starts out true, since an image without a URI is broken....
     mBroken(true),
     mUserDisabled(false),
     mSuppressed(false),
     mBlockingOnload(false),
     mNewRequestsWillNeedAnimationReset(false),
     mPendingRequestNeedsResetAnimation(false),
     mCurrentRequestNeedsResetAnimation(false),
+    mCurrentlyNotifying(nsnull),
     mStateChangerDepth(0),
     mCurrentRequestRegistered(false),
     mPendingRequestRegistered(false)
 {
   if (!nsContentUtils::GetImgLoader()) {
     mLoadingEnabled = false;
   }
 }
@@ -145,17 +146,19 @@ nsImageLoadingContent::~nsImageLoadingCo
 // Macro to call some func on each observer.  This handles observers
 // removing themselves.
 #define LOOP_OVER_OBSERVERS(func_)                                       \
   PR_BEGIN_MACRO                                                         \
     for (ImageObserver* observer = &mObserverList, *next; observer;      \
          observer = next) {                                              \
       next = observer->mNext;                                            \
       if (observer->mObserver) {                                         \
+        mCurrentlyNotifying = observer->mObserver;                       \
         observer->mObserver->func_;                                      \
+        mCurrentlyNotifying = nsnull;                                    \
       }                                                                  \
     }                                                                    \
   PR_END_MACRO
 
 
 /*
  * imgIContainerObserver impl
  */
@@ -434,16 +437,18 @@ nsImageLoadingContent::GetImageBlockingS
 
 NS_IMETHODIMP
 nsImageLoadingContent::AddObserver(imgIDecoderObserver* aObserver)
 {
   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
 
   NS_ENSURE_ARG_POINTER(aObserver);
 
+  NS_ASSERTION(!mCurrentlyNotifying, "adding observer during notification");
+
   if (!mObserverList.mObserver) {
     mObserverList.mObserver = aObserver;
     // Don't touch the linking of the list!
     return NS_OK;
   }
 
   // otherwise we have to create a new entry
 
@@ -462,16 +467,19 @@ nsImageLoadingContent::AddObserver(imgID
 
 NS_IMETHODIMP
 nsImageLoadingContent::RemoveObserver(imgIDecoderObserver* aObserver)
 {
   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
 
   NS_ENSURE_ARG_POINTER(aObserver);
 
+  NS_ASSERTION(!mCurrentlyNotifying || mCurrentlyNotifying == aObserver,
+               "removing observer during notification");
+
   if (mObserverList.mObserver == aObserver) {
     mObserverList.mObserver = nsnull;
     // Don't touch the linking of the list!
     return NS_OK;
   }
 
   // otherwise have to find it and splice it out
   ImageObserver* observer = &mObserverList;
diff --git a/content/base/src/nsImageLoadingContent.h b/content/base/src/nsImageLoadingContent.h
--- a/content/base/src/nsImageLoadingContent.h
+++ b/content/base/src/nsImageLoadingContent.h
@@ -384,16 +384,17 @@ protected:
    * interface), and the other two booleans store which of the current
    * and pending requests are of the sort that need their animation restarted.
    */
   bool mNewRequestsWillNeedAnimationReset : 1;
 
 private:
   bool mPendingRequestNeedsResetAnimation : 1;
   bool mCurrentRequestNeedsResetAnimation : 1;
+  imgIDecoderObserver *mCurrentlyNotifying;
 
   /* The number of nested AutoStateChangers currently tracking our state. */
   PRUint8 mStateChangerDepth;
 
   // Flags to indicate whether each of the current and pending requests are
   // registered with the refresh driver.
   bool mCurrentRequestRegistered;
   bool mPendingRequestRegistered;
