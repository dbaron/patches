From: L. David Baron <dbaron@dbaron.org>

Assert when we're about to hit bug 703133.

diff --git a/content/base/src/nsImageLoadingContent.cpp b/content/base/src/nsImageLoadingContent.cpp
--- a/content/base/src/nsImageLoadingContent.cpp
+++ b/content/base/src/nsImageLoadingContent.cpp
@@ -84,16 +84,17 @@ nsImageLoadingContent::nsImageLoadingCon
     mIsImageStateForced(false),
     mLoading(false),
     // mBroken starts out true, since an image without a URI is broken....
     mBroken(true),
     mUserDisabled(false),
     mSuppressed(false),
     mFireEventsOnDecode(false),
     mNewRequestsWillNeedAnimationReset(false),
+    mCurrentlyNotifying(nullptr),
     mStateChangerDepth(0),
     mCurrentRequestRegistered(false),
     mPendingRequestRegistered(false),
     mFrameCreateCalled(false),
     mVisibleCount(0)
 {
   if (!nsContentUtils::GetImgLoaderForChannel(nullptr)) {
     mLoadingEnabled = false;
@@ -144,17 +145,19 @@ nsImageLoadingContent::Notify(imgIReques
 
   {
     nsAutoScriptBlocker scriptBlocker;
 
     for (ImageObserver* observer = &mObserverList, *next; observer;
          observer = next) {
       next = observer->mNext;
       if (observer->mObserver) {
+        mCurrentlyNotifying = observer->mObserver;
         observer->mObserver->Notify(aRequest, aType, aData);
+        mCurrentlyNotifying = nullptr;
       }
     }
   }
 
   if (aType == imgINotificationObserver::SIZE_AVAILABLE) {
     // Have to check for state changes here, since we might have been in
     // the LOADING state before.
     UpdateImageState(true);
@@ -365,16 +368,18 @@ nsImageLoadingContent::GetImageBlockingS
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsImageLoadingContent::AddObserver(imgINotificationObserver* aObserver)
 {
   NS_ENSURE_ARG_POINTER(aObserver);
 
+  NS_ASSERTION(!mCurrentlyNotifying, "adding observer during notification");
+
   if (!mObserverList.mObserver) {
     mObserverList.mObserver = aObserver;
     // Don't touch the linking of the list!
     return NS_OK;
   }
 
   // otherwise we have to create a new entry
 
@@ -391,16 +396,19 @@ nsImageLoadingContent::AddObserver(imgIN
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsImageLoadingContent::RemoveObserver(imgINotificationObserver* aObserver)
 {
   NS_ENSURE_ARG_POINTER(aObserver);
 
+  NS_ASSERTION(!mCurrentlyNotifying || mCurrentlyNotifying == aObserver,
+               "removing observer during notification");
+
   if (mObserverList.mObserver == aObserver) {
     mObserverList.mObserver = nullptr;
     // Don't touch the linking of the list!
     return NS_OK;
   }
 
   // otherwise have to find it and splice it out
   ImageObserver* observer = &mObserverList;
diff --git a/content/base/src/nsImageLoadingContent.h b/content/base/src/nsImageLoadingContent.h
--- a/content/base/src/nsImageLoadingContent.h
+++ b/content/base/src/nsImageLoadingContent.h
@@ -422,16 +422,18 @@ protected:
    * reset when they are ready. mNewRequestsWillNeedAnimationReset is set to
    * true while preparing such requests (as a hack around needing to change an
    * interface), and the other two booleans store which of the current
    * and pending requests are of the sort that need their animation restarted.
    */
   bool mNewRequestsWillNeedAnimationReset : 1;
 
 private:
+  imgINotificationObserver *mCurrentlyNotifying;
+
   /* The number of nested AutoStateChangers currently tracking our state. */
   uint8_t mStateChangerDepth;
 
   // Flags to indicate whether each of the current and pending requests are
   // registered with the refresh driver.
   bool mCurrentRequestRegistered;
   bool mPendingRequestRegistered;
 
