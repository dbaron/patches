From: L. David Baron <dbaron@dbaron.org>

Simplify storage of computed calc() as a result of removing min() and max().

diff --git a/layout/style/nsStyleCoord.cpp b/layout/style/nsStyleCoord.cpp
--- a/layout/style/nsStyleCoord.cpp
+++ b/layout/style/nsStyleCoord.cpp
@@ -86,17 +86,17 @@ nsStyleCoord::nsStyleCoord(float aValue,
 // default copy construction is defined properly for unions.  But when
 // can we actually use that?  (It seems to work in gcc 4.4.)
 nsStyleCoord& nsStyleCoord::operator=(const nsStyleCoord& aCopy)
 {
   mUnit = aCopy.mUnit;
   if ((eStyleUnit_Percent <= mUnit) && (mUnit < eStyleUnit_Coord)) {
     mValue.mFloat = aCopy.mValue.mFloat;
   }
-  else if (IsArrayValue()) {
+  else if (IsCalcValue()) {
     mValue.mPointer = aCopy.mValue.mPointer;
   }
   else {
     mValue.mInt = aCopy.mValue.mInt;
   }
   return *this;
 }
 
@@ -117,22 +117,17 @@ PRBool nsStyleCoord::operator==(const ns
     case eStyleUnit_Grad:
     case eStyleUnit_Radian:
       return mValue.mFloat == aOther.mValue.mFloat;
     case eStyleUnit_Coord:
     case eStyleUnit_Integer:
     case eStyleUnit_Enumerated:
       return mValue.mInt == aOther.mValue.mInt;
     case eStyleUnit_Calc:
-    case eStyleUnit_Calc_Plus:
-    case eStyleUnit_Calc_Minus:
-    case eStyleUnit_Calc_Times_L:
-    case eStyleUnit_Calc_Times_R:
-    case eStyleUnit_Calc_Divided:
-      return *this->GetArrayValue() == *aOther.GetArrayValue();
+      return *this->GetCalcValue() == *aOther.GetCalcValue();
   }
   NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
   return PR_FALSE;
 }
 
 void nsStyleCoord::Reset()
 {
   mUnit = eStyleUnit_Null;
@@ -179,25 +174,20 @@ void nsStyleCoord::SetAngleValue(float a
     mUnit = aUnit;
     mValue.mFloat = aValue;
   } else {
     NS_NOTREACHED("not an angle value");
     Reset();
   }
 }
 
-void nsStyleCoord::SetArrayValue(Array* aValue, nsStyleUnit aUnit)
+void nsStyleCoord::SetCalcValue(Calc* aValue)
 {
-  mUnit = aUnit;
-  if (IsArrayValue()) {
-    mValue.mPointer = aValue;
-  } else {
-    NS_NOTREACHED("not a pointer value");
-    Reset();
-  }
+  mUnit = eCSSUnit_Calc;
+  mValue.mPointer = aValue;
 }
 
 void nsStyleCoord::SetNormalValue()
 {
   mUnit = eStyleUnit_Normal;
   mValue.mInt = 0;
 }
 
@@ -226,73 +216,16 @@ nsStyleCoord::GetAngleValueInRadians() c
   case eStyleUnit_Grad:   return angle * M_PI / 200.0;
 
   default:
     NS_NOTREACHED("unrecognized angular unit");
     return 0.0;
   }
 }
 
-PRBool
-nsStyleCoord::CalcHasPercent() const
-{
-  NS_ABORT_IF_FALSE(IsCalcUnit(), "caller should check IsCalcUnit()");
-  nsStyleCoord::Array *a = GetArrayValue();
-  for (size_t i = 0, i_end = a->Count(); i < i_end; ++i) {
-    const nsStyleCoord &v = a->Item(i);
-    if (v.GetUnit() == eStyleUnit_Percent) {
-      return PR_TRUE;
-    }
-    if (v.IsCalcUnit() && v.CalcHasPercent()) {
-      return PR_TRUE;
-    }
-  }
-  return PR_FALSE;
-}
-
-
-inline void*
-nsStyleCoord::Array::operator new(size_t aSelfSize,
-                                  nsStyleContext *aAllocationContext,
-                                  size_t aItemCount) CPP_THROW_NEW
-{
-  NS_ABORT_IF_FALSE(aItemCount > 0, "cannot have 0 item count");
-  return aAllocationContext->Alloc(
-           aSelfSize + sizeof(nsStyleCoord) * (aItemCount - 1));
-}
-
-/* static */ nsStyleCoord::Array*
-nsStyleCoord::Array::Create(nsStyleContext *aAllocationContext,
-                            PRBool& aCanStoreInRuleTree,
-                            size_t aCount)
-{
-  // While it's not ideal that every time we use an array, we force it
-  // not to be stored in the rule tree, it's the easiest option for now.
-  // (This is done only because of the style-context-scoped allocation.)
-  aCanStoreInRuleTree = PR_FALSE;
-
-  return new(aAllocationContext, aCount) Array(aCount);
-}
-
-bool
-nsStyleCoord::Array::operator==(const Array& aOther) const
-{
-  if (Count() != aOther.Count()) {
-    return false;
-  }
-
-  for (size_t i = 0; i < mCount; ++i) {
-    if ((*this)[i] != aOther[i]) {
-      return false;
-    }
-  }
-
-  return true;
-}
-
 // used by nsStyleSides and nsStyleCorners
 #define COMPARE_INDEXED_COORD(i)                                              \
   PR_BEGIN_MACRO                                                              \
   if (mUnits[i] != aOther.mUnits[i])                                          \
     return PR_FALSE;                                                          \
   if ((eStyleUnit_Percent <= mUnits[i]) &&                                    \
       (mUnits[i] < eStyleUnit_Coord)) {                                       \
     if (mValues[i].mFloat != aOther.mValues[i].mFloat)                        \
diff --git a/layout/style/nsStyleCoord.h b/layout/style/nsStyleCoord.h
--- a/layout/style/nsStyleCoord.h
+++ b/layout/style/nsStyleCoord.h
@@ -55,52 +55,49 @@ enum nsStyleUnit {
   eStyleUnit_Percent      = 10,     // (float) 1.0 == 100%
   eStyleUnit_Factor       = 11,     // (float) a multiplier
   eStyleUnit_Degree       = 12,     // (float) angle in degrees
   eStyleUnit_Grad         = 13,     // (float) angle in grads
   eStyleUnit_Radian       = 14,     // (float) angle in radians
   eStyleUnit_Coord        = 20,     // (nscoord) value is twips
   eStyleUnit_Integer      = 30,     // (int) value is simple integer
   eStyleUnit_Enumerated   = 32,     // (int) value has enumerated meaning
-  // The following are all of the eCSSUnit_Calc_* types.  They are weak
-  // pointers to a calc tree allocated by nsStyleContext::Alloc.
-  // NOTE:  They are in the same order as the eCSSUnit_Calc_* values so
-  // that converting between the two sets is just addition/subtraction.
-  eStyleUnit_Calc         = 39,     // (Array*) calc() toplevel, to
-                                    // distinguish 50% from calc(50%), etc.
-  eStyleUnit_Calc_Plus    = 40,     // (Array*) + node within calc()
-  eStyleUnit_Calc_Minus   = 41,     // (Array*) - within calc
-  eStyleUnit_Calc_Times_L = 42,     // (Array*) num * val within calc
-  eStyleUnit_Calc_Times_R = 43,     // (Array*) val * num within calc
-  eStyleUnit_Calc_Divided = 44      // (Array*) / within calc
+
+  // The following are allocated types.  They are weak pointers to
+  // values allocated by nsStyleContext::Alloc.
+  eStyleUnit_Calc         = 40,     // (Calc*) calc() toplevel; always present
+                                    // to distinguish 50% from calc(50%), etc.
 };
 
 typedef union {
   PRInt32     mInt;   // nscoord is a PRInt32 for now
   float       mFloat;
   // An mPointer is a weak pointer to a value that is guaranteed to
-  // outlive the nsStyleCoord.  In the case of nsStyleCoord::Array*, it
+  // outlive the nsStyleCoord.  In the case of nsStyleCoord::Calc*, it
   // is a pointer owned by the style context, allocated through
   // nsStyleContext::Alloc (and, therefore, is never stored in the rule
   // tree).
   void*       mPointer;
 } nsStyleUnion;
 
 /**
  * Class that hold a single size specification used by the style
  * system.  The size specification consists of two parts -- a number
  * and a unit.  The number is an integer, a floating point value, an
  * nscoord, or undefined, and the unit is an nsStyleUnit.  Checking
  * the unit is a must before asking for the value in any particular
  * form.
  */
 class nsStyleCoord {
 public:
-  struct Array;
-  friend struct Array;
+  struct Calc {
+    // Every calc() expression evaluates to a length plus a percentage.
+    float mPercent;
+    nscoord mLength;
+  }
 
   nsStyleCoord(nsStyleUnit aUnit = eStyleUnit_Null);
   enum CoordConstructorType { CoordConstructor };
   inline nsStyleCoord(nscoord aValue, CoordConstructorType);
   nsStyleCoord(PRInt32 aValue, nsStyleUnit aUnit);
   nsStyleCoord(float aValue, nsStyleUnit aUnit);
   inline nsStyleCoord(const nsStyleCoord& aCopy);
   inline nsStyleCoord(const nsStyleUnion& aValue, nsStyleUnit aUnit);
@@ -114,31 +111,29 @@ public:
     return mUnit;
   }
 
   PRBool IsAngleValue() const {
     return eStyleUnit_Degree <= mUnit && mUnit <= eStyleUnit_Radian;
   }
 
   PRBool IsCalcUnit() const {
-    return eStyleUnit_Calc <= mUnit && mUnit <= eStyleUnit_Calc_Divided;
+    return eStyleUnit_Calc == mUnit;
   }
 
   PRBool IsCoordPercentCalcUnit() const {
     return mUnit == eStyleUnit_Coord ||
            mUnit == eStyleUnit_Percent ||
            IsCalcUnit();
   }
 
   // Does this calc() expression have any percentages inside it?  Can be
   // called only when IsCalcUnit() is true.
-  PRBool CalcHasPercent() const;
-
-  PRBool IsArrayValue() const {
-    return IsCalcUnit();
+  PRBool CalcHasPercent() const {
+    return GetCalcValue()->mPercent != 0.0f;
   }
 
   PRBool HasPercent() const {
     return mUnit == eStyleUnit_Percent ||
            (IsCalcUnit() && CalcHasPercent());
   }
 
   PRBool ConvertsToLength() const {
@@ -147,87 +142,35 @@ public:
   }
 
   nscoord     GetCoordValue() const;
   PRInt32     GetIntValue() const;
   float       GetPercentValue() const;
   float       GetFactorValue() const;
   float       GetAngleValue() const;
   double      GetAngleValueInRadians() const;
-  Array*      GetArrayValue() const;
+  Calc*       GetCalcValue() const;
   void        GetUnionValue(nsStyleUnion& aValue) const;
 
   void  Reset();  // sets to null
   void  SetCoordValue(nscoord aValue);
   void  SetIntValue(PRInt32 aValue, nsStyleUnit aUnit);
   void  SetPercentValue(float aValue);
   void  SetFactorValue(float aValue);
   void  SetAngleValue(float aValue, nsStyleUnit aUnit);
   void  SetNormalValue();
   void  SetAutoValue();
   void  SetNoneValue();
-  void  SetArrayValue(Array* aValue, nsStyleUnit aUnit);
+  void  SetCalcValue(Calc* aValue);
 
 public: // FIXME: private!
   nsStyleUnit   mUnit;
   nsStyleUnion  mValue;
 };
 
-// A fixed-size array, that, like everything else in nsStyleCoord,
-// doesn't require that its destructors be called.
-struct nsStyleCoord::Array {
-  static Array* Create(nsStyleContext *aAllocationContext,
-                       PRBool& aCanStoreInRuleTree,
-                       size_t aCount);
-
-  size_t Count() const { return mCount; }
-
-  nsStyleCoord& operator[](size_t aIndex) {
-    NS_ABORT_IF_FALSE(aIndex < mCount, "out of range");
-    return mArray[aIndex];
-  }
-
-  const nsStyleCoord& operator[](size_t aIndex) const {
-    NS_ABORT_IF_FALSE(aIndex < mCount, "out of range");
-    return mArray[aIndex];
-  }
-
-  // Easier to use with an Array*:
-  nsStyleCoord& Item(size_t aIndex) { return (*this)[aIndex]; }
-  const nsStyleCoord& Item(size_t aIndex) const { return (*this)[aIndex]; }
-
-  bool operator==(const Array& aOther) const;
-
-  bool operator!=(const Array& aOther) const {
-    return !(*this == aOther);
-  }
-
-private:
-  inline void* operator new(size_t aSelfSize,
-                            nsStyleContext *aAllocationContext,
-                            size_t aItemCount) CPP_THROW_NEW;
-
-  Array(size_t aCount)
-    : mCount(aCount)
-  {
-    // Initialize all entries not in the class.
-    for (size_t i = 1; i < aCount; ++i) {
-      new (mArray + i) nsStyleCoord();
-    }
-  }
-
-  size_t mCount;
-  nsStyleCoord mArray[1]; // for alignment, have the first element in the class
-
-  // not to be implemented
-  Array(const Array& aOther);
-  Array& operator=(const Array& aOther);
-  ~Array();
-};
-
 /**
  * Class that represents a set of top/right/bottom/left nsStyleCoords.
  * This is commonly used to hold the widths of the borders, margins,
  * or paddings of a box.
  */
 class nsStyleSides {
 public:
   nsStyleSides();
@@ -303,17 +246,17 @@ inline nsStyleCoord::nsStyleCoord(nscoor
 // default copy construction is defined properly for unions.  But when
 // can we actually use that?  (It seems to work in gcc 4.4.)
 inline nsStyleCoord::nsStyleCoord(const nsStyleCoord& aCopy)
   : mUnit(aCopy.mUnit)
 {
   if ((eStyleUnit_Percent <= mUnit) && (mUnit < eStyleUnit_Coord)) {
     mValue.mFloat = aCopy.mValue.mFloat;
   }
-  else if (IsArrayValue()) {
+  else if (IsCalcValue()) {
     mValue.mPointer = aCopy.mValue.mPointer;
   }
   else {
     mValue.mInt = aCopy.mValue.mInt;
   }
 }
 
 inline nsStyleCoord::nsStyleCoord(const nsStyleUnion& aValue, nsStyleUnit aUnit)
@@ -370,21 +313,21 @@ inline float nsStyleCoord::GetAngleValue
   NS_ASSERTION(mUnit >= eStyleUnit_Degree &&
                mUnit <= eStyleUnit_Radian, "not an angle value");
   if (mUnit >= eStyleUnit_Degree && mUnit <= eStyleUnit_Radian) {
     return mValue.mFloat;
   }
   return 0.0f;
 }
 
-inline nsStyleCoord::Array* nsStyleCoord::GetArrayValue() const
+inline nsStyleCoord::Calc* nsStyleCoord::GetCalcValue() const
 {
-  NS_ASSERTION(IsArrayValue(), "not a pointer value");
-  if (IsArrayValue()) {
-    return static_cast<Array*>(mValue.mPointer);
+  NS_ASSERTION(IsCalcValue(), "not a pointer value");
+  if (IsCalcValue()) {
+    return static_cast<Calc*>(mValue.mPointer);
   }
   return nsnull;
 }
 
 
 inline void nsStyleCoord::GetUnionValue(nsStyleUnion& aValue) const
 {
   memcpy(&aValue, &mValue, sizeof(nsStyleUnion));
