Rewrite the shorthand condensation code in nsCSSDeclaration::ToString.  (Bug 376075)

diff --git a/layout/style/nsCSSDeclaration.cpp b/layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp
+++ b/layout/style/nsCSSDeclaration.cpp
@@ -54,40 +54,16 @@
 #include "nsFont.h"
 #include "nsReadableUtils.h"
 #include "nsStyleUtil.h"
 
 #include "nsStyleConsts.h"
 
 #include "nsCOMPtr.h"
 
-#define B_BORDER_TOP_STYLE    0x001
-#define B_BORDER_LEFT_STYLE   0x002
-#define B_BORDER_RIGHT_STYLE  0x004
-#define B_BORDER_BOTTOM_STYLE 0x008
-#define B_BORDER_TOP_COLOR    0x010
-#define B_BORDER_LEFT_COLOR   0x020
-#define B_BORDER_RIGHT_COLOR  0x040
-#define B_BORDER_BOTTOM_COLOR 0x080
-#define B_BORDER_TOP_WIDTH    0x100
-#define B_BORDER_LEFT_WIDTH   0x200
-#define B_BORDER_RIGHT_WIDTH  0x400
-#define B_BORDER_BOTTOM_WIDTH 0x800
-
-#define B_BORDER_STYLE        0x00f
-#define B_BORDER_COLOR        0x0f0
-#define B_BORDER_WIDTH        0xf00
-
-#define B_BORDER_TOP          0x111
-#define B_BORDER_LEFT         0x222
-#define B_BORDER_RIGHT        0x444
-#define B_BORDER_BOTTOM       0x888
-
-#define B_BORDER              0xfff
-
 nsCSSDeclaration::nsCSSDeclaration() 
   : mData(nsnull),
     mImportantData(nsnull)
 {
   // check that we can fit all the CSS properties into a PRUint8
   // for the mOrder array - if not, might need to use PRUint16!
   PR_STATIC_ASSERT(eCSSProperty_COUNT_no_shorthands - 1 <= PR_UINT8_MAX);
 
@@ -960,700 +936,48 @@ nsCSSDeclaration::GetValueIsImportant(ns
       }
     }
     return PR_TRUE;
   }
 
   return mImportantData->StorageFor(aProperty) != nsnull;
 }
 
-// XXXldb Bug 376075 All callers of AllPropertiesSameImportance also
-// need to check for 'inherit' and 'initial' values, since you can't
-// output a mix of either mixed with other values in the same shorthand!
-PRBool
-nsCSSDeclaration::AllPropertiesSameImportance(PRInt32 aFirst, PRInt32 aSecond,
-                                              PRInt32 aThird, PRInt32 aFourth,
-                                              PRInt32 aFifth,
-                                              PRBool & aImportance) const
-{
-  aImportance = GetValueIsImportant(OrderValueAt(aFirst-1));
-  if ((aSecond && aImportance != GetValueIsImportant(OrderValueAt(aSecond-1))) ||
-      (aThird && aImportance != GetValueIsImportant(OrderValueAt(aThird-1))) ||
-      (aFourth && aImportance != GetValueIsImportant(OrderValueAt(aFourth-1))) ||
-      (aFifth && aImportance != GetValueIsImportant(OrderValueAt(aFifth-1)))) {
-    return PR_FALSE;
-  }
-  return PR_TRUE;
-}
-
-PRBool
-nsCSSDeclaration::AllPropertiesSameValue(PRInt32 aFirst, PRInt32 aSecond,
-                                         PRInt32 aThird, PRInt32 aFourth) const
-{
-  nsCSSValue firstValue, otherValue;
-  // TryBorderShorthand does the bounds-checking for us; valid values there
-  // are > 0; 0 is a flag for "not set".  We here are passed the actual
-  // index, which comes from finding the value in the mOrder property array.
-  // Of course, re-getting the mOrder value here is pretty silly.
-  GetValueOrImportantValue(OrderValueAt(aFirst-1), firstValue);
-  GetValueOrImportantValue(OrderValueAt(aSecond-1), otherValue);
-  if (firstValue != otherValue) {
-    return PR_FALSE;
-  }
-  GetValueOrImportantValue(OrderValueAt(aThird-1), otherValue);
-  if (firstValue != otherValue) {
-    return PR_FALSE;
-  }
-  GetValueOrImportantValue(OrderValueAt(aFourth-1), otherValue);
-  if (firstValue != otherValue) {
-    return PR_FALSE;
-  }
-  return PR_TRUE;
-}
-
 /* static */ void
 nsCSSDeclaration::AppendImportanceToString(PRBool aIsImportant,
                                            nsAString& aString)
 {
   if (aIsImportant) {
    aString.AppendLiteral(" ! important");
   }
 }
 
 void
 nsCSSDeclaration::AppendPropertyAndValueToString(nsCSSProperty aProperty,
-                                                 nsCSSProperty aPropertyName,
                                                  nsAString& aResult) const
 {
   NS_ASSERTION(0 <= aProperty && aProperty < eCSSProperty_COUNT_no_shorthands,
                "property enum out of range");
-  AppendASCIItoUTF16(nsCSSProps::GetStringValue(aPropertyName), aResult);
+  AppendASCIItoUTF16(nsCSSProps::GetStringValue(aProperty), aResult);
   aResult.AppendLiteral(": ");
   AppendValueToString(aProperty, aResult);
   PRBool  isImportant = GetValueIsImportant(aProperty);
   AppendImportanceToString(isImportant, aResult);
   aResult.AppendLiteral("; ");
 }
 
-PRBool
-nsCSSDeclaration::TryBorderShorthand(nsAString & aString, PRUint32 aPropertiesSet,
-                                     PRInt32 aBorderTopWidth,
-                                     PRInt32 aBorderTopStyle,
-                                     PRInt32 aBorderTopColor,
-                                     PRInt32 aBorderBottomWidth,
-                                     PRInt32 aBorderBottomStyle,
-                                     PRInt32 aBorderBottomColor,
-                                     PRInt32 aBorderLeftWidth,
-                                     PRInt32 aBorderLeftStyle,
-                                     PRInt32 aBorderLeftColor,
-                                     PRInt32 aBorderRightWidth,
-                                     PRInt32 aBorderRightStyle,
-                                     PRInt32 aBorderRightColor) const
-{
-  PRBool border = PR_FALSE, isImportant = PR_FALSE;
-  // 0 means not in the mOrder array; otherwise it's index+1
-  if (B_BORDER == aPropertiesSet
-      && AllPropertiesSameValue(aBorderTopWidth, aBorderBottomWidth,
-                                aBorderLeftWidth, aBorderRightWidth)
-      && AllPropertiesSameValue(aBorderTopStyle, aBorderBottomStyle,
-                                aBorderLeftStyle, aBorderRightStyle)
-      && AllPropertiesSameValue(aBorderTopColor, aBorderBottomColor,
-                                aBorderLeftColor, aBorderRightColor)) {
-    border = PR_TRUE;
-  }
-  if (border) {
-    border = PR_FALSE;
-    PRBool  isWidthImportant, isStyleImportant, isColorImportant;
-    if (AllPropertiesSameImportance(aBorderTopWidth, aBorderBottomWidth,
-                                    aBorderLeftWidth, aBorderRightWidth,
-                                    0,
-                                    isWidthImportant) &&
-        AllPropertiesSameImportance(aBorderTopStyle, aBorderBottomStyle,
-                                    aBorderLeftStyle, aBorderRightStyle,
-                                    0,
-                                    isStyleImportant) &&
-        AllPropertiesSameImportance(aBorderTopColor, aBorderBottomColor,
-                                    aBorderLeftColor, aBorderRightColor,
-                                    0,
-                                    isColorImportant)) {
-      if (isWidthImportant == isStyleImportant && isWidthImportant == isColorImportant) {
-        border = PR_TRUE;
-        isImportant = isWidthImportant;
-      }
-    }
-  }
-  if (border) {
-    AppendASCIItoUTF16(nsCSSProps::GetStringValue(eCSSProperty_border), aString);
-    aString.AppendLiteral(": ");
-
-    AppendValueToString(eCSSProperty_border_top_width, aString);
-    aString.Append(PRUnichar(' '));
-
-    AppendValueToString(eCSSProperty_border_top_style, aString);
-    aString.Append(PRUnichar(' '));
-
-    nsAutoString valueString;
-    AppendValueToString(eCSSProperty_border_top_color, valueString);
-    if (!valueString.EqualsLiteral("-moz-use-text-color")) {
-      /* don't output this value, it's proprietary Mozilla and  */
-      /* not intended to be exposed ; we can remove it from the */
-      /* values of the shorthand since this value represents the */
-      /* initial value of border-*-color */
-      aString.Append(valueString);
-    }
-    AppendImportanceToString(isImportant, aString);
-    aString.AppendLiteral("; ");
-  }
-  return border;
-}
-
-PRBool
-nsCSSDeclaration::TryBorderSideShorthand(nsAString & aString,
-                                         nsCSSProperty aShorthand,
-                                         PRInt32 aBorderWidth,
-                                         PRInt32 aBorderStyle,
-                                         PRInt32 aBorderColor) const
-{
-  PRBool isImportant;
-  if (AllPropertiesSameImportance(aBorderWidth, aBorderStyle, aBorderColor,
-                                  0, 0,
-                                  isImportant)) {
-    AppendASCIItoUTF16(nsCSSProps::GetStringValue(aShorthand), aString);
-    aString.AppendLiteral(": ");
-
-    AppendValueToString(OrderValueAt(aBorderWidth-1), aString);
-
-    aString.Append(PRUnichar(' '));
-    AppendValueToString(OrderValueAt(aBorderStyle-1), aString);
-
-    nsAutoString valueString;
-    AppendValueToString(OrderValueAt(aBorderColor-1), valueString);
-    if (!valueString.EqualsLiteral("-moz-use-text-color")) {
-      aString.AppendLiteral(" ");
-      aString.Append(valueString);
-    }
-    AppendImportanceToString(isImportant, aString);
-    aString.AppendLiteral("; ");
-    return PR_TRUE;
-  }
-  return PR_FALSE;
-}
-
-PRBool
-nsCSSDeclaration::TryFourSidesShorthand(nsAString & aString,
-                                        nsCSSProperty aShorthand,
-                                        PRInt32 & aTop,
-                                        PRInt32 & aBottom,
-                                        PRInt32 & aLeft,
-                                        PRInt32 & aRight,
-                                        PRBool aClearIndexes) const
-{
-  // 0 means not in the mOrder array; otherwise it's index+1
-  PRBool isImportant;
-  if (aTop && aBottom && aLeft && aRight &&
-      AllPropertiesSameImportance(aTop, aBottom, aLeft, aRight,
-                                  0,
-                                  isImportant)) {
-    // all 4 properties are set, we can output a shorthand
-    AppendASCIItoUTF16(nsCSSProps::GetStringValue(aShorthand), aString);
-    aString.AppendLiteral(": ");
-    nsCSSValue topValue, bottomValue, leftValue, rightValue;
-    nsCSSProperty topProp    = OrderValueAt(aTop-1);
-    nsCSSProperty bottomProp = OrderValueAt(aBottom-1);
-    nsCSSProperty leftProp   = OrderValueAt(aLeft-1);
-    nsCSSProperty rightProp  = OrderValueAt(aRight-1);
-    GetValueOrImportantValue(topProp,    topValue);
-    GetValueOrImportantValue(bottomProp, bottomValue);
-    GetValueOrImportantValue(leftProp,   leftValue);
-    GetValueOrImportantValue(rightProp,  rightValue);
-    AppendCSSValueToString(topProp, topValue, aString);
-    if (topValue != rightValue || topValue != leftValue || topValue != bottomValue) {
-      aString.Append(PRUnichar(' '));
-      AppendCSSValueToString(rightProp, rightValue, aString);
-      if (topValue != bottomValue || rightValue != leftValue) {
-        aString.Append(PRUnichar(' '));
-        AppendCSSValueToString(bottomProp, bottomValue, aString);
-        if (rightValue != leftValue) {
-          aString.Append(PRUnichar(' '));
-          AppendCSSValueToString(leftProp, leftValue, aString);
-        }
-      }
-    }
-    if (aClearIndexes) {
-      aTop = 0; aBottom = 0; aLeft = 0; aRight = 0;
-    }
-    AppendImportanceToString(isImportant, aString);
-    aString.AppendLiteral("; ");
-    return PR_TRUE;
-  }
-  return PR_FALSE;
-}
-
-void
-nsCSSDeclaration::TryBackgroundShorthand(nsAString & aString,
-                                         PRInt32 & aBgColor,
-                                         PRInt32 & aBgImage,
-                                         PRInt32 & aBgRepeat,
-                                         PRInt32 & aBgAttachment,
-                                         PRInt32 & aBgPosition) const
-{
-  // 0 means not in the mOrder array; otherwise it's index+1
-  // check if we have at least two properties set; otherwise, no need to
-  // use a shorthand
-  PRBool isImportant;
-  if (aBgColor && aBgImage && aBgRepeat && aBgAttachment && aBgPosition &&
-      AllPropertiesSameImportance(aBgColor, aBgImage, aBgRepeat, aBgAttachment,
-                                  aBgPosition, isImportant)) {
-    AppendASCIItoUTF16(nsCSSProps::GetStringValue(eCSSProperty_background), aString);
-    aString.AppendLiteral(": ");
-
-    AppendValueToString(eCSSProperty_background_color, aString);
-    aBgColor = 0;
-
-    aString.Append(PRUnichar(' '));
-    AppendValueToString(eCSSProperty_background_image, aString);
-    aBgImage = 0;
-
-    aString.Append(PRUnichar(' '));
-    AppendValueToString(eCSSProperty_background_repeat, aString);
-    aBgRepeat = 0;
-
-    aString.Append(PRUnichar(' '));
-    AppendValueToString(eCSSProperty_background_attachment, aString);
-    aBgAttachment = 0;
-
-    aString.Append(PRUnichar(' '));
-    AppendValueToString(eCSSProperty_background_position, aString);
-    aBgPosition = 0;
-
-    AppendImportanceToString(isImportant, aString);
-    aString.AppendLiteral("; ");
-  }
-}
-
-void
-nsCSSDeclaration::TryOverflowShorthand(nsAString & aString,
-                                       PRInt32 & aOverflowX,
-                                       PRInt32 & aOverflowY) const
-{
-  PRBool isImportant;
-  if (aOverflowX && aOverflowY &&
-      AllPropertiesSameImportance(aOverflowX, aOverflowY,
-                                  0, 0, 0, isImportant)) {
-    nsCSSValue xValue, yValue;
-    GetValueOrImportantValue(eCSSProperty_overflow_x, xValue);
-    GetValueOrImportantValue(eCSSProperty_overflow_y, yValue);
-    if (xValue == yValue) {
-      AppendASCIItoUTF16(nsCSSProps::GetStringValue(eCSSProperty_overflow),
-                         aString);
-      aString.AppendLiteral(": ");
-
-      AppendCSSValueToString(eCSSProperty_overflow_x, xValue, aString);
-      AppendImportanceToString(isImportant, aString);
-      aString.AppendLiteral("; ");
-      aOverflowX = aOverflowY = 0;
-    }
-  }
-}
-
-#ifdef MOZ_SVG
-void
-nsCSSDeclaration::TryMarkerShorthand(nsAString & aString,
-                                     PRInt32 & aMarkerEnd,
-                                     PRInt32 & aMarkerMid,
-                                     PRInt32 & aMarkerStart) const
-{
-  PRBool isImportant;
-  if (aMarkerEnd && aMarkerMid && aMarkerEnd &&
-      AllPropertiesSameImportance(aMarkerEnd, aMarkerMid, aMarkerStart,
-                                  0, 0, isImportant)) {
-    nsCSSValue endValue, midValue, startValue;
-    GetValueOrImportantValue(eCSSProperty_marker_end, endValue);
-    GetValueOrImportantValue(eCSSProperty_marker_mid, midValue);
-    GetValueOrImportantValue(eCSSProperty_marker_start, startValue);
-    if (endValue == midValue && midValue == startValue) {
-      AppendASCIItoUTF16(nsCSSProps::GetStringValue(eCSSProperty_marker),
-                         aString);
-      aString.AppendLiteral(": ");
-
-      AppendCSSValueToString(eCSSProperty_marker_end, endValue, aString);
-      AppendImportanceToString(isImportant, aString);
-      aString.AppendLiteral("; ");
-      aMarkerEnd = aMarkerMid = aMarkerStart = 0;
-    }
-  }
-}
-#endif
-
-#define NS_CASE_OUTPUT_PROPERTY_VALUE(_prop, _index) \
-case _prop: \
-          if (_index) { \
-            AppendPropertyAndValueToString(property, aString); \
-            _index = 0; \
-          } \
-          break;
-
-#define NS_CASE_OUTPUT_PROPERTY_VALUE_AS(_prop, _propas, _index) \
-case _prop: \
-          if (_index) { \
-            AppendPropertyAndValueToString(property, _propas, aString); \
-            _index = 0; \
-          } \
-          break;
-
-#define NS_CASE_CONDITIONAL_OUTPUT_PROPERTY_VALUE(_condition, _prop, _index) \
-case _prop: \
-          if ((_condition) && _index) { \
-            AppendPropertyAndValueToString(property, aString); \
-            _index = 0; \
-          } \
-          break;
-
-#define NS_CASE_CONDITIONAL_OUTPUT_PROPERTY_VALUE_AS(_condition, _prop, _propas, _index) \
-case _prop: \
-          if ((_condition) && _index) { \
-            AppendPropertyAndValueToString(property, _propas, aString); \
-            _index = 0; \
-          } \
-          break;
-
-void nsCSSDeclaration::PropertyIsSet(PRInt32 & aPropertyIndex, PRInt32 aIndex, PRUint32 & aSet, PRUint32 aValue) const
-{
-  aPropertyIndex = aIndex + 1;
-  aSet |= aValue;
-}
-
 nsresult
 nsCSSDeclaration::ToString(nsAString& aString) const
 {
   PRInt32 count = mOrder.Length();
   PRInt32 index;
-  // 0 means not in the mOrder array; otherwise it's index+1
-  PRInt32 borderTopWidth = 0, borderTopStyle = 0, borderTopColor = 0;
-  PRInt32 borderBottomWidth = 0, borderBottomStyle = 0, borderBottomColor = 0;
-  PRInt32 borderLeftWidth = 0, borderLeftStyle = 0, borderLeftColor = 0;
-  PRInt32 borderRightWidth = 0, borderRightStyle = 0, borderRightColor = 0;
-  PRInt32 borderStartWidth = 0, borderStartStyle = 0, borderStartColor = 0;
-  PRInt32 borderEndWidth = 0, borderEndStyle = 0, borderEndColor = 0;
-  PRInt32 marginTop = 0,  marginBottom = 0,  marginLeft = 0,  marginRight = 0;
-  PRInt32 paddingTop = 0, paddingBottom = 0, paddingLeft = 0, paddingRight = 0;
-  PRInt32 bgColor = 0, bgImage = 0, bgRepeat = 0, bgAttachment = 0;
-  PRInt32 bgPosition = 0;
-  PRInt32 overflowX = 0, overflowY = 0;
-  PRInt32 columnRuleWidth = 0, columnRuleStyle = 0, columnRuleColor = 0;
-  PRUint32 borderPropertiesSet = 0, finalBorderPropertiesToSet = 0;
-#ifdef MOZ_SVG
-  PRInt32 markerEnd = 0, markerMid = 0, markerStart = 0;
-#endif
-
   for (index = 0; index < count; index++) {
     nsCSSProperty property = OrderValueAt(index);
-    switch (property) {
-      case eCSSProperty_border_top_width:
-        PropertyIsSet(borderTopWidth, index, borderPropertiesSet, B_BORDER_TOP_WIDTH);
-        break;
-      case eCSSProperty_border_bottom_width:
-        PropertyIsSet(borderBottomWidth, index, borderPropertiesSet, B_BORDER_BOTTOM_WIDTH);
-        break;
-      case eCSSProperty_border_left_width_value:
-        PropertyIsSet(borderLeftWidth, index, borderPropertiesSet, B_BORDER_LEFT_WIDTH);
-        break;
-      case eCSSProperty_border_right_width_value:
-        PropertyIsSet(borderRightWidth, index, borderPropertiesSet, B_BORDER_RIGHT_WIDTH);
-        break;
-      case eCSSProperty_border_start_width_value:
-        borderStartWidth = index+1;
-        break;
-      case eCSSProperty_border_end_width_value:
-        borderEndWidth = index+1;
-        break;
-
-      case eCSSProperty_border_top_style:
-        PropertyIsSet(borderTopStyle, index, borderPropertiesSet, B_BORDER_TOP_STYLE);
-        break;
-      case eCSSProperty_border_bottom_style:
-        PropertyIsSet(borderBottomStyle, index, borderPropertiesSet, B_BORDER_BOTTOM_STYLE);
-        break;
-      case eCSSProperty_border_left_style_value:
-        PropertyIsSet(borderLeftStyle, index, borderPropertiesSet, B_BORDER_LEFT_STYLE);
-        break;
-      case eCSSProperty_border_right_style_value:
-        PropertyIsSet(borderRightStyle, index, borderPropertiesSet, B_BORDER_RIGHT_STYLE);
-        break;
-      case eCSSProperty_border_start_style_value:
-        borderStartStyle = index+1;
-        break;
-      case eCSSProperty_border_end_style_value:
-        borderEndStyle = index+1;
-        break;
-
-      case eCSSProperty_border_top_color:
-        PropertyIsSet(borderTopColor, index, borderPropertiesSet, B_BORDER_TOP_COLOR);
-        break;
-      case eCSSProperty_border_bottom_color:
-        PropertyIsSet(borderBottomColor, index, borderPropertiesSet, B_BORDER_BOTTOM_COLOR);
-        break;
-      case eCSSProperty_border_left_color_value:
-        PropertyIsSet(borderLeftColor, index, borderPropertiesSet, B_BORDER_LEFT_COLOR);
-        break;
-      case eCSSProperty_border_right_color_value:
-        PropertyIsSet(borderRightColor, index, borderPropertiesSet, B_BORDER_RIGHT_COLOR);
-        break;
-      case eCSSProperty_border_start_color_value:
-        borderStartColor = index+1;
-        break;
-      case eCSSProperty_border_end_color_value:
-        borderEndColor = index+1;
-        break;
-
-      case eCSSProperty_margin_top:            marginTop     = index+1; break;
-      case eCSSProperty_margin_bottom:         marginBottom  = index+1; break;
-      case eCSSProperty_margin_left_value:     marginLeft    = index+1; break;
-      case eCSSProperty_margin_right_value:    marginRight   = index+1; break;
-
-      case eCSSProperty_padding_top:           paddingTop    = index+1; break;
-      case eCSSProperty_padding_bottom:        paddingBottom = index+1; break;
-      case eCSSProperty_padding_left_value:    paddingLeft   = index+1; break;
-      case eCSSProperty_padding_right_value:   paddingRight  = index+1; break;
-
-      case eCSSProperty_background_color:      bgColor       = index+1; break;
-      case eCSSProperty_background_image:      bgImage       = index+1; break;
-      case eCSSProperty_background_repeat:     bgRepeat      = index+1; break;
-      case eCSSProperty_background_attachment: bgAttachment  = index+1; break;
-      case eCSSProperty_background_position:   bgPosition    = index+1; break;
-
-      case eCSSProperty_overflow_x:            overflowX     = index+1; break;
-      case eCSSProperty_overflow_y:            overflowY     = index+1; break;
-
-      case eCSSProperty__moz_column_rule_width: columnRuleWidth = index+1; break;
-      case eCSSProperty__moz_column_rule_style: columnRuleStyle = index+1; break;
-      case eCSSProperty__moz_column_rule_color: columnRuleColor = index+1; break;
-
-#ifdef MOZ_SVG
-      case eCSSProperty_marker_end:            markerEnd     = index+1; break;
-      case eCSSProperty_marker_mid:            markerMid     = index+1; break;
-      case eCSSProperty_marker_start:          markerStart   = index+1; break;
-#endif
-
-      default: break;
-    }
-  }
-
-  if (!TryBorderShorthand(aString, borderPropertiesSet,
-                          borderTopWidth, borderTopStyle, borderTopColor,
-                          borderBottomWidth, borderBottomStyle, borderBottomColor,
-                          borderLeftWidth, borderLeftStyle, borderLeftColor,
-                          borderRightWidth, borderRightStyle, borderRightColor)) {
-    PRUint32 borderPropertiesToSet = 0;
-    if ((borderPropertiesSet & B_BORDER_STYLE) != B_BORDER_STYLE ||
-        !TryFourSidesShorthand(aString, eCSSProperty_border_style,
-                               borderTopStyle, borderBottomStyle,
-                               borderLeftStyle, borderRightStyle,
-                               PR_FALSE)) {
-      borderPropertiesToSet |= B_BORDER_STYLE;
-    }
-    if ((borderPropertiesSet & B_BORDER_COLOR) != B_BORDER_COLOR ||
-        !TryFourSidesShorthand(aString, eCSSProperty_border_color,
-                               borderTopColor, borderBottomColor,
-                               borderLeftColor, borderRightColor,
-                               PR_FALSE)) {
-      borderPropertiesToSet |= B_BORDER_COLOR;
-    }
-    if ((borderPropertiesSet & B_BORDER_WIDTH) != B_BORDER_WIDTH ||
-        !TryFourSidesShorthand(aString, eCSSProperty_border_width,
-                               borderTopWidth, borderBottomWidth,
-                               borderLeftWidth, borderRightWidth,
-                               PR_FALSE)) {
-      borderPropertiesToSet |= B_BORDER_WIDTH;
-    }
-    borderPropertiesToSet &= borderPropertiesSet;
-    if (borderPropertiesToSet) {
-      if ((borderPropertiesSet & B_BORDER_TOP) != B_BORDER_TOP ||
-          !TryBorderSideShorthand(aString, eCSSProperty_border_top,
-                                  borderTopWidth, borderTopStyle, borderTopColor)) {
-        finalBorderPropertiesToSet |= B_BORDER_TOP;
-      }
-      if ((borderPropertiesSet & B_BORDER_LEFT) != B_BORDER_LEFT ||
-          !TryBorderSideShorthand(aString, eCSSProperty_border_left,
-                                  borderLeftWidth, borderLeftStyle, borderLeftColor)) {
-        finalBorderPropertiesToSet |= B_BORDER_LEFT;
-      }
-      if ((borderPropertiesSet & B_BORDER_RIGHT) != B_BORDER_RIGHT ||
-          !TryBorderSideShorthand(aString, eCSSProperty_border_right,
-                                  borderRightWidth, borderRightStyle, borderRightColor)) {
-        finalBorderPropertiesToSet |= B_BORDER_RIGHT;
-      }
-      if ((borderPropertiesSet & B_BORDER_BOTTOM) != B_BORDER_BOTTOM ||
-          !TryBorderSideShorthand(aString, eCSSProperty_border_bottom,
-                                  borderBottomWidth, borderBottomStyle, borderBottomColor)) {
-        finalBorderPropertiesToSet |= B_BORDER_BOTTOM;
-      }
-      finalBorderPropertiesToSet &= borderPropertiesToSet;
-    }
-  }
-
-  TryFourSidesShorthand(aString, eCSSProperty_margin,
-                        marginTop, marginBottom,
-                        marginLeft, marginRight,
-                        PR_TRUE);
-  TryFourSidesShorthand(aString, eCSSProperty_padding,
-                        paddingTop, paddingBottom,
-                        paddingLeft, paddingRight,
-                        PR_TRUE);
-  TryBackgroundShorthand(aString,
-                         bgColor, bgImage, bgRepeat, bgAttachment,
-                         bgPosition);
-  TryOverflowShorthand(aString, overflowX, overflowY);
-#ifdef MOZ_SVG
-  TryMarkerShorthand(aString, markerEnd, markerMid, markerStart);
-#endif
-
-  if (columnRuleColor && columnRuleStyle && columnRuleWidth) {
-    TryBorderSideShorthand(aString, eCSSProperty__moz_column_rule,
-                           columnRuleWidth, columnRuleStyle, columnRuleColor);
-    columnRuleWidth = columnRuleStyle = columnRuleColor = 0;
-  }
-
-  // FIXME The order of the declarations should depend on the *-source
-  // properties.
-  if (borderStartWidth && borderStartStyle && borderStartColor &&
-      TryBorderSideShorthand(aString, eCSSProperty_border_start,
-                             borderStartWidth, borderStartStyle, borderStartColor))
-    borderStartWidth = borderStartStyle = borderStartColor = 0;
-  if (borderEndWidth && borderEndStyle && borderEndColor &&
-      TryBorderSideShorthand(aString, eCSSProperty_border_end,
-                             borderEndWidth, borderEndStyle, borderEndColor))
-    borderEndWidth = borderEndStyle = borderEndColor = 0;
-
-  for (index = 0; index < count; index++) {
-    nsCSSProperty property = OrderValueAt(index);
-    switch (property) {
-
-      NS_CASE_CONDITIONAL_OUTPUT_PROPERTY_VALUE(finalBorderPropertiesToSet & B_BORDER_TOP_STYLE,
-                                                eCSSProperty_border_top_style, borderTopStyle)
-      NS_CASE_CONDITIONAL_OUTPUT_PROPERTY_VALUE_AS(finalBorderPropertiesToSet & B_BORDER_LEFT_STYLE,
-                                                   eCSSProperty_border_left_style_value,
-                                                   eCSSProperty_border_left_style, borderLeftStyle)
-      NS_CASE_CONDITIONAL_OUTPUT_PROPERTY_VALUE_AS(finalBorderPropertiesToSet & B_BORDER_RIGHT_STYLE,
-                                                   eCSSProperty_border_right_style_value,
-                                                   eCSSProperty_border_right_style, borderRightStyle)
-      NS_CASE_CONDITIONAL_OUTPUT_PROPERTY_VALUE(finalBorderPropertiesToSet & B_BORDER_BOTTOM_STYLE,
-                                                eCSSProperty_border_bottom_style, borderBottomStyle)
-      NS_CASE_OUTPUT_PROPERTY_VALUE_AS(eCSSProperty_border_start_style_value,
-                                       eCSSProperty_border_start_style, borderStartStyle)
-      NS_CASE_OUTPUT_PROPERTY_VALUE_AS(eCSSProperty_border_end_style_value,
-                                       eCSSProperty_border_end_style, borderEndStyle)
-
-      NS_CASE_CONDITIONAL_OUTPUT_PROPERTY_VALUE(finalBorderPropertiesToSet & B_BORDER_TOP_COLOR,
-                                                eCSSProperty_border_top_color, borderTopColor)
-      NS_CASE_CONDITIONAL_OUTPUT_PROPERTY_VALUE_AS(finalBorderPropertiesToSet & B_BORDER_LEFT_COLOR,
-                                                   eCSSProperty_border_left_color_value,
-                                                   eCSSProperty_border_left_color, borderLeftColor)
-      NS_CASE_CONDITIONAL_OUTPUT_PROPERTY_VALUE_AS(finalBorderPropertiesToSet & B_BORDER_RIGHT_COLOR,
-                                                   eCSSProperty_border_right_color_value,
-                                                   eCSSProperty_border_right_color, borderRightColor)
-      NS_CASE_CONDITIONAL_OUTPUT_PROPERTY_VALUE(finalBorderPropertiesToSet & B_BORDER_BOTTOM_COLOR,
-                                                eCSSProperty_border_bottom_color, borderBottomColor)
-      NS_CASE_OUTPUT_PROPERTY_VALUE_AS(eCSSProperty_border_start_color_value,
-                                       eCSSProperty_border_start_color, borderStartColor)
-      NS_CASE_OUTPUT_PROPERTY_VALUE_AS(eCSSProperty_border_end_color_value,
-                                       eCSSProperty_border_end_color, borderEndColor)
-
-      NS_CASE_CONDITIONAL_OUTPUT_PROPERTY_VALUE(finalBorderPropertiesToSet & B_BORDER_TOP_WIDTH,
-                                                eCSSProperty_border_top_width, borderTopWidth)
-      NS_CASE_CONDITIONAL_OUTPUT_PROPERTY_VALUE_AS(finalBorderPropertiesToSet & B_BORDER_LEFT_WIDTH,
-                                                   eCSSProperty_border_left_width_value,
-                                                   eCSSProperty_border_left_width, borderLeftWidth)
-      NS_CASE_CONDITIONAL_OUTPUT_PROPERTY_VALUE_AS(finalBorderPropertiesToSet & B_BORDER_RIGHT_WIDTH,
-                                                   eCSSProperty_border_right_width_value,
-                                                   eCSSProperty_border_right_width, borderRightWidth)
-      NS_CASE_CONDITIONAL_OUTPUT_PROPERTY_VALUE(finalBorderPropertiesToSet & B_BORDER_BOTTOM_WIDTH,
-                                                eCSSProperty_border_bottom_width, borderBottomWidth)
-      NS_CASE_OUTPUT_PROPERTY_VALUE_AS(eCSSProperty_border_start_width_value,
-                                       eCSSProperty_border_start_width, borderStartWidth)
-      NS_CASE_OUTPUT_PROPERTY_VALUE_AS(eCSSProperty_border_end_width_value,
-                                       eCSSProperty_border_end_width, borderEndWidth)
-
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty_margin_top, marginTop)
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty_margin_bottom, marginBottom)
-      NS_CASE_OUTPUT_PROPERTY_VALUE_AS(eCSSProperty_margin_left_value,
-                                       eCSSProperty_margin_left, marginLeft)
-      NS_CASE_OUTPUT_PROPERTY_VALUE_AS(eCSSProperty_margin_right_value,
-                                       eCSSProperty_margin_right, marginRight)
-
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty_padding_top, paddingTop)
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty_padding_bottom, paddingBottom)
-      NS_CASE_OUTPUT_PROPERTY_VALUE_AS(eCSSProperty_padding_left_value,
-                                       eCSSProperty_padding_left, paddingLeft)
-      NS_CASE_OUTPUT_PROPERTY_VALUE_AS(eCSSProperty_padding_right_value,
-                                       eCSSProperty_padding_right, paddingRight)
-
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty_background_color, bgColor)
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty_background_image, bgImage)
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty_background_repeat, bgRepeat)
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty_background_attachment, bgAttachment)
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty_background_position, bgPosition)
-
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty_overflow_x, overflowX)
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty_overflow_y, overflowY)
-
-#ifdef MOZ_SVG
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty_marker_end, markerEnd)
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty_marker_mid, markerMid)
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty_marker_start, markerStart)
-#endif
-
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty__moz_column_rule_width, columnRuleWidth)
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty__moz_column_rule_style, columnRuleStyle)
-      NS_CASE_OUTPUT_PROPERTY_VALUE(eCSSProperty__moz_column_rule_color, columnRuleColor)
-
-      case eCSSProperty_margin_left_ltr_source:
-      case eCSSProperty_margin_left_rtl_source:
-      case eCSSProperty_margin_right_ltr_source:
-      case eCSSProperty_margin_right_rtl_source:
-      case eCSSProperty_padding_left_ltr_source:
-      case eCSSProperty_padding_left_rtl_source:
-      case eCSSProperty_padding_right_ltr_source:
-      case eCSSProperty_padding_right_rtl_source:
-      case eCSSProperty_border_left_color_ltr_source:
-      case eCSSProperty_border_left_color_rtl_source:
-      case eCSSProperty_border_left_style_ltr_source:
-      case eCSSProperty_border_left_style_rtl_source:
-      case eCSSProperty_border_left_width_ltr_source:
-      case eCSSProperty_border_left_width_rtl_source:
-      case eCSSProperty_border_right_color_ltr_source:
-      case eCSSProperty_border_right_color_rtl_source:
-      case eCSSProperty_border_right_style_ltr_source:
-      case eCSSProperty_border_right_style_rtl_source:
-      case eCSSProperty_border_right_width_ltr_source:
-      case eCSSProperty_border_right_width_rtl_source:
-        break;
-
-      case eCSSProperty_margin_start_value:
-        AppendPropertyAndValueToString(property, eCSSProperty_margin_start,
-                                       aString);
-        break;
-      case eCSSProperty_margin_end_value:
-        AppendPropertyAndValueToString(property, eCSSProperty_margin_end,
-                                       aString);
-        break;
-      case eCSSProperty_padding_start_value:
-        AppendPropertyAndValueToString(property, eCSSProperty_padding_start,
-                                       aString);
-        break;
-      case eCSSProperty_padding_end_value:
-        AppendPropertyAndValueToString(property, eCSSProperty_padding_end,
-                                       aString);
-        break;
-
-      default:
-        if (0 <= property) {
-          AppendPropertyAndValueToString(property, aString);
-        }
-        break;
+    if (0 <= property) {
+      AppendPropertyAndValueToString(property, aString);
     }
   }
   if (! aString.IsEmpty()) {
     // if the string is not empty, we have a trailing whitespace we should remove
     aString.Truncate(aString.Length() - 1);
   }
   return NS_OK;
 }
diff --git a/layout/style/nsCSSDeclaration.h b/layout/style/nsCSSDeclaration.h
--- a/layout/style/nsCSSDeclaration.h
+++ b/layout/style/nsCSSDeclaration.h
@@ -160,68 +160,17 @@ private:
   PRBool operator==(const nsCSSDeclaration& aCopy) const;
 
   static void AppendImportanceToString(PRBool aIsImportant, nsAString& aString);
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
   PRBool   AppendValueToString(nsCSSProperty aProperty, nsAString& aResult) const;
   // May be called only for properties whose type is eCSSType_Value.
   nsresult GetValueOrImportantValue(nsCSSProperty aProperty, nsCSSValue& aValue) const;
 
-  void   PropertyIsSet(PRInt32 & aPropertyIndex, PRInt32 aIndex, PRUint32 & aSet, PRUint32 aValue) const;
-  PRBool TryBorderShorthand(nsAString & aString, PRUint32 aPropertiesSet,
-                            PRInt32 aBorderTopWidth,
-                            PRInt32 aBorderTopStyle,
-                            PRInt32 aBorderTopColor,
-                            PRInt32 aBorderBottomWidth,
-                            PRInt32 aBorderBottomStyle,
-                            PRInt32 aBorderBottomColor,
-                            PRInt32 aBorderLeftWidth,
-                            PRInt32 aBorderLeftStyle,
-                            PRInt32 aBorderLeftColor,
-                            PRInt32 aBorderRightWidth,
-                            PRInt32 aBorderRightStyle,
-                            PRInt32 aBorderRightColor) const;
-  PRBool  TryBorderSideShorthand(nsAString & aString,
-                                 nsCSSProperty  aShorthand,
-                                 PRInt32 aBorderWidth,
-                                 PRInt32 aBorderStyle,
-                                 PRInt32 aBorderColor) const;
-  PRBool  TryFourSidesShorthand(nsAString & aString,
-                                nsCSSProperty aShorthand,
-                                PRInt32 & aTop,
-                                PRInt32 & aBottom,
-                                PRInt32 & aLeft,
-                                PRInt32 & aRight,
-                                PRBool aClearIndexes) const;
-  void  TryBackgroundShorthand(nsAString & aString,
-                               PRInt32 & aBgColor, PRInt32 & aBgImage,
-                               PRInt32 & aBgRepeat, PRInt32 & aBgAttachment,
-                               PRInt32 & aBgPosition) const;
-  void  TryOverflowShorthand(nsAString & aString,
-                             PRInt32 & aOverflowX, PRInt32 & aOverflowY) const;
-#ifdef MOZ_SVG
-  void  TryMarkerShorthand(nsAString & aString,
-                           PRInt32 & aMarkerEnd,
-                           PRInt32 & aMarkerMid,
-                           PRInt32 & aMarkerStart) const;
-#endif
-
-  PRBool   AllPropertiesSameImportance(PRInt32 aFirst, PRInt32 aSecond,
-                                       PRInt32 aThird, PRInt32 aFourth,
-                                       PRInt32 aFifth,
-                                       PRBool & aImportance) const;
-  PRBool   AllPropertiesSameValue(PRInt32 aFirst, PRInt32 aSecond,
-                                  PRInt32 aThird, PRInt32 aFourth) const;
   void     AppendPropertyAndValueToString(nsCSSProperty aProperty,
-                                          nsAString& aResult) const
-  {
-    AppendPropertyAndValueToString(aProperty, aProperty, aResult);
-  }
-  void     AppendPropertyAndValueToString(nsCSSProperty aProperty,
-                                          nsCSSProperty aPropertyName,
                                           nsAString& aResult) const;
 
 private:
     //
     // Specialized ref counting.
     // We do not want everyone to ref count us, only the rules which hold
     //  onto us (our well defined lifetime is when the last rule releases
     //  us).
diff --git a/layout/style/nsCSSProps.cpp b/layout/style/nsCSSProps.cpp
--- a/layout/style/nsCSSProps.cpp
+++ b/layout/style/nsCSSProps.cpp
@@ -65,26 +65,43 @@ const char* const kCSSRawProperties[] = 
 #undef CSS_PROP_SHORTHAND
 };
 
 
 static PRInt32 gTableRefCount;
 static nsStaticCaseInsensitiveNameTable* gPropertyTable;
 static nsStaticCaseInsensitiveNameTable* gFontDescTable;
 
+/* static */ nsCSSProperty *
+  nsCSSProps::gShorthandsContainingTable[eCSSProperty_COUNT_no_shorthands];
+/* static */ nsCSSProperty* nsCSSProps::gShorthandsContainingPool = nsnull;
+
 // Keep in sync with enum nsCSSFontDesc in nsCSSProperty.h.
 static const char* const kCSSRawFontDescs[] = {
   "font-family",
   "font-style",
   "font-weight",
   "font-stretch",
   "src",
   "unicode-range"
 };
 
+struct PropertyAndCount {
+  nsCSSProperty property;
+  PRUint32 count;
+};
+
+static int 
+SortPropertyAndCount(const void* s1, const void* s2, void *closure)
+{
+  const PropertyAndCount *pc1 = static_cast<const PropertyAndCount*>(s1);
+  const PropertyAndCount *pc2 = static_cast<const PropertyAndCount*>(s2);
+  return pc1->count - pc2->count;
+}
+
 void
 nsCSSProps::AddRefTable(void) 
 {
   if (0 == gTableRefCount++) {
     NS_ASSERTION(!gPropertyTable, "pre existing array!");
     NS_ASSERTION(!gFontDescTable, "pre existing array!");
 
     gPropertyTable = new nsStaticCaseInsensitiveNameTable();
@@ -115,31 +132,141 @@ nsCSSProps::AddRefTable(void)
         ToLowerCase(temp1);
         NS_ASSERTION(temp1.Equals(temp2), "upper case char in desc table");
         NS_ASSERTION(-1 == temp1.FindChar('_'), "underscore char in desc table");
       }
     }
 #endif      
       gFontDescTable->Init(kCSSRawFontDescs, eCSSFontDesc_COUNT); 
     }
+
+    BuildShorthandsContainingTable();
   }
 }
 
+#undef  DEBUG_SHORTHANDS_CONTAINING
+
+PRBool
+nsCSSProps::BuildShorthandsContainingTable() 
+{
+  PRUint32 occurrenceCounts[eCSSProperty_COUNT_no_shorthands];
+  memset(occurrenceCounts, 0, sizeof(occurrenceCounts));
+  PropertyAndCount subpropCounts[eCSSProperty_COUNT -
+                                   eCSSProperty_COUNT_no_shorthands];
+  for (nsCSSProperty shorthand = eCSSProperty_COUNT_no_shorthands;
+       shorthand < eCSSProperty_COUNT;
+       shorthand = nsCSSProperty(shorthand + 1)) {
+#ifdef DEBUG_SHORTHANDS_CONTAINING
+    printf("Considering shorthand property '%s'.\n",
+           nsCSSProps::GetStringValue(shorthand).get());
+#endif
+    // Fill in subpropCounts backwards since we'll sort and use it backwards.
+    PropertyAndCount &subpropCountsEntry =
+      subpropCounts[eCSSProperty_COUNT - 1 - shorthand];
+    subpropCountsEntry.property = shorthand;
+    subpropCountsEntry.count = 0;
+    for (const nsCSSProperty* subprops = SubpropertyEntryFor(shorthand);
+         *subprops != eCSSProperty_UNKNOWN;
+         ++subprops) {
+      NS_ASSERTION(0 < *subprops &&
+                   *subprops < eCSSProperty_COUNT_no_shorthands,
+                   "subproperty must be a longhand");
+      ++occurrenceCounts[*subprops];
+      ++subpropCountsEntry.count;
+    }
+  }
+
+  PRUint32 poolEntries = 0;
+  for (nsCSSProperty longhand = nsCSSProperty(0);
+       longhand < eCSSProperty_COUNT_no_shorthands;
+       longhand = nsCSSProperty(longhand + 1)) {
+    PRUint32 count = occurrenceCounts[longhand];
+    if (count > 0)
+      // leave room for terminator
+      poolEntries += count + 1;
+  }
+
+  gShorthandsContainingPool = new nsCSSProperty[poolEntries];
+  if (!gShorthandsContainingPool)
+    return PR_FALSE;
+
+  // Initialize all entries to point to their null-terminator.
+  {
+    nsCSSProperty *poolCursor = gShorthandsContainingPool - 1;
+    nsCSSProperty *lastTerminator =
+      gShorthandsContainingPool + poolEntries - 1;
+    for (nsCSSProperty longhand = nsCSSProperty(0);
+         longhand < eCSSProperty_COUNT_no_shorthands;
+         longhand = nsCSSProperty(longhand + 1)) {
+      PRUint32 count = occurrenceCounts[longhand];
+      if (count > 0) {
+        poolCursor += count + 1;
+        gShorthandsContainingTable[longhand] = poolCursor;
+        *poolCursor = eCSSProperty_UNKNOWN;
+      } else {
+        gShorthandsContainingTable[longhand] = lastTerminator;
+      }
+    }
+    NS_ASSERTION(poolCursor == lastTerminator, "miscalculation");
+  }
+
+  // Sort with lowest count at the start and highest at the end (but
+  // stably so that they're still alphabetical within counts).
+  NS_QuickSort(&subpropCounts, NS_ARRAY_LENGTH(subpropCounts),
+               sizeof(subpropCounts[0]), SortPropertyAndCount, nsnull);
+
+  // Fill in all the entries in gShorthandsContainingTable
+  for (const PropertyAndCount *shorthandAndCount = subpropCounts,
+                           *shorthandAndCountEnd =
+                                subpropCounts + NS_ARRAY_LENGTH(subpropCounts);
+       shorthandAndCount < shorthandAndCountEnd;
+       ++shorthandAndCount) {
+#ifdef DEBUG_SHORTHANDS_CONTAINING
+    printf("Entering %u subprops for '%s'.\n",
+           shorthandAndCount->count,
+           nsCSSProps::GetStringValue(shorthandAndCount->property).get());
+#endif
+    for (const nsCSSProperty* subprops =
+           SubpropertyEntryFor(shorthandAndCount->property);
+         *subprops != eCSSProperty_UNKNOWN;
+         ++subprops) {
+      *(--gShorthandsContainingTable[*subprops]) = shorthandAndCount->property;
+    }
+  }
+
+#ifdef DEBUG_SHORTHANDS_CONTAINING
+  for (nsCSSProperty longhand = nsCSSProperty(0);
+       longhand < eCSSProperty_COUNT_no_shorthands;
+       longhand = nsCSSProperty(longhand + 1)) {
+    printf("Property %s is in %d shorthands.\n",
+           nsCSSProps::GetStringValue(longhand).get(),
+           occurrenceCounts[longhand]);
+    for (const nsCSSProperty *shorthands = ShorthandsContaining(longhand);
+         *shorthands != eCSSProperty_UNKNOWN;
+         ++shorthands) {
+      printf("  %s\n", nsCSSProps::GetStringValue(*shorthands).get());
+    }
+  }
+#endif
+
+  return PR_TRUE;
+}
+
 void
 nsCSSProps::ReleaseTable(void) 
 {
   if (0 == --gTableRefCount) {
-    if (gPropertyTable) {
-      delete gPropertyTable;
-      gPropertyTable = nsnull;
-    }
-    if (gFontDescTable) {
-      delete gFontDescTable;
-      gFontDescTable = nsnull;
-    }
+    delete gPropertyTable;
+    gPropertyTable = nsnull;
+
+    delete gFontDescTable;
+    gFontDescTable = nsnull;
+
+    delete gShorthandsContainingPool;
+    gShorthandsContainingPool = nsnull;
   }
 }
 
 nsCSSProperty 
 nsCSSProps::LookupProperty(const nsACString& aProperty)
 {
   NS_ASSERTION(gPropertyTable, "no lookup table, needs addref");
 
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -100,38 +100,61 @@ public:
   // Return |eCSSKeyword_UNKNOWN| if not found.
   static nsCSSKeyword ValueToKeywordEnum(PRInt32 aValue, const PRInt32 aTable[]);
   // Ditto but as a string, return "" when not found.
   static const nsAFlatCString& ValueToKeyword(PRInt32 aValue, const PRInt32 aTable[]);
 
   static const nsCSSType       kTypeTable[eCSSProperty_COUNT_no_shorthands];
   static const nsStyleStructID kSIDTable[eCSSProperty_COUNT_no_shorthands];
   static const PRInt32* const  kKeywordTableTable[eCSSProperty_COUNT_no_shorthands];
+
 private:
   static const PRUint32        kFlagsTable[eCSSProperty_COUNT];
 
+public:
+  static inline PRBool PropHasFlags(nsCSSProperty aProperty, PRUint32 aFlags)
+  {
+    NS_ASSERTION(0 <= aProperty && aProperty < eCSSProperty_COUNT,
+                 "out of range");
+    return (nsCSSProps::kFlagsTable[aProperty] & aFlags) == aFlags;
+  }
+
+private:
   // A table for shorthand properties.  The appropriate index is the
   // property ID minus eCSSProperty_COUNT_no_shorthands.
   static const nsCSSProperty *const
     kSubpropertyTable[eCSSProperty_COUNT - eCSSProperty_COUNT_no_shorthands];
 
 public:
   static inline
-  const nsCSSProperty *const SubpropertyEntryFor(nsCSSProperty aProperty) {
+  const nsCSSProperty * SubpropertyEntryFor(nsCSSProperty aProperty) {
     NS_ASSERTION(eCSSProperty_COUNT_no_shorthands <= aProperty &&
                  aProperty < eCSSProperty_COUNT,
                  "out of range");
     return nsCSSProps::kSubpropertyTable[aProperty -
                                          eCSSProperty_COUNT_no_shorthands];
   }
 
-  static inline PRBool PropHasFlags(nsCSSProperty aProperty, PRUint32 aFlags)
-  {
-    return (nsCSSProps::kFlagsTable[aProperty] & aFlags) == aFlags;
+  // Returns an eCSSProperty_UNKNOWN-terminated array of the shorthand
+  // properties containing |aProperty|, sorted from those that contain
+  // the most properties to those that contain the least.
+  static const nsCSSProperty * ShorthandsContaining(nsCSSProperty aProperty) {
+    NS_ASSERTION(gShorthandsContainingPool, "uninitialized");
+    NS_ASSERTION(0 <= aProperty && aProperty < eCSSProperty_COUNT_no_shorthands,
+                 "out of range");
+    return gShorthandsContainingTable[aProperty];
   }
+private:
+  // gShorthandsContainingTable is an array of the return values for
+  // ShorthandsContaining pointing into memory in gShorthandsContainingPool.
+  static nsCSSProperty *gShorthandsContainingTable[eCSSProperty_COUNT_no_shorthands];
+  static nsCSSProperty* gShorthandsContainingPool;
+  static PRBool BuildShorthandsContainingTable();
+
+public:
 
 #define CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(iter_, prop_)                    \
   for (const nsCSSProperty* iter_ = nsCSSProps::SubpropertyEntryFor(prop_);   \
        *iter_ != eCSSProperty_UNKNOWN; ++iter_)
 
   // Keyword/Enum value tables
   static const PRInt32 kAppearanceKTable[];
   static const PRInt32 kAzimuthKTable[];
