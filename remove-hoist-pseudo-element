From: L. David Baron <dbaron@dbaron.org>

Parse pseudo-elements into their own pointer so we don't have to go through the trouble of removing them from the pseudo-class list.  (Bug 520848)  r=bzbarsky

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -339,19 +339,25 @@ protected:
     eSelectorParsingStatus_Error
   };
   nsSelectorParsingStatus ParseIDSelector(PRInt32&       aDataMask,
                                           nsCSSSelector& aSelector);
 
   nsSelectorParsingStatus ParseClassSelector(PRInt32&       aDataMask,
                                              nsCSSSelector& aSelector);
 
+  // aPseudoElement and aPseudoElementArgs are the location where
+  // pseudo-elements (as opposed to pseudo-classes) are stored;
+  // pseudo-classes are stored on aSelector.  aPseudoElement and
+  // aPseudoElementArgs must be non-null iff !aIsNegated.
   nsSelectorParsingStatus ParsePseudoSelector(PRInt32&       aDataMask,
                                               nsCSSSelector& aSelector,
-                                              PRBool         aIsNegated);
+                                              PRBool         aIsNegated,
+                                              nsIAtom**      aPseudoElement,
+                                              nsPseudoClassList** aPseudoElementArgs);
 
   nsSelectorParsingStatus ParseAttributeSelector(PRInt32&       aDataMask,
                                                  nsCSSSelector& aSelector);
 
   nsSelectorParsingStatus ParseTypeOrUniversalSelector(PRInt32&       aDataMask,
                                                        nsCSSSelector& aSelector,
                                                        PRBool         aIsNegated);
 
@@ -359,17 +365,19 @@ protected:
                                                        nsIAtom*       aPseudo);
 
   nsSelectorParsingStatus ParsePseudoClassWithNthPairArg(nsCSSSelector& aSelector,
                                                          nsIAtom*       aPseudo);
 
   nsSelectorParsingStatus ParseNegatedSimpleSelector(PRInt32&       aDataMask,
                                                      nsCSSSelector& aSelector);
 
-  nsSelectorParsingStatus ParseSelector(nsCSSSelector& aSelectorResult);
+  nsSelectorParsingStatus ParseSelector(nsCSSSelector& aSelectorResult,
+                                        nsIAtom** aPseudoElement,
+                                        nsPseudoClassList** aPseudoElementArgs);
 
   // If aTerminateAtBrace is true, the selector list is done when we
   // hit a '{'.  Otherwise, it's done when we hit EOF.
   PRBool ParseSelectorList(nsCSSSelectorList*& aListHead,
                            PRBool aTerminateAtBrace);
   PRBool ParseSelectorGroup(nsCSSSelectorList*& aListHead);
   nsCSSDeclaration* ParseDeclarationBlock(PRBool aCheckForBraces);
   PRBool ParseDeclaration(nsCSSDeclaration* aDeclaration,
@@ -398,17 +406,17 @@ protected:
   // for the property id.  This can only be used for non-shorthand properties.
   void CopyValue(void *aSource, void *aDest, nsCSSProperty aPropID,
                  PRBool* aChanged);
   PRBool ParseProperty(nsCSSProperty aPropID);
   PRBool ParseSingleValueProperty(nsCSSValue& aValue,
                                   nsCSSProperty aPropID);
 
 #ifdef MOZ_XUL
-  PRBool ParseTreePseudoElement(nsCSSSelector& aSelector);
+  PRBool ParseTreePseudoElement(nsPseudoClassList **aPseudoElementArgs);
 #endif
 
   void InitBoxPropsAsPhysical(const nsCSSProperty *aSourceProperties);
 
   // Property specific parsing routines
   PRBool ParseAzimuth(nsCSSValue& aValue);
   PRBool ParseBackground();
 
@@ -2456,26 +2464,25 @@ CSSParserImpl::ParseSelectorList(nsCSSSe
     break;
   }
 
   delete aListHead;
   aListHead = nsnull;
   return PR_FALSE;
 }
 
-static PRBool IsSinglePseudoClass(const nsCSSSelector& aSelector)
+static PRBool IsUniversalSelector(const nsCSSSelector& aSelector)
 {
   return PRBool((aSelector.mNameSpace == kNameSpaceID_Unknown) &&
                 (aSelector.mLowercaseTag == nsnull) &&
                 (aSelector.mIDList == nsnull) &&
                 (aSelector.mClassList == nsnull) &&
                 (aSelector.mAttrList == nsnull) &&
                 (aSelector.mNegations == nsnull) &&
-                (aSelector.mPseudoClassList != nsnull) &&
-                (aSelector.mPseudoClassList->mNext == nsnull));
+                (aSelector.mPseudoClassList == nsnull));
 }
 
 #ifdef MOZ_XUL
 static PRBool IsTreePseudoElement(nsIAtom* aPseudo)
 {
   const char* str;
   aPseudo->GetUTF8String(&str);
   static const char moz_tree[] = ":-moz-tree-";
@@ -2492,18 +2499,21 @@ CSSParserImpl::ParseSelectorGroup(nsCSSS
   PRBool        havePseudoElement = PR_FALSE;
   PRBool        done = PR_FALSE;
   while (!done) {
     nsAutoPtr<nsCSSSelector> newSelector(new nsCSSSelector());
     if (!newSelector) {
       mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
       return PR_FALSE;
     }
+    nsCOMPtr<nsIAtom> pseudoElement;
+    nsAutoPtr<nsPseudoClassList> pseudoElementArgs;
     nsSelectorParsingStatus parsingStatus =
-      ParseSelector(*newSelector);
+      ParseSelector(*newSelector, getter_AddRefs(pseudoElement),
+                    getter_Transfers(pseudoElementArgs));
     if (parsingStatus == eSelectorParsingStatus_Empty) {
       if (!list) {
         REPORT_UNEXPECTED(PESelectorGroupNoSelector);
       }
       break;
     }
     if (parsingStatus == eSelectorParsingStatus_Error) {
       list = nsnull;
@@ -2514,72 +2524,38 @@ CSSParserImpl::ParseSelectorGroup(nsCSSS
       if (nsnull == list) {
         mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
         return PR_FALSE;
       }
     }
     list->AddSelector(newSelector);
     nsCSSSelector* listSel = list->mSelectors;
 
-    // pull out pseudo elements here
-    nsPseudoClassList* prevList = nsnull;
-    nsPseudoClassList* pseudoClassList = listSel->mPseudoClassList;
-    while (nsnull != pseudoClassList) {
-      if (! nsCSSPseudoClasses::IsPseudoClass(pseudoClassList->mAtom)) {
-        havePseudoElement = PR_TRUE;
-        if (IsSinglePseudoClass(*listSel)) {  // convert to pseudo element selector
-          nsIAtom* pseudoElement = pseudoClassList->mAtom;  // steal ref count
-          pseudoClassList->mAtom = nsnull;
-          listSel->Reset();
-          if (listSel->mNext) {// more to the selector
-            listSel->mOperator = PRUnichar('>');
-            nsAutoPtr<nsCSSSelector> empty(new nsCSSSelector());
-            if (!empty) {
-              mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-              return PR_FALSE;
-            }
-            list->AddSelector(empty); // leave a blank (universal) selector in the middle
-            listSel = list->mSelectors; // use the new one for the pseudo
-          }
-          listSel->mLowercaseTag = pseudoElement;
-        }
-        else {  // append new pseudo element selector
-          nsAutoPtr<nsCSSSelector> pseudoTagSelector(new nsCSSSelector());
-          if (!pseudoTagSelector) {
-            mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-            return PR_FALSE;
-          }
-          pseudoTagSelector->mLowercaseTag = pseudoClassList->mAtom; // steal ref count
-#ifdef MOZ_XUL
-          if (IsTreePseudoElement(pseudoTagSelector->mLowercaseTag)) {
-            // Take the remaining "pseudoclasses" that we parsed
-            // inside the tree pseudoelement's ()-list, and
-            // make our new selector have these pseudoclasses
-            // in its pseudoclass list.
-            pseudoTagSelector->mPseudoClassList = pseudoClassList->mNext;
-            pseudoClassList->mNext = nsnull;
-          }
-#endif
-          list->AddSelector(pseudoTagSelector);
-          pseudoClassList->mAtom = nsnull;
-          listSel->mOperator = PRUnichar('>');
-          if (nsnull == prevList) { // delete list entry
-            listSel->mPseudoClassList = pseudoClassList->mNext;
-          }
-          else {
-            prevList->mNext = pseudoClassList->mNext;
-          }
-          pseudoClassList->mNext = nsnull;
-          delete pseudoClassList;
-          weight += listSel->CalcWeight(); // capture weight from remainder
-        }
-        break;  // only one pseudo element per selector
-      }
-      prevList = pseudoClassList;
-      pseudoClassList = pseudoClassList->mNext;
+    // We got a pseudo-element (or anonymous box).  We actually
+    // represent pseudo-elements as a child of the rest of the selector.
+    if (pseudoElement) {
+      if (listSel->mNext || !IsUniversalSelector(*listSel)) {
+        // We need to put the pseudo-element on a new selector that's a
+        // child of the current one.  (If it's the only thing in the
+        // entire selector group, we can just put it on this one.)
+        listSel->mOperator = PRUnichar('>');
+        nsAutoPtr<nsCSSSelector> empty(new nsCSSSelector());
+        if (!empty) {
+          mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+          return PR_FALSE;
+        }
+        list->AddSelector(empty);
+        listSel = list->mSelectors; // use the new one for the pseudo
+      }
+      NS_ASSERTION(!listSel->mLowercaseTag &&
+                   !listSel->mCasedTag &&
+                   !listSel->mPseudoClassList,
+                   "already initialized");
+      listSel->mLowercaseTag.swap(pseudoElement);
+      listSel->mPseudoClassList = pseudoElementArgs.forget();
     }
 
     combinator = PRUnichar(0);
     if (!GetToken(PR_FALSE)) {
       break;
     }
 
     // Assume we are done unless we find a combinator here.
@@ -3014,18 +2990,25 @@ CSSParserImpl::ParseAttributeSelector(PR
 }
 
 //
 // Parse pseudo-classes and pseudo-elements
 //
 CSSParserImpl::nsSelectorParsingStatus
 CSSParserImpl::ParsePseudoSelector(PRInt32&       aDataMask,
                                    nsCSSSelector& aSelector,
-                                   PRBool         aIsNegated)
-{
+                                   PRBool         aIsNegated,
+                                   nsIAtom**      aPseudoElement,
+                                   nsPseudoClassList** aPseudoElementArgs)
+{
+  NS_ASSERTION(aIsNegated || (aPseudoElement && aPseudoElementArgs),
+               "expected location to store pseudo element");
+  NS_ASSERTION(!aIsNegated || (!aPseudoElement && !aPseudoElementArgs),
+               "negated selectors shouldn't have a place to store "
+               "pseudo elements");
   if (! GetToken(PR_FALSE)) { // premature eof
     REPORT_UNEXPECTED_EOF(PEPseudoSelEOF);
     return eSelectorParsingStatus_Error;
   }
 
   // First, find out whether we are parsing a CSS3 pseudo-element
   PRBool parsingPseudoElement = PR_FALSE;
   if (mToken.IsSymbol(':')) {
@@ -3046,16 +3029,20 @@ CSSParserImpl::ParsePseudoSelector(PRInt
 
   // OK, now we know we have an mIdent.  Atomize it.  All the atoms, for
   // pseudo-classes as well as pseudo-elements, start with a single ':'.
   nsAutoString buffer;
   buffer.Append(PRUnichar(':'));
   buffer.Append(mToken.mIdent);
   ToLowerCase(buffer);
   nsCOMPtr<nsIAtom> pseudo = do_GetAtom(buffer);
+  if (!pseudo) {
+    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+    return eSelectorParsingStatus_Error;
+  }
 
   // stash away some info about this pseudo so we only have to get it once.
   PRBool isTreePseudo = PR_FALSE;
 #ifdef MOZ_XUL
   isTreePseudo = IsTreePseudoElement(pseudo);
   // If a tree pseudo-element is using the function syntax, it will
   // get isTree set here and will pass the check below that only
   // allows functions if they are in our list of things allowed to be
@@ -3157,25 +3144,25 @@ CSSParserImpl::ParsePseudoSelector(PRInt
         ) {
       REPORT_UNEXPECTED_TOKEN(PEPseudoSelNewStyleOnly);
       UngetToken();
       return eSelectorParsingStatus_Error;
     }
 
     if (0 == (aDataMask & SEL_MASK_PELEM)) {
       aDataMask |= SEL_MASK_PELEM;
-      aSelector.AddPseudoClass(pseudo); // store it here, it gets pulled later
+      NS_ADDREF(*aPseudoElement = pseudo);
 
 #ifdef MOZ_XUL
       if (isTree) {
         // We have encountered a pseudoelement of the form
         // -moz-tree-xxxx(a,b,c).  We parse (a,b,c) and add each
         // item in the list to the pseudoclass list.  They will be pulled
         // from the list later along with the pseudo-element.
-        if (!ParseTreePseudoElement(aSelector)) {
+        if (!ParseTreePseudoElement(aPseudoElementArgs)) {
           return eSelectorParsingStatus_Error;
         }
       }
 #endif
 
       // ensure selector ends here, must be followed by EOF, space, '{' or ','
       if (GetToken(PR_FALSE)) { // premature eof is ok (here!)
         if ((eCSSToken_WhiteSpace == mToken.mType) ||
@@ -3248,17 +3235,18 @@ CSSParserImpl::ParseNegatedSimpleSelecto
   nsSelectorParsingStatus parsingStatus;
   if (eCSSToken_ID == mToken.mType) { // #id
     parsingStatus = ParseIDSelector(aDataMask, *newSel);
   }
   else if (mToken.IsSymbol('.')) {    // .class
     parsingStatus = ParseClassSelector(aDataMask, *newSel);
   }
   else if (mToken.IsSymbol(':')) {    // :pseudo
-    parsingStatus = ParsePseudoSelector(aDataMask, *newSel, PR_TRUE);
+    parsingStatus = ParsePseudoSelector(aDataMask, *newSel, PR_TRUE,
+                                        nsnull, nsnull);
   }
   else if (mToken.IsSymbol('[')) {    // [attribute
     parsingStatus = ParseAttributeSelector(aDataMask, *newSel);
   }
   else {
     // then it should be a type element or universal selector
     parsingStatus = ParseTypeOrUniversalSelector(aDataMask, *newSel, PR_TRUE);
   }
@@ -3456,17 +3444,19 @@ CSSParserImpl::ParsePseudoClassWithNthPa
 }
 
 
 /**
  * This is the format for selectors:
  * operator? [[namespace |]? element_name]? [ ID | class | attrib | pseudo ]*
  */
 CSSParserImpl::nsSelectorParsingStatus
-CSSParserImpl::ParseSelector(nsCSSSelector& aSelector)
+CSSParserImpl::ParseSelector(nsCSSSelector& aSelector,
+                             nsIAtom** aPseudoElement,
+                             nsPseudoClassList** aPseudoElementArgs)
 {
   if (! GetToken(PR_TRUE)) {
     REPORT_UNEXPECTED_EOF(PESelectorEOF);
     return eSelectorParsingStatus_Error;
   }
 
   PRInt32 dataMask = 0;
   nsSelectorParsingStatus parsingStatus =
@@ -3478,17 +3468,18 @@ CSSParserImpl::ParseSelector(nsCSSSelect
   for (;;) {
     if (eCSSToken_ID == mToken.mType) { // #id
       parsingStatus = ParseIDSelector(dataMask, aSelector);
     }
     else if (mToken.IsSymbol('.')) {    // .class
       parsingStatus = ParseClassSelector(dataMask, aSelector);
     }
     else if (mToken.IsSymbol(':')) {    // :pseudo
-      parsingStatus = ParsePseudoSelector(dataMask, aSelector, PR_FALSE);
+      parsingStatus = ParsePseudoSelector(dataMask, aSelector, PR_FALSE,
+                                          aPseudoElement, aPseudoElementArgs);
     }
     else if (mToken.IsSymbol('[')) {    // [attribute
       parsingStatus = ParseAttributeSelector(dataMask, aSelector);
     }
     else {  // not a selector token, we're done
       parsingStatus = eSelectorParsingStatus_Done;
       break;
     }
@@ -3877,35 +3868,38 @@ CSSParserImpl::ParseColorOpacity(PRUint8
 
   aOpacity = value;
 
   return PR_TRUE;
 }
 
 #ifdef MOZ_XUL
 PRBool
-CSSParserImpl::ParseTreePseudoElement(nsCSSSelector& aSelector)
+CSSParserImpl::ParseTreePseudoElement(nsPseudoClassList **aPseudoElementArgs)
 {
   // The argument to a tree pseudo-element is a sequence of identifiers
   // that are either space- or comma-separated.  (Was the intent to
   // allow only comma-separated?  That's not what was done.)
+  nsCSSSelector fakeSelector; // so we can reuse AddPseudoClass
   if (ExpectSymbol('(', PR_FALSE)) {
     while (!ExpectSymbol(')', PR_TRUE)) {
       if (!GetToken(PR_TRUE)) {
         return PR_FALSE;
       }
       if (eCSSToken_Ident == mToken.mType) {
         nsCOMPtr<nsIAtom> pseudo = do_GetAtom(mToken.mIdent);
-        aSelector.AddPseudoClass(pseudo);
+        fakeSelector.AddPseudoClass(pseudo);
       }
       else if (!mToken.IsSymbol(',')) {
         SkipUntil(')');
         return PR_FALSE;
       }
     }
+    *aPseudoElementArgs = fakeSelector.mPseudoClassList;
+    fakeSelector.mPseudoClassList = nsnull;
     return PR_TRUE;
   }
   return PR_FALSE;
 }
 #endif
 
 //----------------------------------------------------------------------
 
