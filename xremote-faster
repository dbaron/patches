Make FindBestWindow faster when there are a lot of windows (many of which may be Firefox windows).  (Bug 467635)  r+sr=roc

diff --git a/widget/src/xremoteclient/XRemoteClient.cpp b/widget/src/xremoteclient/XRemoteClient.cpp
--- a/widget/src/xremoteclient/XRemoteClient.cpp
+++ b/widget/src/xremoteclient/XRemoteClient.cpp
@@ -455,17 +455,16 @@ XRemoteClient::FindBestWindow(const char
 XRemoteClient::FindBestWindow(const char *aProgram, const char *aUsername,
                               const char *aProfile,
                               PRBool aSupportsCommandLine)
 {
   Window root = RootWindowOfScreen(DefaultScreenOfDisplay(mDisplay));
   Window bestWindow = 0;
   Window root2, parent, *kids;
   unsigned int nkids;
-  int i;
 
   // Get a list of the children of the root window, walk the list
   // looking for the best window that fits the criteria.
   if (!XQueryTree(mDisplay, root, &root2, &parent, &kids, &nkids)) {
     PR_LOG(sRemoteLm, PR_LOG_DEBUG,
            ("XQueryTree failed in XRemoteClient::FindBestWindow"));
     return 0;
   }
@@ -473,17 +472,17 @@ XRemoteClient::FindBestWindow(const char
   if (!(kids && nkids)) {
     PR_LOG(sRemoteLm, PR_LOG_DEBUG, ("root window has no children"));
     return 0;
   }
 
   // We'll walk the list of windows looking for a window that best
   // fits the criteria here.
 
-  for (i=nkids-1; i >= 0; i--) {
+  for (unsigned int i = 0; i < nkids; i++) {
     Atom type;
     int format;
     unsigned long nitems, bytesafter;
     unsigned char *data_return = 0;
     Window w;
     w = kids[i];
     // find the inner window with WM_STATE on it
     w = CheckWindow(w);
@@ -586,19 +585,20 @@ XRemoteClient::FindBestWindow(const char
 
             XFree(data_return);
         }
     }
 
     // Check to see if the window supports the new command-line passing
     // protocol, if that is requested.
 
-    // If we got this far, this is the best window so far.  It passed
+    // If we got this far, this is the best window.  It passed
     // all the tests.
     bestWindow = w;
+    break;
   }
 
   if (kids)
     XFree((char *) kids);
 
   return bestWindow;
 }
 
@@ -694,34 +694,32 @@ estrcpy(const char* s, char* d)
   return d;
 }
 
 nsresult
 XRemoteClient::DoSendCommandLine(Window aWindow, PRInt32 argc, char **argv,
                                  const char* aDesktopStartupID,
                                  char **aResponse, PRBool *aDestroyed)
 {
-  int i;
-
   *aDestroyed = PR_FALSE;
 
   char cwdbuf[MAX_PATH];
   if (!getcwd(cwdbuf, MAX_PATH))
     return NS_ERROR_UNEXPECTED;
 
   // the commandline property is constructed as an array of PRInt32
   // followed by a series of null-terminated strings:
   //
   // [argc][offsetargv0][offsetargv1...]<workingdir>\0<argv[0]>\0argv[1]...\0
   // (offset is from the beginning of the buffer)
 
   static char desktopStartupPrefix[] = " DESKTOP_STARTUP_ID=";
 
   PRInt32 argvlen = strlen(cwdbuf);
-  for (i = 0; i < argc; ++i) {
+  for (int i = 0; i < argc; ++i) {
     PRInt32 len = strlen(argv[i]);
     if (i == 0 && aDesktopStartupID) {
       len += sizeof(desktopStartupPrefix) - 1 + strlen(aDesktopStartupID);
     }
     argvlen += len;
   }
 
   // XXXldb Would be nice to free |buffer|!
