From: L. David Baron <dbaron@dbaron.org>

Instead of stack-allocating nsRuleData* structs in separate methods for each style struct, allocate an array of nsCSSValue using alloca.  (Bug 636039)

diff --git a/layout/style/nsRuleData.h b/layout/style/nsRuleData.h
--- a/layout/style/nsRuleData.h
+++ b/layout/style/nsRuleData.h
@@ -59,54 +59,37 @@ struct nsRuleData
   PRUint32 mSIDs;
   PRPackedBool mCanStoreInRuleTree;
   PRPackedBool mIsImportantRule;
   PRUint8 mLevel; // an nsStyleSet::sheetType
   nsPresContext* mPresContext;
   nsStyleContext* mStyleContext;
   nsPostResolveFunc mPostResolveCallback;
 
-  // Should always be stack-allocated! We don't own these structures!
-  nsRuleDataFont* mFontData;
-  nsRuleDataDisplay* mDisplayData;
-  nsRuleDataMargin* mMarginData;
-  nsRuleDataList* mListData;
-  nsRuleDataPosition* mPositionData;
-  nsRuleDataTable* mTableData;
-  nsRuleDataColor* mColorData;
-  nsRuleDataContent* mContentData;
-  nsRuleDataText* mTextData;
-  nsRuleDataUserInterface* mUserInterfaceData;
-  nsRuleDataXUL* mXULData;
-  nsRuleDataSVG* mSVGData;
-  nsRuleDataColumn* mColumnData;
+  nsCSSValue* mValueStorage; // our user owns this array
+  size_t mValueOffsets[nsStyleStructID_Length]
 
   nsRuleData(PRUint32 aSIDs,
              nsPresContext* aContext,
              nsStyleContext* aStyleContext)
     : mSIDs(aSIDs),
       mCanStoreInRuleTree(PR_TRUE),
       mPresContext(aContext),
       mStyleContext(aStyleContext),
-      mPostResolveCallback(nsnull),
-      mFontData(nsnull),
-      mDisplayData(nsnull),
-      mMarginData(nsnull),
-      mListData(nsnull),
-      mPositionData(nsnull),
-      mTableData(nsnull),
-      mColorData(nsnull),
-      mContentData(nsnull),
-      mTextData(nsnull),
-      mUserInterfaceData(nsnull),
-      mXULData(nsnull),
-      mSVGData(nsnull),
-      mColumnData(nsnull)
-  {}
-  ~nsRuleData() {}
+      mPostResolveCallback(nsnull)
+  {
+  #ifdef DEBUG
+    // FIXME: WRITE ME
+  #endif
+  }
+  ~nsRuleData() {
+  #ifdef DEBUG
+    // FIXME: WRITE ME
+  #endif
+  }
 
   /**
    * Return a pointer to the value object within |this| corresponding
    * to property |aProperty|.
    *
    * This function must only be called if the given property is in
    * mSIDs.
    */
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -76,16 +76,17 @@
 #include "nsStyleTransformMatrix.h"
 #include "nsCSSKeywords.h"
 #include "nsCSSProps.h"
 #include "nsTArray.h"
 #include "nsContentUtils.h"
 #include "mozilla/dom/Element.h"
 #include "CSSCalc.h"
 #include "nsPrintfCString.h"
+#include <alloca.h>
 
 using namespace mozilla::dom;
 namespace css = mozilla::css;
 
 #define NS_SET_IMAGE_REQUEST(method_, context_, request_)                   \
   if ((context_)->PresContext()->IsDynamic()) {                               \
     method_(request_);                                                      \
   } else {                                                                  \
@@ -1296,43 +1297,25 @@ nsRuleNode::PropagateDependentBit(PRUint
   }
 }
 
 /*
  * The following "Check" functions are used for determining what type of
  * sharing can be used for the data on this rule node.  MORE HERE...
  */
 
-/* the information for a property (or in some cases, a rect group of
-   properties) */
-
-struct PropertyCheckData {
-  size_t offset;
-  // These duplicate the data in nsCSSProps::kFlagsTable, except that
-  // we have some extra entries for CSS_PROP_INCLUDE_NOT_CSS.
-  PRUint32 flags;
-};
-
 /*
  * a callback function that that can revise the result of
  * CheckSpecifiedProperties before finishing; aResult is the current
  * result, and it returns the revised one.
  */
 typedef nsRuleNode::RuleDetail
-  (* CheckCallbackFn)(const nsRuleDataStruct& aData,
+  (* CheckCallbackFn)(const nsRuleData* aRuleData,
                       nsRuleNode::RuleDetail aResult);
 
-/* the information for all the properties in a style struct */
-struct StructCheckData {
-  const PropertyCheckData* props;
-  PRInt32 nprops;
-  CheckCallbackFn callback;
-};
-
-
 /**
  * @param aValue the value being examined
  * @param aSpecifiedCount to be incremented by one if the value is specified
  * @param aInherited to be incremented by one if the value is set to inherit
  */
 inline void
 ExamineCSSValue(const nsCSSValue& aValue,
                 PRUint32& aSpecifiedCount, PRUint32& aInheritedCount)
@@ -1341,35 +1324,32 @@ ExamineCSSValue(const nsCSSValue& aValue
     ++aSpecifiedCount;
     if (aValue.GetUnit() == eCSSUnit_Inherit) {
       ++aInheritedCount;
     }
   }
 }
 
 static nsRuleNode::RuleDetail
-CheckFontCallback(const nsRuleDataStruct& aData,
+CheckFontCallback(const nsRuleData* aRuleData,
                   nsRuleNode::RuleDetail aResult)
 {
-  const nsRuleDataFont& fontData =
-      static_cast<const nsRuleDataFont&>(aData);
-
   // em, ex, percent, 'larger', and 'smaller' values on font-size depend
   // on the parent context's font-size
   // Likewise, 'lighter' and 'bolder' values of 'font-weight', and 'wider'
   // and 'narrower' values of 'font-stretch' depend on the parent.
-  const nsCSSValue& size = fontData.mSize;
-  const nsCSSValue& weight = fontData.mWeight;
+  const nsCSSValue& size = *aRuleData->ValueForFontSize();
+  const nsCSSValue& weight = *aRuleData->ValueForFontWeight();
   if (size.IsRelativeLengthUnit() ||
       size.GetUnit() == eCSSUnit_Percent ||
       (size.GetUnit() == eCSSUnit_Enumerated &&
        (size.GetIntValue() == NS_STYLE_FONT_SIZE_SMALLER ||
         size.GetIntValue() == NS_STYLE_FONT_SIZE_LARGER)) ||
 #ifdef MOZ_MATHML
-      fontData.mScriptLevel.GetUnit() == eCSSUnit_Integer ||
+      aRuleData->ValueForScriptLevel()->GetUnit() == eCSSUnit_Integer ||
 #endif
       (weight.GetUnit() == eCSSUnit_Enumerated &&
        (weight.GetIntValue() == NS_STYLE_FONT_WEIGHT_BOLDER ||
         weight.GetIntValue() == NS_STYLE_FONT_WEIGHT_LIGHTER))) {
     NS_ASSERTION(aResult == nsRuleNode::eRulePartialReset ||
                  aResult == nsRuleNode::eRuleFullReset ||
                  aResult == nsRuleNode::eRulePartialMixed ||
                  aResult == nsRuleNode::eRuleFullMixed,
@@ -1382,275 +1362,98 @@ CheckFontCallback(const nsRuleDataStruct
     else if (aResult == nsRuleNode::eRuleFullReset)
       aResult = nsRuleNode::eRuleFullMixed;
   }
 
   return aResult;
 }
 
 static nsRuleNode::RuleDetail
-CheckColorCallback(const nsRuleDataStruct& aData,
+CheckColorCallback(const nsRuleData* aRuleData,
                    nsRuleNode::RuleDetail aResult)
 {
-  const nsRuleDataColor& colorData =
-      static_cast<const nsRuleDataColor&>(aData);
-
   // currentColor values for color require inheritance
-  if (colorData.mColor.GetUnit() == eCSSUnit_EnumColor &&
-      colorData.mColor.GetIntValue() == NS_COLOR_CURRENTCOLOR) {
+  const nsCSSValue* colorValue = aRuleData->ValueForColor();
+  if (colorValue->GetUnit() == eCSSUnit_EnumColor &&
+      colorValue->GetIntValue() == NS_COLOR_CURRENTCOLOR) {
     NS_ASSERTION(aResult == nsRuleNode::eRuleFullReset,
                  "we should already be counted as full-reset");
     aResult = nsRuleNode::eRuleFullInherited;
   }
 
   return aResult;
 }
 
 static nsRuleNode::RuleDetail
-CheckTextCallback(const nsRuleDataStruct& aData,
+CheckTextCallback(const nsRuleData* aRuleData,
                   nsRuleNode::RuleDetail aResult)
 {
-  const nsRuleDataText& textData =
-    static_cast<const nsRuleDataText&>(aData);
-
-  if (textData.mTextAlign.GetUnit() == eCSSUnit_Enumerated &&
-      textData.mTextAlign.GetIntValue() ==
+  const nsCSSValue* textAlignValue = aRuleData->ValueForTextAlign();
+  if (textAlignValue->GetUnit() == eCSSUnit_Enumerated &&
+      textAlignValue->GetIntValue() ==
         NS_STYLE_TEXT_ALIGN_MOZ_CENTER_OR_INHERIT) {
     // Promote reset to mixed since we have something that depends on
     // the parent.
     if (aResult == nsRuleNode::eRulePartialReset)
       aResult = nsRuleNode::eRulePartialMixed;
     else if (aResult == nsRuleNode::eRuleFullReset)
       aResult = nsRuleNode::eRuleFullMixed;
   }
 
   return aResult;
 }
 
-// for nsCSSPropList.h, so we get information on things in the style
-// structs but not nsCSS*
-#define CSS_PROP_INCLUDE_NOT_CSS
-
-#define CHECK_DATA_FOR_PROPERTY(name_, id_, method_, flags_, datastruct_,     \
-                                member_, parsevariant_, kwtable_,             \
-                                stylestructoffset_, animtype_)                \
-  { offsetof(nsRuleData##datastruct_, member_), flags_ },
-
-static const PropertyCheckData FontCheckProperties[] = {
-#define CSS_PROP_FONT CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_FONT
-};
-
-static const PropertyCheckData DisplayCheckProperties[] = {
-#define CSS_PROP_DISPLAY CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_DISPLAY
-};
-
-static const PropertyCheckData VisibilityCheckProperties[] = {
-#define CSS_PROP_VISIBILITY CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_VISIBILITY
-};
-
-static const PropertyCheckData MarginCheckProperties[] = {
-#define CSS_PROP_MARGIN CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_MARGIN
-};
-
-static const PropertyCheckData BorderCheckProperties[] = {
-#define CSS_PROP_BORDER CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_BORDER
-};
-
-static const PropertyCheckData PaddingCheckProperties[] = {
-#define CSS_PROP_PADDING CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_PADDING
-};
-
-static const PropertyCheckData OutlineCheckProperties[] = {
-#define CSS_PROP_OUTLINE CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_OUTLINE
-};
-
-static const PropertyCheckData ListCheckProperties[] = {
-#define CSS_PROP_LIST CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_LIST
-};
-
-static const PropertyCheckData ColorCheckProperties[] = {
-#define CSS_PROP_COLOR CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_COLOR
-};
-
-static const PropertyCheckData BackgroundCheckProperties[] = {
-#define CSS_PROP_BACKGROUND CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_BACKGROUND
-};
-
-static const PropertyCheckData PositionCheckProperties[] = {
-#define CSS_PROP_POSITION CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_POSITION
-};
-
-static const PropertyCheckData TableCheckProperties[] = {
-#define CSS_PROP_TABLE CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_TABLE
-};
-
-static const PropertyCheckData TableBorderCheckProperties[] = {
-#define CSS_PROP_TABLEBORDER CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_TABLEBORDER
-};
-
-static const PropertyCheckData ContentCheckProperties[] = {
-#define CSS_PROP_CONTENT CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_CONTENT
-};
-
-static const PropertyCheckData QuotesCheckProperties[] = {
-#define CSS_PROP_QUOTES CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_QUOTES
-};
-
-static const PropertyCheckData TextCheckProperties[] = {
-#define CSS_PROP_TEXT CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_TEXT
-};
-
-static const PropertyCheckData TextResetCheckProperties[] = {
-#define CSS_PROP_TEXTRESET CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_TEXTRESET
-};
-
-static const PropertyCheckData UserInterfaceCheckProperties[] = {
-#define CSS_PROP_USERINTERFACE CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_USERINTERFACE
-};
-
-static const PropertyCheckData UIResetCheckProperties[] = {
-#define CSS_PROP_UIRESET CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_UIRESET
-};
-
-static const PropertyCheckData XULCheckProperties[] = {
-#define CSS_PROP_XUL CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_XUL
-};
-
-static const PropertyCheckData SVGCheckProperties[] = {
-#define CSS_PROP_SVG CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_SVG
-};
-
-static const PropertyCheckData SVGResetCheckProperties[] = {
-#define CSS_PROP_SVGRESET CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_SVGRESET
-};
-
-static const PropertyCheckData ColumnCheckProperties[] = {
-#define CSS_PROP_COLUMN CHECK_DATA_FOR_PROPERTY
-#include "nsCSSPropList.h"
-#undef CSS_PROP_COLUMN
-};
-
-#undef CSS_PROP_INCLUDE_NOT_CSS
-#undef CHECK_DATA_FOR_PROPERTY
-
-static const StructCheckData gCheckProperties[] = {
+static const CheckCallbackFn gCheckCallbacks[] = {
 
 #define STYLE_STRUCT(name, checkdata_cb, ctor_args) \
-  {name##CheckProperties, \
-   sizeof(name##CheckProperties)/sizeof(PropertyCheckData), \
-   checkdata_cb},
+  checkdata_cb,
 #include "nsStyleStructList.h"
 #undef STYLE_STRUCT
-  {nsnull, 0, nsnull}
 
 };
 
-
-
-// XXXldb Taking the address of a reference is evil.
-
-inline nsCSSValue&
-ValueAtOffset(nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
-{
-  return * reinterpret_cast<nsCSSValue*>
-                           (reinterpret_cast<char*>(&aRuleDataStruct) + aOffset);
-}
-
-inline const nsCSSValue&
-ValueAtOffset(const nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
-{
-  return * reinterpret_cast<const nsCSSValue*>
-                           (reinterpret_cast<const char*>(&aRuleDataStruct) + aOffset);
-}
-
 #if defined(MOZ_MATHML) && defined(DEBUG)
 static PRBool
-AreAllMathMLPropertiesUndefined(const nsCSSFont& aRuleData)
+AreAllMathMLPropertiesUndefined(const nsRuleData* aRuleData)
 {
-  return aRuleData.mScriptLevel.GetUnit() == eCSSUnit_Null &&
-         aRuleData.mScriptSizeMultiplier.GetUnit() == eCSSUnit_Null &&
-         aRuleData.mScriptMinSize.GetUnit() == eCSSUnit_Null;
+  return
+    aRuleData->ValueForScriptLevel()->GetUnit() == eCSSUnit_Null &&
+    aRuleData->ValueForScriptSizeMultiplier()->GetUnit() == eCSSUnit_Null &&
+    aRuleData->ValueForScriptMinSize()->GetUnit() == eCSSUnit_Null;
 }
 #endif
 
 inline nsRuleNode::RuleDetail
 nsRuleNode::CheckSpecifiedProperties(const nsStyleStructID aSID,
-                                     const nsRuleDataStruct& aRuleDataStruct)
+                                     const nsRuleData* aRuleData)
 {
-  const StructCheckData *structData = gCheckProperties + aSID;
-
   // Build a count of the:
   PRUint32 total = 0,      // total number of props in the struct
            specified = 0,  // number that were specified for this node
            inherited = 0;  // number that were 'inherit' (and not
                            //   eCSSUnit_Inherit) for this node
 
-  for (const PropertyCheckData *prop = structData->props,
-                           *prop_end = prop + structData->nprops;
-       prop != prop_end;
-       ++prop) {
-
+  NS_ABORT_IF_FALSE(aRuleData.mValueOffsets[aSID] == 0,
+                    "we assume the value offset is zero instead of adding it");
+  for (nsCSSValue *values = aRuleData.mValueStorage,
+              *values_end = values + nsCSSProps::PropertiesInSID(aSID);
+       values != values_end; ++values) {
     ++total;
-    ExamineCSSValue(ValueAtOffset(aRuleDataStruct, prop->offset),
-                    specified, inherited);
+    ExamineCSSValue(*values, specified, inherited);
   }
 
 #if 0
   printf("CheckSpecifiedProperties: SID=%d total=%d spec=%d inh=%d.\n",
          aSID, total, specified, inherited);
 #endif
 
 #ifdef MOZ_MATHML
   NS_ASSERTION(aSID != eStyleStruct_Font ||
                mPresContext->Document()->GetMathMLEnabled() ||
-               AreAllMathMLPropertiesUndefined(static_cast<const nsCSSFont&>(aRuleDataStruct)),
+               AreAllMathMLPropertiesUndefined(aRuleData),
                "MathML style property was defined even though MathML is disabled");
 #endif
 
   /*
    * Return the most specific information we can: prefer None or Full
    * over Partial, and Reset or Inherited over Mixed, since we can
    * optimize based on the edge cases and not the in-between cases.
    */
@@ -1677,253 +1480,24 @@ nsRuleNode::CheckSpecifiedProperties(con
     result = eRuleNone;
   else if (specified == inherited)
     result = eRulePartialInherited;
   else if (inherited == 0)
     result = eRulePartialReset;
   else
     result = eRulePartialMixed;
 
-  if (structData->callback) {
-    result = (*structData->callback)(aRuleDataStruct, result);
+  CheckCallbackFn cb = gCheckCallbacks[aSID];
+  if (cb) {
+    result = (*cb)(aRuleData, result);
   }
 
   return result;
 }
 
-const void*
-nsRuleNode::GetDisplayData(nsStyleContext* aContext)
-{
-  nsRuleDataDisplay displayData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Display), mPresContext, aContext);
-  ruleData.mDisplayData = &displayData;
-
-  return WalkRuleTree(eStyleStruct_Display, aContext, &ruleData, &displayData);
-}
-
-const void*
-nsRuleNode::GetVisibilityData(nsStyleContext* aContext)
-{
-  nsRuleDataDisplay displayData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Visibility), mPresContext, aContext);
-  ruleData.mDisplayData = &displayData;
-
-  return WalkRuleTree(eStyleStruct_Visibility, aContext, &ruleData, &displayData);
-}
-
-const void*
-nsRuleNode::GetTextData(nsStyleContext* aContext)
-{
-  nsRuleDataText textData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Text), mPresContext, aContext);
-  ruleData.mTextData = &textData;
-
-  return WalkRuleTree(eStyleStruct_Text, aContext, &ruleData, &textData);
-}
-
-const void*
-nsRuleNode::GetTextResetData(nsStyleContext* aContext)
-{
-  nsRuleDataText textData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(TextReset), mPresContext, aContext);
-  ruleData.mTextData = &textData;
-
-  return WalkRuleTree(eStyleStruct_TextReset, aContext, &ruleData, &textData);
-}
-
-const void*
-nsRuleNode::GetUserInterfaceData(nsStyleContext* aContext)
-{
-  nsRuleDataUserInterface uiData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(UserInterface), mPresContext, aContext);
-  ruleData.mUserInterfaceData = &uiData;
-
-  return WalkRuleTree(eStyleStruct_UserInterface, aContext, &ruleData, &uiData);
-}
-
-const void*
-nsRuleNode::GetUIResetData(nsStyleContext* aContext)
-{
-  nsRuleDataUserInterface uiData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(UIReset), mPresContext, aContext);
-  ruleData.mUserInterfaceData = &uiData;
-
-  return WalkRuleTree(eStyleStruct_UIReset, aContext, &ruleData, &uiData);
-}
-
-const void*
-nsRuleNode::GetFontData(nsStyleContext* aContext)
-{
-  nsRuleDataFont fontData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Font), mPresContext, aContext);
-  ruleData.mFontData = &fontData;
-
-  return WalkRuleTree(eStyleStruct_Font, aContext, &ruleData, &fontData);
-}
-
-const void*
-nsRuleNode::GetColorData(nsStyleContext* aContext)
-{
-  nsRuleDataColor colorData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Color), mPresContext, aContext);
-  ruleData.mColorData = &colorData;
-
-  return WalkRuleTree(eStyleStruct_Color, aContext, &ruleData, &colorData);
-}
-
-const void*
-nsRuleNode::GetBackgroundData(nsStyleContext* aContext)
-{
-  nsRuleDataColor colorData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Background), mPresContext, aContext);
-  ruleData.mColorData = &colorData;
-
-  return WalkRuleTree(eStyleStruct_Background, aContext, &ruleData, &colorData);
-}
-
-const void*
-nsRuleNode::GetMarginData(nsStyleContext* aContext)
-{
-  nsRuleDataMargin marginData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Margin), mPresContext, aContext);
-  ruleData.mMarginData = &marginData;
-
-  return WalkRuleTree(eStyleStruct_Margin, aContext, &ruleData, &marginData);
-}
-
-const void*
-nsRuleNode::GetBorderData(nsStyleContext* aContext)
-{
-  nsRuleDataMargin marginData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Border), mPresContext, aContext);
-  ruleData.mMarginData = &marginData;
-
-  return WalkRuleTree(eStyleStruct_Border, aContext, &ruleData, &marginData);
-}
-
-const void*
-nsRuleNode::GetPaddingData(nsStyleContext* aContext)
-{
-  nsRuleDataMargin marginData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Padding), mPresContext, aContext);
-  ruleData.mMarginData = &marginData;
-
-  return WalkRuleTree(eStyleStruct_Padding, aContext, &ruleData, &marginData);
-}
-
-const void*
-nsRuleNode::GetOutlineData(nsStyleContext* aContext)
-{
-  nsRuleDataMargin marginData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Outline), mPresContext, aContext);
-  ruleData.mMarginData = &marginData;
-
-  return WalkRuleTree(eStyleStruct_Outline, aContext, &ruleData, &marginData);
-}
-
-const void*
-nsRuleNode::GetListData(nsStyleContext* aContext)
-{
-  nsRuleDataList listData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(List), mPresContext, aContext);
-  ruleData.mListData = &listData;
-
-  return WalkRuleTree(eStyleStruct_List, aContext, &ruleData, &listData);
-}
-
-const void*
-nsRuleNode::GetPositionData(nsStyleContext* aContext)
-{
-  nsRuleDataPosition posData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Position), mPresContext, aContext);
-  ruleData.mPositionData = &posData;
-
-  return WalkRuleTree(eStyleStruct_Position, aContext, &ruleData, &posData);
-}
-
-const void*
-nsRuleNode::GetTableData(nsStyleContext* aContext)
-{
-  nsRuleDataTable tableData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Table), mPresContext, aContext);
-  ruleData.mTableData = &tableData;
-
-  return WalkRuleTree(eStyleStruct_Table, aContext, &ruleData, &tableData);
-}
-
-const void*
-nsRuleNode::GetTableBorderData(nsStyleContext* aContext)
-{
-  nsRuleDataTable tableData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(TableBorder), mPresContext, aContext);
-  ruleData.mTableData = &tableData;
-
-  return WalkRuleTree(eStyleStruct_TableBorder, aContext, &ruleData, &tableData);
-}
-
-const void*
-nsRuleNode::GetContentData(nsStyleContext* aContext)
-{
-  nsRuleDataContent contentData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Content), mPresContext, aContext);
-  ruleData.mContentData = &contentData;
-
-  return WalkRuleTree(eStyleStruct_Content, aContext, &ruleData, &contentData);
-}
-
-const void*
-nsRuleNode::GetQuotesData(nsStyleContext* aContext)
-{
-  nsRuleDataContent contentData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Quotes), mPresContext, aContext);
-  ruleData.mContentData = &contentData;
-
-  return WalkRuleTree(eStyleStruct_Quotes, aContext, &ruleData, &contentData);
-}
-
-const void*
-nsRuleNode::GetXULData(nsStyleContext* aContext)
-{
-  nsRuleDataXUL xulData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(XUL), mPresContext, aContext);
-  ruleData.mXULData = &xulData;
-
-  return WalkRuleTree(eStyleStruct_XUL, aContext, &ruleData, &xulData);
-}
-
-const void*
-nsRuleNode::GetColumnData(nsStyleContext* aContext)
-{
-  nsRuleDataColumn columnData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Column), mPresContext, aContext);
-  ruleData.mColumnData = &columnData;
-
-  return WalkRuleTree(eStyleStruct_Column, aContext, &ruleData, &columnData);
-}
-
-const void*
-nsRuleNode::GetSVGData(nsStyleContext* aContext)
-{
-  nsRuleDataSVG svgData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(SVG), mPresContext, aContext);
-  ruleData.mSVGData = &svgData;
-
-  return WalkRuleTree(eStyleStruct_SVG, aContext, &ruleData, &svgData);
-}
-
-const void*
-nsRuleNode::GetSVGResetData(nsStyleContext* aContext)
-{
-  nsRuleDataSVG svgData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(SVGReset), mPresContext, aContext);
-  ruleData.mSVGData = &svgData;
-
-  return WalkRuleTree(eStyleStruct_SVGReset, aContext, &ruleData, &svgData);
-}
-
 // If we need to restrict which properties apply to the style context,
 // return the bit to check in nsCSSProp's flags table.  Otherwise,
 // return 0.
 inline PRUint32
 GetPseudoRestriction(nsStyleContext *aContext)
 {
   // This needs to match nsStyleSet::WalkRestrictionRule.
   PRUint32 pseudoRestriction = 0;
@@ -1935,37 +1509,71 @@ GetPseudoRestriction(nsStyleContext *aCo
       pseudoRestriction = CSS_PROPERTY_APPLIES_TO_FIRST_LINE;
     }
   }
   return pseudoRestriction;
 }
 
 static void
 UnsetPropertiesWithoutFlags(const nsStyleStructID aSID,
-                            nsRuleDataStruct& aRuleDataStruct,
+                            nsRuleData* aRuleData,
                             PRUint32 aFlags)
 {
   NS_ASSERTION(aFlags != 0, "aFlags must be nonzero");
   const StructCheckData *structData = gCheckProperties + aSID;
 
   for (const PropertyCheckData *prop = structData->props,
                            *prop_end = prop + structData->nprops;
        prop != prop_end;
        ++prop) {
     if ((prop->flags & aFlags) != aFlags)
-      ValueAtOffset(aRuleDataStruct, prop->offset).Reset();
+      aRuleData->ValueFor(prop->property)->Reset();
   }
 }
 
+struct AutoCSSValueArray {
+  AutoCSSValueArray(void* aStorage, size_t aCount) {
+    mArray = new (aStorage) nsCSSValue[aCount];
+  }
+
+  ~AutoCSSValueArray() {
+    for (size_t i = 0; i < mCount; ++i) {
+      mArray[i].~nsCSSValue();
+    }
+  }
+
+  nsCSSValue* get() { return mArray; }
+
+private:
+  nsCSSValue *mArray;
+  size_t mCount;
+};
+
+static const ptrdiff_t gRuleDataOffsets[nsStyleStructID_Length + 1] = {
+  #define STYLE_STRUCT(name, checkdata_cb, ctor_args)                         \
+    offsetof(nsRuleData, m##name##Data),
+  #include "nsStyleStructList.h"
+  #undef STYLE_STRUCT
+  -1 /* final value without a comma */
+};
+
 const void*
 nsRuleNode::WalkRuleTree(const nsStyleStructID aSID,
-                         nsStyleContext* aContext,
-                         nsRuleData* aRuleData,
-                         nsRuleDataStruct* aSpecificData)
+                         nsStyleContext* aContext)
 {
+  nsRuleData ruleData(nsCachedStyleData::GetBitForSID(aSID),
+                      mPresContext, aContext);
+  const StructCheckData *structData = gCheckProperties + aSID;
+  // use placement new[] on the result of alloca() to allocate a
+  // variable-sized stack array, including execution of constructors
+  void* dataStorage = alloca(structData->nprops * sizeof(nsCSSValue));
+  AutoCSSValueArray dataArray(dataStorage, structData->nprops);
+  ruleData.mValueStorage = dataArray.get();
+  ruleData.mValueOffsets[aSID] = 0;
+
   // We start at the most specific rule in the tree.
   void* startStruct = nsnull;
 
   nsRuleNode* ruleNode = this;
   nsRuleNode* highestNode = nsnull; // The highest node in the rule tree
                                     // that has the same properties
                                     // specified for struct |aSID| as
                                     // |this| does.
@@ -2000,25 +1608,25 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
     if (startStruct)
       break; // We found a rule with fully specified data.  We don't
              // need to go up the tree any further, since the remainder
              // of this branch has already been computed.
 
     // Ask the rule to fill in the properties that it specifies.
     nsIStyleRule *rule = ruleNode->mRule;
     if (rule) {
-      aRuleData->mLevel = ruleNode->GetLevel();
-      aRuleData->mIsImportantRule = ruleNode->IsImportantRule();
-      rule->MapRuleInfoInto(aRuleData);
+      ruleData.mLevel = ruleNode->GetLevel();
+      ruleData.mIsImportantRule = ruleNode->IsImportantRule();
+      rule->MapRuleInfoInto(&ruleData);
     }
 
     // Now we check to see how many properties have been specified by
     // the rules we've examined so far.
     RuleDetail oldDetail = detail;
-    detail = CheckSpecifiedProperties(aSID, *aSpecificData);
+    detail = CheckSpecifiedProperties(aSID, &ruleData);
 
     if (oldDetail == eRuleNone && detail != eRuleNone)
       highestNode = ruleNode;
 
     if (detail == eRuleFullReset ||
         detail == eRuleFullMixed ||
         detail == eRuleFullInherited)
       break; // We don't need to examine any more rules.  All properties
@@ -2029,38 +1637,38 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
     ruleNode = ruleNode->mParent;
   }
 
   // If needed, unset the properties that don't have a flag that allows
   // them to be set for this style context.  (For example, only some
   // properties apply to :first-line and :first-letter.)
   PRUint32 pseudoRestriction = GetPseudoRestriction(aContext);
   if (pseudoRestriction) {
-    UnsetPropertiesWithoutFlags(aSID, *aSpecificData, pseudoRestriction);
+    UnsetPropertiesWithoutFlags(aSID, &ruleData, pseudoRestriction);
 
     // Recompute |detail| based on the restrictions we just applied.
     // We can adjust |detail| arbitrarily because of the restriction
     // rule added in nsStyleSet::WalkRestrictionRule.
-    detail = CheckSpecifiedProperties(aSID, *aSpecificData);
+    detail = CheckSpecifiedProperties(aSID, &ruleData);
   }
 
   NS_ASSERTION(!startStruct || (detail != eRuleFullReset &&
                                 detail != eRuleFullMixed &&
                                 detail != eRuleFullInherited),
                "can't have start struct and be fully specified");
 
   PRBool isReset = nsCachedStyleData::IsReset(aSID);
   if (!highestNode)
     highestNode = rootNode;
 
-  if (!aRuleData->mCanStoreInRuleTree)
+  if (!ruleData.mCanStoreInRuleTree)
     detail = eRulePartialMixed; // Treat as though some data is specified to avoid
                                 // the optimizations and force data computation.
 
-  if (detail == eRuleNone && startStruct && !aRuleData->mPostResolveCallback) {
+  if (detail == eRuleNone && startStruct && !ruleData.mPostResolveCallback) {
     // We specified absolutely no rule information, but a parent rule in the tree
     // specified all the rule information.  We set a bit along the branch from our
     // node in the tree to the node that specified the data that tells nodes on that
     // branch that they never need to examine their rules for this particular struct type
     // ever again.
     PropagateDependentBit(bit, ruleNode);
     return startStruct;
   }
@@ -2108,25 +1716,25 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
       // come from the pres context.
       return SetDefaultOnRoot(aSID, aContext);
   }
 
   // We need to compute the data from the information that the rules specified.
   const void* res;
 #define STYLE_STRUCT_TEST aSID
 #define STYLE_STRUCT(name, checkdata_cb, ctor_args)                           \
-  res = Compute##name##Data(startStruct, aRuleData, aContext,                 \
-                      highestNode, detail, aRuleData->mCanStoreInRuleTree);
+  res = Compute##name##Data(startStruct, &ruleData, aContext,                 \
+                            highestNode, detail, ruleData.mCanStoreInRuleTree);
 #include "nsStyleStructList.h"
 #undef STYLE_STRUCT
 #undef STYLE_STRUCT_TEST
 
   // If we have a post-resolve callback, handle that now.
-  if (aRuleData->mPostResolveCallback && (NS_LIKELY(res != nsnull)))
-    (*aRuleData->mPostResolveCallback)(const_cast<void*>(res), aRuleData);
+  if (ruleData.mPostResolveCallback && (NS_LIKELY(res != nsnull)))
+    (*ruleData.mPostResolveCallback)(const_cast<void*>(res), &ruleData);
 
   // Now return the result.
   return res;
 }
 
 const void*
 nsRuleNode::SetDefaultOnRoot(const nsStyleStructID aSID, nsStyleContext* aContext)
 {
@@ -6563,22 +6171,17 @@ nsRuleNode::GetStyleData(nsStyleStructID
   data = mStyleData.GetStyleData(aSID);
   if (NS_LIKELY(data != nsnull))
     return data; // We have a fully specified struct. Just return it.
 
   if (NS_UNLIKELY(!aComputeData))
     return nsnull;
 
   // Nothing is cached.  We'll have to delve further and examine our rules.
-#define STYLE_STRUCT_TEST aSID
-#define STYLE_STRUCT(name, checkdata_cb, ctor_args) \
-  data = Get##name##Data(aContext);
-#include "nsStyleStructList.h"
-#undef STYLE_STRUCT
-#undef STYLE_STRUCT_TEST
+  data = WalkRuleTree(aSID, aContext);
 
   if (NS_LIKELY(data != nsnull))
     return data;
 
   NS_NOTREACHED("could not create style struct");
   // To ensure that |GetStyleData| never returns null (even when we're
   // out of memory), we'll get the style set and get a copy of the
   // default values for the given style struct from the set.  Note that
@@ -6605,18 +6208,18 @@ nsRuleNode::GetStyle##name_(nsStyleConte
                                                                               \
   data = mStyleData.GetStyle##name_();                                        \
   if (NS_LIKELY(data != nsnull))                                              \
     return data;                                                              \
                                                                               \
   if (NS_UNLIKELY(!aComputeData))                                             \
     return nsnull;                                                            \
                                                                               \
-  data =                                                                      \
-    static_cast<const nsStyle##name_ *>(Get##name_##Data(aContext));          \
+  data = static_cast<const nsStyle##name_ *>                                  \
+           (WalkRuleTree(eStyleStruct_##name_, aContext));                    \
                                                                               \
   if (NS_LIKELY(data != nsnull))                                              \
     return data;                                                              \
                                                                               \
   NS_NOTREACHED("could not create style struct");                             \
   return                                                                      \
     static_cast<const nsStyle##name_ *>(                                      \
                    mPresContext->PresShell()->StyleSet()->                    \
diff --git a/layout/style/nsRuleNode.h b/layout/style/nsRuleNode.h
--- a/layout/style/nsRuleNode.h
+++ b/layout/style/nsRuleNode.h
@@ -50,18 +50,16 @@
 
 class nsStyleContext;
 struct PLDHashTable;
 class nsILanguageAtomService;
 struct nsRuleData;
 class nsIStyleRule;
 struct nsCSSStruct;
 struct nsCSSValueList;
-// Copy of typedef that's in nsCSSStruct.h, for compilation speed.
-typedef nsCSSStruct nsRuleDataStruct;
 
 struct nsRuleDataFont;
 class nsCSSValue;
 struct nsCSSRect;
 
 class nsStyleCoord;
 
 struct nsInheritedStyleData
@@ -454,18 +452,17 @@ protected:
   void DestroyInternal(nsRuleNode ***aDestroyQueueTail);
   void PropagateDependentBit(PRUint32 aBit, nsRuleNode* aHighestNode);
   void PropagateNoneBit(PRUint32 aBit, nsRuleNode* aHighestNode);
 
   const void* SetDefaultOnRoot(const nsStyleStructID aSID,
                                nsStyleContext* aContext);
 
   const void*
-    WalkRuleTree(const nsStyleStructID aSID, nsStyleContext* aContext,
-                 nsRuleData* aRuleData, nsRuleDataStruct* aSpecificData);
+    WalkRuleTree(const nsStyleStructID aSID, nsStyleContext* aContext);
 
   const void*
     ComputeDisplayData(void* aStartStruct,
                        const nsRuleData* aRuleData,
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
                        RuleDetail aRuleDetail,
                        const PRBool aCanStoreInRuleTree);
 
@@ -657,50 +654,25 @@ protected:
                             const nsCSSValue& aLTRSource,
                             const nsCSSValue& aRTLSource,
                             const nsCSSValue& aLTRLogicalValue,
                             const nsCSSValue& aRTLLogicalValue,
                             mozilla::css::Side aSide,
                             nsCSSRect& aValueRect,
                             PRBool& aCanStoreInRuleTree);
 
-  inline RuleDetail CheckSpecifiedProperties(const nsStyleStructID aSID, const nsRuleDataStruct& aRuleDataStruct);
+  inline RuleDetail CheckSpecifiedProperties(const nsStyleStructID aSID,
+                                             const nsRuleData* aRuleData);
 
   const void* GetParentData(const nsStyleStructID aSID);
   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)  \
     const nsStyle##name_* GetParent##name_();
   #include "nsStyleStructList.h"
   #undef STYLE_STRUCT
 
-  const void* GetDisplayData(nsStyleContext* aContext);
-  const void* GetVisibilityData(nsStyleContext* aContext);
-  const void* GetFontData(nsStyleContext* aContext);
-  const void* GetColorData(nsStyleContext* aContext);
-  const void* GetBackgroundData(nsStyleContext* aContext);
-  const void* GetMarginData(nsStyleContext* aContext);
-  const void* GetBorderData(nsStyleContext* aContext);
-  const void* GetPaddingData(nsStyleContext* aContext);
-  const void* GetOutlineData(nsStyleContext* aContext);
-  const void* GetListData(nsStyleContext* aContext);
-  const void* GetPositionData(nsStyleContext* aContext);
-  const void* GetTableData(nsStyleContext* aContext);
-  const void* GetTableBorderData(nsStyleContext* aContext);
-
-  const void* GetContentData(nsStyleContext* aContext);
-  const void* GetQuotesData(nsStyleContext* aContext);
-  const void* GetTextData(nsStyleContext* aContext);
-  const void* GetTextResetData(nsStyleContext* aContext);
-  const void* GetUserInterfaceData(nsStyleContext* aContext);
-
-  const void* GetUIResetData(nsStyleContext* aContext);
-  const void* GetXULData(nsStyleContext* aContext);
-  const void* GetColumnData(nsStyleContext* aContext);
-  const void* GetSVGData(nsStyleContext* aContext);
-  const void* GetSVGResetData(nsStyleContext* aContext);
-
   already_AddRefed<nsCSSShadowArray>
               GetShadowData(const nsCSSValueList* aList,
                             nsStyleContext* aContext,
                             PRBool aIsBoxShadow,
                             PRBool& inherited);
 
 private:
   nsRuleNode(nsPresContext* aPresContext, nsRuleNode* aParent,
