From: L. David Baron <dbaron@dbaron.org>

Instead of stack-allocating nsRuleData* structs in separate methods for each style struct, allocate an array of nsCSSValue using alloca.  (Bug 636039)

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -76,16 +76,17 @@
 #include "nsStyleTransformMatrix.h"
 #include "nsCSSKeywords.h"
 #include "nsCSSProps.h"
 #include "nsTArray.h"
 #include "nsContentUtils.h"
 #include "mozilla/dom/Element.h"
 #include "CSSCalc.h"
 #include "nsPrintfCString.h"
+#include <alloca.h>
 
 using namespace mozilla::dom;
 namespace css = mozilla::css;
 
 #define NS_SET_IMAGE_REQUEST(method_, context_, request_)                   \
   if ((context_)->PresContext()->IsDynamic()) {                               \
     method_(request_);                                                      \
   } else {                                                                  \
@@ -1312,17 +1313,17 @@ struct PropertyCheckData {
 };
 
 /*
  * a callback function that that can revise the result of
  * CheckSpecifiedProperties before finishing; aResult is the current
  * result, and it returns the revised one.
  */
 typedef nsRuleNode::RuleDetail
-  (* CheckCallbackFn)(const nsRuleDataStruct& aData,
+  (* CheckCallbackFn)(const nsRuleData* aRuleData,
                       nsRuleNode::RuleDetail aResult);
 
 /* the information for all the properties in a style struct */
 struct StructCheckData {
   const PropertyCheckData* props;
   PRInt32 nprops;
   CheckCallbackFn callback;
 };
@@ -1341,35 +1342,32 @@ ExamineCSSValue(const nsCSSValue& aValue
     ++aSpecifiedCount;
     if (aValue.GetUnit() == eCSSUnit_Inherit) {
       ++aInheritedCount;
     }
   }
 }
 
 static nsRuleNode::RuleDetail
-CheckFontCallback(const nsRuleDataStruct& aData,
+CheckFontCallback(const nsRuleData* aRuleData,
                   nsRuleNode::RuleDetail aResult)
 {
-  const nsRuleDataFont& fontData =
-      static_cast<const nsRuleDataFont&>(aData);
-
   // em, ex, percent, 'larger', and 'smaller' values on font-size depend
   // on the parent context's font-size
   // Likewise, 'lighter' and 'bolder' values of 'font-weight', and 'wider'
   // and 'narrower' values of 'font-stretch' depend on the parent.
-  const nsCSSValue& size = fontData.mSize;
-  const nsCSSValue& weight = fontData.mWeight;
+  const nsCSSValue& size = *aRuleData->ValueForFontSize();
+  const nsCSSValue& weight = *aRuleData->ValueForFontWeight();
   if (size.IsRelativeLengthUnit() ||
       size.GetUnit() == eCSSUnit_Percent ||
       (size.GetUnit() == eCSSUnit_Enumerated &&
        (size.GetIntValue() == NS_STYLE_FONT_SIZE_SMALLER ||
         size.GetIntValue() == NS_STYLE_FONT_SIZE_LARGER)) ||
 #ifdef MOZ_MATHML
-      fontData.mScriptLevel.GetUnit() == eCSSUnit_Integer ||
+      aRuleData->ValueForScriptLevel()->GetUnit() == eCSSUnit_Integer ||
 #endif
       (weight.GetUnit() == eCSSUnit_Enumerated &&
        (weight.GetIntValue() == NS_STYLE_FONT_WEIGHT_BOLDER ||
         weight.GetIntValue() == NS_STYLE_FONT_WEIGHT_LIGHTER))) {
     NS_ASSERTION(aResult == nsRuleNode::eRulePartialReset ||
                  aResult == nsRuleNode::eRuleFullReset ||
                  aResult == nsRuleNode::eRulePartialMixed ||
                  aResult == nsRuleNode::eRuleFullMixed,
@@ -1382,42 +1380,38 @@ CheckFontCallback(const nsRuleDataStruct
     else if (aResult == nsRuleNode::eRuleFullReset)
       aResult = nsRuleNode::eRuleFullMixed;
   }
 
   return aResult;
 }
 
 static nsRuleNode::RuleDetail
-CheckColorCallback(const nsRuleDataStruct& aData,
+CheckColorCallback(const nsRuleData* aRuleData,
                    nsRuleNode::RuleDetail aResult)
 {
-  const nsRuleDataColor& colorData =
-      static_cast<const nsRuleDataColor&>(aData);
-
   // currentColor values for color require inheritance
-  if (colorData.mColor.GetUnit() == eCSSUnit_EnumColor &&
-      colorData.mColor.GetIntValue() == NS_COLOR_CURRENTCOLOR) {
+  const nsCSSValue* colorValue = aRuleData->ValueForColor();
+  if (colorValue->GetUnit() == eCSSUnit_EnumColor &&
+      colorValue->GetIntValue() == NS_COLOR_CURRENTCOLOR) {
     NS_ASSERTION(aResult == nsRuleNode::eRuleFullReset,
                  "we should already be counted as full-reset");
     aResult = nsRuleNode::eRuleFullInherited;
   }
 
   return aResult;
 }
 
 static nsRuleNode::RuleDetail
-CheckTextCallback(const nsRuleDataStruct& aData,
+CheckTextCallback(const nsRuleData* aRuleData,
                   nsRuleNode::RuleDetail aResult)
 {
-  const nsRuleDataText& textData =
-    static_cast<const nsRuleDataText&>(aData);
-
-  if (textData.mTextAlign.GetUnit() == eCSSUnit_Enumerated &&
-      textData.mTextAlign.GetIntValue() ==
+  const nsCSSValue* textAlignValue = aRuleData->ValueForTextAlign();
+  if (textAlignValue->GetUnit() == eCSSUnit_Enumerated &&
+      textAlignValue->GetIntValue() ==
         NS_STYLE_TEXT_ALIGN_MOZ_CENTER_OR_INHERIT) {
     // Promote reset to mixed since we have something that depends on
     // the parent.
     if (aResult == nsRuleNode::eRulePartialReset)
       aResult = nsRuleNode::eRulePartialMixed;
     else if (aResult == nsRuleNode::eRuleFullReset)
       aResult = nsRuleNode::eRuleFullMixed;
   }
@@ -1626,17 +1620,19 @@ nsRuleNode::CheckSpecifiedProperties(con
            specified = 0,  // number that were specified for this node
            inherited = 0;  // number that were 'inherit' (and not
                            //   eCSSUnit_Inherit) for this node
 
   for (const PropertyCheckData *prop = structData->props,
                            *prop_end = prop + structData->nprops;
        prop != prop_end;
        ++prop) {
-
+    NS_ASSERTION(prop->offset + sizeof(nsCSSValue) <=
+                   structData->nprops * sizeof(nsCSSValue),
+                 "arrays do not match nsRuleData* structs");
     ++total;
     ExamineCSSValue(ValueAtOffset(aRuleDataStruct, prop->offset),
                     specified, inherited);
   }
 
 #if 0
   printf("CheckSpecifiedProperties: SID=%d total=%d spec=%d inh=%d.\n",
          aSID, total, specified, inherited);
@@ -1678,252 +1674,22 @@ nsRuleNode::CheckSpecifiedProperties(con
   else if (specified == inherited)
     result = eRulePartialInherited;
   else if (inherited == 0)
     result = eRulePartialReset;
   else
     result = eRulePartialMixed;
 
   if (structData->callback) {
-    result = (*structData->callback)(aRuleDataStruct, result);
+    result = (*structData->callback)(aRuleData, result);
   }
 
   return result;
 }
 
-const void*
-nsRuleNode::GetDisplayData(nsStyleContext* aContext)
-{
-  nsRuleDataDisplay displayData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Display), mPresContext, aContext);
-  ruleData.mDisplayData = &displayData;
-
-  return WalkRuleTree(eStyleStruct_Display, aContext, &ruleData, &displayData);
-}
-
-const void*
-nsRuleNode::GetVisibilityData(nsStyleContext* aContext)
-{
-  nsRuleDataDisplay displayData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Visibility), mPresContext, aContext);
-  ruleData.mDisplayData = &displayData;
-
-  return WalkRuleTree(eStyleStruct_Visibility, aContext, &ruleData, &displayData);
-}
-
-const void*
-nsRuleNode::GetTextData(nsStyleContext* aContext)
-{
-  nsRuleDataText textData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Text), mPresContext, aContext);
-  ruleData.mTextData = &textData;
-
-  return WalkRuleTree(eStyleStruct_Text, aContext, &ruleData, &textData);
-}
-
-const void*
-nsRuleNode::GetTextResetData(nsStyleContext* aContext)
-{
-  nsRuleDataText textData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(TextReset), mPresContext, aContext);
-  ruleData.mTextData = &textData;
-
-  return WalkRuleTree(eStyleStruct_TextReset, aContext, &ruleData, &textData);
-}
-
-const void*
-nsRuleNode::GetUserInterfaceData(nsStyleContext* aContext)
-{
-  nsRuleDataUserInterface uiData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(UserInterface), mPresContext, aContext);
-  ruleData.mUserInterfaceData = &uiData;
-
-  return WalkRuleTree(eStyleStruct_UserInterface, aContext, &ruleData, &uiData);
-}
-
-const void*
-nsRuleNode::GetUIResetData(nsStyleContext* aContext)
-{
-  nsRuleDataUserInterface uiData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(UIReset), mPresContext, aContext);
-  ruleData.mUserInterfaceData = &uiData;
-
-  return WalkRuleTree(eStyleStruct_UIReset, aContext, &ruleData, &uiData);
-}
-
-const void*
-nsRuleNode::GetFontData(nsStyleContext* aContext)
-{
-  nsRuleDataFont fontData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Font), mPresContext, aContext);
-  ruleData.mFontData = &fontData;
-
-  return WalkRuleTree(eStyleStruct_Font, aContext, &ruleData, &fontData);
-}
-
-const void*
-nsRuleNode::GetColorData(nsStyleContext* aContext)
-{
-  nsRuleDataColor colorData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Color), mPresContext, aContext);
-  ruleData.mColorData = &colorData;
-
-  return WalkRuleTree(eStyleStruct_Color, aContext, &ruleData, &colorData);
-}
-
-const void*
-nsRuleNode::GetBackgroundData(nsStyleContext* aContext)
-{
-  nsRuleDataColor colorData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Background), mPresContext, aContext);
-  ruleData.mColorData = &colorData;
-
-  return WalkRuleTree(eStyleStruct_Background, aContext, &ruleData, &colorData);
-}
-
-const void*
-nsRuleNode::GetMarginData(nsStyleContext* aContext)
-{
-  nsRuleDataMargin marginData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Margin), mPresContext, aContext);
-  ruleData.mMarginData = &marginData;
-
-  return WalkRuleTree(eStyleStruct_Margin, aContext, &ruleData, &marginData);
-}
-
-const void*
-nsRuleNode::GetBorderData(nsStyleContext* aContext)
-{
-  nsRuleDataMargin marginData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Border), mPresContext, aContext);
-  ruleData.mMarginData = &marginData;
-
-  return WalkRuleTree(eStyleStruct_Border, aContext, &ruleData, &marginData);
-}
-
-const void*
-nsRuleNode::GetPaddingData(nsStyleContext* aContext)
-{
-  nsRuleDataMargin marginData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Padding), mPresContext, aContext);
-  ruleData.mMarginData = &marginData;
-
-  return WalkRuleTree(eStyleStruct_Padding, aContext, &ruleData, &marginData);
-}
-
-const void*
-nsRuleNode::GetOutlineData(nsStyleContext* aContext)
-{
-  nsRuleDataMargin marginData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Outline), mPresContext, aContext);
-  ruleData.mMarginData = &marginData;
-
-  return WalkRuleTree(eStyleStruct_Outline, aContext, &ruleData, &marginData);
-}
-
-const void*
-nsRuleNode::GetListData(nsStyleContext* aContext)
-{
-  nsRuleDataList listData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(List), mPresContext, aContext);
-  ruleData.mListData = &listData;
-
-  return WalkRuleTree(eStyleStruct_List, aContext, &ruleData, &listData);
-}
-
-const void*
-nsRuleNode::GetPositionData(nsStyleContext* aContext)
-{
-  nsRuleDataPosition posData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Position), mPresContext, aContext);
-  ruleData.mPositionData = &posData;
-
-  return WalkRuleTree(eStyleStruct_Position, aContext, &ruleData, &posData);
-}
-
-const void*
-nsRuleNode::GetTableData(nsStyleContext* aContext)
-{
-  nsRuleDataTable tableData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Table), mPresContext, aContext);
-  ruleData.mTableData = &tableData;
-
-  return WalkRuleTree(eStyleStruct_Table, aContext, &ruleData, &tableData);
-}
-
-const void*
-nsRuleNode::GetTableBorderData(nsStyleContext* aContext)
-{
-  nsRuleDataTable tableData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(TableBorder), mPresContext, aContext);
-  ruleData.mTableData = &tableData;
-
-  return WalkRuleTree(eStyleStruct_TableBorder, aContext, &ruleData, &tableData);
-}
-
-const void*
-nsRuleNode::GetContentData(nsStyleContext* aContext)
-{
-  nsRuleDataContent contentData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Content), mPresContext, aContext);
-  ruleData.mContentData = &contentData;
-
-  return WalkRuleTree(eStyleStruct_Content, aContext, &ruleData, &contentData);
-}
-
-const void*
-nsRuleNode::GetQuotesData(nsStyleContext* aContext)
-{
-  nsRuleDataContent contentData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Quotes), mPresContext, aContext);
-  ruleData.mContentData = &contentData;
-
-  return WalkRuleTree(eStyleStruct_Quotes, aContext, &ruleData, &contentData);
-}
-
-const void*
-nsRuleNode::GetXULData(nsStyleContext* aContext)
-{
-  nsRuleDataXUL xulData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(XUL), mPresContext, aContext);
-  ruleData.mXULData = &xulData;
-
-  return WalkRuleTree(eStyleStruct_XUL, aContext, &ruleData, &xulData);
-}
-
-const void*
-nsRuleNode::GetColumnData(nsStyleContext* aContext)
-{
-  nsRuleDataColumn columnData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Column), mPresContext, aContext);
-  ruleData.mColumnData = &columnData;
-
-  return WalkRuleTree(eStyleStruct_Column, aContext, &ruleData, &columnData);
-}
-
-const void*
-nsRuleNode::GetSVGData(nsStyleContext* aContext)
-{
-  nsRuleDataSVG svgData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(SVG), mPresContext, aContext);
-  ruleData.mSVGData = &svgData;
-
-  return WalkRuleTree(eStyleStruct_SVG, aContext, &ruleData, &svgData);
-}
-
-const void*
-nsRuleNode::GetSVGResetData(nsStyleContext* aContext)
-{
-  nsRuleDataSVG svgData; // Declare a struct with null CSS values.
-  nsRuleData ruleData(NS_STYLE_INHERIT_BIT(SVGReset), mPresContext, aContext);
-  ruleData.mSVGData = &svgData;
-
-  return WalkRuleTree(eStyleStruct_SVGReset, aContext, &ruleData, &svgData);
-}
-
 // If we need to restrict which properties apply to the style context,
 // return the bit to check in nsCSSProp's flags table.  Otherwise,
 // return 0.
 inline PRUint32
 GetPseudoRestriction(nsStyleContext *aContext)
 {
   // This needs to match nsStyleSet::WalkRestrictionRule.
   PRUint32 pseudoRestriction = 0;
@@ -1945,27 +1711,68 @@ UnsetPropertiesWithoutFlags(const nsStyl
 {
   NS_ASSERTION(aFlags != 0, "aFlags must be nonzero");
   const StructCheckData *structData = gCheckProperties + aSID;
 
   for (const PropertyCheckData *prop = structData->props,
                            *prop_end = prop + structData->nprops;
        prop != prop_end;
        ++prop) {
+    NS_ASSERTION(prop->offset + sizeof(nsCSSValue) <=
+                   structData->nprops * sizeof(nsCSSValue),
+                 "arrays do not match nsRuleData* structs");
     if ((prop->flags & aFlags) != aFlags)
       ValueAtOffset(aRuleDataStruct, prop->offset).Reset();
   }
 }
 
+struct AutoCSSValueArray {
+  AutoCSSValueArray(void* aStorage, size_t aCount) {
+    mArray = new (aStorage) nsCSSValue[aCount];
+  }
+
+  ~AutoCSSValueArray() {
+    for (size_t i = 0; i < mCount; ++i) {
+      mArray[i].~nsCSSValue();
+    }
+  }
+
+  nsCSSValue* get() { return mArray; }
+
+private:
+  nsCSSValue *mArray;
+  size_t mCount;
+};
+
+static const ptrdiff_t gRuleDataOffsets[nsStyleStructID_Length + 1] = {
+  #define STYLE_STRUCT(name, checkdata_cb, ctor_args)                         \
+    offsetof(nsRuleData, m##name##Data),
+  #include "nsStyleStructList.h"
+  #undef STYLE_STRUCT
+  -1 /* final value without a comma */
+};
+
 const void*
 nsRuleNode::WalkRuleTree(const nsStyleStructID aSID,
-                         nsStyleContext* aContext,
-                         nsRuleData* aRuleData,
-                         nsRuleDataStruct* aSpecificData)
+                         nsStyleContext* aContext)
 {
+  nsRuleData ruleData(nsCachedStyleData::GetBitForSID(aSID),
+                      mPresContext, aContext);
+  const StructCheckData *structData = gCheckProperties + aSID;
+  // use placement new[] on the result of alloca() to allocate a
+  // variable-sized stack array, including execution of constructors
+  void* dataStorage = alloca(structData->nprops * sizeof(nsCSSValue));
+  AutoCSSValueArray dataArray(dataStorage, structData->nprops);
+  // The assertions in CheckSpecifiedProperties *mostly* ensure that this
+  // is safe.
+  nsRuleDataStruct* specificData =
+    reinterpret_cast<nsRuleDataStruct*>(dataArray.get());
+  *reinterpret_cast<nsRuleDataStruct**>(
+    reinterpret_cast<char*>(&ruleData) + gRuleDataOffsets[aSID]) = specificData;
+
   // We start at the most specific rule in the tree.
   void* startStruct = nsnull;
 
   nsRuleNode* ruleNode = this;
   nsRuleNode* highestNode = nsnull; // The highest node in the rule tree
                                     // that has the same properties
                                     // specified for struct |aSID| as
                                     // |this| does.
@@ -2000,25 +1807,25 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
     if (startStruct)
       break; // We found a rule with fully specified data.  We don't
              // need to go up the tree any further, since the remainder
              // of this branch has already been computed.
 
     // Ask the rule to fill in the properties that it specifies.
     nsIStyleRule *rule = ruleNode->mRule;
     if (rule) {
-      aRuleData->mLevel = ruleNode->GetLevel();
-      aRuleData->mIsImportantRule = ruleNode->IsImportantRule();
-      rule->MapRuleInfoInto(aRuleData);
+      ruleData.mLevel = ruleNode->GetLevel();
+      ruleData.mIsImportantRule = ruleNode->IsImportantRule();
+      rule->MapRuleInfoInto(&ruleData);
     }
 
     // Now we check to see how many properties have been specified by
     // the rules we've examined so far.
     RuleDetail oldDetail = detail;
-    detail = CheckSpecifiedProperties(aSID, *aSpecificData);
+    detail = CheckSpecifiedProperties(aSID, *specificData);
 
     if (oldDetail == eRuleNone && detail != eRuleNone)
       highestNode = ruleNode;
 
     if (detail == eRuleFullReset ||
         detail == eRuleFullMixed ||
         detail == eRuleFullInherited)
       break; // We don't need to examine any more rules.  All properties
@@ -2029,38 +1836,38 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
     ruleNode = ruleNode->mParent;
   }
 
   // If needed, unset the properties that don't have a flag that allows
   // them to be set for this style context.  (For example, only some
   // properties apply to :first-line and :first-letter.)
   PRUint32 pseudoRestriction = GetPseudoRestriction(aContext);
   if (pseudoRestriction) {
-    UnsetPropertiesWithoutFlags(aSID, *aSpecificData, pseudoRestriction);
+    UnsetPropertiesWithoutFlags(aSID, *specificData, pseudoRestriction);
 
     // Recompute |detail| based on the restrictions we just applied.
     // We can adjust |detail| arbitrarily because of the restriction
     // rule added in nsStyleSet::WalkRestrictionRule.
-    detail = CheckSpecifiedProperties(aSID, *aSpecificData);
+    detail = CheckSpecifiedProperties(aSID, *specificData);
   }
 
   NS_ASSERTION(!startStruct || (detail != eRuleFullReset &&
                                 detail != eRuleFullMixed &&
                                 detail != eRuleFullInherited),
                "can't have start struct and be fully specified");
 
   PRBool isReset = nsCachedStyleData::IsReset(aSID);
   if (!highestNode)
     highestNode = rootNode;
 
-  if (!aRuleData->mCanStoreInRuleTree)
+  if (!ruleData.mCanStoreInRuleTree)
     detail = eRulePartialMixed; // Treat as though some data is specified to avoid
                                 // the optimizations and force data computation.
 
-  if (detail == eRuleNone && startStruct && !aRuleData->mPostResolveCallback) {
+  if (detail == eRuleNone && startStruct && !ruleData.mPostResolveCallback) {
     // We specified absolutely no rule information, but a parent rule in the tree
     // specified all the rule information.  We set a bit along the branch from our
     // node in the tree to the node that specified the data that tells nodes on that
     // branch that they never need to examine their rules for this particular struct type
     // ever again.
     PropagateDependentBit(bit, ruleNode);
     return startStruct;
   }
@@ -2109,24 +1916,24 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
       return SetDefaultOnRoot(aSID, aContext);
   }
 
   // We need to compute the data from the information that the rules specified.
   const void* res;
 #define STYLE_STRUCT_TEST aSID
 #define STYLE_STRUCT(name, checkdata_cb, ctor_args)                           \
   res = Compute##name##Data(startStruct, aRuleData, aContext,                 \
-                      highestNode, detail, aRuleData->mCanStoreInRuleTree);
+                            highestNode, detail, ruleData.mCanStoreInRuleTree);
 #include "nsStyleStructList.h"
 #undef STYLE_STRUCT
 #undef STYLE_STRUCT_TEST
 
   // If we have a post-resolve callback, handle that now.
-  if (aRuleData->mPostResolveCallback && (NS_LIKELY(res != nsnull)))
-    (*aRuleData->mPostResolveCallback)(const_cast<void*>(res), aRuleData);
+  if (ruleData.mPostResolveCallback && (NS_LIKELY(res != nsnull)))
+    (*ruleData.mPostResolveCallback)(const_cast<void*>(res), &ruleData);
 
   // Now return the result.
   return res;
 }
 
 const void*
 nsRuleNode::SetDefaultOnRoot(const nsStyleStructID aSID, nsStyleContext* aContext)
 {
@@ -6585,22 +6392,17 @@ nsRuleNode::GetStyleData(nsStyleStructID
   data = mStyleData.GetStyleData(aSID);
   if (NS_LIKELY(data != nsnull))
     return data; // We have a fully specified struct. Just return it.
 
   if (NS_UNLIKELY(!aComputeData))
     return nsnull;
 
   // Nothing is cached.  We'll have to delve further and examine our rules.
-#define STYLE_STRUCT_TEST aSID
-#define STYLE_STRUCT(name, checkdata_cb, ctor_args) \
-  data = Get##name##Data(aContext);
-#include "nsStyleStructList.h"
-#undef STYLE_STRUCT
-#undef STYLE_STRUCT_TEST
+  data = WalkRuleTree(aSID, aContext);
 
   if (NS_LIKELY(data != nsnull))
     return data;
 
   NS_NOTREACHED("could not create style struct");
   // To ensure that |GetStyleData| never returns null (even when we're
   // out of memory), we'll get the style set and get a copy of the
   // default values for the given style struct from the set.  Note that
@@ -6627,18 +6429,18 @@ nsRuleNode::GetStyle##name_(nsStyleConte
                                                                               \
   data = mStyleData.GetStyle##name_();                                        \
   if (NS_LIKELY(data != nsnull))                                              \
     return data;                                                              \
                                                                               \
   if (NS_UNLIKELY(!aComputeData))                                             \
     return nsnull;                                                            \
                                                                               \
-  data =                                                                      \
-    static_cast<const nsStyle##name_ *>(Get##name_##Data(aContext));          \
+  data = static_cast<const nsStyle##name_ *>                                  \
+           (WalkRuleTree(eStyleStruct_##name_, aContext));                    \
                                                                               \
   if (NS_LIKELY(data != nsnull))                                              \
     return data;                                                              \
                                                                               \
   NS_NOTREACHED("could not create style struct");                             \
   return                                                                      \
     static_cast<const nsStyle##name_ *>(                                      \
                    mPresContext->PresShell()->StyleSet()->                    \
diff --git a/layout/style/nsRuleNode.h b/layout/style/nsRuleNode.h
--- a/layout/style/nsRuleNode.h
+++ b/layout/style/nsRuleNode.h
@@ -454,18 +454,17 @@ protected:
   void DestroyInternal(nsRuleNode ***aDestroyQueueTail);
   void PropagateDependentBit(PRUint32 aBit, nsRuleNode* aHighestNode);
   void PropagateNoneBit(PRUint32 aBit, nsRuleNode* aHighestNode);
 
   const void* SetDefaultOnRoot(const nsStyleStructID aSID,
                                nsStyleContext* aContext);
 
   const void*
-    WalkRuleTree(const nsStyleStructID aSID, nsStyleContext* aContext,
-                 nsRuleData* aRuleData, nsRuleDataStruct* aSpecificData);
+    WalkRuleTree(const nsStyleStructID aSID, nsStyleContext* aContext);
 
   const void*
     ComputeDisplayData(void* aStartStruct,
                        const nsRuleData* aRuleData,
                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
                        RuleDetail aRuleDetail,
                        const PRBool aCanStoreInRuleTree);
 
@@ -665,42 +664,16 @@ protected:
   inline RuleDetail CheckSpecifiedProperties(const nsStyleStructID aSID, const nsRuleDataStruct& aRuleDataStruct);
 
   const void* GetParentData(const nsStyleStructID aSID);
   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)  \
     const nsStyle##name_* GetParent##name_();
   #include "nsStyleStructList.h"
   #undef STYLE_STRUCT
 
-  const void* GetDisplayData(nsStyleContext* aContext);
-  const void* GetVisibilityData(nsStyleContext* aContext);
-  const void* GetFontData(nsStyleContext* aContext);
-  const void* GetColorData(nsStyleContext* aContext);
-  const void* GetBackgroundData(nsStyleContext* aContext);
-  const void* GetMarginData(nsStyleContext* aContext);
-  const void* GetBorderData(nsStyleContext* aContext);
-  const void* GetPaddingData(nsStyleContext* aContext);
-  const void* GetOutlineData(nsStyleContext* aContext);
-  const void* GetListData(nsStyleContext* aContext);
-  const void* GetPositionData(nsStyleContext* aContext);
-  const void* GetTableData(nsStyleContext* aContext);
-  const void* GetTableBorderData(nsStyleContext* aContext);
-
-  const void* GetContentData(nsStyleContext* aContext);
-  const void* GetQuotesData(nsStyleContext* aContext);
-  const void* GetTextData(nsStyleContext* aContext);
-  const void* GetTextResetData(nsStyleContext* aContext);
-  const void* GetUserInterfaceData(nsStyleContext* aContext);
-
-  const void* GetUIResetData(nsStyleContext* aContext);
-  const void* GetXULData(nsStyleContext* aContext);
-  const void* GetColumnData(nsStyleContext* aContext);
-  const void* GetSVGData(nsStyleContext* aContext);
-  const void* GetSVGResetData(nsStyleContext* aContext);
-
   already_AddRefed<nsCSSShadowArray>
               GetShadowData(const nsCSSValueList* aList,
                             nsStyleContext* aContext,
                             PRBool aIsBoxShadow,
                             PRBool& inherited);
 
 private:
   nsRuleNode(nsPresContext* aPresContext, nsRuleNode* aParent,
