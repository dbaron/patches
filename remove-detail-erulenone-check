From: L. David Baron <dbaron@dbaron.org>

Remove unneeded detail == eRuleNone check.  (Bug 114100)

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -1701,27 +1701,24 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
   while (ruleNode) {
     // See if this rule node has cached the fact that the remaining
     // nodes along this path specify no data whatsoever.
     if (ruleNode->mNoneBits & bit)
       break;
 
     // If the dependent bit is set on a rule node for this struct, that
     // means its rule won't have any information to add, so skip it.
-    // XXXldb I don't understand why we need to check |detail| here, but
-    // we do.
-    if (detail == eRuleNone)
-      while (ruleNode->mDependentBits & bit) {
-        NS_ASSERTION(ruleNode->mStyleData.GetStyleData(aSID) == nsnull,
-                     "dependent bit with cached data makes no sense");
-        // Climb up to the next rule in the tree (a less specific rule).
-        rootNode = ruleNode;
-        ruleNode = ruleNode->mParent;
-        NS_ASSERTION(!(ruleNode->mNoneBits & bit), "can't have both bits set");
-      }
+    while (ruleNode->mDependentBits & bit) {
+      NS_ASSERTION(ruleNode->mStyleData.GetStyleData(aSID) == nsnull,
+                   "dependent bit with cached data makes no sense");
+      // Climb up to the next rule in the tree (a less specific rule).
+      rootNode = ruleNode;
+      ruleNode = ruleNode->mParent;
+      NS_ASSERTION(!(ruleNode->mNoneBits & bit), "can't have both bits set");
+    }
 
     // Check for cached data after the inner loop above -- otherwise
     // we'll miss it.
     startStruct = ruleNode->mStyleData.GetStyleData(aSID);
     if (startStruct)
       break; // We found a rule with fully specified data.  We don't
              // need to go up the tree any further, since the remainder
              // of this branch has already been computed.
