Use _beginthreadex rather than CreateThread, since the thread might use the C Runtime Library.

diff --git a/xpcom/base/nsStackFrameWin.cpp b/xpcom/base/nsStackFrameWin.cpp
--- a/xpcom/base/nsStackFrameWin.cpp
+++ b/xpcom/base/nsStackFrameWin.cpp
@@ -40,6 +40,7 @@
 
 #include "nscore.h"
 #include <windows.h>
+#include <process.h>
 #include <stdio.h>
 #include "nsStackFrameWin.h"
 #include "plstr.h"
@@ -478,7 +479,7 @@ NS_StackWalk(NS_WalkStackCallback aCallb
     data.closure = aClosure;
     data.thread = myThread;
     data.process = myProcess;
-    walkerThread = ::CreateThread( NULL, 0, WalkStackThread, (LPVOID) &data, 0, NULL ) ;
+    walkerThread = (HANDLE) _beginthreadex(NULL, 0, WalkStackThread, (LPVOID) &data, 0, NULL ) ;
     if (walkerThread) {
         walkerReturn = ::WaitForSingleObject(walkerThread, 2000); // no timeout is never a good idea
         if (walkerReturn != WAIT_OBJECT_0) {
@@ -494,10 +495,10 @@ NS_StackWalk(NS_WalkStackCallback aCallb
     return NS_OK;
 }
 
-DWORD WINAPI
-WalkStackThread(LPVOID lpdata)
-{
-    struct WalkStackData *data = (WalkStackData *)lpdata;
+unsigned int WINAPI
+WalkStackThread(void* aData)
+{
+    struct WalkStackData *data = (WalkStackData *)aData;
     DWORD ret ;
 
     // Suspend the calling thread, dump his stack, and then resume him.
diff --git a/xpcom/base/nsStackFrameWin.h b/xpcom/base/nsStackFrameWin.h
--- a/xpcom/base/nsStackFrameWin.h
+++ b/xpcom/base/nsStackFrameWin.h
@@ -184,7 +184,7 @@ struct WalkStackData {
 };
 
 void PrintError(char *prefix, WalkStackData* data);
-DWORD WINAPI  WalkStackThread(LPVOID data);
+unsigned int WINAPI WalkStackThread(void* data);
 void WalkStackMain64(struct WalkStackData* data);
 void WalkStackMain(struct WalkStackData* data);
 
