Convert nsTransactionManager's mListeners from nsVoidArray* to nsCOMArray<nsITransactionListener>.  (Bug 488799)  r+sr=peterv

diff --git a/editor/txmgr/src/nsTransactionManager.cpp b/editor/txmgr/src/nsTransactionManager.cpp
--- a/editor/txmgr/src/nsTransactionManager.cpp
+++ b/editor/txmgr/src/nsTransactionManager.cpp
@@ -46,38 +46,23 @@
 #include "nsAutoPtr.h"
 #include "nsCOMPtr.h"
 
 #define LOCK_TX_MANAGER(mgr)    (mgr)->Lock()
 #define UNLOCK_TX_MANAGER(mgr)  (mgr)->Unlock()
 
 
 nsTransactionManager::nsTransactionManager(PRInt32 aMaxTransactionCount)
-  : mMaxTransactionCount(aMaxTransactionCount), mListeners(0)
+  : mMaxTransactionCount(aMaxTransactionCount)
 {
   mMonitor = ::PR_NewMonitor();
 }
 
 nsTransactionManager::~nsTransactionManager()
 {
-  if (mListeners)
-  {
-    PRInt32 i;
-    nsITransactionListener *listener;
-
-    for (i = 0; i < mListeners->Count(); i++)
-    {
-      listener = (nsITransactionListener *)mListeners->ElementAt(i);
-      NS_IF_RELEASE(listener);
-    }
-
-    delete mListeners;
-    mListeners = 0;
-  }
-
   if (mMonitor)
   {
     ::PR_DestroyMonitor(mMonitor);
     mMonitor = 0;
   }
 }
 
 #ifdef DEBUG_TXMGR_REFCNT
@@ -648,65 +633,36 @@ nsTransactionManager::GetRedoList(nsITra
 NS_IMETHODIMP
 nsTransactionManager::AddListener(nsITransactionListener *aListener)
 {
   if (!aListener)
     return NS_ERROR_NULL_POINTER;
 
   LOCK_TX_MANAGER(this);
 
-  if (!mListeners) {
-    mListeners = new nsAutoVoidArray();
-
-    if (!mListeners) {
-      UNLOCK_TX_MANAGER(this);
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-  }
-
-  if (!mListeners->AppendElement((void *)aListener)) {
-    UNLOCK_TX_MANAGER(this);
-    return NS_ERROR_FAILURE;
-  }
-
-  NS_ADDREF(aListener);
+  nsresult rv = mListeners.AppendObject(aListener) ? NS_OK : NS_ERROR_FAILURE;
 
   UNLOCK_TX_MANAGER(this);
 
-  return NS_OK;
+  return rv;
 }
 
 NS_IMETHODIMP
 nsTransactionManager::RemoveListener(nsITransactionListener *aListener)
 {
   if (!aListener)
     return NS_ERROR_NULL_POINTER;
 
-  if (!mListeners)
-    return NS_ERROR_FAILURE;
-
   LOCK_TX_MANAGER(this);
 
-  if (!mListeners->RemoveElement((void *)aListener))
-  {
-    UNLOCK_TX_MANAGER(this);
-    return NS_ERROR_FAILURE;
-  }
-
-  NS_IF_RELEASE(aListener);
-
-  if (mListeners->Count() < 1)
-  {
-    delete mListeners;
-    mListeners = 0;
-  }
+  nsresult rv = mListeners.RemoveObject(aListener) ? NS_OK : NS_ERROR_FAILURE;
 
   UNLOCK_TX_MANAGER(this);
 
-  return NS_OK;
+  return rv;
 }
 
 nsresult
 nsTransactionManager::ClearUndoStack()
 {
   nsresult result;
 
   LOCK_TX_MANAGER(this);
@@ -726,275 +682,220 @@ nsTransactionManager::ClearRedoStack()
   UNLOCK_TX_MANAGER(this);
 
   return result;
 }
 
 nsresult
 nsTransactionManager::WillDoNotify(nsITransaction *aTransaction, PRBool *aInterrupt)
 {
-  if (!mListeners)
-    return NS_OK;
-
   nsresult result = NS_OK;
-  PRInt32 i, lcount = mListeners->Count();
-
-  for (i = 0; i < lcount; i++)
+  for (PRInt32 i = 0, lcount = mListeners.Count(); i < lcount; i++)
   {
-    nsITransactionListener *listener = (nsITransactionListener *)mListeners->ElementAt(i);
+    nsITransactionListener *listener = mListeners[i];
 
     if (!listener)
       return NS_ERROR_FAILURE;
 
     result = listener->WillDo(this, aTransaction, aInterrupt);
     
     if (NS_FAILED(result) || *aInterrupt)
       break;
   }
 
   return result;
 }
 
 nsresult
 nsTransactionManager::DidDoNotify(nsITransaction *aTransaction, nsresult aDoResult)
 {
-  if (!mListeners)
-    return NS_OK;
-
   nsresult result = NS_OK;
-  PRInt32 i, lcount = mListeners->Count();
-
-  for (i = 0; i < lcount; i++)
+  for (PRInt32 i = 0, lcount = mListeners.Count(); i < lcount; i++)
   {
-    nsITransactionListener *listener = (nsITransactionListener *)mListeners->ElementAt(i);
+    nsITransactionListener *listener = mListeners[i];
 
     if (!listener)
       return NS_ERROR_FAILURE;
 
     result = listener->DidDo(this, aTransaction, aDoResult);
     
     if (NS_FAILED(result))
       break;
   }
 
   return result;
 }
 
 nsresult
 nsTransactionManager::WillUndoNotify(nsITransaction *aTransaction, PRBool *aInterrupt)
 {
-  if (!mListeners)
-    return NS_OK;
-
   nsresult result = NS_OK;
-  PRInt32 i, lcount = mListeners->Count();
-
-  for (i = 0; i < lcount; i++)
+  for (PRInt32 i = 0, lcount = mListeners.Count(); i < lcount; i++)
   {
-    nsITransactionListener *listener = (nsITransactionListener *)mListeners->ElementAt(i);
+    nsITransactionListener *listener = mListeners[i];
 
     if (!listener)
       return NS_ERROR_FAILURE;
 
     result = listener->WillUndo(this, aTransaction, aInterrupt);
     
     if (NS_FAILED(result) || *aInterrupt)
       break;
   }
 
   return result;
 }
 
 nsresult
 nsTransactionManager::DidUndoNotify(nsITransaction *aTransaction, nsresult aUndoResult)
 {
-  if (!mListeners)
-    return NS_OK;
-
   nsresult result = NS_OK;
-  PRInt32 i, lcount = mListeners->Count();
-
-  for (i = 0; i < lcount; i++)
+  for (PRInt32 i = 0, lcount = mListeners.Count(); i < lcount; i++)
   {
-    nsITransactionListener *listener = (nsITransactionListener *)mListeners->ElementAt(i);
+    nsITransactionListener *listener = mListeners[i];
 
     if (!listener)
       return NS_ERROR_FAILURE;
 
     result = listener->DidUndo(this, aTransaction, aUndoResult);
     
     if (NS_FAILED(result))
       break;
   }
 
   return result;
 }
 
 nsresult
 nsTransactionManager::WillRedoNotify(nsITransaction *aTransaction, PRBool *aInterrupt)
 {
-  if (!mListeners)
-    return NS_OK;
-
   nsresult result = NS_OK;
-  PRInt32 i, lcount = mListeners->Count();
-
-  for (i = 0; i < lcount; i++)
+  for (PRInt32 i = 0, lcount = mListeners.Count(); i < lcount; i++)
   {
-    nsITransactionListener *listener = (nsITransactionListener *)mListeners->ElementAt(i);
+    nsITransactionListener *listener = mListeners[i];
 
     if (!listener)
       return NS_ERROR_FAILURE;
 
     result = listener->WillRedo(this, aTransaction, aInterrupt);
     
     if (NS_FAILED(result) || *aInterrupt)
       break;
   }
 
   return result;
 }
 
 nsresult
 nsTransactionManager::DidRedoNotify(nsITransaction *aTransaction, nsresult aRedoResult)
 {
-  if (!mListeners)
-    return NS_OK;
-
   nsresult result = NS_OK;
-  PRInt32 i, lcount = mListeners->Count();
-
-  for (i = 0; i < lcount; i++)
+  for (PRInt32 i = 0, lcount = mListeners.Count(); i < lcount; i++)
   {
-    nsITransactionListener *listener = (nsITransactionListener *)mListeners->ElementAt(i);
+    nsITransactionListener *listener = mListeners[i];
 
     if (!listener)
       return NS_ERROR_FAILURE;
 
     result = listener->DidRedo(this, aTransaction, aRedoResult);
     
     if (NS_FAILED(result))
       break;
   }
 
   return result;
 }
 
 nsresult
 nsTransactionManager::WillBeginBatchNotify(PRBool *aInterrupt)
 {
-  if (!mListeners)
-    return NS_OK;
-
   nsresult result = NS_OK;
-  PRInt32 i, lcount = mListeners->Count();
-
-  for (i = 0; i < lcount; i++)
+  for (PRInt32 i = 0, lcount = mListeners.Count(); i < lcount; i++)
   {
-    nsITransactionListener *listener = (nsITransactionListener *)mListeners->ElementAt(i);
+    nsITransactionListener *listener = mListeners[i];
 
     if (!listener)
       return NS_ERROR_FAILURE;
 
     result = listener->WillBeginBatch(this, aInterrupt);
     
     if (NS_FAILED(result) || *aInterrupt)
       break;
   }
 
   return result;
 }
 
 nsresult
 nsTransactionManager::DidBeginBatchNotify(nsresult aResult)
 {
-  if (!mListeners)
-    return NS_OK;
-
   nsresult result = NS_OK;
-  PRInt32 i, lcount = mListeners->Count();
-
-  for (i = 0; i < lcount; i++)
+  for (PRInt32 i = 0, lcount = mListeners.Count(); i < lcount; i++)
   {
-    nsITransactionListener *listener = (nsITransactionListener *)mListeners->ElementAt(i);
+    nsITransactionListener *listener = mListeners[i];
 
     if (!listener)
       return NS_ERROR_FAILURE;
 
     result = listener->DidBeginBatch(this, aResult);
     
     if (NS_FAILED(result))
       break;
   }
 
   return result;
 }
 
 nsresult
 nsTransactionManager::WillEndBatchNotify(PRBool *aInterrupt)
 {
-  if (!mListeners)
-    return NS_OK;
-
   nsresult result = NS_OK;
-  PRInt32 i, lcount = mListeners->Count();
-
-  for (i = 0; i < lcount; i++)
+  for (PRInt32 i = 0, lcount = mListeners.Count(); i < lcount; i++)
   {
-    nsITransactionListener *listener = (nsITransactionListener *)mListeners->ElementAt(i);
+    nsITransactionListener *listener = mListeners[i];
 
     if (!listener)
       return NS_ERROR_FAILURE;
 
     result = listener->WillEndBatch(this, aInterrupt);
     
     if (NS_FAILED(result) || *aInterrupt)
       break;
   }
 
   return result;
 }
 
 nsresult
 nsTransactionManager::DidEndBatchNotify(nsresult aResult)
 {
-  if (!mListeners)
-    return NS_OK;
-
   nsresult result = NS_OK;
-  PRInt32 i, lcount = mListeners->Count();
-
-  for (i = 0; i < lcount; i++)
+  for (PRInt32 i = 0, lcount = mListeners.Count(); i < lcount; i++)
   {
-    nsITransactionListener *listener = (nsITransactionListener *)mListeners->ElementAt(i);
+    nsITransactionListener *listener = mListeners[i];
 
     if (!listener)
       return NS_ERROR_FAILURE;
 
     result = listener->DidEndBatch(this, aResult);
     
     if (NS_FAILED(result))
       break;
   }
 
   return result;
 }
 
 nsresult
 nsTransactionManager::WillMergeNotify(nsITransaction *aTop, nsITransaction *aTransaction, PRBool *aInterrupt)
 {
-  if (!mListeners)
-    return NS_OK;
-
   nsresult result = NS_OK;
-  PRInt32 i, lcount = mListeners->Count();
-
-  for (i = 0; i < lcount; i++)
+  for (PRInt32 i = 0, lcount = mListeners.Count(); i < lcount; i++)
   {
-    nsITransactionListener *listener = (nsITransactionListener *)mListeners->ElementAt(i);
+    nsITransactionListener *listener = mListeners[i];
 
     if (!listener)
       return NS_ERROR_FAILURE;
 
     result = listener->WillMerge(this, aTop, aTransaction, aInterrupt);
     
     if (NS_FAILED(result) || *aInterrupt)
       break;
@@ -1004,25 +905,20 @@ nsTransactionManager::WillMergeNotify(ns
 }
 
 nsresult
 nsTransactionManager::DidMergeNotify(nsITransaction *aTop,
                                      nsITransaction *aTransaction,
                                      PRBool aDidMerge,
                                      nsresult aMergeResult)
 {
-  if (!mListeners)
-    return NS_OK;
-
   nsresult result = NS_OK;
-  PRInt32 i, lcount = mListeners->Count();
-
-  for (i = 0; i < lcount; i++)
+  for (PRInt32 i = 0, lcount = mListeners.Count(); i < lcount; i++)
   {
-    nsITransactionListener *listener = (nsITransactionListener *)mListeners->ElementAt(i);
+    nsITransactionListener *listener = mListeners[i];
 
     if (!listener)
       return NS_ERROR_FAILURE;
 
     result = listener->DidMerge(this, aTop, aTransaction, aDidMerge, aMergeResult);
     
     if (NS_FAILED(result))
       break;
diff --git a/editor/txmgr/src/nsTransactionManager.h b/editor/txmgr/src/nsTransactionManager.h
--- a/editor/txmgr/src/nsTransactionManager.h
+++ b/editor/txmgr/src/nsTransactionManager.h
@@ -36,37 +36,38 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsTransactionManager_h__
 #define nsTransactionManager_h__
 
 #include "prmon.h"
 #include "nsWeakReference.h"
 #include "nsITransactionManager.h"
+#include "nsCOMArray.h"
+#include "nsITransactionListener.h"
 
 class nsITransaction;
 class nsITransactionListener;
 class nsTransactionItem;
 class nsTransactionStack;
 class nsTransactionRedoStack;
-class nsVoidArray;
 
 /** implementation of a transaction manager object.
  *
  */
 class nsTransactionManager : public nsITransactionManager
                            , public nsSupportsWeakReference
 {
 private:
 
   PRInt32                mMaxTransactionCount;
   nsTransactionStack     mDoStack;
   nsTransactionStack     mUndoStack;
   nsTransactionRedoStack mRedoStack;
-  nsVoidArray            *mListeners;
+  nsCOMArray<nsITransactionListener> mListeners;
 
   PRMonitor              *mMonitor;
 
 public:
 
   /** The default constructor.
    */
   nsTransactionManager(PRInt32 aMaxTransactionCount=-1);
