From: L. David Baron <dbaron@dbaron.org>

Add test for nsStyleAnimation::ComputeDistance.

diff --git a/dom/base/nsDOMWindowUtils.cpp b/dom/base/nsDOMWindowUtils.cpp
--- a/dom/base/nsDOMWindowUtils.cpp
+++ b/dom/base/nsDOMWindowUtils.cpp
@@ -64,16 +64,18 @@
 
 #include "nsIDOMHTMLCanvasElement.h"
 #include "gfxContext.h"
 #include "gfxImageSurface.h"
 #include "nsLayoutUtils.h"
 #include "nsComputedDOMStyle.h"
 #include "nsIViewObserver.h"
 #include "nsIPresShell.h"
+#include "nsStyleAnimation.h"
+#include "nsCSSProps.h"
 
 #if defined(MOZ_X11) && defined(MOZ_WIDGET_GTK2)
 #include <gdk/gdk.h>
 #include <gdk/gdkx.h>
 #endif
 
 #include "jsobj.h"
 
@@ -1548,16 +1550,45 @@ nsDOMWindowUtils::GetLayerManagerType(ns
   if (!mgr)
     return NS_ERROR_FAILURE;
 
   mgr->GetBackendName(aType);
 
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsDOMWindowUtils::ComputeAnimationDistance(nsIDOMElement* aElement,
+                                           const nsAString& aProperty,
+                                           const nsAString& aValue1,
+                                           const nsAString& aValue2,
+                                           double* aResult)
+{
+  nsresult rv;
+  nsCOMPtr<nsIContent> content = do_QueryInterface(aElement, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCSSProperty property = nsCSSProps::LookupProperty(aProperty);
+
+  nsStyleAnimation::Value v1, v2;
+  if (property == eCSSProperty_UNKNOWN ||
+      !nsStyleAnimation::ComputeValue(property, content, aValue1,
+                                      PR_FALSE, v1) ||
+      !nsStyleAnimation::ComputeValue(property, content, aValue2,
+                                      PR_FALSE, v2)) {
+    return NS_ERROR_ILLEGAL_VALUE;
+  }
+
+  if (!nsStyleAnimation::ComputeDistance(property, v1, v2, *aResult)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+}
+
 nsresult
 nsDOMWindowUtils::RenderDocument(const nsRect& aRect,
                                  PRUint32 aFlags,
                                  nscolor aBackgroundColor,
                                  gfxContext* aThebesContext)
 {
     // Get DOM Document
     nsresult rv;
diff --git a/dom/interfaces/base/nsIDOMWindowUtils.idl b/dom/interfaces/base/nsIDOMWindowUtils.idl
--- a/dom/interfaces/base/nsIDOMWindowUtils.idl
+++ b/dom/interfaces/base/nsIDOMWindowUtils.idl
@@ -55,17 +55,17 @@ interface nsICycleCollectorListener;
 interface nsIDOMNode;
 interface nsIDOMNodeList;
 interface nsIDOMElement;
 interface nsIDOMHTMLCanvasElement;
 interface nsIDOMEvent;
 interface nsITransferable;
 interface nsIQueryContentEventResult;
 
-[scriptable, uuid(8707ed93-3277-42a5-a235-533aa661a263)]
+[scriptable, uuid(def3fbe8-961b-4c8b-8cac-eb6a4e604bb5)]
 interface nsIDOMWindowUtils : nsISupports {
 
   /**
    * Image animation mode of the window. When this attribute's value
    * is changed, the implementation should set all images in the window
    * to the given value. That is, when set to kDontAnimMode, all images
    * will stop animating. The attribute's value must be one of the
    * animationMode values from imgIContainer.
@@ -795,15 +795,27 @@ interface nsIDOMWindowUtils : nsISupport
 
   /**
    * What type of layer manager the widget associated with this window is
    * using. "Basic" is unaccelerated; other types are accelerated. Throws an
    * error if there is no widget associated with this window.
    */
   readonly attribute AString layerManagerType;
 
+  /**
+   * Method for testing nsStyleAnimation::ComputeDistance.
+   *
+   * Returns the distance between the two values as reported by
+   * nsStyleAnimation::ComputeDistance for the given element and
+   * property.
+   */
+  double computeAnimationDistance(in nsIDOMElement element,
+                                  in AString property,
+                                  in AString value1,
+                                  in AString value2);
+
 %{C++
   virtual nsresult RenderDocument(const nsRect& aRect,
                                   PRUint32 aFlags,
                                   nscolor aBackgroundColor,
                                   gfxContext* aThebesContext) = 0;
 %}
 };
diff --git a/layout/style/test/test_transitions_per_property.html b/layout/style/test/test_transitions_per_property.html
--- a/layout/style/test/test_transitions_per_property.html
+++ b/layout/style/test/test_transitions_per_property.html
@@ -269,16 +269,34 @@ for (prop in supported_properties) {
     var prereqs = info.prerequisites;
     for (var prereq in prereqs) {
       div.style.removeProperty(prereq);
     }
   }
 }
 div.style.removeProperty("-moz-transition");
 
+var get_distance(prop, v1, v2)
+{
+  netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+  var utils = window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
+                      .getInterface(Components.interfaces.nsIDOMWindowUtils);
+  return utils.computeAnimationDistance(div, prop, v1, v2);
+}
+
+function check_distance(prop, start, quarter, end)
+{
+  var sq = get_distance(prop, start, quarter);
+  var se = get_distance(prop, start, end);
+  var qe = get_distance(prop, quarter, end);
+
+  is(sq * 4, se, "property '" + prop + "': distance from start '" + start + "' to quarter '" + quarter + "' should be quarter distance from start '" + start + "' to end '" + end + "');
+  is(qe * 4, se * 3, "property '" + prop + "': distance from quarter '" + start + "' to end '" + quarter + "' should be three quarters distance from start '" + start + "' to end '" + end + "');
+}
+
 function test_length_transition(prop) {
   div.style.setProperty("-moz-transition-property", "none", "");
   div.style.setProperty(prop, "4px", "");
   is(cs.getPropertyValue(prop), "4px",
      "length-valued property " + prop + ": computed value before transition");
   div.style.setProperty("-moz-transition-property", prop, "");
   div.style.setProperty(prop, "12px", "");
   is(cs.getPropertyValue(prop), "6px",
