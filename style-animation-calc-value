From: L. David Baron <dbaron@dbaron.org>

Add calc() unit to nsStyleAnimation::Value.  (Bug 520234)

diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -108,16 +108,54 @@ gcd(PRUint32 a, PRUint32 b)
 // Least Common Multiple
 static PRUint32
 lcm(PRUint32 a, PRUint32 b)
 {
   // Divide first to reduce overflow risk.
   return (a / gcd(a, b)) * b;
 }
 
+// Like nsStyleCoord::Calc, but with length in float pixels instead of nscoord.
+struct CalcValue {
+  float mLength, mPercent;
+  PRBool mHasPercent;
+};
+
+static CalcValue
+ExtractCalcValue(const nsStyleAnimation::Value& aValue)
+{
+  NS_ABORT_IF_FALSE(aValue.GetUnit() == nsStyleAnimation::eUnit_Calc,
+                    "unexpected unit");
+  nsCSSValue *val = aValue.GetCSSValueValue();
+  NS_ABORT_IF_FALSE(val->GetUnit() == eCSSUnit_Calc, "unexpected unit");
+  nsCSSValue::Array *arr = val->GetArrayValue();
+  NS_ABORT_IF_FALSE(arr->Count() == 1, "unexpected length");
+  CalcValue result;
+
+  const nsCSSValue &topval = arr->Item(0);
+  if (topval.GetUnit() == eCSSUnit_Pixel) {
+    result.mLength = topval.GetFloatValue();
+    result.mPercent = 0.0f;
+    result.mHasPercent = PR_FALSE;
+  } else {
+    NS_ABORT_IF_FALSE(topval.GetUnit() == eCSSUnit_Calc_Plus,
+                      "unexpected unit");
+    nsCSSValue::Array *arr2 = topval.GetArrayValue();
+    const nsCSSValue &len = arr2->Item(0);
+    const nsCSSValue &pct = arr2->Item(1);
+    NS_ABORT_IF_FALSE(len.GetUnit() == eCSSUnit_Pixel, "unexpected unit");
+    NS_ABORT_IF_FALSE(pct.GetUnit() == eCSSUnit_Percent, "unexpected unit");
+    result.mLength = len.GetFloatValue();
+    result.mPercent = pct.GetPercentValue();
+    result.mHasPercent = PR_TRUE;
+  }
+
+  return result;
+}
+
 // CLASS METHODS
 // -------------
 
 PRBool
 nsStyleAnimation::ComputeDistance(nsCSSProperty aProperty,
                                   const Value& aStartValue,
                                   const Value& aEndValue,
                                   double& aDistance)
@@ -208,16 +246,24 @@ nsStyleAnimation::ComputeDistance(nsCSSP
       double diffA = startA - endA;
       double diffR = startR - endR;
       double diffG = startG - endG;
       double diffB = startB - endB;
       aDistance = sqrt(diffA * diffA + diffR * diffR +
                        diffG * diffG + diffB * diffB);
       return PR_TRUE;
     }
+    case eUnit_Calc: {
+      CalcValue v1 = ExtractCalcValue(aStartValue);
+      CalcValue v2 = ExtractCalcValue(aEndValue);
+      float difflen = v2.mLength - v1.mLength;
+      float diffpct = v2.mPercent - v1.mPercent;
+      aDistance = sqrt(difflen * difflen + diffpct * diffpct);
+      return PR_TRUE;
+    }
     case eUnit_CSSValuePair: {
       const nsCSSValuePair *pair1 = aStartValue.GetCSSValuePairValue();
       const nsCSSValuePair *pair2 = aEndValue.GetCSSValuePairValue();
       if (pair1->mXValue.GetUnit() != pair2->mXValue.GetUnit() ||
           pair1->mYValue.GetUnit() != pair2->mYValue.GetUnit()) {
         // At least until we have calc()
         return PR_FALSE;
       }
@@ -1261,16 +1307,43 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
         PRUint8 Rres = ClampColor((R1 * aCoeff1 + R2 * aCoeff2) * factor);
         PRUint8 Gres = ClampColor((G1 * aCoeff1 + G2 * aCoeff2) * factor);
         PRUint8 Bres = ClampColor((B1 * aCoeff1 + B2 * aCoeff2) * factor);
         resultColor = NS_RGBA(Rres, Gres, Bres, Ares);
       }
       aResultValue.SetColorValue(resultColor);
       return PR_TRUE;
     }
+    case eUnit_Calc: {
+      CalcValue v1 = ExtractCalcValue(aValue1);
+      CalcValue v2 = ExtractCalcValue(aValue2);
+      double len = aCoeff1 * v1.mLength + aCoeff2 * v2.mLength;
+      double pct = aCoeff1 * v1.mPercent + aCoeff2 * v2.mPercent;
+      PRBool hasPct = (aCoeff1 != 0.0 && v1.mHasPercent) ||
+                      (aCoeff2 != 0.0 && v2.mHasPercent);
+      nsCSSValue *val = new nsCSSValue();
+      nsCSSValue::Array *arr = nsCSSValue::Array::Create(1);
+      if (!arr) {
+        return PR_FALSE;
+      }
+      val->SetArrayValue(arr, eCSSUnit_Calc);
+      if (hasPct) {
+        nsCSSValue::Array *arr2 = nsCSSValue::Array::Create(2);
+        if (!arr2) {
+          return PR_FALSE;
+        }
+        arr2->Item(0).SetFloatValue(len, eCSSUnit_Pixel);
+        arr2->Item(1).SetPercentValue(pct);
+        arr->Item(0).SetArrayValue(arr2, eCSSUnit_Calc_Plus);
+      } else {
+        arr->Item(0).SetFloatValue(len, eCSSUnit_Pixel);
+      }
+      aResultValue.SetAndAdoptCSSValueValue(val, eUnit_Calc);
+      return PR_TRUE;
+    }
     case eUnit_CSSValuePair: {
       const nsCSSValuePair *pair1 = aValue1.GetCSSValuePairValue();
       const nsCSSValuePair *pair2 = aValue2.GetCSSValuePairValue();
       if (pair1->mXValue.GetUnit() != pair2->mXValue.GetUnit() ||
           pair1->mYValue.GetUnit() != pair2->mYValue.GetUnit()) {
         // At least until we have calc()
         return PR_FALSE;
       }
@@ -1747,16 +1820,22 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
     case eUnit_Float:
       aSpecifiedValue.
         SetFloatValue(aComputedValue.GetFloatValue(), eCSSUnit_Number);
       break;
     case eUnit_Color:
       // colors can be alone, or part of a paint server
       aSpecifiedValue.SetColorValue(aComputedValue.GetColorValue());
       break;
+    case eUnit_Calc: {
+      nsCSSValue *val = aComputedValue.GetCSSValueValue();
+      NS_ABORT_IF_FALSE(val->GetUnit() == eCSSUnit_Calc, "unexpected unit");
+      aSpecifiedValue = *val;
+      break;
+    }
     case eUnit_CSSValuePair: {
       // Rule node processing expects pair values to be collapsed to a
       // single value if both halves would be equal, for most but not
       // all properties.  At present, all animatable properties that
       // use pairs do expect collapsing.
       const nsCSSValuePair* pair = aComputedValue.GetCSSValuePairValue();
       if (pair->mXValue == pair->mYValue) {
         aSpecifiedValue = pair->mXValue;
@@ -2479,16 +2558,23 @@ nsStyleAnimation::Value::operator=(const
       break;
     case eUnit_Percent:
     case eUnit_Float:
       mValue.mFloat = aOther.mValue.mFloat;
       break;
     case eUnit_Color:
       mValue.mColor = aOther.mValue.mColor;
       break;
+    case eUnit_Calc:
+      NS_ABORT_IF_FALSE(aOther.mValue.mCSSValue, "values may not be null");
+      mValue.mCSSValue = new nsCSSValue(*aOther.mValue.mCSSValue);
+      if (!mValue.mCSSValue) {
+        mUnit = eUnit_Null;
+      }
+      break;
     case eUnit_CSSValuePair:
       NS_ABORT_IF_FALSE(aOther.mValue.mCSSValuePair,
                         "value pairs may not be null");
       mValue.mCSSValuePair = new nsCSSValuePair(*aOther.mValue.mCSSValuePair);
       if (!mValue.mCSSValuePair) {
         mUnit = eUnit_Null;
       }
       break;
@@ -2602,16 +2688,27 @@ nsStyleAnimation::Value::SetUnparsedStri
   if (NS_UNLIKELY(!mValue.mString)) {
     // not much we can do here; just make sure that our promise of a
     // non-null mValue.mString holds for string units.
     mUnit = eUnit_Null;
   }
 }
 
 void
+nsStyleAnimation::Value::SetAndAdoptCSSValueValue(nsCSSValue *aValue,
+                                                  Unit aUnit)
+{
+  FreeValue();
+  NS_ABORT_IF_FALSE(IsCSSValueUnit(aUnit), "bad unit");
+  NS_ABORT_IF_FALSE(aValue != nsnull, "values may not be null");
+  mUnit = aUnit;
+  mValue.mCSSValue = aValue; // take ownership
+}
+
+void
 nsStyleAnimation::Value::SetAndAdoptCSSValuePairValue(
                            nsCSSValuePair *aValuePair, Unit aUnit)
 {
   FreeValue();
   NS_ABORT_IF_FALSE(IsCSSValuePairUnit(aUnit), "bad unit");
   NS_ABORT_IF_FALSE(aValuePair != nsnull, "value pairs may not be null");
   mUnit = aUnit;
   mValue.mCSSValuePair = aValuePair; // take ownership
@@ -2647,17 +2744,19 @@ nsStyleAnimation::Value::SetAndAdoptCSSV
   NS_ABORT_IF_FALSE(aValuePairList, "may not be null");
   mUnit = eUnit_CSSValuePairList;
   mValue.mCSSValuePairList = aValuePairList; // take ownership
 }
 
 void
 nsStyleAnimation::Value::FreeValue()
 {
-  if (IsCSSValueListUnit(mUnit)) {
+  if (IsCSSValueUnit(mUnit)) {
+    delete mValue.mCSSValue;
+  } else if (IsCSSValueListUnit(mUnit)) {
     delete mValue.mCSSValueList;
   } else if (IsCSSValuePairUnit(mUnit)) {
     delete mValue.mCSSValuePair;
   } else if (IsCSSRectUnit(mUnit)) {
     delete mValue.mCSSRect;
   } else if (IsCSSValuePairListUnit(mUnit)) {
     delete mValue.mCSSValuePairList;
   } else if (IsStringUnit(mUnit)) {
@@ -2685,16 +2784,18 @@ nsStyleAnimation::Value::operator==(cons
       return mValue.mInt == aOther.mValue.mInt;
     case eUnit_Coord:
       return mValue.mCoord == aOther.mValue.mCoord;
     case eUnit_Percent:
     case eUnit_Float:
       return mValue.mFloat == aOther.mValue.mFloat;
     case eUnit_Color:
       return mValue.mColor == aOther.mValue.mColor;
+    case eUnit_Calc:
+      return *mValue.mCSSValue == *aOther.mValue.mCSSValue;
     case eUnit_CSSValuePair:
       return *mValue.mCSSValuePair == *aOther.mValue.mCSSValuePair;
     case eUnit_CSSRect:
       return *mValue.mCSSRect == *aOther.mValue.mCSSRect;
     case eUnit_Dasharray:
     case eUnit_Shadow:
     case eUnit_Transform:
       return *mValue.mCSSValueList == *aOther.mValue.mCSSValueList;
diff --git a/layout/style/nsStyleAnimation.h b/layout/style/nsStyleAnimation.h
--- a/layout/style/nsStyleAnimation.h
+++ b/layout/style/nsStyleAnimation.h
@@ -224,16 +224,18 @@ public:
     eUnit_Enumerated,
     eUnit_Visibility, // special case for transitions (which converts
                       // Enumerated to Visibility as needed)
     eUnit_Integer,
     eUnit_Coord,
     eUnit_Percent,
     eUnit_Float,
     eUnit_Color,
+    eUnit_Calc, // nsCSSValue* (never null), always with a single
+                // calc() expression that's either length or length+percent
     eUnit_CSSValuePair, // nsCSSValuePair* (never null)
     eUnit_CSSRect, // nsCSSRect* (never null)
     eUnit_Dasharray, // nsCSSValueList* (never null)
     eUnit_Shadow, // nsCSSValueList* (may be null)
     eUnit_Transform, // nsCSSValueList* (never null)
     eUnit_CSSValuePairList, // nsCSSValuePairList* (never null)
     eUnit_UnparsedString // nsStringBuffer* (never null)
   };
@@ -241,16 +243,17 @@ public:
   class Value {
   private:
     Unit mUnit;
     union {
       PRInt32 mInt;
       nscoord mCoord;
       float mFloat;
       nscolor mColor;
+      nsCSSValue* mCSSValue;
       nsCSSValuePair* mCSSValuePair;
       nsCSSRect* mCSSRect;
       nsCSSValueList* mCSSValueList;
       nsCSSValuePairList* mCSSValuePairList;
       nsStringBuffer* mString;
     } mValue;
   public:
     Unit GetUnit() const {
@@ -279,16 +282,20 @@ public:
     float GetFloatValue() const {
       NS_ASSERTION(mUnit == eUnit_Float, "unit mismatch");
       return mValue.mFloat;
     }
     nscolor GetColorValue() const {
       NS_ASSERTION(mUnit == eUnit_Color, "unit mismatch");
       return mValue.mColor;
     }
+    nsCSSValue* GetCSSValueValue() const {
+      NS_ASSERTION(IsCSSValueUnit(mUnit), "unit mismatch");
+      return mValue.mCSSValue;
+    }
     nsCSSValuePair* GetCSSValuePairValue() const {
       NS_ASSERTION(IsCSSValuePairUnit(mUnit), "unit mismatch");
       return mValue.mCSSValuePair;
     }
     nsCSSRect* GetCSSRectValue() const {
       NS_ASSERTION(IsCSSRectUnit(mUnit), "unit mismatch");
       return mValue.mCSSRect;
     }
@@ -338,16 +345,17 @@ public:
     void SetCoordValue(nscoord aCoord);
     void SetPercentValue(float aPercent);
     void SetFloatValue(float aFloat);
     void SetColorValue(nscolor aColor);
     void SetUnparsedStringValue(const nsString& aString);
 
     // These setters take ownership of |aValue|, and are therefore named
     // "SetAndAdopt*".
+    void SetAndAdoptCSSValueValue(nsCSSValue *aValue, Unit aUnit);
     void SetAndAdoptCSSValuePairValue(nsCSSValuePair *aValue, Unit aUnit);
     void SetAndAdoptCSSRectValue(nsCSSRect *aValue, Unit aUnit);
     void SetAndAdoptCSSValueListValue(nsCSSValueList *aValue, Unit aUnit);
     void SetAndAdoptCSSValuePairListValue(nsCSSValuePairList *aValue);
 
     Value& operator=(const Value& aOther);
 
     PRBool operator==(const Value& aOther) const;
@@ -360,16 +368,19 @@ public:
     static const PRUnichar* GetBufferValue(nsStringBuffer* aBuffer) {
       return static_cast<PRUnichar*>(aBuffer->Data());
     }
 
     static PRBool IsIntUnit(Unit aUnit) {
       return aUnit == eUnit_Enumerated || aUnit == eUnit_Visibility ||
              aUnit == eUnit_Integer;
     }
+    static PRBool IsCSSValueUnit(Unit aUnit) {
+      return aUnit == eUnit_Calc;
+    }
     static PRBool IsCSSValuePairUnit(Unit aUnit) {
       return aUnit == eUnit_CSSValuePair;
     }
     static PRBool IsCSSRectUnit(Unit aUnit) {
       return aUnit == eUnit_CSSRect;
     }
     static PRBool IsCSSValueListUnit(Unit aUnit) {
       return aUnit == eUnit_Dasharray || aUnit == eUnit_Shadow ||
