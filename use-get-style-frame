From: L. David Baron <dbaron@dbaron.org>

Bug 858937 patch 2:  Make transitions code that should be using nsLayoutUtils::GetStyleFrame do so.

The fixes to the miniflush code
(nsTransitionManager::UpdateThrottledStyle and UpdateAllThrottledStyles)
fix the case where we constructed totally incorrect style contexts for
outer table frames (which have special style contexts inheriting from
the table frame) during the miniflush, leading to inconsistent style
data and other bad things, when we should have been touching the style
on the table frame instead.

The fixes to the other OMTA codepaths lead to layer tests being
performed on the same frame that the styles will be applied to, and
probably fix real bugs (which would occur when animating opacity or
transform on a table).

diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -255,17 +255,17 @@ CommonElementAnimationData::CanAnimatePr
   bool shouldLog = nsLayoutUtils::IsAnimationLoggingEnabled();
   if (shouldLog && !gfxPlatform::OffMainThreadCompositingEnabled()) {
     nsCString message;
     message.AppendLiteral("Performance warning: Compositor disabled");
     LogAsyncAnimationFailure(message);
     return false;
   }
 
-  nsIFrame* frame = aElement->GetPrimaryFrame();
+  nsIFrame* frame = nsLayoutUtils::GetStyleFrame(aElement);
   if (IsGeometricProperty(aProperty)) {
     if (shouldLog) {
       nsCString message;
       message.AppendLiteral("Performance warning: Async animation of geometric property '");
       message.Append(nsCSSProps::GetStringValue(aProperty));
       message.AppendLiteral("' is disabled");
       LogAsyncAnimationFailure(message, aElement);
     }
@@ -347,18 +347,18 @@ CommonElementAnimationData::CanThrottleT
 
   // If this animation can cause overflow, we can throttle some of the ticks.
   if ((aTime - mStyleRuleRefreshTime) < TimeDuration::FromMilliseconds(200)) {
     return true;
   }
 
   // If the nearest scrollable ancestor has overflow:hidden,
   // we don't care about overflow.
-  nsIScrollableFrame* scrollable =
-    nsLayoutUtils::GetNearestScrollableFrame(mElement->GetPrimaryFrame());
+  nsIScrollableFrame* scrollable = nsLayoutUtils::GetNearestScrollableFrame(
+                                     nsLayoutUtils::GetStyleFrame(mElement));
   if (!scrollable) {
     return true;
   }
 
   nsPresContext::ScrollbarStyles ss = scrollable->GetScrollbarStyles();
   if (ss.mVertical == NS_STYLE_OVERFLOW_HIDDEN &&
       ss.mHorizontal == NS_STYLE_OVERFLOW_HIDDEN &&
       scrollable->GetLogicalScrollPosition() == nsPoint(0, 0)) {
@@ -366,17 +366,17 @@ CommonElementAnimationData::CanThrottleT
   }
 
   return false;
 }
 
 bool
 CommonElementAnimationData::CanThrottleAnimation(TimeStamp aTime)
 {
-  nsIFrame* frame = mElement->GetPrimaryFrame();
+  nsIFrame* frame = nsLayoutUtils::GetStyleFrame(mElement);
   if (!frame) {
     return false;
   }
 
   bool hasTransform = HasAnimationOfProperty(eCSSProperty_transform);
   bool hasOpacity = HasAnimationOfProperty(eCSSProperty_opacity);
   if (hasOpacity) {
     Layer* layer = FrameLayerBuilder::GetDedicatedLayer(
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -350,17 +350,17 @@ ElementAnimations::HasAnimationOfPropert
     }
   }
   return false;
 }
 
 bool
 ElementAnimations::CanPerformOnCompositorThread(CanAnimateFlags aFlags) const
 {
-  nsIFrame* frame = mElement->GetPrimaryFrame();
+  nsIFrame* frame = nsLayoutUtils::GetStyleFrame(mElement);
   if (!frame) {
     return false;
   }
 
   if (mElementProperty != nsGkAtoms::animationsProperty) {
     if (nsLayoutUtils::IsAnimationLoggingEnabled()) {
       nsCString message;
       message.AppendLiteral("Gecko bug: Async animation of pseudoelements not supported.  See bug 771367 (");
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -136,17 +136,17 @@ ElementTransitions::HasAnimationOfProper
     }
   }
   return false;
 }
 
 bool
 ElementTransitions::CanPerformOnCompositorThread(CanAnimateFlags aFlags) const
 {
-  nsIFrame* frame = mElement->GetPrimaryFrame();
+  nsIFrame* frame = nsLayoutUtils::GetStyleFrame(mElement);
   if (!frame) {
     return false;
   }
 
   if (mElementProperty != nsGkAtoms::transitionsProperty) {
     if (nsLayoutUtils::IsAnimationLoggingEnabled()) {
       nsCString message;
       message.AppendLiteral("Gecko bug: Async transition of pseudoelements not supported.  See bug 771367");
@@ -254,17 +254,17 @@ nsStyleContext*
 nsTransitionManager::UpdateThrottledStyle(dom::Element* aElement,
                                           nsStyleContext* aParentStyle,
                                           nsStyleChangeList& aChangeList)
 {
   NS_ASSERTION(GetElementTransitions(aElement,
                                      nsCSSPseudoElements::ePseudo_NotPseudoElement,
                                      false), "element not transitioning");
 
-  nsIFrame* primaryFrame = aElement->GetPrimaryFrame();
+  nsIFrame* primaryFrame = nsLayoutUtils::GetStyleFrame(aElement);
   if (!primaryFrame) {
     return nullptr;
   }
 
   nsStyleContext* oldStyle = primaryFrame->StyleContext();
   nsRuleNode* ruleNode = oldStyle->RuleNode();
   nsTArray<nsStyleSet::RuleAndLevel> rules;
   do {
@@ -345,17 +345,17 @@ nsTransitionManager::UpdateThrottledStyl
                                   false))) {
     // re-resolve our style
     newStyle = UpdateThrottledStyle(element, aParentStyle, aChangeList);
     // remove the current transition from the working set
     et->mFlushGeneration = mPresContext->RefreshDriver()->MostRecentRefresh();
   } else {
     // reparent the element's style
     nsStyleSet* styleSet = mPresContext->PresShell()->StyleSet();
-    nsIFrame* primaryFrame = aContent->GetPrimaryFrame();
+    nsIFrame* primaryFrame = nsLayoutUtils::GetStyleFrame(aContent);
     if (!primaryFrame) {
       return;
     }
 
     newStyle = styleSet->ReparentStyleContext(primaryFrame->StyleContext(),
                                               aParentStyle, element);
     primaryFrame->SetStyleContextWithoutNotification(newStyle);
     ReparentBeforeAndAfter(element, primaryFrame, newStyle, styleSet);
@@ -418,17 +418,17 @@ nsTransitionManager::UpdateAllThrottledS
                                 false)) {
         element = ancestors[i];
         break;
       }
     }
 
     nsIFrame* primaryFrame;
     if (element &&
-        (primaryFrame = element->GetPrimaryFrame())) {
+        (primaryFrame = nsLayoutUtils::GetStyleFrame(element))) {
       UpdateThrottledStylesForSubtree(element,
         primaryFrame->StyleContext()->GetParent(), changeList);
     }
   }
 
   mPresContext->PresShell()->FrameConstructor()->
     ProcessRestyledFrames(changeList);
   mPresContext->PresShell()->FrameConstructor()->
