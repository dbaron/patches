From: L. David Baron <dbaron@dbaron.org>

Get rid of per-SID getter functions when we can now efficiently use a single function.  (Bug 636039, at least for now)

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -6286,40 +6286,16 @@ nsRuleNode::GetParentData(const nsStyleS
     NS_ASSERTION(ruleNode->mStyleData.GetStyleData(aSID) == nsnull,
                  "both struct and dependent bits present");
     ruleNode = ruleNode->mParent;
   }
 
   return ruleNode->mStyleData.GetStyleData(aSID);
 }
 
-#define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)                      \
-inline const nsStyle##name_ *                                               \
-nsRuleNode::GetParent##name_()                                              \
-{                                                                           \
-  NS_PRECONDITION(mDependentBits &                                          \
-                  nsCachedStyleData::GetBitForSID(eStyleStruct_##name_),    \
-                  "should be called when node depends on parent data");     \
-  NS_ASSERTION(mStyleData.GetStyle##name_() == nsnull,                      \
-               "both struct and dependent bits present");                   \
-  /* Walk up the rule tree from this rule node (towards less specific */    \
-  /* rules). */                                                             \
-  PRUint32 bit = nsCachedStyleData::GetBitForSID(eStyleStruct_##name_);     \
-  nsRuleNode *ruleNode = mParent;                                           \
-  while (ruleNode->mDependentBits & bit) {                                  \
-    NS_ASSERTION(ruleNode->mStyleData.GetStyle##name_() == nsnull,          \
-                 "both struct and dependent bits present");                 \
-    ruleNode = ruleNode->mParent;                                           \
-  }                                                                         \
-                                                                            \
-  return ruleNode->mStyleData.GetStyle##name_();                            \
-}
-#include "nsStyleStructList.h"
-#undef STYLE_STRUCT
-
 const void*
 nsRuleNode::GetStyleData(nsStyleStructID aSID,
                          nsStyleContext* aContext,
                          PRBool aComputeData)
 {
   const void *data;
   if (mDependentBits & nsCachedStyleData::GetBitForSID(aSID)) {
     // We depend on an ancestor for this struct since the cached struct
@@ -6349,52 +6325,16 @@ nsRuleNode::GetStyleData(nsStyleStructID
   // default values for the given style struct from the set.  Note that
   // this works fine even if |this| is a rule node that has been
   // destroyed (leftover from a previous rule tree) but is somehow still
   // used.
   return mPresContext->PresShell()->StyleSet()->
     DefaultStyleData()->GetStyleData(aSID);
 }
 
-// See comments above in GetStyleData for an explanation of what the
-// code below does.
-#define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)                        \
-const nsStyle##name_*                                                         \
-nsRuleNode::GetStyle##name_(nsStyleContext* aContext, PRBool aComputeData)    \
-{                                                                             \
-  const nsStyle##name_ *data;                                                 \
-  if (mDependentBits &                                                        \
-      nsCachedStyleData::GetBitForSID(eStyleStruct_##name_)) {                \
-    data = GetParent##name_();                                                \
-    NS_ASSERTION(data, "dependent bits set but no cached struct present");    \
-    return data;                                                              \
-  }                                                                           \
-                                                                              \
-  data = mStyleData.GetStyle##name_();                                        \
-  if (NS_LIKELY(data != nsnull))                                              \
-    return data;                                                              \
-                                                                              \
-  if (NS_UNLIKELY(!aComputeData))                                             \
-    return nsnull;                                                            \
-                                                                              \
-  data = static_cast<const nsStyle##name_ *>                                  \
-           (WalkRuleTree(eStyleStruct_##name_, aContext));                    \
-                                                                              \
-  if (NS_LIKELY(data != nsnull))                                              \
-    return data;                                                              \
-                                                                              \
-  NS_NOTREACHED("could not create style struct");                             \
-  return                                                                      \
-    static_cast<const nsStyle##name_ *>(                                      \
-                   mPresContext->PresShell()->StyleSet()->                    \
-                     DefaultStyleData()->GetStyleData(eStyleStruct_##name_)); \
-}
-#include "nsStyleStructList.h"
-#undef STYLE_STRUCT
-
 void
 nsRuleNode::Mark()
 {
   for (nsRuleNode *node = this;
        node && !(node->mDependentBits & NS_RULE_NODE_GC_MARK);
        node = node->mParent)
     node->mDependentBits |= NS_RULE_NODE_GC_MARK;
 }
diff --git a/layout/style/nsRuleNode.h b/layout/style/nsRuleNode.h
--- a/layout/style/nsRuleNode.h
+++ b/layout/style/nsRuleNode.h
@@ -174,31 +174,16 @@ struct nsCachedStyleData
     } else {
       if (mInheritedData) {
         return mInheritedData->mStyleStructs[aSID];
       }
     }
     return nsnull;
   }
 
-  // Typesafe and faster versions of the above
-  #define STYLE_STRUCT_INHERITED(name_, checkdata_cb_, ctor_args_)       \
-    nsStyle##name_ * NS_FASTCALL GetStyle##name_ () {                    \
-      return mInheritedData ? static_cast<nsStyle##name_*>(              \
-        mInheritedData->mStyleStructs[eStyleStruct_##name_]) : nsnull;   \
-    }
-  #define STYLE_STRUCT_RESET(name_, checkdata_cb_, ctor_args_)           \
-    nsStyle##name_ * NS_FASTCALL GetStyle##name_ () {                    \
-      return mResetData ? static_cast<nsStyle##name_*>(                  \
-        mResetData->mStyleStructs[eStyleStruct_##name_]) : nsnull;       \
-    }
-  #include "nsStyleStructList.h"
-  #undef STYLE_STRUCT_RESET
-  #undef STYLE_STRUCT_INHERITED
-
   void Destroy(PRUint32 aBits, nsPresContext* aContext) {
     if (mResetData)
       mResetData->Destroy(aBits, aContext);
     if (mInheritedData)
       mInheritedData->Destroy(aBits, aContext);
     mResetData = nsnull;
     mInheritedData = nsnull;
   }
@@ -636,20 +621,16 @@ protected:
                             mozilla::css::Side aSide,
                             nsCSSRect& aValueRect,
                             PRBool& aCanStoreInRuleTree);
 
   inline RuleDetail CheckSpecifiedProperties(const nsStyleStructID aSID,
                                              const nsRuleData* aRuleData);
 
   const void* GetParentData(const nsStyleStructID aSID);
-  #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)  \
-    const nsStyle##name_* GetParent##name_();
-  #include "nsStyleStructList.h"
-  #undef STYLE_STRUCT
 
   already_AddRefed<nsCSSShadowArray>
               GetShadowData(const nsCSSValueList* aList,
                             nsStyleContext* aContext,
                             PRBool aIsBoxShadow,
                             PRBool& inherited);
 
 private:
@@ -681,22 +662,16 @@ public:
   nsIStyleRule* GetRule() const { return mRule; }
   // NOTE: Does not |AddRef|.
   nsPresContext* GetPresContext() const { return mPresContext; }
 
   const void* GetStyleData(nsStyleStructID aSID,
                            nsStyleContext* aContext,
                            PRBool aComputeData);
 
-  #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)                      \
-    const nsStyle##name_* GetStyle##name_(nsStyleContext* aContext,           \
-                                          PRBool aComputeData);
-  #include "nsStyleStructList.h"
-  #undef STYLE_STRUCT
-
   /*
    * Garbage collection.  Mark walks up the tree, marking any unmarked
    * ancestors until it reaches a marked one.  Sweep recursively sweeps
    * the children, destroys any that are unmarked, and clears marks,
    * returning true if the node on which it was called was destroyed.
    */
   void Mark();
   PRBool Sweep();
diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -241,16 +241,28 @@ const void* nsStyleContext::GetCachedSty
 const void* nsStyleContext::GetStyleData(nsStyleStructID aSID)
 {
   const void* cachedData = GetCachedStyleData(aSID);
   if (cachedData)
     return cachedData; // We have computed data stored on this node in the context tree.
   return mRuleNode->GetStyleData(aSID, this, PR_TRUE); // Our rule node will take care of it for us.
 }
 
+const void*
+nsStyleContext::PeekStyleData(nsStyleStructID aSID)
+{
+  const void* cachedData = GetCachedStyleData(aSID);
+  if (cachedData) {
+    // We have computed data stored on this node in the context tree.
+    return cachedData;
+  }
+  // Our rule node will take care of it for us.
+  return mRuleNode->GetStyleData(aSID, this, PR_FALSE);
+}
+
 // This is an evil evil function, since it forces you to alloc your own separate copy of
 // style data!  Do not use this function unless you absolutely have to!  You should avoid
 // this at all costs! -dwh
 void* 
 nsStyleContext::GetUniqueStyleData(const nsStyleStructID& aSID)
 {
   // If we already own the struct and no kids could depend on it, then
   // just return it.  (We leak in this case if there are kids -- and this
diff --git a/layout/style/nsStyleContext.h b/layout/style/nsStyleContext.h
--- a/layout/style/nsStyleContext.h
+++ b/layout/style/nsStyleContext.h
@@ -252,31 +252,35 @@ public:
    * Define typesafe getter functions for each style struct by
    * preprocessing the list of style structs.  These functions are the
    * preferred way to get style data.  The macro creates functions like:
    *   const nsStyleBorder* GetStyleBorder();
    *   const nsStyleColor* GetStyleColor();
    */
   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)  \
     const nsStyle##name_ * GetStyle##name_() {            \
-      return DoGetStyle##name_(PR_TRUE);                  \
+      return static_cast<const nsStyle##name_*>(          \
+        GetStyleData(eStyleStruct_##name_));              \
     }
   #include "nsStyleStructList.h"
   #undef STYLE_STRUCT
 
   /**
    * PeekStyle* is like GetStyle* but doesn't trigger style
    * computation if the data is not cached on either the style context
    * or the rule node.
    *
    * Perhaps this shouldn't be a public nsStyleContext API.
    */
+  const void* NS_FASTCALL PeekStyleData(nsStyleStructID aSID);
+
   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)  \
     const nsStyle##name_ * PeekStyle##name_() {           \
-      return DoGetStyle##name_(PR_FALSE);                 \
+      return static_cast<const nsStyle##name_*>(          \
+        PeekStyleData(eStyleStruct_##name_));             \
     }
   #include "nsStyleStructList.h"
   #undef STYLE_STRUCT
 
   void* GetUniqueStyleData(const nsStyleStructID& aSID);
 
   nsChangeHint CalcStyleDifference(nsStyleContext* aOther);
 
@@ -343,42 +347,16 @@ protected:
   void ApplyStyleFixups(nsPresContext* aPresContext);
 
   void FreeAllocations(nsPresContext* aPresContext);
 
   // Helper function that GetStyleData and GetUniqueStyleData use.  Only
   // returns the structs we cache ourselves; never consults the ruletree.
   inline const void* GetCachedStyleData(nsStyleStructID aSID);
 
-  // Helper functions for GetStyle* and PeekStyle*
-  #define STYLE_STRUCT_INHERITED(name_, checkdata_cb_, ctor_args_)      \
-    const nsStyle##name_ * DoGetStyle##name_(PRBool aComputeData) {     \
-      const nsStyle##name_ * cachedData =                               \
-        static_cast<nsStyle##name_*>(                                   \
-          mCachedInheritedData.mStyleStructs[eStyleStruct_##name_]);    \
-      if (cachedData) /* Have it cached already, yay */                 \
-        return cachedData;                                              \
-      /* Have the rulenode deal */                                      \
-      return mRuleNode->GetStyle##name_(this, aComputeData);            \
-    }
-  #define STYLE_STRUCT_RESET(name_, checkdata_cb_, ctor_args_)          \
-    const nsStyle##name_ * DoGetStyle##name_(PRBool aComputeData) {     \
-      const nsStyle##name_ * cachedData = mCachedResetData              \
-        ? static_cast<nsStyle##name_*>(                                 \
-            mCachedResetData->mStyleStructs[eStyleStruct_##name_])      \
-        : nsnull;                                                       \
-      if (cachedData) /* Have it cached already, yay */                 \
-        return cachedData;                                              \
-      /* Have the rulenode deal */                                      \
-      return mRuleNode->GetStyle##name_(this, aComputeData);            \
-    }
-  #include "nsStyleStructList.h"
-  #undef STYLE_STRUCT_RESET
-  #undef STYLE_STRUCT_INHERITED
-
   nsStyleContext* const mParent; // STRONG
 
   // Children are kept in two circularly-linked lists.  The list anchor
   // is not part of the list (null for empty), and we point to the first
   // child.
   // mEmptyChild for children whose rule node is the root rule node, and
   // mChild for other children.  The order of children is not
   // meaningful.
