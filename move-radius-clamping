From: L. David Baron <dbaron@dbaron.org>

Move clamping of border-radii that are too big from nsCSSRendering::ComputePixelRadii to nsIFrame::ComputeBorderRadius.  This also fixes a bug in nsDisplayBoxShadowOuter::ComputeVisibility.  (Bug 485501)

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -465,52 +465,25 @@ RectToGfxRect(const nsRect& rect, nscoor
                  gfxFloat(rect.y) / twipsPerPixel,
                  gfxFloat(rect.width) / twipsPerPixel,
                  gfxFloat(rect.height) / twipsPerPixel);
 }
 
 /*
  * Compute the float-pixel radii that should be used for drawing
  * this border/outline, given the various input bits.
- *
- * All corner radii are then adjusted so they do not require more
- * space than outerRect, according to the algorithm in css3-background.
  */
 static void
 ComputePixelRadii(const nscoord *aTwipsRadii,
-                  const nsRect& outerRect,
                   nscoord twipsPerPixel,
                   gfxCornerSizes *oBorderRadii)
 {
-  nscoord twipsRadii[8];
-  memcpy(twipsRadii, aTwipsRadii, sizeof twipsRadii);
-
   gfxFloat radii[8];
   NS_FOR_CSS_HALF_CORNERS(corner)
-    radii[corner] = gfxFloat(twipsRadii[corner]) / twipsPerPixel;
-
-  // css3-background specifies this algorithm for reducing
-  // corner radii when they are too big.
-  gfxFloat maxWidth = gfxFloat(outerRect.width) / twipsPerPixel;
-  gfxFloat maxHeight = gfxFloat(outerRect.height) / twipsPerPixel;
-  gfxFloat f = 1.0f;
-  NS_FOR_CSS_SIDES(side) {
-    PRUint32 hc1 = NS_SIDE_TO_HALF_CORNER(side, PR_FALSE, PR_TRUE);
-    PRUint32 hc2 = NS_SIDE_TO_HALF_CORNER(side, PR_TRUE, PR_TRUE);
-    gfxFloat length = NS_SIDE_IS_VERTICAL(side) ? maxHeight : maxWidth;
-    gfxFloat sum = radii[hc1] + radii[hc2];
-    // avoid floating point division in the normal case
-    if (length < sum)
-      f = NS_MIN(f, length/sum);
-  }
-  if (f < 1.0) {
-    NS_FOR_CSS_HALF_CORNERS(corner) {
-      radii[corner] *= f;
-    }
-  }
+    radii[corner] = gfxFloat(aTwipsRadii[corner]) / twipsPerPixel;
 
   (*oBorderRadii)[C_TL] = gfxSize(radii[NS_CORNER_TOP_LEFT_X],
                                   radii[NS_CORNER_TOP_LEFT_Y]);
   (*oBorderRadii)[C_TR] = gfxSize(radii[NS_CORNER_TOP_RIGHT_X],
                                   radii[NS_CORNER_TOP_RIGHT_Y]);
   (*oBorderRadii)[C_BR] = gfxSize(radii[NS_CORNER_BOTTOM_RIGHT_X],
                                   radii[NS_CORNER_BOTTOM_RIGHT_Y]);
   (*oBorderRadii)[C_BL] = gfxSize(radii[NS_CORNER_BOTTOM_LEFT_X],
@@ -594,17 +567,18 @@ nsCSSRendering::PaintBorderWithStyleBord
   border = aStyleBorder.GetComputedBorder();
   if ((0 == border.left) && (0 == border.right) &&
       (0 == border.top) && (0 == border.bottom)) {
     // Empty border area
     return;
   }
 
   nsIFrame::ComputeBorderRadius(aStyleBorder.mBorderRadius,
-                                aForFrame->GetSize(), aSkipSides, twipsRadii);
+                                aForFrame->GetSize(), aBorderArea,
+                                aSkipSides, twipsRadii);
 
   // Turn off rendering for all of the zero sized sides
   if (aSkipSides & SIDE_BIT_TOP) border.top = 0;
   if (aSkipSides & SIDE_BIT_RIGHT) border.right = 0;
   if (aSkipSides & SIDE_BIT_BOTTOM) border.bottom = 0;
   if (aSkipSides & SIDE_BIT_LEFT) border.left = 0;
 
   // get the inside and outside parts of the border
@@ -623,17 +597,17 @@ nsCSSRendering::PaintBorderWithStyleBord
   // convert the border widths
   gfxFloat borderWidths[4] = { gfxFloat(border.top / twipsPerPixel),
                                gfxFloat(border.right / twipsPerPixel),
                                gfxFloat(border.bottom / twipsPerPixel),
                                gfxFloat(border.left / twipsPerPixel) };
 
   // convert the radii
   gfxCornerSizes borderRadii;
-  ComputePixelRadii(twipsRadii, outerRect, twipsPerPixel, &borderRadii);
+  ComputePixelRadii(twipsRadii, twipsPerPixel, &borderRadii);
 
   PRUint8 borderStyles[4];
   nscolor borderColors[4];
   nsBorderColors *compositeColors[4];
 
   // pull out styles, colors, composite colors
   NS_FOR_CSS_SIDES (i) {
     PRBool foreground;
@@ -712,20 +686,16 @@ nsCSSRendering::PaintOutline(nsPresConte
   }
 
   nsIFrame* bgFrame = nsCSSRendering::FindNonTransparentBackgroundFrame
     (aForFrame, PR_FALSE);
   nsStyleContext* bgContext = bgFrame->GetStyleContext();
   nscolor bgColor =
     bgContext->GetVisitedDependentColor(eCSSProperty_background_color);
 
-  // get the radius for our outline
-  nsIFrame::ComputeBorderRadius(ourOutline->mOutlineRadius, aBorderArea.Size(),
-                                0, twipsRadii);
-
   // When the outline property is set on :-moz-anonymous-block or
   // :-moz-anonyomus-positioned-block pseudo-elements, it inherited that
   // outline from the inline that was broken because it contained a
   // block.  In that case, we don't want a really wide outline if the
   // block inside the inline is narrow, so union the actual contents of
   // the anonymous blocks.
   nsIFrame *frameForArea = aForFrame;
   do {
@@ -761,26 +731,30 @@ nsCSSRendering::PaintOutline(nsPresConte
   // encroach into the content area.  A safer calculation would be to
   // shorten insideRect by the radius one each side before performing this test.
   if (innerRect.Contains(aDirtyRect))
     return;
 
   nsRect outerRect = innerRect;
   outerRect.Inflate(width, width);
 
+  // get the radius for our outline
+  nsIFrame::ComputeBorderRadius(ourOutline->mOutlineRadius,
+                                aBorderArea.Size(), outerRect, 0, twipsRadii);
+
   // Get our conversion values
   nscoord twipsPerPixel = aPresContext->DevPixelsToAppUnits(1);
 
   // get the outer rectangles
   gfxRect oRect(RectToGfxRect(outerRect, twipsPerPixel));
 
   // convert the radii
   nsMargin outlineMargin(width, width, width, width);
   gfxCornerSizes outlineRadii;
-  ComputePixelRadii(twipsRadii, outerRect, twipsPerPixel, &outlineRadii);
+  ComputePixelRadii(twipsRadii, twipsPerPixel, &outlineRadii);
 
   PRUint8 outlineStyle = ourOutline->GetOutlineStyle();
   PRUint8 outlineStyles[4] = { outlineStyle,
                                outlineStyle,
                                outlineStyle,
                                outlineStyle };
 
   // This handles treating the initial color as 'currentColor'; if we
@@ -828,17 +802,17 @@ nsCSSRendering::PaintFocus(nsPresContext
   nscoord oneCSSPixel = nsPresContext::CSSPixelsToAppUnits(1);
   nscoord oneDevPixel = aPresContext->DevPixelsToAppUnits(1);
 
   gfxRect focusRect(RectToGfxRect(aFocusRect, oneDevPixel));
 
   gfxCornerSizes focusRadii;
   {
     nscoord twipsRadii[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
-    ComputePixelRadii(twipsRadii, aFocusRect, oneDevPixel, &focusRadii);
+    ComputePixelRadii(twipsRadii, oneDevPixel, &focusRadii);
   }
   gfxFloat focusWidths[4] = { gfxFloat(oneCSSPixel / oneDevPixel),
                               gfxFloat(oneCSSPixel / oneDevPixel),
                               gfxFloat(oneCSSPixel / oneDevPixel),
                               gfxFloat(oneCSSPixel / oneDevPixel) };
 
   PRUint8 focusStyles[4] = { NS_STYLE_BORDER_STYLE_DOTTED,
                              NS_STYLE_BORDER_STYLE_DOTTED,
@@ -1130,20 +1104,20 @@ nsCSSRendering::PaintBoxShadowOuter(nsPr
     hasBorderRadius = PR_FALSE;
     // For opaque (rectangular) theme widgets we can take the generic
     // border-box path with border-radius disabled.
     nativeTheme = transparency != nsITheme::eOpaque;
   } else {
     nativeTheme = PR_FALSE;
     nscoord twipsRadii[8];
     hasBorderRadius = nsIFrame::ComputeBorderRadius(styleBorder->mBorderRadius,
-                        aFrameArea.Size(), aForFrame->GetSkipSides(),
-                        twipsRadii);
+                        aFrameArea.Size(), aFrameArea,
+                        aForFrame->GetSkipSides(), twipsRadii);
     if (hasBorderRadius) {
-      ComputePixelRadii(twipsRadii, aFrameArea, twipsPerPixel, &borderRadii);
+      ComputePixelRadii(twipsRadii, twipsPerPixel, &borderRadii);
     }
   }
 
   nsRect frameRect =
     nativeTheme ? aForFrame->GetOverflowRectRelativeToSelf() + aFrameArea.TopLeft() : aFrameArea;
   gfxRect frameGfxRect = RectToGfxRect(frameRect, twipsPerPixel);
   frameGfxRect.Round();
 
@@ -1310,29 +1284,30 @@ nsCSSRendering::PaintBoxShadowInner(nsPr
     // box shadows since chrome can be aware of the platform theme.
     return;
   }
 
   // Get any border radius, since box-shadow must also have rounded corners if the frame does
   nscoord twipsRadii[8];
   PRBool hasBorderRadius = nsIFrame::ComputeBorderRadius(
                              styleBorder->mBorderRadius, aFrameArea.Size(),
-                             aForFrame->GetSkipSides(), twipsRadii);
+                             aFrameArea.Size(), aForFrame->GetSkipSides(),
+                             twipsRadii);
   nscoord twipsPerPixel = aPresContext->DevPixelsToAppUnits(1);
 
   nsRect paddingRect = aFrameArea;
   nsMargin border = aForFrame->GetUsedBorder();
   aForFrame->ApplySkipSides(border);
   paddingRect.Deflate(border);
 
   gfxCornerSizes innerRadii;
   if (hasBorderRadius) {
     gfxCornerSizes borderRadii;
 
-    ComputePixelRadii(twipsRadii, aFrameArea, twipsPerPixel, &borderRadii);
+    ComputePixelRadii(twipsRadii, twipsPerPixel, &borderRadii);
     gfxFloat borderSizes[4] = {
       gfxFloat(border.top / twipsPerPixel),
       gfxFloat(border.right / twipsPerPixel),
       gfxFloat(border.bottom / twipsPerPixel),
       gfxFloat(border.left / twipsPerPixel)
     };
     nsCSSBorderRenderer::ComputeInnerRadii(borderRadii, borderSizes,
                                            &innerRadii);
@@ -2200,20 +2175,20 @@ nsCSSRendering::PaintBackgroundWithSC(ns
   nscoord appUnitsPerPixel = aPresContext->AppUnitsPerDevPixel();
 
   // Same coordinate space as aBorderArea & aBGClipRect
   gfxCornerSizes bgRadii;
   PRBool haveRoundedCorners;
   {
     nscoord radii[8];
     haveRoundedCorners = nsIFrame::ComputeBorderRadius(aBorder.mBorderRadius,
-                           aForFrame->GetSize(), aForFrame->GetSkipSides(),
-                           radii);
+                           aForFrame->GetSize(), aBorderArea,
+                           aForFrame->GetSkipSides(), radii);
     if (haveRoundedCorners)
-      ComputePixelRadii(radii, aBorderArea, appUnitsPerPixel, &bgRadii);
+      ComputePixelRadii(radii, appUnitsPerPixel, &bgRadii);
   }
 
   // The 'bgClipArea' (used only by the image tiling logic, far below)
   // is the caller-provided aBGClipRect if any, or else the area
   // determined by the value of 'background-clip' in
   // SetupCurrentBackgroundClip.  (Arguably it should be the
   // intersection, but that breaks the table painter -- in particular,
   // taking the intersection breaks reftests/bugs/403249-1[ab].)
@@ -3890,24 +3865,25 @@ nsAutoClipToBorderRadius::nsAutoClipToBo
                             nsIRenderingContext &aRenderingContext,
                             nsIFrame *aFrame, nsPoint aOffsetToFrame)
 {
   // This has some code in common with SetupBackgroundClip and
   // PaintBackgroundWithSC, but it looks hard to refactor, and this
   // isn't too bad.
   const nsStyleBorder *border = aFrame->GetStyleBorder();
   nscoord radii[8];
+  nsSize frameSize = aFrame->GetSize();
   PRBool haveRoundedCorners = nsIFrame::ComputeBorderRadius(
-                                border->mBorderRadius, aFrame->GetSize(),
+                                border->mBorderRadius, frameSize, frameSize,
                                 aFrame->GetSkipSides(), radii);
   if (haveRoundedCorners) {
     PRInt32 appUnitsPerPixel = aFrame->PresContext()->AppUnitsPerDevPixel();
 
     gfxCornerSizes pixelRadii;
-    ComputePixelRadii(radii, aFrame->GetRect(), appUnitsPerPixel, &pixelRadii);
+    ComputePixelRadii(radii, appUnitsPerPixel, &pixelRadii);
 
     nsMargin bp = aFrame->GetUsedBorderAndPadding();
     aFrame->ApplySkipSides(bp);
     gfxFloat bpSizes[4] = {
       gfxFloat(bp.top / appUnitsPerPixel),
       gfxFloat(bp.right / appUnitsPerPixel),
       gfxFloat(bp.bottom / appUnitsPerPixel),
       gfxFloat(bp.left / appUnitsPerPixel)
diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -998,18 +998,18 @@ nsDisplayBoxShadowOuter::ComputeVisibili
   if (!frameRect.Contains(visibleBounds))
     return PR_TRUE;
 
   // the visible region is entirely inside the border-rect, and box shadows
   // never render within the border-rect (unless there's a border radius).
   nscoord twipsRadii[8];
   PRBool hasBorderRadii = nsIFrame::ComputeBorderRadius(
                             mFrame->GetStyleBorder()->mBorderRadius,
-                            frameRect.Size(), mFrame->GetSkipSides(),
-                            twipsRadii);
+                            frameRect.Size(), frameRect.Size(),
+                            mFrame->GetSkipSides(), twipsRadii);
   if (!hasBorderRadii)
     return PR_FALSE;
 
   return !RoundedRectContainsRect(frameRect, twipsRadii, visibleBounds);
 }
 
 void
 nsDisplayBoxShadowInner::Paint(nsDisplayListBuilder* aBuilder,
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -734,16 +734,17 @@ nsIFrame::GetContentRect() const
   nsRect r(mRect);
   r.Deflate(bp);
   return r;
 }
 
 PRBool
 nsIFrame::ComputeBorderRadius(const nsStyleCorners& aBorderRadius,
                               const nsSize& aFrameSize,
+                              const nsSize& aBorderArea,
                               PRIntn aSkipSides,
                               nscoord aRadii[8])
 {
   // Percentages are relative to whichever side they're on.
   NS_FOR_CSS_HALF_CORNERS(i) {
     const nsStyleCoord c = aBorderRadius.Get(i);
     nscoord axis =
       NS_HALF_CORNER_IS_X(i) ? aFrameSize.width : aFrameSize.height;
@@ -787,25 +788,40 @@ nsIFrame::ComputeBorderRadius(const nsSt
 
   if (aSkipSides & (1 << NS_SIDE_LEFT)) {
     aRadii[NS_CORNER_BOTTOM_LEFT_X] = 0;
     aRadii[NS_CORNER_BOTTOM_LEFT_Y] = 0;
     aRadii[NS_CORNER_TOP_LEFT_X] = 0;
     aRadii[NS_CORNER_TOP_LEFT_Y] = 0;
   }
 
-  PRBool result = PR_FALSE;
-  NS_FOR_CSS_HALF_CORNERS(i) {
-    if (aRadii[i]) {
-      result = PR_TRUE;
-      break;
-    }
-  }
-
-  return result;
+  // css3-background specifies this algorithm for reducing
+  // corner radii when they are too big.
+  PRBool haveRadius = PR_FALSE;
+  double ratio = 1.0f;
+  NS_FOR_CSS_SIDES(side) {
+    PRUint32 hc1 = NS_SIDE_TO_HALF_CORNER(side, PR_FALSE, PR_TRUE);
+    PRUint32 hc2 = NS_SIDE_TO_HALF_CORNER(side, PR_TRUE, PR_TRUE);
+    nscoord length =
+      NS_SIDE_IS_VERTICAL(side) ? aBorderArea.height : aBorderArea.width;
+    nscoord sum = aRadii[hc1] + aRadii[hc2];
+    if (sum)
+      haveRadius = PR_TRUE;
+
+    // avoid floating point division in the normal case
+    if (length < sum)
+      ratio = NS_MIN(ratio, length/sum);
+  }
+  if (ratio < 1.0) {
+    NS_FOR_CSS_HALF_CORNERS(corner) {
+      aRadii[corner] *= ratio;
+    }
+  }
+
+  return haveRadius;
 }
 
 nsStyleContext*
 nsFrame::GetAdditionalStyleContext(PRInt32 aIndex) const
 {
   NS_PRECONDITION(aIndex >= 0, "invalid index number");
   return nsnull;
 }
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -915,19 +915,30 @@ public:
   nsRect GetPaddingRect() const;
   nsRect GetContentRect() const;
 
   /**
    * Get the size, in app units, of the border radii. It returns FALSE iff all
    * returned radii == 0 (so no border radii), TRUE otherwise.
    * For the aRadii indexes, use the NS_CORNER_* constants in nsStyleConsts.h
    * If a side is skipped via aSkipSides, its corners are forced to 0.
+   *
+   * All corner radii are then adjusted so they do not require more
+   * space than aBorderArea, according to the algorithm in css3-background.
+   *
+   * aFrameSize is used as the basis for percentage widths and heights.
+   * aBorderArea is used for the adjustment of radii that might be too
+   * large.
+   * FIXME: In the long run, we can probably get away with only one of
+   * these, especially if we change the way we handle outline-radius (by
+   * removing it and inflating the border radius)
    */
   static PRBool ComputeBorderRadius(const nsStyleCorners& aBorderRadius,
                                     const nsSize& aFrameSize,
+                                    const nsSize& aBorderArea,
                                     PRIntn aSkipSides,
                                     nscoord aRadii[8]);
 
   /**
    * Get the position of the frame's baseline, relative to the top of
    * the frame (its top border edge).  Only valid when Reflow is not
    * needed and when the frame returned nsHTMLReflowMetrics::
    * ASK_FOR_BASELINE as ascent in its reflow metrics.
