From: L. David Baron <dbaron@dbaron.org>

Split nsStyleSet::ResolveStyleForRules into two different APIs for the two different types of uses.  (Bug 147777)

diff --git a/content/canvas/src/nsCanvasRenderingContext2D.cpp b/content/canvas/src/nsCanvasRenderingContext2D.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp
+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp
@@ -2023,29 +2023,24 @@ nsCanvasRenderingContext2D::SetFont(cons
         nsCOMPtr<nsICSSStyleRule> parentRule;
         rv = CreateFontStyleRule(NS_LITERAL_STRING("10px sans-serif"),
                                  document,
                                  getter_AddRefs(parentRule));
         if (NS_FAILED(rv))
             return rv;
         nsCOMArray<nsIStyleRule> parentRules;
         parentRules.AppendObject(parentRule);
-        parentContext =
-            styleSet->ResolveStyleForRules(nsnull, nsnull,
-                                           nsCSSPseudoElements::ePseudo_NotPseudoElement,
-                                           nsnull, parentRules);
+        parentContext = styleSet->ResolveStyleForRules(nsnull, parentRules);
     }
 
     if (!parentContext)
         return NS_ERROR_FAILURE;
 
     nsRefPtr<nsStyleContext> sc =
-        styleSet->ResolveStyleForRules(parentContext, nsnull,
-                                       nsCSSPseudoElements::ePseudo_NotPseudoElement,
-                                       nsnull, rules);
+        styleSet->ResolveStyleForRules(parentContext, rules);
     if (!sc)
         return NS_ERROR_FAILURE;
     const nsStyleFont* fontStyle = sc->GetStyleFont();
 
     NS_ASSERTION(fontStyle, "Could not obtain font style");
 
     nsIAtom* language = sc->GetStyleVisibility()->mLanguage;
     if (!language) {
diff --git a/layout/base/nsFrameManager.cpp b/layout/base/nsFrameManager.cpp
--- a/layout/base/nsFrameManager.cpp
+++ b/layout/base/nsFrameManager.cpp
@@ -742,22 +742,18 @@ TryStartingTransition(nsPresContext *aPr
   // currently starting with their start value so we don't start
   // them again for descendants that inherit that value.
   nsCOMPtr<nsIStyleRule> coverRule = 
     aPresContext->TransitionManager()->StyleContextChanged(
       aContent, aOldStyleContext, *aNewStyleContext);
   if (coverRule) {
     nsCOMArray<nsIStyleRule> rules;
     rules.AppendObject(coverRule);
-    *aNewStyleContext = aPresContext->StyleSet()->ResolveStyleForRules(
-                     (*aNewStyleContext)->GetParent(),
-                     (*aNewStyleContext)->GetPseudo(),
-                     (*aNewStyleContext)->GetPseudoType(),
-                     (*aNewStyleContext)->GetRuleNode(),
-                     rules);
+    *aNewStyleContext = aPresContext->StyleSet()->
+                          ResolveStyleByAddingRules(*aNewStyleContext, rules);
   }
 }
 
 nsresult
 nsFrameManager::ReParentStyleContext(nsIFrame* aFrame)
 {
   if (nsGkAtoms::placeholderFrame == aFrame->GetType()) {
     // Also reparent the out-of-flow
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -1027,21 +1027,17 @@ StyleWithDeclarationAdded(nsCSSProperty 
   }
 
   styleRule->RuleMatched();
 
   // Create a temporary nsStyleContext for the style rule
   nsCOMArray<nsIStyleRule> ruleArray;
   ruleArray.AppendObject(styleRule);
   nsStyleSet* styleSet = styleContext->PresContext()->StyleSet();
-  return styleSet->ResolveStyleForRules(styleContext->GetParent(),
-                                        styleContext->GetPseudo(),
-                                        styleContext->GetPseudoType(),
-                                        styleContext->GetRuleNode(),
-                                        ruleArray);
+  return styleSet->ResolveStyleByAddingRules(styleContext, ruleArray);
 }
 
 PRBool
 nsStyleAnimation::ComputeValue(nsCSSProperty aProperty,
                                nsIContent* aTargetElement,
                                const nsAString& aSpecifiedValue,
                                Value& aComputedValue)
 {
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -758,38 +758,58 @@ nsStyleSet::ResolveStyleFor(nsIContent* 
                         nsCSSPseudoElements::ePseudo_NotPseudoElement).get();
   }
 
   return result;
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForRules(nsStyleContext* aParentContext,
-                                 nsIAtom* aPseudoTag,
-                                 nsCSSPseudoElements::Type aPseudoType,
-                                 nsRuleNode *aRuleNode,
                                  const nsCOMArray<nsIStyleRule> &aRules)
 {
   NS_ENSURE_FALSE(mInShutdown, nsnull);
   nsStyleContext* result = nsnull;
   nsPresContext *presContext = PresContext();
 
   if (presContext) {
     nsRuleWalker ruleWalker(mRuleTree);
-    if (aRuleNode)
-      ruleWalker.SetCurrentNode(aRuleNode);
     // FIXME: Perhaps this should be passed in, but it probably doesn't
     // matter.
     ruleWalker.SetLevel(eDocSheet, PR_FALSE, PR_FALSE);
     for (PRInt32 i = 0; i < aRules.Count(); i++) {
       ruleWalker.Forward(aRules.ObjectAt(i));
     }
     result = GetContext(presContext, aParentContext,
-                        ruleWalker.CurrentNode(), aPseudoTag,
-                        aPseudoType).get();
+                        ruleWalker.CurrentNode(), nsnull,
+                        nsCSSPseudoElements::ePseudo_NotPseudoElement).get();
+  }
+  return result;
+}
+
+already_AddRefed<nsStyleContext>
+nsStyleSet::ResolveStyleByAddingRules(nsStyleContext* aBaseContext,
+                                      const nsCOMArray<nsIStyleRule> &aRules)
+{
+  NS_ENSURE_FALSE(mInShutdown, nsnull);
+  nsStyleContext* result = nsnull;
+  nsPresContext *presContext = PresContext();
+
+  if (presContext) {
+    nsRuleWalker ruleWalker(mRuleTree);
+    ruleWalker.SetCurrentNode(aBaseContext->GetRuleNode());
+    // FIXME: Perhaps this should be passed in, but it probably doesn't
+    // matter.
+    ruleWalker.SetLevel(eDocSheet, PR_FALSE, PR_FALSE);
+    for (PRInt32 i = 0; i < aRules.Count(); i++) {
+      ruleWalker.Forward(aRules.ObjectAt(i));
+    }
+    result = GetContext(presContext, aBaseContext->GetParent(),
+                        ruleWalker.CurrentNode(),
+                        aBaseContext->GetPseudo(),
+                        aBaseContext->GetPseudoType()).get();
   }
   return result;
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleForNonElement(nsStyleContext* aParentContext)
 {
   nsStyleContext* result = nsnull;
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -94,28 +94,29 @@ class nsStyleSet
 
   // enable / disable the Quirk style sheet
   void EnableQuirkStyleSheet(PRBool aEnable);
 
   // get a style context for a non-pseudo frame.
   already_AddRefed<nsStyleContext>
   ResolveStyleFor(nsIContent* aContent, nsStyleContext* aParentContext);
 
-  // Get a style context (with the given parent and pseudo-tag/type) for a
-  // sequence of style rules consisting of the concatenation of:
-  //  (1) the rule sequence represented by aRuleNode (which is the empty
-  //      sequence if aRuleNode is null or the root of the rule tree), and
-  //  (2) the rules in the |aRules| array.
+  // Get a style context (with the given parent) for the
+  // sequence of style rules in the |aRules| array.
   already_AddRefed<nsStyleContext>
   ResolveStyleForRules(nsStyleContext* aParentContext,
-                       nsIAtom* aPseudoTag,
-                       nsCSSPseudoElements::Type aPseudoType,
-                       nsRuleNode *aRuleNode,
                        const nsCOMArray<nsIStyleRule> &aRules);
 
+  // Get a style context that represents aBaseContext, but as though
+  // it additionally matched the rules in the aRules array (in that
+  // order, as more specific than any other rules).
+  already_AddRefed<nsStyleContext>
+  ResolveStyleByAddingRules(nsStyleContext* aBaseContext,
+                            const nsCOMArray<nsIStyleRule> &aRules);
+
   // Get a style context for a non-element (which no rules will match),
   // such as text nodes, placeholder frames, and the nsFirstLetterFrame
   // for everything after the first letter.
   //
   // Perhaps this should go away and we shouldn't even create style
   // contexts for such content nodes.  However, not doing any rule
   // matching for them is a first step.
   already_AddRefed<nsStyleContext>
