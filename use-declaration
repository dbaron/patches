From: L. David Baron <dbaron@dbaron.org>

Bug 978833 patch 8 - Use the css::Declaration instead of the css::StyleRule as the matching rule.

FIXME: Confirm that it's this patch that fixes the mochitest.

diff --git a/dom/canvas/CanvasRenderingContext2D.cpp b/dom/canvas/CanvasRenderingContext2D.cpp
--- a/dom/canvas/CanvasRenderingContext2D.cpp
+++ b/dom/canvas/CanvasRenderingContext2D.cpp
@@ -2130,17 +2130,17 @@ CanvasRenderingContext2D::SetShadowColor
 
   CurrentState().shadowColor = color;
 }
 
 //
 // filters
 //
 
-static already_AddRefed<StyleRule>
+static already_AddRefed<Declaration>
 CreateStyleRule(nsINode* aNode,
   const nsCSSProperty aProp1, const nsAString& aValue1, bool* aChanged1,
   const nsCSSProperty aProp2, const nsAString& aValue2, bool* aChanged2,
   ErrorResult& error)
 {
   RefPtr<StyleRule> rule;
 
   nsIPrincipal* principal = aNode->NodePrincipal();
@@ -2166,20 +2166,21 @@ CreateStyleRule(nsINode* aNode,
 
   if (aProp2 != eCSSProperty_UNKNOWN) {
     parser.ParseProperty(aProp2, aValue2, docURL, baseURL, principal,
                          rule->GetDeclaration(), aChanged2, false);
   }
 
   rule->RuleMatched();
 
-  return rule.forget();
+  RefPtr<Declaration> declaration = rule->GetDeclaration();
+  return declaration.forget();
 }
 
-static already_AddRefed<StyleRule>
+static already_AddRefed<Declaration>
 CreateFontStyleRule(const nsAString& aFont,
                     nsINode* aNode,
                     bool* aOutFontChanged,
                     ErrorResult& error)
 {
   bool lineHeightChanged;
   return CreateStyleRule(aNode,
     eCSSProperty_font, aFont, aOutFontChanged,
@@ -2200,17 +2201,17 @@ GetFontParentStyleContext(Element* aElem
       error.Throw(NS_ERROR_FAILURE);
       return nullptr;
     }
     return result.forget();
   }
 
   // otherwise inherit from default (10px sans-serif)
   bool changed;
-  RefPtr<css::StyleRule> parentRule =
+  RefPtr<css::Declaration> parentRule =
     CreateFontStyleRule(NS_LITERAL_STRING("10px sans-serif"),
                         presShell->GetDocument(), &changed, error);
 
   if (error.Failed()) {
     return nullptr;
   }
 
   nsTArray<nsCOMPtr<nsIStyleRule>> parentRules;
@@ -2221,36 +2222,35 @@ GetFontParentStyleContext(Element* aElem
   if (!result) {
     error.Throw(NS_ERROR_FAILURE);
     return nullptr;
   }
   return result.forget();
 }
 
 static bool
-PropertyIsInheritOrInitial(StyleRule* aRule, const nsCSSProperty aProperty)
-{
-  css::Declaration* declaration = aRule->GetDeclaration();
+PropertyIsInheritOrInitial(Declaration* aDeclaration, const nsCSSProperty aProperty)
+{
   // We know the declaration is not !important, so we can use
   // GetNormalBlock().
   const nsCSSValue* filterVal =
-    declaration->GetNormalBlock()->ValueFor(aProperty);
+    aDeclaration->GetNormalBlock()->ValueFor(aProperty);
   return (!filterVal || (filterVal->GetUnit() == eCSSUnit_Unset ||
                          filterVal->GetUnit() == eCSSUnit_Inherit ||
                          filterVal->GetUnit() == eCSSUnit_Initial));
 }
 
 static already_AddRefed<nsStyleContext>
 GetFontStyleContext(Element* aElement, const nsAString& aFont,
                     nsIPresShell* presShell,
                     nsAString& aOutUsedFont,
                     ErrorResult& error)
 {
   bool fontParsedSuccessfully = false;
-  RefPtr<css::StyleRule> rule =
+  RefPtr<css::Declaration> rule =
     CreateFontStyleRule(aFont, presShell->GetDocument(),
                         &fontParsedSuccessfully, error);
 
   if (error.Failed()) {
     return nullptr;
   }
 
   if (!fontParsedSuccessfully) {
@@ -2290,22 +2290,22 @@ GetFontStyleContext(Element* aElement, c
   nsStyleSet* styleSet = presShell->StyleSet();
   RefPtr<nsStyleContext> sc =
     styleSet->ResolveStyleForRules(parentContext, rules);
 
   // The font getter is required to be reserialized based on what we
   // parsed (including having line-height removed).  (Older drafts of
   // the spec required font sizes be converted to pixels, but that no
   // longer seems to be required.)
-  rule->GetDeclaration()->GetValue(eCSSProperty_font, aOutUsedFont);
+  rule->GetValue(eCSSProperty_font, aOutUsedFont);
 
   return sc.forget();
 }
 
-static already_AddRefed<StyleRule>
+static already_AddRefed<Declaration>
 CreateFilterStyleRule(const nsAString& aFilter,
                       nsINode* aNode,
                       bool* aOutFilterChanged,
                       ErrorResult& error)
 {
   bool dummy;
   return CreateStyleRule(aNode,
     eCSSProperty_filter, aFilter, aOutFilterChanged,
@@ -2316,17 +2316,17 @@ CreateFilterStyleRule(const nsAString& a
 static already_AddRefed<nsStyleContext>
 ResolveStyleForFilterRule(const nsAString& aFilterString,
                           nsIPresShell* aPresShell,
                           nsStyleContext* aParentContext,
                           ErrorResult& error)
 {
   nsIDocument* document = aPresShell->GetDocument();
   bool filterChanged = false;
-  RefPtr<css::StyleRule> rule =
+  RefPtr<css::Declaration> rule =
     CreateFilterStyleRule(aFilterString, document, &filterChanged, error);
 
   if (error.Failed()) {
     return nullptr;
   }
 
   if (!filterChanged) {
     // Refuse to accept the filter, but do not throw an error.
diff --git a/dom/svg/nsSVGElement.cpp b/dom/svg/nsSVGElement.cpp
--- a/dom/svg/nsSVGElement.cpp
+++ b/dom/svg/nsSVGElement.cpp
@@ -899,17 +899,17 @@ nsSVGElement::WalkContentStyleRules(nsRu
 #ifdef DEBUG
 //  printf("nsSVGElement(%p)::WalkContentStyleRules()\n", this);
 #endif
   if (!mContentStyleRule)
     UpdateContentStyleRule();
 
   if (mContentStyleRule) {
     mContentStyleRule->RuleMatched();
-    aRuleWalker->Forward(mContentStyleRule);
+    aRuleWalker->Forward(mContentStyleRule->GetDeclaration());
   }
 
   return NS_OK;
 }
 
 void
 nsSVGElement::WalkAnimatedContentStyleRules(nsRuleWalker* aRuleWalker)
 {
@@ -923,17 +923,17 @@ nsSVGElement::WalkAnimatedContentStyleRu
     // update/walk the animated content style rule.
     css::StyleRule* animContentStyleRule = GetAnimatedContentStyleRule();
     if (!animContentStyleRule) {
       UpdateAnimatedContentStyleRule();
       animContentStyleRule = GetAnimatedContentStyleRule();
     }
     if (animContentStyleRule) {
       animContentStyleRule->RuleMatched();
-      aRuleWalker->Forward(animContentStyleRule);
+      aRuleWalker->Forward(animContentStyleRule->GetDeclaration());
     }
   }
 }
 
 NS_IMETHODIMP_(bool)
 nsSVGElement::IsAttributeMapped(const nsIAtom* name) const
 {
   if (name == nsGkAtoms::lang) {
diff --git a/layout/style/StyleAnimationValue.cpp b/layout/style/StyleAnimationValue.cpp
--- a/layout/style/StyleAnimationValue.cpp
+++ b/layout/style/StyleAnimationValue.cpp
@@ -2656,17 +2656,17 @@ StyleAnimationValue::ComputeValues(
   RefPtr<nsStyleContext> tmpStyleContext;
   if (aIsContextSensitive) {
     MOZ_ASSERT(!nsCSSProps::IsShorthand(aProperty),
                "to correctly set aIsContextSensitive for shorthand properties, "
                "this code must be adjusted");
 
     nsCOMArray<nsIStyleRule> ruleArray;
     ruleArray.AppendObject(styleSet->InitialStyleRule());
-    ruleArray.AppendObject(aStyleRule);
+    ruleArray.AppendObject(aStyleRule->GetDeclaration());
     aStyleRule->RuleMatched();
     tmpStyleContext =
       styleSet->ResolveStyleByAddingRules(styleContext, ruleArray);
     if (!tmpStyleContext) {
       return false;
     }
 
     // Force walk of rule tree
@@ -2683,17 +2683,17 @@ StyleAnimationValue::ComputeValues(
   // If we're not concerned whether the property is context sensitive then just
   // add the rule to a new temporary style context alongside the target
   // element's style context.
   // Also, if we previously discovered that this property IS context-sensitive
   // then we need to throw the temporary style context out since the property's
   // value may have been biased by the 'initial' values supplied.
   if (!aIsContextSensitive || *aIsContextSensitive) {
     nsCOMArray<nsIStyleRule> ruleArray;
-    ruleArray.AppendObject(aStyleRule);
+    ruleArray.AppendObject(aStyleRule->GetDeclaration());
     aStyleRule->RuleMatched();
     tmpStyleContext =
       styleSet->ResolveStyleByAddingRules(styleContext, ruleArray);
     if (!tmpStyleContext) {
       return false;
     }
   }
 
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -627,17 +627,17 @@ ResolvedStyleCache::Get(nsPresContext *a
   if (!result) {
     Declaration *declaration = aKeyframe->Declaration();
     declaration->SetImmutable();
     // The spec says that !important declarations should just be ignored
     MOZ_ASSERT(!declaration->HasImportantData(),
                "Keyframe rule has !important data");
 
     nsCOMArray<nsIStyleRule> rules;
-    rules.AppendObject(aKeyframe);
+    rules.AppendObject(declaration);
     RefPtr<nsStyleContext> resultStrong = aPresContext->StyleSet()->
       ResolveStyleByAddingRules(aParentStyleContext, rules);
     mCache.Put(aKeyframe, resultStrong);
     result = resultStrong;
   }
   return result;
 }
 
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -2615,17 +2615,17 @@ void ContentEnumFunc(const RuleValue& va
     if (!next ||
         SelectorMatchesTree(data->mElement, next,
                             data->mTreeMatchContext,
                             nodeContext.mIsRelevantLink ?
                               SelectorMatchesTreeFlags(0) :
                               eLookForRelevantLink)) {
       css::StyleRule *rule = value.mRule;
       rule->RuleMatched();
-      data->mRuleWalker->Forward(rule);
+      data->mRuleWalker->Forward(rule->GetDeclaration());
       // nsStyleSet will deal with the !important rule
     }
   }
 }
 
 /* virtual */ void
 nsCSSRuleProcessor::RulesMatching(ElementRuleProcessorData *aData)
 {
@@ -2661,17 +2661,17 @@ nsCSSRuleProcessor::RulesMatching(AnonBo
   if (cascade && cascade->mAnonBoxRules.EntryCount()) {
     auto entry = static_cast<RuleHashTagTableEntry*>
                             (cascade->mAnonBoxRules.Search(aData->mPseudoTag));
     if (entry) {
       nsTArray<RuleValue>& rules = entry->mRules;
       for (RuleValue *value = rules.Elements(), *end = value + rules.Length();
            value != end; ++value) {
         value->mRule->RuleMatched();
-        aData->mRuleWalker->Forward(value->mRule);
+        aData->mRuleWalker->Forward(value->mRule->GetDeclaration());
       }
     }
   }
 }
 
 #ifdef MOZ_XUL
 /* virtual */ void
 nsCSSRuleProcessor::RulesMatching(XULTreeRuleProcessorData* aData)
diff --git a/layout/style/nsHTMLCSSStyleSheet.cpp b/layout/style/nsHTMLCSSStyleSheet.cpp
--- a/layout/style/nsHTMLCSSStyleSheet.cpp
+++ b/layout/style/nsHTMLCSSStyleSheet.cpp
@@ -63,27 +63,27 @@ void
 nsHTMLCSSStyleSheet::ElementRulesMatching(nsPresContext* aPresContext,
                                           Element* aElement,
                                           nsRuleWalker* aRuleWalker)
 {
   // just get the one and only style rule from the content's STYLE attribute
   css::StyleRule* rule = aElement->GetInlineStyleRule();
   if (rule) {
     rule->RuleMatched();
-    aRuleWalker->Forward(rule);
+    aRuleWalker->Forward(rule->GetDeclaration());
   }
 
   rule = aElement->GetSMILOverrideStyleRule();
   if (rule) {
     RestyleManager* restyleManager = aPresContext->RestyleManager();
     if (!restyleManager->SkipAnimationRules()) {
       // Animation restyle (or non-restyle traversal of rules)
       // Now we can walk SMIL overrride style, without triggering transitions.
       rule->RuleMatched();
-      aRuleWalker->Forward(rule);
+      aRuleWalker->Forward(rule->GetDeclaration());
     }
   }
 }
 
 void
 nsHTMLCSSStyleSheet::PseudoElementRulesMatching(Element* aPseudoElement,
                                                 nsCSSPseudoElements::Type
                                                   aPseudoType,
@@ -92,17 +92,17 @@ nsHTMLCSSStyleSheet::PseudoElementRulesM
   MOZ_ASSERT(nsCSSPseudoElements::
                PseudoElementSupportsStyleAttribute(aPseudoType));
   MOZ_ASSERT(aPseudoElement);
 
   // just get the one and only style rule from the content's STYLE attribute
   css::StyleRule* rule = aPseudoElement->GetInlineStyleRule();
   if (rule) {
     rule->RuleMatched();
-    aRuleWalker->Forward(rule);
+    aRuleWalker->Forward(rule->GetDeclaration());
   }
 }
 
 /* virtual */ void
 nsHTMLCSSStyleSheet::RulesMatching(PseudoElementRuleProcessorData* aData)
 {
   if (nsCSSPseudoElements::PseudoElementSupportsStyleAttribute(aData->mPseudoType) &&
       aData->mPseudoElement) {
diff --git a/layout/style/nsRuleWalker.h b/layout/style/nsRuleWalker.h
--- a/layout/style/nsRuleWalker.h
+++ b/layout/style/nsRuleWalker.h
@@ -8,17 +8,17 @@
  * rules are matched
  */
 
 #ifndef nsRuleWalker_h_
 #define nsRuleWalker_h_
 
 #include "nsRuleNode.h"
 #include "nsIStyleRule.h"
-#include "StyleRule.h"
+#include "Declaration.h"
 #include "nsQueryObject.h"
 
 class nsRuleWalker {
 public:
   nsRuleNode* CurrentNode() { return mCurrent; }
   void SetCurrentNode(nsRuleNode* aNode) {
     NS_ASSERTION(aNode, "Must have node here!");
     mCurrent = aNode;
@@ -29,24 +29,24 @@ public:
 protected:
   void DoForward(nsIStyleRule* aRule) {
     mCurrent = mCurrent->Transition(aRule, mLevel, mImportance);
     NS_POSTCONDITION(mCurrent, "Transition messed up");
   }
 
 public:
   void Forward(nsIStyleRule* aRule) {
-    NS_PRECONDITION(!RefPtr<mozilla::css::StyleRule>(do_QueryObject(aRule)),
+    NS_PRECONDITION(!RefPtr<mozilla::css::Declaration>(do_QueryObject(aRule)),
                     "Calling the wrong Forward() overload");
     DoForward(aRule);
   }
-  void Forward(mozilla::css::StyleRule* aRule) {
+  void Forward(mozilla::css::Declaration* aRule) {
     DoForward(aRule);
     mCheckForImportantRules =
-      mCheckForImportantRules && !aRule->GetImportantRule();
+      mCheckForImportantRules && !aRule->HasImportantData();
   }
   // ForwardOnPossiblyCSSRule should only be used by callers that have
   // an explicit list of rules they need to walk, with the list
   // already containing any important rules they care about.
   void ForwardOnPossiblyCSSRule(nsIStyleRule* aRule) {
     DoForward(aRule);
   }
 
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1034,21 +1034,21 @@ nsStyleSet::AddImportantRules(nsRuleNode
   NS_ASSERTION(aCurrLevelNode &&
                aCurrLevelNode != aLastPrevLevelNode, "How did we get here?");
 
   nsAutoTArray<nsIStyleRule*, 16> importantRules;
   for (nsRuleNode *node = aCurrLevelNode; node != aLastPrevLevelNode;
        node = node->GetParent()) {
     // We guarantee that we never walk the root node here, so no need
     // to null-check GetRule().  Furthermore, it must be a CSS rule.
-    NS_ASSERTION(RefPtr<css::StyleRule>(do_QueryObject(node->GetRule())),
+    NS_ASSERTION(RefPtr<css::Declaration>(do_QueryObject(node->GetRule())),
                  "Unexpected non-CSS rule");
 
     nsIStyleRule* impRule =
-      static_cast<css::StyleRule*>(node->GetRule())->GetImportantRule();
+      static_cast<css::Declaration*>(node->GetRule())->GetImportantStyleData();
     if (impRule)
       importantRules.AppendElement(impRule);
   }
 
   NS_ASSERTION(importantRules.Length() != 0,
                "Why did we think there were important rules?");
 
   for (uint32_t i = importantRules.Length(); i-- != 0; ) {
@@ -1061,35 +1061,41 @@ void
 nsStyleSet::AssertNoImportantRules(nsRuleNode* aCurrLevelNode,
                                    nsRuleNode* aLastPrevLevelNode)
 {
   if (!aCurrLevelNode)
     return;
 
   for (nsRuleNode *node = aCurrLevelNode; node != aLastPrevLevelNode;
        node = node->GetParent()) {
-    RefPtr<css::StyleRule> rule(do_QueryObject(node->GetRule()));
-    NS_ASSERTION(rule, "Unexpected non-CSS rule");
+    RefPtr<css::Declaration> declaration(do_QueryObject(node->GetRule()));
+    NS_ASSERTION(declaration, "Unexpected non-CSS rule");
 
-    NS_ASSERTION(!rule->GetImportantRule(), "Unexpected important rule");
+    NS_ASSERTION(!declaration->GetImportantStyleData(),
+                 "Unexpected important style source");
   }
 }
 
 void
 nsStyleSet::AssertNoCSSRules(nsRuleNode* aCurrLevelNode,
                              nsRuleNode* aLastPrevLevelNode)
 {
   if (!aCurrLevelNode)
     return;
 
   for (nsRuleNode *node = aCurrLevelNode; node != aLastPrevLevelNode;
        node = node->GetParent()) {
     nsIStyleRule *rule = node->GetRule();
-    RefPtr<css::StyleRule> cssRule(do_QueryObject(rule));
-    NS_ASSERTION(!cssRule || !cssRule->Selector(), "Unexpected CSS rule");
+    RefPtr<css::Declaration> declaration(do_QueryObject(rule));
+    if (declaration) {
+      RefPtr<css::StyleRule> cssRule =
+        do_QueryObject(declaration->GetOwningRule());
+      NS_ASSERTION(!cssRule || !cssRule->Selector(),
+                   "Unexpected CSS rule");
+    }
   }
 }
 #endif
 
 // Enumerate the rules in a way that cares about the order of the rules.
 void
 nsStyleSet::FileRules(nsIStyleRuleProcessor::EnumFunc aCollectorFunc, 
                       RuleProcessorData* aData, Element* aElement,
@@ -1958,19 +1964,21 @@ nsStyleSet::ResolveAnonymousBoxStyle(nsI
             &ruleWalker);
 
   if (aPseudoTag == nsCSSAnonBoxes::pageContent) {
     // Add any @page rules that are specified.
     nsTArray<nsCSSPageRule*> rules;
     nsTArray<css::ImportantStyleData*> importantRules;
     PresContext()->StyleSet()->AppendPageRules(rules);
     for (uint32_t i = 0, i_end = rules.Length(); i != i_end; ++i) {
-      rules[i]->Declaration()->SetImmutable();
-      ruleWalker.Forward(rules[i]);
-      css::ImportantStyleData* importantRule = rules[i]->GetImportantRule();
+      css::Declaration* declaration = rules[i]->Declaration();
+      declaration->SetImmutable();
+      ruleWalker.Forward(declaration);
+      css::ImportantStyleData* importantRule =
+        declaration->GetImportantStyleData();
       if (importantRule) {
         importantRules.AppendElement(importantRule);
       }
     }
     for (uint32_t i = 0, i_end = importantRules.Length(); i != i_end; ++i) {
       ruleWalker.Forward(importantRules[i]);
     }
   }
diff --git a/layout/style/test/test_animations_dynamic_changes.html b/layout/style/test/test_animations_dynamic_changes.html
--- a/layout/style/test/test_animations_dynamic_changes.html
+++ b/layout/style/test/test_animations_dynamic_changes.html
@@ -41,17 +41,17 @@ function test_bug978833() {
   // Temporarily remove the animation style, since we resolve keyframes
   // on top of current animation styles (although maybe we shouldn't),
   // so we need to remove those styles to hit the rule tree cache.
   p.classList.remove("alwaysa");
   is(cs.marginLeft, "0px", "p margin-left should be 0px without animation");
 
   p.classList.add("alwaysa");
   kf.style.marginLeft = "100px";
-  todo_is(cs.marginLeft, "100px", "p margin-left should be 100px after change");
+  is(cs.marginLeft, "100px", "p margin-left should be 100px after change");
 
   p.style.animation = "";
 }
 test_bug978833();
 
 </script>
 </pre>
 </body>
