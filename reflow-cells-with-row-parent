From: L. David Baron <dbaron@dbaron.org>

Don't construct cell reflow states with a row group reflow state as their parent; instead, always link in a table row reflow state as appropriate.  (Bug 627842, patch 3.875)  r=roc

Fixes assertion on layout/reftests/bugs/409084-1a.html once the rest
of the inflation patches land.

diff --git a/layout/tables/nsTableRowGroupFrame.cpp b/layout/tables/nsTableRowGroupFrame.cpp
--- a/layout/tables/nsTableRowGroupFrame.cpp
+++ b/layout/tables/nsTableRowGroupFrame.cpp
@@ -946,16 +946,18 @@ nsTableRowGroupFrame::SplitSpanningCells
                                          nsTableRowFrame*&        aContRow,
                                          nsTableRowFrame*&        aFirstTruncatedRow,
                                          nscoord&                 aDesiredHeight)
 {
   NS_ASSERTION(aSpanningRowBottom >= 0, "Can't split negative heights");
   aFirstTruncatedRow = nsnull;
   aDesiredHeight     = 0;
 
+  bool borderCollapse =
+    static_cast<nsTableFrame*>(aTable.GetFirstInFlow())->IsBorderCollapse();
   PRInt32 lastRowIndex = aLastRow.GetRowIndex();
   bool wasLast = false;
   // Iterate the rows between aFirstRow and aLastRow
   for (nsTableRowFrame* row = &aFirstRow; !wasLast; row = row->GetNextRow()) {
     wasLast = (row == &aLastRow);
     PRInt32 rowIndex = row->GetRowIndex();
     nsPoint rowPos = row->GetPosition();
     // Iterate the cells looking for those that have rowspan > 1
@@ -965,17 +967,31 @@ nsTableRowGroupFrame::SplitSpanningCells
       // were reflowed correctly during the unconstrained height reflow. 
       if ((rowSpan > 1) && (rowIndex + rowSpan > lastRowIndex)) {
         nsReflowStatus status;
         // Ask the row to reflow the cell to the height of all the rows it spans up through aLastRow
         // aAvailHeight is the space between the row group start and the end of the page
         nscoord cellAvailHeight = aSpanningRowBottom - rowPos.y;
         NS_ASSERTION(cellAvailHeight >= 0, "No space for cell?");
         bool isTopOfPage = (row == &aFirstRow) && aFirstRowIsTopOfPage;
-        nscoord cellHeight = row->ReflowCellFrame(&aPresContext, aReflowState,
+
+        nsRect rowRect = row->GetRect();
+        nsSize rowAvailSize(aReflowState.availableWidth,
+                            NS_MAX(aReflowState.availableHeight - rowRect.y,
+                                   0));
+        // don't let the available height exceed what
+        // CalculateRowHeights set for it
+        rowAvailSize.height = NS_MIN(rowAvailSize.height, rowRect.height);
+        nsHTMLReflowState rowReflowState(&aPresContext, aReflowState,
+                                         row, rowAvailSize,
+                                         -1, -1, false);
+        InitChildReflowState(aPresContext, borderCollapse, rowReflowState);
+        rowReflowState.mFlags.mIsTopOfPage = isTopOfPage; // set top of page
+
+        nscoord cellHeight = row->ReflowCellFrame(&aPresContext, rowReflowState,
                                                   isTopOfPage, cell,
                                                   cellAvailHeight, status);
         aDesiredHeight = NS_MAX(aDesiredHeight, rowPos.y + cellHeight);
         if (NS_FRAME_IS_COMPLETE(status)) {
           if (cellHeight > cellAvailHeight) {
             aFirstTruncatedRow = row;
             if ((row != &aFirstRow) || !aFirstRowIsTopOfPage) {
               // return now, since we will be getting another reflow after either (1) row is 
