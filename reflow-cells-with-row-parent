From: L. David Baron <dbaron@dbaron.org>

Don't construct cell reflow states with a row group reflow state as their parent; instead, always link in a table row reflow state as appropriate.  (Bug 627842, patch 3.875)  r?roc

Fixes assertion on layout/reftests/bugs/409084-1a.html once the rest
of the inflation patches land.

diff --git a/layout/tables/nsTableRowGroupFrame.cpp b/layout/tables/nsTableRowGroupFrame.cpp
--- a/layout/tables/nsTableRowGroupFrame.cpp
+++ b/layout/tables/nsTableRowGroupFrame.cpp
@@ -932,17 +932,17 @@ nsTableRowGroupFrame::CreateContinuingRo
   PushChildren(&aPresContext, *aContRowFrame, &aRowFrame);
 }
 
 // Reflow the cells with rowspan > 1 which originate between aFirstRow
 // and end on or after aLastRow. aFirstTruncatedRow is the highest row on the
 // page that contains a cell which cannot split on this page 
 void
 nsTableRowGroupFrame::SplitSpanningCells(nsPresContext&           aPresContext,
-                                         const nsHTMLReflowState& aReflowState,
+                                         const nsHTMLReflowState& aRowReflowState,
                                          nsTableFrame&            aTable,
                                          nsTableRowFrame&         aFirstRow, 
                                          nsTableRowFrame&         aLastRow,  
                                          bool                     aFirstRowIsTopOfPage,
                                          nscoord                  aSpanningRowBottom,
                                          nsTableRowFrame*&        aContRow,
                                          nsTableRowFrame*&        aFirstTruncatedRow,
                                          nscoord&                 aDesiredHeight)
@@ -965,17 +965,18 @@ nsTableRowGroupFrame::SplitSpanningCells
       // were reflowed correctly during the unconstrained height reflow. 
       if ((rowSpan > 1) && (rowIndex + rowSpan > lastRowIndex)) {
         nsReflowStatus status;
         // Ask the row to reflow the cell to the height of all the rows it spans up through aLastRow
         // aAvailHeight is the space between the row group start and the end of the page
         nscoord cellAvailHeight = aSpanningRowBottom - rowPos.y;
         NS_ASSERTION(cellAvailHeight >= 0, "No space for cell?");
         bool isTopOfPage = (row == &aFirstRow) && aFirstRowIsTopOfPage;
-        nscoord cellHeight = row->ReflowCellFrame(&aPresContext, aReflowState,
+        nscoord cellHeight = row->ReflowCellFrame(&aPresContext,
+                                                  aRowReflowState,
                                                   isTopOfPage, cell,
                                                   cellAvailHeight, status);
         aDesiredHeight = NS_MAX(aDesiredHeight, rowPos.y + cellHeight);
         if (NS_FRAME_IS_COMPLETE(status)) {
           if (cellHeight > cellAvailHeight) {
             aFirstTruncatedRow = row;
             if ((row != &aFirstRow) || !aFirstRowIsTopOfPage) {
               // return now, since we will be getting another reflow after either (1) row is 
@@ -1083,30 +1084,31 @@ nsTableRowGroupFrame::SplitRowGroup(nsPr
   // Walk each of the row frames looking for the first row frame that doesn't fit 
   // in the available space
   for (nsTableRowFrame* rowFrame = firstRowThisPage; rowFrame; rowFrame = rowFrame->GetNextRow()) {
     bool rowIsOnPage = true;
     nsRect rowRect = rowFrame->GetRect();
     // See if the row fits on this page
     if (rowRect.YMost() > availHeight) {
       nsTableRowFrame* contRow = nsnull;
+
+      nsSize availSize(availWidth, NS_MAX(availHeight - rowRect.y, 0));
+      // don't let the available height exceed what CalculateRowHeights
+      // set for it
+      availSize.height = NS_MIN(availSize.height, rowRect.height);
+      nsHTMLReflowState rowReflowState(aPresContext, aReflowState,
+                                       rowFrame, availSize,
+                                       -1, -1, false);
+      InitChildReflowState(*aPresContext, borderCollapse, rowReflowState);
+      rowReflowState.mFlags.mIsTopOfPage = isTopOfPage; // set top of page
+
       // Reflow the row in the availabe space and have it split if it is the 1st
       // row (on the page) or there is at least 5% of the current page available 
       // XXX this 5% should be made a preference 
       if (!prevRowFrame || (availHeight - aDesiredSize.height > pageHeight / 20)) { 
-        nsSize availSize(availWidth, NS_MAX(availHeight - rowRect.y, 0));
-        // don't let the available height exceed what CalculateRowHeights set for it
-        availSize.height = NS_MIN(availSize.height, rowRect.height);
-
-        nsHTMLReflowState rowReflowState(aPresContext, aReflowState,
-                                         rowFrame, availSize,
-                                         -1, -1, false);
-                                         
-        InitChildReflowState(*aPresContext, borderCollapse, rowReflowState);
-        rowReflowState.mFlags.mIsTopOfPage = isTopOfPage; // set top of page
         nsHTMLReflowMetrics rowMetrics;
 
         // Get the old size before we reflow.
         nsRect oldRowRect = rowFrame->GetRect();
         nsRect oldRowVisualOverflow = rowFrame->GetVisualOverflowRect();
 
         // Reflow the cell with the constrained height. A cell with rowspan >1 will get this
         // reflow later during SplitSpanningCells.
@@ -1189,17 +1191,17 @@ nsTableRowGroupFrame::SplitRowGroup(nsPr
           aStatus = NS_FRAME_COMPLETE;
           break;
         }
       }
       // reflow the cells with rowspan >1 that occur on the page
 
       nsTableRowFrame* firstTruncatedRow;
       nscoord yMost;
-      SplitSpanningCells(*aPresContext, aReflowState, *aTableFrame, *firstRowThisPage,
+      SplitSpanningCells(*aPresContext, rowReflowState, *aTableFrame, *firstRowThisPage,
                          *lastRowThisPage, aReflowState.mFlags.mIsTopOfPage, spanningRowBottom, contRow, 
                          firstTruncatedRow, yMost);
       if (firstTruncatedRow) {
         // A rowspan >1 cell did not fit (and could not split) in the space we gave it
         if (firstTruncatedRow == firstRowThisPage) {
           if (aReflowState.mFlags.mIsTopOfPage) {
             NS_WARNING("data loss in a row spanned cell");
           }
@@ -1219,27 +1221,27 @@ nsTableRowGroupFrame::SplitRowGroup(nsPr
 
           UndoContinuedRow(aPresContext, contRow);
           contRow = nsnull;
           nsTableRowFrame* oldLastRowThisPage = lastRowThisPage;
           lastRowThisPage = firstTruncatedRow;
           aStatus = NS_FRAME_NOT_COMPLETE;
 
           // Call SplitSpanningCells again with rowBefore as the last row on the page
-          SplitSpanningCells(*aPresContext, aReflowState, *aTableFrame, 
+          SplitSpanningCells(*aPresContext, rowReflowState, *aTableFrame, 
                              *firstRowThisPage, *rowBefore, aReflowState.mFlags.mIsTopOfPage, 
                              spanningRowBottom, contRow, firstTruncatedRow, aDesiredSize.height);
           if (firstTruncatedRow) {
             if (aReflowState.mFlags.mIsTopOfPage) {
               // We were better off with the 1st call to SplitSpanningCells, do it again
               UndoContinuedRow(aPresContext, contRow);
               contRow = nsnull;
               lastRowThisPage = oldLastRowThisPage;
               spanningRowBottom = oldSpanningRowBottom;
-              SplitSpanningCells(*aPresContext, aReflowState, *aTableFrame, *firstRowThisPage,
+              SplitSpanningCells(*aPresContext, rowReflowState, *aTableFrame, *firstRowThisPage,
                                  *lastRowThisPage, aReflowState.mFlags.mIsTopOfPage, spanningRowBottom, contRow, 
                                  firstTruncatedRow, aDesiredSize.height);
               NS_WARNING("data loss in a row spanned cell");
             }
             else {
               // Let our parent reflow us again with more space
               aDesiredSize.height = rowRect.YMost();
               aStatus = NS_FRAME_COMPLETE;
diff --git a/layout/tables/nsTableRowGroupFrame.h b/layout/tables/nsTableRowGroupFrame.h
--- a/layout/tables/nsTableRowGroupFrame.h
+++ b/layout/tables/nsTableRowGroupFrame.h
@@ -398,17 +398,17 @@ protected:
 
   nsresult SplitRowGroup(nsPresContext*           aPresContext,
                          nsHTMLReflowMetrics&     aDesiredSize,
                          const nsHTMLReflowState& aReflowState,
                          nsTableFrame*            aTableFrame,
                          nsReflowStatus&          aStatus);
 
   void SplitSpanningCells(nsPresContext&           aPresContext,
-                          const nsHTMLReflowState& aReflowState,
+                          const nsHTMLReflowState& aRowReflowState,
                           nsTableFrame&            aTableFrame,
                           nsTableRowFrame&         aFirstRow, 
                           nsTableRowFrame&         aLastRow,  
                           bool                     aFirstRowIsTopOfPage,
                           nscoord                  aSpanningRowBottom,
                           nsTableRowFrame*&        aContRowFrame,
                           nsTableRowFrame*&        aFirstTruncatedRow,
                           nscoord&                 aDesiredHeight);
