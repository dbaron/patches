From: L. David Baron <dbaron@dbaron.org>

Bug 1343715 - Split nsTSubstring::mFlags into separate variables for class and data flags (rust bindings changes).  r=mystor

Thanks to Manish for help in reflecting this idiomatically in rust.

MozReview-Commit-ID: 8tB7vsc5yxc

diff --git a/toolkit/library/gtest/rust/Cargo.lock b/toolkit/library/gtest/rust/Cargo.lock
--- a/toolkit/library/gtest/rust/Cargo.lock
+++ b/toolkit/library/gtest/rust/Cargo.lock
@@ -544,16 +544,19 @@ name = "nserror"
 version = "0.1.0"
 dependencies = [
  "nsstring 0.1.0",
 ]
 
 [[package]]
 name = "nsstring"
 version = "0.1.0"
+dependencies = [
+ "bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
 
 [[package]]
 name = "nsstring-gtest"
 version = "0.1.0"
 dependencies = [
  "nsstring 0.1.0",
 ]
 
diff --git a/toolkit/library/rust/Cargo.lock b/toolkit/library/rust/Cargo.lock
--- a/toolkit/library/rust/Cargo.lock
+++ b/toolkit/library/rust/Cargo.lock
@@ -538,16 +538,19 @@ name = "nserror"
 version = "0.1.0"
 dependencies = [
  "nsstring 0.1.0",
 ]
 
 [[package]]
 name = "nsstring"
 version = "0.1.0"
+dependencies = [
+ "bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
 
 [[package]]
 name = "nsstring_vendor"
 version = "0.1.0"
 
 [[package]]
 name = "num-integer"
 version = "0.1.33"
diff --git a/xpcom/rust/nsstring/Cargo.toml b/xpcom/rust/nsstring/Cargo.toml
--- a/xpcom/rust/nsstring/Cargo.toml
+++ b/xpcom/rust/nsstring/Cargo.toml
@@ -1,8 +1,9 @@
 [package]
 name = "nsstring"
 version = "0.1.0"
 authors = ["nobody@mozilla.com"]
 license = "MPL-2.0"
 description = "Rust bindings to xpcom string types"
 
 [dependencies]
+bitflags = "0.8"
diff --git a/xpcom/rust/nsstring/gtest/Test.cpp b/xpcom/rust/nsstring/gtest/Test.cpp
--- a/xpcom/rust/nsstring/gtest/Test.cpp
+++ b/xpcom/rust/nsstring/gtest/Test.cpp
@@ -40,55 +40,54 @@ SIZE_ALIGN_CHECK(nsFixedCString)
       }                                                                 \
     };                                                                  \
     static_assert(sizeof(Clazz) == sizeof(Hack), "Hack matches class"); \
     Hack::RunTest();                                                    \
   }
 
 MEMBER_CHECK(nsString, mData)
 MEMBER_CHECK(nsString, mLength)
-MEMBER_CHECK(nsString, mFlags)
+MEMBER_CHECK(nsString, mDataFlags)
+MEMBER_CHECK(nsString, mClassFlags)
 MEMBER_CHECK(nsCString, mData)
 MEMBER_CHECK(nsCString, mLength)
-MEMBER_CHECK(nsCString, mFlags)
+MEMBER_CHECK(nsCString, mDataFlags)
+MEMBER_CHECK(nsCString, mClassFlags)
 MEMBER_CHECK(nsFixedString, mFixedCapacity)
 MEMBER_CHECK(nsFixedString, mFixedBuf)
 MEMBER_CHECK(nsFixedCString, mFixedCapacity)
 MEMBER_CHECK(nsFixedCString, mFixedBuf)
 
-extern "C" void Rust_Test_NsStringFlags(uint32_t* f_none,
-                                        uint32_t* f_terminated,
-                                        uint32_t* f_voided,
-                                        uint32_t* f_shared,
-                                        uint32_t* f_owned,
-                                        uint32_t* f_fixed,
-                                        uint32_t* f_literal,
-                                        uint32_t* f_class_fixed);
+extern "C" void Rust_Test_NsStringFlags(uint16_t* f_terminated,
+                                        uint16_t* f_voided,
+                                        uint16_t* f_shared,
+                                        uint16_t* f_owned,
+                                        uint16_t* f_fixed,
+                                        uint16_t* f_literal,
+                                        uint16_t* f_class_fixed);
 TEST(RustNsString, NsStringFlags) {
-  uint32_t f_none, f_terminated, f_voided, f_shared, f_owned, f_fixed, f_literal, f_class_fixed;
-  Rust_Test_NsStringFlags(&f_none, &f_terminated,
+  uint16_t f_terminated, f_voided, f_shared, f_owned, f_fixed, f_literal, f_class_fixed;
+  Rust_Test_NsStringFlags(&f_terminated,
                           &f_voided, &f_shared,
                           &f_owned, &f_fixed,
                           &f_literal, &f_class_fixed);
-  EXPECT_EQ(f_none, nsAString::F_NONE);
-  EXPECT_EQ(f_none, nsACString::F_NONE);
-  EXPECT_EQ(f_terminated, nsAString::F_TERMINATED);
-  EXPECT_EQ(f_terminated, nsACString::F_TERMINATED);
-  EXPECT_EQ(f_voided, nsAString::F_VOIDED);
-  EXPECT_EQ(f_voided, nsACString::F_VOIDED);
-  EXPECT_EQ(f_shared, nsAString::F_SHARED);
-  EXPECT_EQ(f_shared, nsACString::F_SHARED);
-  EXPECT_EQ(f_owned, nsAString::F_OWNED);
-  EXPECT_EQ(f_owned, nsACString::F_OWNED);
-  EXPECT_EQ(f_fixed, nsAString::F_FIXED);
-  EXPECT_EQ(f_fixed, nsACString::F_FIXED);
-  EXPECT_EQ(f_literal, nsAString::F_LITERAL);
-  EXPECT_EQ(f_literal, nsACString::F_LITERAL);
-  EXPECT_EQ(f_class_fixed, nsAString::F_CLASS_FIXED);
-  EXPECT_EQ(f_class_fixed, nsACString::F_CLASS_FIXED);
+  EXPECT_EQ(f_terminated, uint16_t(nsAString::DataFlags::TERMINATED));
+  EXPECT_EQ(f_terminated, uint16_t(nsACString::DataFlags::TERMINATED));
+  EXPECT_EQ(f_voided, uint16_t(nsAString::DataFlags::VOIDED));
+  EXPECT_EQ(f_voided, uint16_t(nsACString::DataFlags::VOIDED));
+  EXPECT_EQ(f_shared, uint16_t(nsAString::DataFlags::SHARED));
+  EXPECT_EQ(f_shared, uint16_t(nsACString::DataFlags::SHARED));
+  EXPECT_EQ(f_owned, uint16_t(nsAString::DataFlags::OWNED));
+  EXPECT_EQ(f_owned, uint16_t(nsACString::DataFlags::OWNED));
+  EXPECT_EQ(f_fixed, uint16_t(nsAString::DataFlags::FIXED));
+  EXPECT_EQ(f_fixed, uint16_t(nsACString::DataFlags::FIXED));
+  EXPECT_EQ(f_literal, uint16_t(nsAString::DataFlags::LITERAL));
+  EXPECT_EQ(f_literal, uint16_t(nsACString::DataFlags::LITERAL));
+  EXPECT_EQ(f_class_fixed, uint16_t(nsAString::ClassFlags::FIXED));
+  EXPECT_EQ(f_class_fixed, uint16_t(nsACString::ClassFlags::FIXED));
 }
 
 extern "C" void Rust_StringFromCpp(const nsACString* aCStr, const nsAString* aStr);
 TEST(RustNsString, StringFromCpp) {
   nsAutoCString foo;
   foo.AssignASCII("Hello, World!");
 
   nsAutoString bar;
diff --git a/xpcom/rust/nsstring/src/lib.rs b/xpcom/rust/nsstring/src/lib.rs
--- a/xpcom/rust/nsstring/src/lib.rs
+++ b/xpcom/rust/nsstring/src/lib.rs
@@ -110,44 +110,64 @@
 //!
 //! If this type is dropped in rust, it will not free its backing storage. This
 //! can be useful when implementing FFI types which contain `ns[C]String` members
 //! which invoke their member's destructors through C++ code.
 
 #![allow(non_camel_case_types)]
 #![deny(warnings)]
 
+#[macro_use]
+extern crate bitflags;
+
 use std::ops::{Deref, DerefMut};
 use std::marker::PhantomData;
 use std::borrow;
 use std::slice;
 use std::ptr;
 use std::mem;
 use std::fmt;
 use std::cmp;
 use std::str;
 use std::u32;
 use std::os::raw::c_void;
 
 //////////////////////////////////
 // Internal Implemenation Flags //
 //////////////////////////////////
 
-const F_NONE: u32 = 0; // no flags
+mod data_flags {
+    bitflags! {
+        // While this has the same layout as u16, it cannot be passed
+        // over FFI safely as a u16.
+        #[repr(C)]
+        pub flags DataFlags : u16 {
+            const TERMINATED = 1 << 0, // IsTerminated returns true
+            const VOIDED = 1 << 1, // IsVoid returns true
+            const SHARED = 1 << 2, // mData points to a heap-allocated, shared buffer
+            const OWNED = 1 << 3, // mData points to a heap-allocated, raw buffer
+            const FIXED = 1 << 4, // mData points to a fixed-size writable, dependent buffer
+            const LITERAL = 1 << 5, // mData points to a string literal; TERMINATED will also be set
+        }
+    }
+}
 
-// data flags are in the lower 16-bits
-const F_TERMINATED: u32 = 1 << 0; // IsTerminated returns true
-const F_VOIDED: u32 = 1 << 1; // IsVoid returns true
-const F_SHARED: u32 = 1 << 2; // mData points to a heap-allocated, shared buffer
-const F_OWNED: u32 = 1 << 3; // mData points to a heap-allocated, raw buffer
-const F_FIXED: u32 = 1 << 4; // mData points to a fixed-size writable, dependent buffer
-const F_LITERAL: u32 = 1 << 5; // mData points to a string literal; F_TERMINATED will also be set
+mod class_flags {
+    bitflags! {
+        // While this has the same layout as u16, it cannot be passed
+        // over FFI safely as a u16.
+        #[repr(C)]
+        pub flags ClassFlags : u16 {
+            const FIXED = 1 << 0, // indicates that |this| is of type nsTFixedString
+        }
+    }
+}
 
-// class flags are in the upper 16-bits
-const F_CLASS_FIXED: u32 = 1 << 16; // indicates that |this| is of type nsTFixedString
+use data_flags::DataFlags;
+use class_flags::ClassFlags;
 
 ////////////////////////////////////
 // Generic String Bindings Macros //
 ////////////////////////////////////
 
 macro_rules! define_string_types {
     {
         char_t = $char_t: ty;
@@ -177,17 +197,18 @@ macro_rules! define_string_types {
         ///
         /// This struct will leak its data if dropped from rust. See the module
         /// documentation for more information on this type.
         #[repr(C)]
         #[derive(Debug)]
         pub struct $StringRepr {
             data: *const $char_t,
             length: u32,
-            flags: u32,
+            dataflags: DataFlags,
+            classflags: ClassFlags,
         }
 
         impl Deref for $StringRepr {
             type Target = $AString;
             fn deref(&self) -> &$AString {
                 unsafe {
                     mem::transmute(self)
                 }
@@ -382,17 +403,18 @@ macro_rules! define_string_types {
         }
 
         impl $String<'static> {
             pub fn new() -> $String<'static> {
                 $String {
                     hdr: $StringRepr {
                         data: ptr::null(),
                         length: 0,
-                        flags: F_NONE,
+                        dataflags: DataFlags::empty(),
+                        classflags: ClassFlags::empty(),
                     },
                     _marker: PhantomData,
                 }
             }
         }
 
         impl<'a> Drop for $String<'a> {
             fn drop(&mut self) {
@@ -435,46 +457,48 @@ macro_rules! define_string_types {
 
         impl<'a> From<&'a [$char_t]> for $String<'a> {
             fn from(s: &'a [$char_t]) -> $String<'a> {
                 assert!(s.len() < (u32::MAX as usize));
                 $String {
                     hdr: $StringRepr {
                         data: if s.is_empty() { ptr::null() } else { s.as_ptr() },
                         length: s.len() as u32,
-                        flags: F_NONE,
+                        dataflags: DataFlags::empty(),
+                        classflags: ClassFlags::empty(),
                     },
                     _marker: PhantomData,
                 }
             }
         }
 
         impl From<Box<[$char_t]>> for $String<'static> {
             fn from(s: Box<[$char_t]>) -> $String<'static> {
                 assert!(s.len() < (u32::MAX as usize));
                 if s.is_empty() {
                     return $String::new();
                 }
 
-                // SAFETY NOTE: This method produces an F_OWNED ns[C]String from
-                // a Box<[$char_t]>. this is only safe because in the Gecko
-                // tree, we use the same allocator for Rust code as for C++
-                // code, meaning that our box can be legally freed with
-                // libc::free().
+                // SAFETY NOTE: This method produces an data_flags::OWNED
+                // ns[C]String from a Box<[$char_t]>. this is only safe
+                // because in the Gecko tree, we use the same allocator for
+                // Rust code as for C++ code, meaning that our box can be
+                // legally freed with libc::free().
                 let length = s.len() as u32;
                 let ptr = s.as_ptr();
                 mem::forget(s);
                 unsafe {
                     Gecko_IncrementStringAdoptCount(ptr as *mut _);
                 }
                 $String {
                     hdr: $StringRepr {
                         data: ptr,
                         length: length,
-                        flags: F_OWNED,
+                        dataflags: data_flags::OWNED,
+                        classflags: ClassFlags::empty(),
                     },
                     _marker: PhantomData,
                 }
             }
         }
 
         impl From<Vec<$char_t>> for $String<'static> {
             fn from(s: Vec<$char_t>) -> $String<'static> {
@@ -554,17 +578,18 @@ macro_rules! define_string_types {
                 let len = buf.len();
                 assert!(len < (u32::MAX as usize));
                 let buf_ptr = buf.as_mut_ptr();
                 $FixedString {
                     base: $String {
                         hdr: $StringRepr {
                             data: ptr::null(),
                             length: 0,
-                            flags: F_CLASS_FIXED,
+                            dataflags: DataFlags::empty(),
+                            classflags: class_flags::FIXED,
                         },
                         _marker: PhantomData,
                     },
                     capacity: len as u32,
                     buffer: buf_ptr,
                     _marker: PhantomData,
                 }
             }
@@ -993,24 +1018,18 @@ pub mod test_helpers {
 
     use super::{
         nsFixedCString,
         nsFixedString,
         nsCString,
         nsString,
         nsCStringRepr,
         nsStringRepr,
-        F_NONE,
-        F_TERMINATED,
-        F_VOIDED,
-        F_SHARED,
-        F_OWNED,
-        F_FIXED,
-        F_LITERAL,
-        F_CLASS_FIXED,
+        data_flags,
+        class_flags,
     };
     use std::mem;
 
     /// Generates an #[no_mangle] extern "C" function which returns the size and
     /// alignment of the given type with the given name.
     macro_rules! size_align_check {
         ($T:ty, $fname:ident) => {
             #[no_mangle]
@@ -1094,39 +1113,39 @@ pub mod test_helpers {
                     mem::forget(tmp);
                 }
             }
         }
     }
 
     member_check!(nsStringRepr, nsString<'static>, data, Rust_Test_Member_nsString_mData);
     member_check!(nsStringRepr, nsString<'static>, length, Rust_Test_Member_nsString_mLength);
-    member_check!(nsStringRepr, nsString<'static>, flags, Rust_Test_Member_nsString_mFlags);
+    member_check!(nsStringRepr, nsString<'static>, dataflags, Rust_Test_Member_nsString_mDataFlags);
+    member_check!(nsStringRepr, nsString<'static>, classflags, Rust_Test_Member_nsString_mClassFlags);
     member_check!(nsCStringRepr, nsCString<'static>, data, Rust_Test_Member_nsCString_mData);
     member_check!(nsCStringRepr, nsCString<'static>, length, Rust_Test_Member_nsCString_mLength);
-    member_check!(nsCStringRepr, nsCString<'static>, flags, Rust_Test_Member_nsCString_mFlags);
+    member_check!(nsCStringRepr, nsCString<'static>, dataflags, Rust_Test_Member_nsCString_mDataFlags);
+    member_check!(nsCStringRepr, nsCString<'static>, classflags, Rust_Test_Member_nsCString_mClassFlags);
     member_check!(nsFixedString<'static>, capacity, Rust_Test_Member_nsFixedString_mFixedCapacity);
     member_check!(nsFixedString<'static>, buffer, Rust_Test_Member_nsFixedString_mFixedBuf);
     member_check!(nsFixedCString<'static>, capacity, Rust_Test_Member_nsFixedCString_mFixedCapacity);
     member_check!(nsFixedCString<'static>, buffer, Rust_Test_Member_nsFixedCString_mFixedBuf);
 
     #[no_mangle]
     #[allow(non_snake_case)]
-    pub extern fn Rust_Test_NsStringFlags(f_none: *mut u32,
-                                          f_terminated: *mut u32,
-                                          f_voided: *mut u32,
-                                          f_shared: *mut u32,
-                                          f_owned: *mut u32,
-                                          f_fixed: *mut u32,
-                                          f_literal: *mut u32,
-                                          f_class_fixed: *mut u32) {
+    pub extern fn Rust_Test_NsStringFlags(f_terminated: *mut u16,
+                                          f_voided: *mut u16,
+                                          f_shared: *mut u16,
+                                          f_owned: *mut u16,
+                                          f_fixed: *mut u16,
+                                          f_literal: *mut u16,
+                                          f_class_fixed: *mut u16) {
         unsafe {
-            *f_none = F_NONE;
-            *f_terminated = F_TERMINATED;
-            *f_voided = F_VOIDED;
-            *f_shared = F_SHARED;
-            *f_owned = F_OWNED;
-            *f_fixed = F_FIXED;
-            *f_literal = F_LITERAL;
-            *f_class_fixed = F_CLASS_FIXED;
+            *f_terminated = data_flags::TERMINATED.bits();
+            *f_voided = data_flags::VOIDED.bits();
+            *f_shared = data_flags::SHARED.bits();
+            *f_owned = data_flags::OWNED.bits();
+            *f_fixed = data_flags::FIXED.bits();
+            *f_literal = data_flags::LITERAL.bits();
+            *f_class_fixed = class_flags::FIXED.bits();
         }
     }
 }
