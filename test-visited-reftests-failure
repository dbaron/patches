From: L. David Baron <dbaron@dbaron.org>

Make test_visited_reftests report failures instead of using timeout to indicate failure.

diff --git a/layout/style/test/test_visited_reftests.html b/layout/style/test/test_visited_reftests.html
--- a/layout/style/test/test_visited_reftests.html
+++ b/layout/style/test/test_visited_reftests.html
@@ -88,16 +88,25 @@ var gTests = [
 // Maintain a reference count of how many things we're waiting for until
 // we can say the tests are done.
 var gDelayCount = 0;
 function AddFinishDependency()
   { ++gDelayCount; }
 function RemoveFinishDependency()
   { if (--gDelayCount == 0) SimpleTest.finish(); }
 
+// We record the maximum number of times we had to look at a test before
+// it switched to the passing state (though we assume it's 10 to start
+// rather than 0 so that we have a reasonable default).  Then we make a
+// test "time out" if it takes more than gTimeoutFactor times that
+// amount of time.  This allows us to report a test failure rather than
+// making a test failure just show up as a timeout.
+var gMaxPassingTries = 10;
+var gTimeoutFactor = 10;
+
 function loadVisitedPage()
 {
   var element = document.createElement("iframe");
   element.addEventListener("load", visitedPageLoad, false);
   element.src = "css-visited/visited-page.html";
   document.body.appendChild(element);
   AddFinishDependency();
 }
@@ -122,16 +131,17 @@ function passes(op, shot1, shot2)
 }
 
 function startTest(i)
 {
   var testLine = gTests[i];
   var splitData = testLine.split(" ");
   var testData =
     { op: splitData[0], test: splitData[1], reference: splitData[2] };
+  var tries = 0;
 
   // Maintain state specific to this test in the closure exposed to all
   // the functions nested inside this one.
 
   function startIframe(url)
   {
     var element = document.createElement("iframe");
     element.addEventListener("load", handleLoad, false);
@@ -152,26 +162,37 @@ function startTest(i)
         // happens should fail at least some of the time.
         setTimeout(checkTest, 100);
       }
     }
     function checkTest()
     {
       var test_snapshot = takeSnapshot(test.element);
       if (passes(testData.op, test_snapshot, reference.snapshot)) {
-        reportSuccess();
+        if (tries > gMaxPassingTries) {
+          gMaxPassingTries = tries;
+        }
+        report(true);
       } else {
-        // Links might not have been colored yet.  Try again in 100ms.
-        setTimeout(checkTest, 100);
+        ++tries;
+        if (tries > gMaxPassingTries * gTimeoutFactor) {
+          info("Giving up after " + tries + " tries, " +
+               "maxp=" + gMaxPassingTries +
+               "fact=" + gTimeoutFactor);
+          report(false);
+        } else {
+          // Links might not have been colored yet.  Try again in 100ms.
+          setTimeout(checkTest, 100);
+        }
       }
     }
-    function reportSuccess()
+    function report(result)
     {
-      ok(true, "(" + i + ") " +
-               testData.op + " " + testData.test + " " + testData.reference);
+      ok(result, "(" + i + ") " +
+                 testData.op + " " + testData.test + " " + testData.reference);
       RemoveFinishDependency();
     }
     var iframe = { element: element, loaded: false };
 
     return iframe;
   }
 
   AddFinishDependency();
