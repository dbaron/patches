Add comment explaining mJSRoots and ExplainLiveExpectedGarbage business.

diff --git a/js/src/xpconnect/src/nsXPConnect.cpp b/js/src/xpconnect/src/nsXPConnect.cpp
--- a/js/src/xpconnect/src/nsXPConnect.cpp
+++ b/js/src/xpconnect/src/nsXPConnect.cpp
@@ -751,14 +751,26 @@ nsXPConnect::Traverse(void *p, nsCycleCo
     CCNodeType type;
 
 #ifdef DEBUG_CC
+    // Note that the conditions under which we specify GCMarked vs.
+    // GCUnmarked are different between ExplainLiveExpectedGarbage and
+    // the normal case.  In the normal case, we're saying that anything
+    // reachable from a JS runtime root is itself such a root.  This
+    // doesn't actually break anything; it really just does some of the
+    // cycle collector's work for it.  However, when debugging, we
+    // (1) actually need to know what the root is and (2) don't want to
+    // do an extra GC, so we use mJSRoots, built from JS_TraceRuntime,
+    // which produces a different result because we didn't call
+    // JS_TraceChildren to trace everything that was reachable.
     if(mJSRoots.ops)
     {
+        // ExplainLiveExpectedGarbage codepath
         PLDHashEntryHdr* entry =
             PL_DHashTableOperate(&mJSRoots, p, PL_DHASH_LOOKUP);
         type = PL_DHASH_ENTRY_IS_BUSY(entry) ? GCMarked : GCUnmarked;
     }
     else
     {
+        // Normal codepath (matches non-DEBUG_CC codepath).
         type = JS_IsAboutToBeFinalized(cx, p) ? GCUnmarked : GCMarked;
     }
 
