From: L. David Baron <dbaron@dbaron.org>

Add support for calc() expressions in translate functions of -moz-transform.

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -8068,52 +8068,48 @@ static PRBool GetFunctionParseInformatio
                                           PRUint16 &aMinElems,
                                           PRUint16 &aMaxElems,
                                           const PRInt32 *& aVariantMask)
 {
 /* These types represent the common variant masks that will be used to
    * parse out the individual functions.  The order in the enumeration
    * must match the order in which the masks are declared.
    */
-  enum { eLengthPercent,
-         eTwoLengthPercents,
+  enum { eLengthPercentCalc,
+         eTwoLengthPercentCalcs,
          eAngle,
          eTwoAngles,
          eNumber,
          eTwoNumbers,
          eMatrix,
          eNumVariantMasks };
   static const PRInt32 kMaxElemsPerFunction = 6;
   static const PRInt32 kVariantMasks[eNumVariantMasks][kMaxElemsPerFunction] = {
-    {VARIANT_LENGTH | VARIANT_PERCENT},
-    {VARIANT_LENGTH | VARIANT_PERCENT, VARIANT_LENGTH | VARIANT_PERCENT},
+    {VARIANT_LENGTH | VARIANT_PERCENT | VARIANT_CALC},
+    {VARIANT_LENGTH | VARIANT_PERCENT | VARIANT_CALC,
+     VARIANT_LENGTH | VARIANT_PERCENT | VARIANT_CALC},
     {VARIANT_ANGLE_OR_ZERO},
     {VARIANT_ANGLE_OR_ZERO, VARIANT_ANGLE_OR_ZERO},
     {VARIANT_NUMBER},
     {VARIANT_NUMBER, VARIANT_NUMBER},
     {VARIANT_NUMBER, VARIANT_NUMBER, VARIANT_NUMBER, VARIANT_NUMBER,
      VARIANT_LENGTH | VARIANT_PERCENT, VARIANT_LENGTH | VARIANT_PERCENT}};
 
 #ifdef DEBUG
   static const PRUint8 kVariantMaskLengths[eNumVariantMasks] =
     {1, 2, 1, 2, 1, 2, 6};
 #endif
 
   PRInt32 variantIndex = eNumVariantMasks;
 
   switch (aToken) {
   case eCSSKeyword_translatex:
-    /* Exactly one length or percent. */
-    variantIndex = eLengthPercent;
-    aMinElems = 1U;
-    aMaxElems = 1U;
-    break;
   case eCSSKeyword_translatey:
     /* Exactly one length or percent. */
-    variantIndex = eLengthPercent;
+    variantIndex = eLengthPercentCalc;
     aMinElems = 1U;
     aMaxElems = 1U;
     break;
   case eCSSKeyword_scalex:
     /* Exactly one scale factor. */
     variantIndex = eNumber;
     aMinElems = 1U;
     aMaxElems = 1U;
@@ -8127,17 +8123,17 @@ static PRBool GetFunctionParseInformatio
   case eCSSKeyword_rotate:
     /* Exactly one angle. */
     variantIndex = eAngle;
     aMinElems = 1U;
     aMaxElems = 1U;
     break;
   case eCSSKeyword_translate:
     /* One or two lengths or percents. */
-    variantIndex = eTwoLengthPercents;
+    variantIndex = eTwoLengthPercentCalcs;
     aMinElems = 1U;
     aMaxElems = 2U;
     break;
   case eCSSKeyword_skew:
     /* Exactly one or two angles. */
     variantIndex = eTwoAngles;
     aMinElems = 1U;
     aMaxElems = 2U;
diff --git a/layout/style/nsStyleTransformMatrix.cpp b/layout/style/nsStyleTransformMatrix.cpp
--- a/layout/style/nsStyleTransformMatrix.cpp
+++ b/layout/style/nsStyleTransformMatrix.cpp
@@ -41,16 +41,19 @@
 #include "nsStyleTransformMatrix.h"
 #include "nsAutoPtr.h"
 #include "nsCSSValue.h"
 #include "nsStyleContext.h"
 #include "nsPresContext.h"
 #include "nsRuleNode.h"
 #include "nsCSSKeywords.h"
 #include "nsMathUtils.h"
+#include "CSSCalc.h"
+
+namespace css = mozilla::css;
 
 /* Note on floating point precision: The transform matrix is an array
  * of single precision 'float's, and so are most of the input values
  * we get from the style system, but intermediate calculations
  * involving angles need to be done in 'double'.
  */
 
 /* Force small values to zero.  We do this to avoid having sin(360deg)
@@ -247,24 +250,110 @@ static void ProcessMatrix(float aMain[4]
    */
   if (aData->Item(6).GetUnit() == eCSSUnit_Percent)
     aY[1] = aData->Item(6).GetPercentValue();
   else
     SetCoordToValue(aData->Item(6), aContext, aPresContext, aCanStoreInRuleTree,
                     aDelta[1]);
 }
 
+struct LengthPercentPairCalcOps : public css::NumbersAlreadyNormalizedOps
+{
+  struct result_type {
+    nscoord mLength;
+    float mPercent;
+
+    result_type(nscoord aLength, float aPercent)
+      : mLength(aLength), mPercent(aPercent) {}
+  };
+
+  LengthPercentPairCalcOps(nsStyleContext* aContext,
+                           nsPresContext* aPresContext,
+                           PRBool& aCanStoreInRuleTree)
+    : mContext(aContext),
+      mPresContext(aPresContext),
+      mCanStoreInRuleTree(aCanStoreInRuleTree) {}
+
+  nsStyleContext* mContext;
+  nsPresContext* mPresContext;
+  PRBool& mCanStoreInRuleTree;
+
+  result_type ComputeLeafValue(const nsCSSValue& aValue)
+  {
+    if (aValue.GetUnit() == eCSSUnit_Percent) {
+      return result_type(0, aValue.GetPercentValue());
+    } else {
+      return result_type(nsRuleNode::CalcLength(aValue, mContext, mPresContext,
+                                                mCanStoreInRuleTree),
+                         0.0f);
+    }
+  }
+
+  result_type
+  MergeAdditive(nsCSSUnit aCalcFunction,
+                result_type aValue1, result_type aValue2)
+  {
+    if (aCalcFunction == eCSSUnit_Calc_Plus) {
+      return result_type(aValue1.mLength + aValue2.mLength,
+                         aValue1.mPercent + aValue2.mPercent);
+    }
+    if (aCalcFunction == eCSSUnit_Calc_Minus) {
+      return result_type(aValue1.mLength - aValue2.mLength,
+                         aValue1.mPercent - aValue2.mPercent);
+    }
+    if (aCalcFunction == eCSSUnit_Calc_Minimum) {
+      return result_type(NS_MIN(aValue1.mLength, aValue2.mLength),
+                         NS_MIN(aValue1.mPercent, aValue2.mPercent));
+    }
+    NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Maximum,
+                      "unexpected unit");
+    return result_type(NS_MAX(aValue1.mLength, aValue2.mLength),
+                       NS_MAX(aValue1.mPercent, aValue2.mPercent));
+  }
+
+  result_type
+  MergeMultiplicativeL(nsCSSUnit aCalcFunction,
+                       float aValue1, result_type aValue2)
+  {
+    NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Times_L,
+                      "unexpected unit");
+    return result_type(NSToCoordRound(aValue1 * aValue2.mLength),
+                       aValue1 * aValue2.mPercent);
+  }
+
+  result_type
+  MergeMultiplicativeR(nsCSSUnit aCalcFunction,
+                       result_type aValue1, float aValue2)
+  {
+    if (aCalcFunction == eCSSUnit_Calc_Times_R) {
+      return result_type(NSToCoordRound(aValue1.mLength * aValue2),
+                         aValue1.mPercent * aValue2);
+    }
+    NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Divided,
+                      "unexpected unit");
+    return result_type(NSToCoordRound(aValue1.mLength / aValue2),
+                       aValue1.mPercent / aValue2);
+  }
+
+};
+
 static void ProcessTranslatePart(nscoord& aOffset, float& aPercent,
                                  const nsCSSValue& aValue,
                                  nsStyleContext* aContext,
                                  nsPresContext* aPresContext,
                                  PRBool& aCanStoreInRuleTree)
 {
   if (aValue.GetUnit() == eCSSUnit_Percent) {
     aPercent = aValue.GetPercentValue();
+  } else if (aValue.IsCalcUnit()) {
+    LengthPercentPairCalcOps ops(aContext, aPresContext, aCanStoreInRuleTree);
+    LengthPercentPairCalcOps::result_type result =
+      css::ComputeCalc(aValue, ops);
+    aPercent = result.mPercent;
+    aOffset = result.mLength;
   } else {
     SetCoordToValue(aValue, aContext, aPresContext, aCanStoreInRuleTree,
                     aOffset);
   }
 }
 
 /* Helper function to process a translatex function. */
 static void ProcessTranslateX(nscoord aDelta[2], float aX[2],
