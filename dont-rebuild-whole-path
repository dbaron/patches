From: L. David Baron <dbaron@dbaron.org>

Bug 1305754 - Don't rebuild the whole path in the rule tree when resolving style with replacement.  r=heycam

MozReview-Commit-ID: HdNhDBnOS3u

diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -992,16 +992,20 @@ nsStyleSet::GetContext(nsStyleContext* a
                "unexpected visited rule node");
     MOZ_ASSERT(!aVisitedRuleNode ||
                result->GetStyleIfVisited()->RuleNode() == aVisitedRuleNode,
                "unexpected visited rule node");
     MOZ_ASSERT(!aVisitedRuleNode ||
                oldAnimRule == GetAnimationRule(aVisitedRuleNode),
                "animation rule mismatch between rule nodes");
     if (oldAnimRule != animRule) {
+      // FIXME: This should use ResolveStyleWithReplacement instead (and
+      // we can remove ReplaceAnimationRule), since
+      // ResolveStyleWithReplacement should now be equally efficient
+      // (except for the extra code complexity to be more general).
       nsRuleNode *ruleNode =
         ReplaceAnimationRule(aRuleNode, oldAnimRule, animRule);
       nsRuleNode *visitedRuleNode = aVisitedRuleNode
         ? ReplaceAnimationRule(aVisitedRuleNode, oldAnimRule, animRule)
         : nullptr;
       MOZ_ASSERT(!visitedRuleNode ||
                  GetAnimationRule(ruleNode) ==
                    GetAnimationRule(visitedRuleNode),
@@ -1520,55 +1524,102 @@ nsStyleSet::RuleNodeWithReplacement(Elem
   NS_ASSERTION(mBatching == 0, "rule processors out of date");
 
   MOZ_ASSERT(!aPseudoElement ==
              (aPseudoType >= CSSPseudoElementType::Count ||
               !(nsCSSPseudoElements::PseudoElementSupportsStyleAttribute(aPseudoType) ||
                 nsCSSPseudoElements::PseudoElementSupportsUserActionState(aPseudoType))),
              "should have aPseudoElement only for certain pseudo elements");
 
+  // Remove the Force bits, which we don't need and which could confuse
+  // the remainingReplacements code below.
+  aReplacements &= ~(eRestyle_Force | eRestyle_ForceDescendants);
+
   MOZ_ASSERT(!(aReplacements & ~(eRestyle_CSSTransitions |
                                  eRestyle_CSSAnimations |
                                  eRestyle_SVGAttrAnimations |
                                  eRestyle_StyleAttribute |
-                                 eRestyle_StyleAttribute_Animations |
-                                 eRestyle_Force |
-                                 eRestyle_ForceDescendants)),
+                                 eRestyle_StyleAttribute_Animations)),
              "unexpected replacement bits");
 
-  // FIXME (perf): This should probably not rebuild the whole path, but
-  // only the path from the last change in the rule tree, like
-  // ReplaceAnimationRule in nsStyleSet.cpp does.  (That could then
-  // perhaps share this code, too?)
-  // But if we do that, we'll need to pass whether we are rebuilding the
-  // rule tree from ElementRestyler::RestyleSelf to avoid taking that
-  // path when we're rebuilding the rule tree.
-
   // This array can be hot and often grows to ~20 elements, so inline storage
   // is best.
   AutoTArray<RuleNodeInfo, 30> rules;
-  for (nsRuleNode* ruleNode = aOldRuleNode; !ruleNode->IsRoot();
-       ruleNode = ruleNode->GetParent()) {
-    RuleNodeInfo* curRule = rules.AppendElement();
-    curRule->mRule = ruleNode->GetRule();
-    curRule->mLevel = ruleNode->GetLevel();
-    curRule->mIsImportant = ruleNode->IsImportantRule();
-    curRule->mIsAnimationRule = ruleNode->IsAnimationRule();
+
+  const CascadeLevel* startingLevel = gCascadeLevels;
+  nsRuleNode* startingNode = mRuleTree;
+  if (mInReconstruct) {
+    // Replace the entire path in the rule tree, since the rule tree has
+    // a new root.
+
+    for (nsRuleNode* ruleNode = aOldRuleNode; !ruleNode->IsRoot();
+         ruleNode = ruleNode->GetParent()) {
+      RuleNodeInfo* curRule = rules.AppendElement();
+      curRule->mRule = ruleNode->GetRule();
+      curRule->mLevel = ruleNode->GetLevel();
+      curRule->mIsImportant = ruleNode->IsImportantRule();
+      curRule->mIsAnimationRule = ruleNode->IsAnimationRule();
+    }
+  } else {
+    if (aReplacements == nsRestyleHint(0)) {
+      // Nothing to do.
+      return aOldRuleNode;
+    }
+
+    // Walk up the rule tree from aOldNode to figure out the *part* of
+    // the path in the rule tree that we need to replace.
+
+    nsRestyleHint remainingReplacements = aReplacements;
+    nsRuleNode* ruleNode = aOldRuleNode;
+    for (const CascadeLevel *level = ArrayEnd(gCascadeLevels);
+         level-- != gCascadeLevels; ) {
+      SheetType nodeLevel;
+      bool nodeIsImportant;
+      while (!ruleNode->IsRoot() &&
+             (nodeLevel = ruleNode->GetLevel()) == level->mLevel &&
+             (nodeIsImportant = ruleNode->IsImportantRule()) ==
+               level->mIsImportant) {
+        if (!(level->mLevelReplacementHint & aReplacements)) {
+          RuleNodeInfo* curRule = rules.AppendElement();
+          curRule->mRule = ruleNode->GetRule();
+          curRule->mLevel = nodeLevel;
+          curRule->mIsImportant = nodeIsImportant;
+          curRule->mIsAnimationRule = ruleNode->IsAnimationRule();
+        }
+
+        ruleNode = ruleNode->GetParent();
+      }
+      if (!level->mIsImportant &&
+          (level->mLevelReplacementHint & aReplacements)) {
+        remainingReplacements &= ~level->mLevelReplacementHint;
+        if (remainingReplacements == nsRestyleHint(0)) {
+          // We've found the part of the path in the rule tree we
+          // need to replace.
+          startingLevel = level;
+          startingNode = ruleNode;
+          break;
+        }
+      }
+    }
+    MOZ_ASSERT(remainingReplacements == nsRestyleHint(0),
+               "unexpected replacements (but we safely handle this case by "
+               "falling through to replacing the whole path");
   }
 
   nsRuleWalker ruleWalker(mRuleTree, mAuthorStyleDisabled);
+  ruleWalker.SetCurrentNode(startingNode);
   auto rulesIndex = rules.Length();
 
   // We need to transfer this information between the non-!important and
   // !important phases for the style attribute level.
   nsRuleNode* lastScopedRN = nullptr;
   nsRuleNode* lastStyleAttrRN = nullptr;
   bool haveImportantStyleAttrRules = false;
 
-  for (const CascadeLevel *level = gCascadeLevels,
+  for (const CascadeLevel *level = startingLevel,
                        *levelEnd = ArrayEnd(gCascadeLevels);
        level != levelEnd; ++level) {
 
     bool doReplace = level->mLevelReplacementHint & aReplacements;
 
     ruleWalker.SetLevel(level->mLevel, level->mIsImportant,
                         level->mCheckForImportantRules && doReplace);
 
@@ -1658,16 +1709,18 @@ nsStyleSet::RuleNodeWithReplacement(Elem
       const RuleNodeInfo& ruleInfo = rules[rulesIndex];
 
       if (ruleInfo.mLevel != level->mLevel ||
           ruleInfo.mIsImportant != level->mIsImportant) {
         ++rulesIndex;
         break;
       }
 
+      // When mIsReconstruct is true, we have rules we need to skip in
+      // the array, so we need to test !doReplace here.
       if (!doReplace) {
         ruleWalker.ForwardOnPossiblyCSSRule(ruleInfo.mRule);
         if (ruleInfo.mIsAnimationRule) {
           ruleWalker.CurrentNode()->SetIsAnimationRule();
         }
       }
     }
   }
