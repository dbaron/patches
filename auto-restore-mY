From: L. David Baron <dbaron@dbaron.org>

Use an AutoRestore to restore mY in nsBlockReflowState::FlowAndPlaceFloat.  (Bug 563584)

diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -653,17 +653,19 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
                                       nsReflowStatus& aReflowStatus)
 {
   aReflowStatus = NS_FRAME_COMPLETE;
   // Save away the Y coordinate before placing the float. We will
   // restore mY at the end after placing the float. This is
   // necessary because any adjustments to mY during the float
   // placement are for the float only, not for any non-floating
   // content.
-  nscoord saveY = mY;
+  AutoRestore<nscoord> restoreY(mY);
+  // FIXME: Should give AutoRestore a getter for the value to avoid this.
+  const nscoord saveY = mY;
 
   // Grab the float's display information
   const nsStyleDisplay* floatDisplay = aFloat->GetStyleDisplay();
 
   // The float's old region, so we can propagate damage.
   nsRect oldRegion = nsFloatManager::GetRegionFor(aFloat);
 
   // Enforce CSS2 9.5.1 rule [2], i.e., make sure that a float isn't
@@ -700,17 +702,16 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
 	       "invalid float type");
 
   // Can the float fit here?
   PRBool keepFloatOnSameLine = PR_FALSE;
 
   while (!CanPlaceFloat(floatMarginWidth, floatAvailableSpace)) {
     if (floatAvailableSpace.mRect.height <= 0) {
       // No space, nowhere to put anything.
-      mY = saveY;
       return PR_FALSE;
     }
 
     // Nope. try to advance to the next band.
     if (NS_STYLE_DISPLAY_TABLE != floatDisplay->mDisplay ||
           eCompatibility_NavQuirks != mPresContext->CompatibilityMode() ) {
 
       mY += floatAvailableSpace.mRect.height;
@@ -814,17 +815,16 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
 
   // In the case that we're in columns and not splitting floats, we need
   // to check here that the float's height fit, and if it didn't, bail.
   // (This code is only for DISABLE_FLOAT_BREAKING_IN_COLUMNS .)
   if (aState.mContentArea.height != NS_UNCONSTRAINEDSIZE &&
       adjustedAvailableSpace.height == NS_UNCONSTRAINEDSIZE &&
       aFloat->GetSize().height + floatMargin.TopBottom() >
         mContentArea.height - floatY) {
-    mY = saveY;
     return PR_FALSE;
   }
 
   // Calculate the actual origin of the float frame's border rect
   // relative to the parent block; floatX/Y must be converted from space-manager
   // coordinates to parent coordinates, and the margin must be added in
   // to get the border rect
   nsPoint origin(borderPadding.left + floatMargin.left + floatX,
@@ -879,19 +879,16 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
   nscoord tx, ty;
   mFloatManager->GetTranslation(tx, ty);
   nsFrame::ListTag(stdout, mBlock);
   printf(": FlowAndPlaceFloat: AddFloat: txy=%d,%d (%d,%d) {%d,%d,%d,%d}\n",
          tx, ty, mFloatManagerX, mFloatManagerY,
          region.x, region.y, region.width, region.height);
 #endif
 
-  // Now restore mY
-  mY = saveY;
-
 #ifdef DEBUG
   if (nsBlockFrame::gNoisyReflow) {
     nsRect r = aFloat->GetRect();
     nsFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent);
     printf("placed float: ");
     nsFrame::ListTag(stdout, aFloat);
     printf(" %d,%d,%d,%d\n", r.x, r.y, r.width, r.height);
   }
