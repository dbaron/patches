From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Only consume restyle data for the primary frame.

This is needed for the following patch (FIXME: remove-restyling-phases),
so that when the transition manager posts a restyle to undo the covering
done by the cover rule, that restyle doesn't get consumed by an inner
frame.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -2661,17 +2661,22 @@ ElementRestyler::Restyle(nsRestyleHint a
       // If we're we're resolving from the root of the frame tree (which
       // we do when mDoRebuildAllStyleData), we need to avoid getting the
       // root's restyle data until we get to its primary frame, since
       // it's the primary frame that has the styles for the root element
       // (rather than the ancestors of the primary frame whose mContent
       // is the root node but which have different styles).  If we use
       // up the hint for one of the ancestors that we hit first, then
       // we'll fail to do the restyling we need to do.
-      (mContent->GetParent() || mContent->GetPrimaryFrame() == mFrame)) {
+      // Likewise, if we're restyling something with two nested frames,
+      // and we post a restyle from the transition manager while
+      // computing style for the outer frame (to be computed after the
+      // descendants have been resolved), we don't want to consume it
+      // for the inner frame.
+      mContent->GetPrimaryFrame() == mFrame) {
     mContent->OwnerDoc()->FlushPendingLinkUpdates();
     nsAutoPtr<RestyleTracker::RestyleData> restyleData;
     if (mRestyleTracker.GetRestyleData(mContent->AsElement(), restyleData)) {
       if (NS_UpdateHint(mHintsHandled, restyleData->mChangeHint)) {
         mChangeList->AppendChange(mFrame, mContent, restyleData->mChangeHint);
       }
       hintToRestore = restyleData->mRestyleHint;
       aRestyleHint = nsRestyleHint(aRestyleHint | restyleData->mRestyleHint);
