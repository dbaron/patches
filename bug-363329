diff -r f113a4896d2c layout/tables/BasicTableLayoutStrategy.cpp
--- a/layout/tables/BasicTableLayoutStrategy.cpp	Fri Jan 12 10:38:29 2007 -0800
+++ b/layout/tables/BasicTableLayoutStrategy.cpp	Fri Jan 12 11:10:08 2007 -0800
@@ -46,6 +46,7 @@
 #include "nsTableCellFrame.h"
 #include "nsLayoutUtils.h"
 #include "nsGkAtoms.h"
+#include "SpanningCellSorter.h"
 
 #undef  DEBUG_TABLE_STRATEGY 
 
@@ -221,10 +222,12 @@ BasicTableLayoutStrategy::ComputeColumnI
 BasicTableLayoutStrategy::ComputeColumnIntrinsicWidths(nsIRenderingContext* aRenderingContext)
 {
     nsTableFrame *tableFrame = mTableFrame;
-    float p2t = tableFrame->GetPresContext()->ScaledPixelsToTwips();
+    nsPresContext *presContext = tableFrame->GetPresContext();
+    float p2t = presContext->ScaledPixelsToTwips();
     nsTableCellMap *cellMap = tableFrame->GetCellMap();
 
     nscoord spacing = tableFrame->GetCellSpacingX();
+    SpanningCellSorter spanningCells(presContext->PresShell());
 
     // Loop over the columns to consider the columns and cells *without*
     // a colspan.
@@ -272,8 +275,13 @@ BasicTableLayoutStrategy::ComputeColumnI
             PRInt32 colSpan;
             nsTableCellFrame *cellFrame =
                 cellMap->GetCellInfoAt(row, col, &originates, &colSpan);
-            if (!cellFrame || !originates || colSpan > 1)
+            if (!cellFrame || !originates) {
                 continue;
+            }
+            if (colSpan > 1) {
+                spanningCells.AddCell(colSpan, row, col);
+                continue;
+            }
 
             CellWidthInfo info = GetCellWidthInfo(aRenderingContext, cellFrame);
 
@@ -299,17 +307,17 @@ BasicTableLayoutStrategy::ComputeColumnI
     // (rather than incrementally including the results from spanning
     // cells, or doing spanning and non-spanning cells in a single pass)
     // means that layout remains row-order-invariant.
-    for (col = 0, col_end = cellMap->GetColCount(); col < col_end; ++col) {
-        for (PRInt32 row = 0, row_end = cellMap->GetRowCount();
-             row < row_end; ++row) {
+    SpanningCellSorter::Item *item;
+    while ((item = spanningCells.GetNext())) {
+        do {
+            PRInt32 row = item->row;
+            col = item->col;
             PRBool originates;
             PRInt32 colSpan;
             nsTableCellFrame *cellFrame =
                 cellMap->GetCellInfoAt(row, col, &originates, &colSpan);
-            if (!cellFrame || !originates || colSpan == 1)
-                continue;
-
-            NS_ASSERTION(colSpan > 1, "bad colspan");
+            NS_ASSERTION(cellFrame && originates && colSpan > 1,
+                         "cell shoud not be in spanning cells");
 
             CellWidthInfo info = GetCellWidthInfo(aRenderingContext, cellFrame);
 
@@ -325,11 +333,9 @@ BasicTableLayoutStrategy::ComputeColumnI
                     NS_ERROR("column frames out of sync with cell map");
                     continue;
                 }
-                if (!mTableFrame->GetNumCellsOriginatingInCol(scol)) {
-                   continue;
-                }
-
-                if (scol != col) {
+
+                if (mTableFrame->GetNumCellsOriginatingInCol(scol) &&
+                    scol != col) {
                     info.minCoord -= spacing;
                     info.prefCoord -= spacing;
                 }
@@ -394,50 +400,51 @@ BasicTableLayoutStrategy::ComputeColumnI
                 scolFrame->AddSpanPrefCoord(NSToCoordRound(
                                float(info.prefCoord) * coordRatio));
             }
+        } while ((item = item->next));
+
+        // Combine the results of the span analysis into the main results,
+        // for each increment of colspan.
+
+        // Prevent percentages from adding to more than 100% by (to be
+        // compatible with other browsers) treating any percentages that would
+        // increase the total percentage to more than 100% as the number that
+        // would increase it to only 100% (which is 0% if we've already hit
+        // 100%).  This means layout depends on the order of columns.
+        float pct_used = 0.0f;
+        for (col = 0, col_end = cellMap->GetColCount(); col < col_end; ++col) {
+            nsTableColFrame *colFrame = tableFrame->GetColFrame(col);
+            if (!colFrame) {
+                NS_ERROR("column frames out of sync with cell map");
+                continue;
+            }
+
+            // Since PrefCoord is really a shorthand for two values (XXX
+            // this isn't really a space savings since we have to store
+            // mHasSpecifiedCoord; we should probably just store the values
+            // since it's less confusing) and calling AddMinCoord can
+            // influence the result of GetPrefCoord, save the value as it
+            // was during the loop over spanning cells before messing with
+            // anything.
+            nscoord prefCoord = colFrame->GetPrefCoord();
+            colFrame->AddMinCoord(colFrame->GetMinCoord() +
+                                  colFrame->GetSpanMinCoord());
+            colFrame->AddPrefCoord(prefCoord +
+                                   PR_MAX(colFrame->GetSpanMinCoord(),
+                                          colFrame->GetSpanPrefCoord()),
+                                   colFrame->GetHasSpecifiedCoord());
+            NS_ASSERTION(colFrame->GetMinCoord() <= colFrame->GetPrefCoord(),
+                         "min larger than pref");
+            colFrame->AddPrefPercent(colFrame->GetSpanPrefPercent());
+
+            colFrame->AdjustPrefPercent(&pct_used);
+
+            colFrame->ResetSpanMinCoord();
+            colFrame->ResetSpanPrefCoord();
+            colFrame->ResetSpanPrefPercent();
         }
     }
 #ifdef DEBUG_TABLE_STRATEGY
-    printf("ComputeColumnIntrinsicWidths span incr.\n");
-    mTableFrame->Dump(PR_FALSE, PR_TRUE, PR_FALSE);
-#endif
-
-    // Combine the results of the span analysis into the main results.
-
-    // Prevent percentages from adding to more than 100% by (to be
-    // compatible with other browsers) treating any percentages that would
-    // increase the total percentage to more than 100% as the number that
-    // would increase it to only 100% (which is 0% if we've already hit
-    // 100%).  This means layout depends on the order of columns.
-    float pct_used = 0.0f;
-    for (col = 0, col_end = cellMap->GetColCount(); col < col_end; ++col) {
-        nsTableColFrame *colFrame = tableFrame->GetColFrame(col);
-        if (!colFrame) {
-            NS_ERROR("column frames out of sync with cell map");
-            continue;
-        }
-
-        // Since PrefCoord is really a shorthand for two values (XXX
-        // this isn't really a space savings since we have to store
-        // mHasSpecifiedCoord; we should probably just store the values
-        // since it's less confusing) and calling AddMinCoord can
-        // influence the result of GetPrefCoord, save the value as it
-        // was during the loop over spanning cells before messing with
-        // anything.
-        nscoord prefCoord = colFrame->GetPrefCoord();
-        colFrame->AddMinCoord(colFrame->GetMinCoord() +
-                              colFrame->GetSpanMinCoord());
-        colFrame->AddPrefCoord(prefCoord +
-                               PR_MAX(colFrame->GetSpanMinCoord(),
-                                      colFrame->GetSpanPrefCoord()),
-                               colFrame->GetHasSpecifiedCoord());
-        NS_ASSERTION(colFrame->GetMinCoord() <= colFrame->GetPrefCoord(),
-                     "min larger than pref");
-        colFrame->AddPrefPercent(colFrame->GetSpanPrefPercent());
-
-        colFrame->AdjustPrefPercent(&pct_used);
-    }
-#ifdef DEBUG_TABLE_STRATEGY
-    printf("ComputeColumnIntrinsicWidths adjust\n");
+    printf("ComputeColumnIntrinsicWidths spanning\n");
     mTableFrame->Dump(PR_FALSE, PR_TRUE, PR_FALSE);
 #endif
 }
diff -r f113a4896d2c layout/tables/Makefile.in
--- a/layout/tables/Makefile.in	Fri Jan 12 10:38:29 2007 -0800
+++ b/layout/tables/Makefile.in	Fri Jan 12 11:10:08 2007 -0800
@@ -71,6 +71,7 @@ CPPSRCS		= \
 CPPSRCS		= \
 		BasicTableLayoutStrategy.cpp \
 		FixedTableLayoutStrategy.cpp \
+		SpanningCellSorter.cpp \
 		nsCellMap.cpp \
 		nsTableCellFrame.cpp \
 		nsTableColFrame.cpp \
diff -r f113a4896d2c layout/tables/SpanningCellSorter.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/tables/SpanningCellSorter.cpp	Fri Jan 12 11:22:38 2007 -0800
@@ -0,0 +1,229 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+// vim:cindent:ts=4:et:sw=4:
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla's table layout code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * Code to sort cells by their colspan, used by BasicTableLayoutStrategy.
+ */
+
+#include "SpanningCellSorter.h"
+#include "nsQuickSort.h"
+
+//#define DEBUG_SPANNING_CELL_SORTER
+
+SpanningCellSorter::SpanningCellSorter(nsIPresShell *aPresShell)
+  : mPresShell(aPresShell)
+  , mState(ADDING)
+  , mSortedHashTable(nsnull)
+{
+    memset(mArray, 0, sizeof(mArray));
+    mHashTable.entryCount = 0;
+    mPresShell->PushStackMemory();
+}
+
+SpanningCellSorter::~SpanningCellSorter()
+{
+    if (mHashTable.entryCount) {
+        PL_DHashTableFinish(&mHashTable);
+        mHashTable.entryCount = 0;
+    }
+    delete mSortedHashTable;
+    mPresShell->PopStackMemory();
+}
+
+/* static */ PLDHashTableOps
+SpanningCellSorter::HashTableOps = {
+    PL_DHashAllocTable,
+    PL_DHashFreeTable,
+    HashTableGetKey,
+    HashTableHashKey,
+    HashTableMatchEntry,
+    PL_DHashMoveEntryStub,
+    PL_DHashClearEntryStub,
+    PL_DHashFinalizeStub,
+    nsnull
+};
+
+/* static */ PR_CALLBACK const void*
+SpanningCellSorter::HashTableGetKey(PLDHashTable *table,
+                                    PLDHashEntryHdr *hdr)
+{
+    HashTableEntry *entry = NS_STATIC_CAST(HashTableEntry*, hdr);
+    return NS_INT32_TO_PTR(entry->mColSpan);
+}
+
+/* static */ PR_CALLBACK PLDHashNumber
+SpanningCellSorter::HashTableHashKey(PLDHashTable *table, const void *key)
+{
+    return NS_PTR_TO_INT32(key);
+}
+
+/* static */ PR_CALLBACK PRBool
+SpanningCellSorter::HashTableMatchEntry(PLDHashTable *table,
+                                        const PLDHashEntryHdr *hdr,
+                                        const void *key)
+{
+    const HashTableEntry *entry = NS_STATIC_CAST(const HashTableEntry*, hdr);
+    return NS_PTR_TO_INT32(key) == entry->mColSpan;
+}
+
+PRBool
+SpanningCellSorter::AddCell(PRInt32 aColSpan, PRInt32 aRow, PRInt32 aCol)
+{
+    NS_ASSERTION(mState == ADDING, "cannot call AddCell after GetNext");
+    NS_ASSERTION(aColSpan >= ARRAY_BASE, "cannot add cells with colspan<2");
+
+    Item *i;
+    nsresult rv = mPresShell->AllocateStackMemory(sizeof(Item), (void**)&i);
+    NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+    i->row = aRow;
+    i->col = aCol;
+
+    if (UseArrayForSpan(aColSpan)) {
+        PRInt32 index = SpanToIndex(aColSpan);
+        i->next = mArray[index];
+        mArray[index] = i;
+    } else {
+        if (!mHashTable.entryCount &&
+            !PL_DHashTableInit(&mHashTable, &HashTableOps, nsnull,
+                               sizeof(HashTableEntry), PL_DHASH_MIN_SIZE)) {
+            NS_NOTREACHED("table init failed");
+            mHashTable.entryCount = 0;
+            return PR_FALSE;
+        }
+        HashTableEntry *entry = NS_STATIC_CAST(HashTableEntry*,
+            PL_DHashTableOperate(&mHashTable, NS_INT32_TO_PTR(aColSpan),
+                                 PL_DHASH_ADD));
+        NS_ENSURE_TRUE(entry, PR_FALSE);
+
+        NS_ASSERTION(entry->mColSpan == 0 || entry->mColSpan == aColSpan,
+                     "wrong entry");
+        NS_ASSERTION((entry->mColSpan == 0) == (entry->mItems == nsnull),
+                     "entry should be either new or properly initialized");
+        entry->mColSpan = aColSpan;
+
+        i->next = entry->mItems;
+        entry->mItems = i;
+    }
+
+    return PR_TRUE;
+}
+
+PR_STATIC_CALLBACK(PLDHashOperator)
+FillSortedArray(PLDHashTable *table, PLDHashEntryHdr *hdr,
+                PRUint32 number, void *arg)
+{
+    HashTableEntry *entry = NS_STATIC_CAST(HashTableEntry*, hdr);
+    HashTableEntry **sh = NS_STATIC_CAST(HashTableEntry**, arg);
+
+    sh[number] = entry;
+
+    return PL_DHASH_NEXT;
+}
+
+static int
+SortArray(const void *a, const void *b, void *closure)
+{
+    PRInt32 spanA = (*NS_STATIC_CAST(HashTableEntry*const*, a))->mColSpan;
+    PRInt32 spanB = (*NS_STATIC_CAST(HashTableEntry*const*, b))->mColSpan;
+
+    if (spanA < spanB)
+        return -1;
+    if (spanA == spanB)
+        return 0;
+    return 1;
+}
+
+SpanningCellSorter::Item*
+SpanningCellSorter::GetNext()
+{
+    NS_ASSERTION(mState != DONE, "done enumerating, stop calling");
+
+    switch (mState) {
+        case ADDING:
+            /* prepare to enumerate the array */
+            mState = ENUMERATING_ARRAY;
+            mEnumerationIndex = 0;
+            /* fall through */
+        case ENUMERATING_ARRAY:
+            while (mEnumerationIndex < ARRAY_SIZE && !mArray[mEnumerationIndex])
+                ++mEnumerationIndex;
+            if (mEnumerationIndex < ARRAY_SIZE) {
+                Item *result = mArray[mEnumerationIndex];
+                NS_ASSERTION(result, "logic error");
+#ifdef DEBUG_SPANNING_CELL_SORTER
+                printf("SpanningCellSorter[%p]:"
+                       " returning list for colspan=%d from array\n",
+                       NS_STATIC_CAST(void*, this),
+                       IndexToSpan(mEnumerationIndex));
+#endif
+                ++mEnumerationIndex;
+                return result;
+            }
+            /* prepare to enumerate the hash */
+            mState = ENUMERATING_HASH;
+            mEnumerationIndex = 0;
+            if (mHashTable.entryCount) {
+                HashTableEntry **sh =
+                    new HashTableEntry*[mHashTable.entryCount];
+                PL_DHashTableEnumerate(&mHashTable, FillSortedArray, sh);
+                NS_QuickSort(sh, mHashTable.entryCount, sizeof(sh[0]),
+                             SortArray, nsnull);
+                mSortedHashTable = sh;
+            }
+            /* fall through */
+        case ENUMERATING_HASH:
+            if (mEnumerationIndex < mHashTable.entryCount) {
+                Item *result = mSortedHashTable[mEnumerationIndex]->mItems;
+                NS_ASSERTION(result, "holes in hash table");
+#ifdef DEBUG_SPANNING_CELL_SORTER
+                printf("SpanningCellSorter[%p]:"
+                       " returning list for colspan=%d from hash\n",
+                       NS_STATIC_CAST(void*, this),
+                       mSortedHashTable[mEnumerationIndex]->mColSpan);
+#endif
+                ++mEnumerationIndex;
+                return result;
+            }
+            mState = DONE;
+            /* fall through */
+        case DONE:
+            ;
+    }
+    return nsnull;
+}
diff -r f113a4896d2c layout/tables/SpanningCellSorter.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/tables/SpanningCellSorter.h	Fri Jan 12 11:20:10 2007 -0800
@@ -0,0 +1,114 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+// vim:cindent:ts=4:et:sw=4:
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla's table layout code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * Code to sort cells by their colspan, used by BasicTableLayoutStrategy.
+ */
+
+#include "nsIPresShell.h"
+#include "pldhash.h"
+
+/**
+ * The SpanningCellSorter is responsible for accumulating lists of cells
+ * with colspans so that those cells can later be enumerated, sorted
+ * from lowest number of columns spanned to highest.  It does not use a
+ * stable sort (in fact, it currently reverses).
+ */
+class SpanningCellSorter {
+public:
+    SpanningCellSorter(nsIPresShell *aPresShell);
+    ~SpanningCellSorter();
+
+    struct Item {
+        PRInt32 row, col;
+        Item *next;
+    };
+
+    /**
+     * Add a cell to the sorter.  Returns false on out of memory.
+     * aColSpan is the number of columns spanned, and aRow/aCol are the
+     * position of the cell in the table (for GetCellInfoAt).
+     */
+    PRBool AddCell(PRInt32 aColSpan, PRInt32 aRow, PRInt32 aCol);
+
+    /**
+     * Get the next *list* of cells.  Each list contains all the cells
+     * for a colspan value, and the lists are given in order from lowest
+     * to highest colspan.
+     */
+    Item* GetNext();
+private:
+    nsIPresShell *mPresShell;
+
+    enum State { ADDING, ENUMERATING_ARRAY, ENUMERATING_HASH, DONE };
+    State mState;
+
+    // store small colspans in an array for fast sorting and
+    // enumeration, and large colspans in a hash table
+
+    enum { ARRAY_BASE = 2 };
+    enum { ARRAY_SIZE = 8 };
+    Item *mArray[ARRAY_SIZE];
+    PRInt32 SpanToIndex(PRInt32 aSpan) { return aSpan - ARRAY_BASE; }
+    PRInt32 IndexToSpan(PRInt32 aIndex) { return aIndex + ARRAY_BASE; }
+    PRBool UseArrayForSpan(PRInt32 aSpan) {
+        NS_ASSERTION(SpanToIndex(aSpan) >= 0, "cell without colspan");
+        return SpanToIndex(aSpan) < ARRAY_SIZE;
+    }
+
+    PLDHashTable mHashTable;
+    struct HashTableEntry : public PLDHashEntryHdr {
+        PRInt32 mColSpan;
+        Item *mItems;
+    };
+
+    static PLDHashTableOps HashTableOps;
+
+    PR_STATIC_CALLBACK(const void*)
+        HashTableGetKey(PLDHashTable *table, PLDHashEntryHdr *hdr);
+    PR_STATIC_CALLBACK(PLDHashNumber)
+        HashTableHashKey(PLDHashTable *table, const void *key);
+    PR_STATIC_CALLBACK(PRBool)
+        HashTableMatchEntry(PLDHashTable *table, const PLDHashEntryHdr *hdr,
+                            const void *key);
+
+    /* state used only during enumeration */
+    PRUint32 mEnumerationIndex; // into mArray or mSortedHashTable
+    HashTableEntry **mSortedHashTable;
+};
+
