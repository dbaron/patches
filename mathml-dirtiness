Remove the aBits parameter from ReLayoutChildren, given that what it does blows away the distinction between NS_FRAME_IS_DIRTY and NS_FRAME_HAS_DIRTY_CHILDREN.  (Bug 477294)

diff --git a/layout/mathml/base/src/nsMathMLContainerFrame.cpp b/layout/mathml/base/src/nsMathMLContainerFrame.cpp
--- a/layout/mathml/base/src/nsMathMLContainerFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLContainerFrame.cpp
@@ -709,18 +709,17 @@ nsMathMLContainerFrame::RebuildAutomatic
   }
   nsIMathMLFrame* mathMLFrame = do_QueryFrame(aParentFrame);
   if (mathMLFrame) {
     mathMLFrame->TransmitAutomaticData();
   }
 }
 
 /* static */ nsresult
-nsMathMLContainerFrame::ReLayoutChildren(nsIFrame* aParentFrame,
-                                         nsFrameState aBits)
+nsMathMLContainerFrame::ReLayoutChildren(nsIFrame* aParentFrame)
 {
   if (!aParentFrame)
     return NS_OK;
 
   // walk-up to the first frame that is a MathML frame, stop if we reach <math>
   nsIFrame* frame = aParentFrame;
   while (1) {
      nsIFrame* parent = frame->GetParent();
@@ -738,32 +737,35 @@ nsMathMLContainerFrame::ReLayoutChildren
     if (!content)
       break;
     // XXXldb This should check namespaces too.
     if (content->Tag() == nsGkAtoms::math)
       break;
 
     // mark the frame dirty, and continue to climb up.  It's important that
     // we're NOT doing this to the frame we plan to pass to FrameNeedsReflow()
+    // XXXldb Why do we need to bother with this?  Marking ancestor
+    // dirty (which we do below) should do a superset of the work this
+    // does.
     frame->AddStateBits(NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN);
 
     frame = parent;
   }
 
   // re-sync the presentation data and embellishment data of our children
   RebuildAutomaticDataForChildren(frame);
 
   // Ask our parent frame to reflow us
   nsIFrame* parent = frame->GetParent();
   NS_ASSERTION(parent, "No parent to pass the reflow request up to");
   if (!parent)
     return NS_OK;
 
   return frame->PresContext()->PresShell()->
-    FrameNeedsReflow(frame, nsIPresShell::eStyleChange, aBits);
+    FrameNeedsReflow(frame, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
 }
 
 // There are precise rules governing children of a MathML frame,
 // and properties such as the scriptlevel depends on those rules.
 // Hence for things to work, callers must use Append/Insert/etc wisely.
 
 nsresult
 nsMathMLContainerFrame::ChildListChanged(PRInt32 aModType)
@@ -777,20 +779,23 @@ nsMathMLContainerFrame::ChildListChanged
     nsEmbellishData embellishData;
     for ( ; parent; frame = parent, parent = parent->GetParent()) {
       GetEmbellishDataFrom(parent, embellishData);
       if (embellishData.coreFrame != mEmbellishData.coreFrame)
         break;
 
       // Important: do not do this to the frame we plan to pass to
       // ReLayoutChildren
+      // XXXldb Why do we need to bother with this?  Marking ancestor
+      // dirty (which we do below) should do a superset of the work this
+      // does.
       frame->AddStateBits(NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN);
     }
   }
-  return ReLayoutChildren(frame, NS_FRAME_IS_DIRTY);
+  return ReLayoutChildren(frame);
 }
 
 NS_IMETHODIMP
 nsMathMLContainerFrame::AppendFrames(nsIAtom*        aListName,
                                      nsIFrame*       aFrameList)
 {
   if (aListName) {
     return NS_ERROR_INVALID_ARG;
diff --git a/layout/mathml/base/src/nsMathMLContainerFrame.h b/layout/mathml/base/src/nsMathMLContainerFrame.h
--- a/layout/mathml/base/src/nsMathMLContainerFrame.h
+++ b/layout/mathml/base/src/nsMathMLContainerFrame.h
@@ -348,17 +348,17 @@ public:
   // the ancestor that is a MathML frame, and re-layout from there -- this is
   // to guarantee that automatic data will be rebuilt properly. Note that this
   // method re-builds the automatic data in the children -- not in the parent
   // frame itself (except for those particular operations that the parent frame
   // may do do its TransmitAutomaticData()). @see RebuildAutomaticDataForChildren
   //
   // aBits are the bits to pass to FrameNeedsReflow() when we call it.
   static nsresult
-  ReLayoutChildren(nsIFrame* aParentFrame, nsFrameState aBits);
+  ReLayoutChildren(nsIFrame* aParentFrame);
 
 protected:
   // Helper method which positions child frames as an <mrow> on given baseline
   // y = aBaseline starting from x = aOffsetX, calling FinishReflowChild()
   // on the frames.
   void
   PositionRowChildFrames(nscoord aOffsetX, nscoord aBaseline);
 
@@ -410,45 +410,42 @@ public:
   NS_IMETHOD
   AppendFrames(nsIAtom*        aListName,
                nsIFrame*       aFrameList)
   {
     NS_ASSERTION(!aListName || nsGkAtoms::nextBidi == aListName,
                  "unexpected frame list");
     nsresult rv = nsBlockFrame::AppendFrames(aListName, aFrameList);
     if (NS_LIKELY(!aListName))
-      nsMathMLContainerFrame::ReLayoutChildren(this,
-                                               NS_FRAME_HAS_DIRTY_CHILDREN);
+      nsMathMLContainerFrame::ReLayoutChildren(this);
     return rv;
   }
 
   NS_IMETHOD
   InsertFrames(nsIAtom*        aListName,
                nsIFrame*       aPrevFrame,
                nsIFrame*       aFrameList)
   {
     NS_ASSERTION(!aListName || nsGkAtoms::nextBidi == aListName,
                  "unexpected frame list");
     nsresult rv = nsBlockFrame::InsertFrames(aListName, aPrevFrame, aFrameList);
     if (NS_LIKELY(!aListName))
-      nsMathMLContainerFrame::ReLayoutChildren(this,
-                                               NS_FRAME_HAS_DIRTY_CHILDREN);
+      nsMathMLContainerFrame::ReLayoutChildren(this);
     return rv;
   }
 
   NS_IMETHOD
   RemoveFrame(nsIAtom*        aListName,
               nsIFrame*       aOldFrame)
   {
     NS_ASSERTION(!aListName || nsGkAtoms::nextBidi == aListName,
                  "unexpected frame list");
     nsresult rv = nsBlockFrame::RemoveFrame(aListName, aOldFrame);
     if (NS_LIKELY(!aListName))
-      nsMathMLContainerFrame::ReLayoutChildren(this,
-                                               NS_FRAME_HAS_DIRTY_CHILDREN);
+      nsMathMLContainerFrame::ReLayoutChildren(this);
     return rv;
   }
 
   virtual PRBool IsFrameOfType(PRUint32 aFlags) const {
     return nsBlockFrame::IsFrameOfType(aFlags &
               ~(nsIFrame::eMathML | nsIFrame::eExcludesIgnorableWhitespace));
   }
 
@@ -481,45 +478,42 @@ public:
   NS_IMETHOD
   AppendFrames(nsIAtom*        aListName,
                nsIFrame*       aFrameList)
   {
     NS_ASSERTION(!aListName || nsGkAtoms::nextBidi == aListName,
                  "unexpected frame list");
     nsresult rv = nsInlineFrame::AppendFrames(aListName, aFrameList);
     if (NS_LIKELY(!aListName))
-      nsMathMLContainerFrame::ReLayoutChildren(this,
-                                               NS_FRAME_HAS_DIRTY_CHILDREN);
+      nsMathMLContainerFrame::ReLayoutChildren(this);
     return rv;
   }
 
   NS_IMETHOD
   InsertFrames(nsIAtom*        aListName,
                nsIFrame*       aPrevFrame,
                nsIFrame*       aFrameList)
   {
     NS_ASSERTION(!aListName || nsGkAtoms::nextBidi == aListName,
                  "unexpected frame list");
     nsresult rv = nsInlineFrame::InsertFrames(aListName, aPrevFrame, aFrameList);
     if (NS_LIKELY(!aListName))
-      nsMathMLContainerFrame::ReLayoutChildren(this,
-                                               NS_FRAME_HAS_DIRTY_CHILDREN);
+      nsMathMLContainerFrame::ReLayoutChildren(this);
     return rv;
   }
 
   NS_IMETHOD
   RemoveFrame(nsIAtom*        aListName,
               nsIFrame*       aOldFrame)
   {
     NS_ASSERTION(!aListName || nsGkAtoms::nextBidi == aListName,
                  "unexpected frame list");
     nsresult rv = nsInlineFrame::RemoveFrame(aListName, aOldFrame);
     if (NS_LIKELY(!aListName))
-      nsMathMLContainerFrame::ReLayoutChildren(this,
-                                               NS_FRAME_HAS_DIRTY_CHILDREN);
+      nsMathMLContainerFrame::ReLayoutChildren(this);
     return rv;
   }
 
   virtual PRBool IsFrameOfType(PRUint32 aFlags) const {
       return nsInlineFrame::IsFrameOfType(aFlags &
                 ~(nsIFrame::eMathML | nsIFrame::eExcludesIgnorableWhitespace));
   }
 
diff --git a/layout/mathml/base/src/nsMathMLmoFrame.cpp b/layout/mathml/base/src/nsMathMLmoFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmoFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmoFrame.cpp
@@ -1032,17 +1032,17 @@ nsMathMLmoFrame::AttributeChanged(PRInt3
     nsIFrame* target = this;
     nsEmbellishData embellishData;
     do {
       target = target->GetParent();
       GetEmbellishDataFrom(target, embellishData);
     } while (embellishData.coreFrame == this);
 
     // we have automatic data to update in the children of the target frame
-    return ReLayoutChildren(target, NS_FRAME_IS_DIRTY);
+    return ReLayoutChildren(target);
   }
 
   return nsMathMLTokenFrame::
          AttributeChanged(aNameSpaceID, aAttribute, aModType);
 }
 
 // ----------------------
 // No need to tract the style context given to our MathML char. 
diff --git a/layout/mathml/base/src/nsMathMLmoverFrame.cpp b/layout/mathml/base/src/nsMathMLmoverFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmoverFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmoverFrame.cpp
@@ -69,17 +69,17 @@ nsMathMLmoverFrame::~nsMathMLmoverFrame(
 NS_IMETHODIMP
 nsMathMLmoverFrame::AttributeChanged(PRInt32         aNameSpaceID,
                                      nsIAtom*        aAttribute,
                                      PRInt32         aModType)
 {
   if (nsGkAtoms::accent_ == aAttribute) {
     // When we have automatic data to update within ourselves, we ask our
     // parent to re-layout its children
-    return ReLayoutChildren(mParent, NS_FRAME_IS_DIRTY);
+    return ReLayoutChildren(mParent);
   }
 
   return nsMathMLContainerFrame::
          AttributeChanged(aNameSpaceID, aAttribute, aModType);
 }
 
 NS_IMETHODIMP
 nsMathMLmoverFrame::UpdatePresentationData(PRUint32        aFlagsValues,
diff --git a/layout/mathml/base/src/nsMathMLmstyleFrame.cpp b/layout/mathml/base/src/nsMathMLmstyleFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmstyleFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmstyleFrame.cpp
@@ -130,10 +130,10 @@ nsMathMLmstyleFrame::AttributeChanged(PR
                                       nsIAtom*        aAttribute,
                                       PRInt32         aModType)
 {
   // Other attributes can affect too many things, ask our parent to re-layout
   // its children so that we can pick up changes in our attributes & transmit
   // them in our subtree. However, our siblings will be re-laid too. We used
   // to have a more speedier but more verbose alternative that didn't re-layout
   // our siblings. See bug 114909 - attachment 67668.
-  return ReLayoutChildren(mParent, NS_FRAME_IS_DIRTY);
+  return ReLayoutChildren(mParent);
 }
diff --git a/layout/mathml/base/src/nsMathMLmunderFrame.cpp b/layout/mathml/base/src/nsMathMLmunderFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmunderFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmunderFrame.cpp
@@ -69,17 +69,17 @@ nsMathMLmunderFrame::~nsMathMLmunderFram
 NS_IMETHODIMP
 nsMathMLmunderFrame::AttributeChanged(PRInt32         aNameSpaceID,
                                       nsIAtom*        aAttribute,
                                       PRInt32         aModType)
 {
   if (nsGkAtoms::accentunder_ == aAttribute) {
     // When we have automatic data to update within ourselves, we ask our
     // parent to re-layout its children
-    return ReLayoutChildren(mParent, NS_FRAME_IS_DIRTY);
+    return ReLayoutChildren(mParent);
   }
 
   return nsMathMLContainerFrame::
          AttributeChanged(aNameSpaceID, aAttribute, aModType);
 }
 
 NS_IMETHODIMP
 nsMathMLmunderFrame::UpdatePresentationData(PRUint32        aFlagsValues,
diff --git a/layout/mathml/base/src/nsMathMLmunderoverFrame.cpp b/layout/mathml/base/src/nsMathMLmunderoverFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmunderoverFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmunderoverFrame.cpp
@@ -70,17 +70,17 @@ NS_IMETHODIMP
 nsMathMLmunderoverFrame::AttributeChanged(PRInt32         aNameSpaceID,
                                           nsIAtom*        aAttribute,
                                           PRInt32         aModType)
 {
   if (nsGkAtoms::accent_ == aAttribute ||
       nsGkAtoms::accentunder_ == aAttribute) {
     // When we have automatic data to update within ourselves, we ask our
     // parent to re-layout its children
-    return ReLayoutChildren(mParent, NS_FRAME_IS_DIRTY);
+    return ReLayoutChildren(mParent);
   }
 
   return nsMathMLContainerFrame::
          AttributeChanged(aNameSpaceID, aAttribute, aModType);
 }
 
 NS_IMETHODIMP
 nsMathMLmunderoverFrame::UpdatePresentationData(PRUint32        aFlagsValues,
