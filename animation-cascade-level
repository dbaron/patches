From: L. David Baron <dbaron@dbaron.org>

Lower the level in the cascade of animations.

diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -417,16 +417,78 @@ template<class T>
 static PRBool
 EnumRulesMatching(nsIStyleRuleProcessor* aProcessor, void* aData)
 {
   T* data = static_cast<T*>(aData);
   aProcessor->RulesMatching(data);
   return PR_TRUE;
 }
 
+inline bool
+IsMoreSpecificThanAnimation(nsRuleNode *aRuleNode)
+{
+  return !aRuleNode->IsRoot() &&
+         (aRuleNode->GetLevel() == nsStyleSet::eTransitionSheet ||
+          (aRuleNode->IsImportantRule() &&
+           (aRuleNode->GetLevel() == nsStyleSet::eAgentSheet ||
+            aRuleNode->GetLevel() == nsStyleSet::eUserSheet)));
+}
+
+static nsIStyleRule*
+GetAnimationRule(nsRuleNode *aRuleNode)
+{
+  nsRuleNode *n = aRuleNode;
+  while (IsMoreSpecificThanAnimation(n)) {
+    n = n->GetParent();
+  }
+
+  if (n->IsRoot() || n->GetLevel() != nsStyleSet::eAnimationSheet) {
+    return nsnull;
+  }
+
+  return n->GetRule();
+}
+
+static nsRuleNode*
+ReplaceAnimationRule(nsRuleNode *aOldRuleNode,
+                     nsIStyleRule *aOldAnimRule,
+                     nsIStyleRule *aNewAnimRule)
+{
+  nsTArray<nsRuleNode*> moreSpecificNodes;
+
+  nsRuleNode *n = aOldRuleNode;
+  while (IsMoreSpecificThanAnimation(n)) {
+    moreSpecificNodes.AppendElement(n);
+    n = n->GetParent();
+  }
+
+  if (aOldAnimRule) {
+    NS_ABORT_IF_FALSE(n->GetRule() == aOldAnimRule, "wrong rule");
+    NS_ABORT_IF_FALSE(n->GetLevel() == nsStyleSet::eAnimationSheet,
+                      "wrong level");
+    n = n->GetParent();
+  }
+
+  NS_ABORT_IF_FALSE(!IsMoreSpecificThanAnimation(n) &&
+                    n->GetLevel() != nsStyleSet::eAnimationSheet,
+                    "wrong level");
+
+  if (aNewAnimRule) {
+    n = n->Transition(aNewAnimRule, nsStyleSet::eAnimationSheet, PR_FALSE);
+  }
+
+  for (PRUint32 i = moreSpecificNodes.Length(); i-- != 0; ) {
+    nsRuleNode *oldNode = moreSpecificNodes[i];
+    n = n->Transition(oldNode->GetRule(), oldNode->GetLevel(),
+                      oldNode->IsImportantRule());
+  }
+
+  return n;
+}
+
 /**
  * |GetContext| implements sharing of style contexts (not just the data
  * on the rule nodes) between siblings and cousins of the same
  * generation.  (It works for cousins of the same generation since
  * |aParentContext| could itself be a shared context.)
  */
 already_AddRefed<nsStyleContext>
 nsStyleSet::GetContext(nsStyleContext* aParentContext,
@@ -526,50 +588,33 @@ nsStyleSet::GetContext(nsStyleContext* a
   }
 
 #ifdef MOZ_CSS_ANIMATIONS
   if (aDoAnimations) {
     // Normally the animation manager has already added the correct
     // style rule.  However, if the animation-name just changed, it
     // might have been wrong.  So ask it to double-check based on the
     // resulting style context.
+    nsIStyleRule *oldAnimRule = GetAnimationRule(aRuleNode);
     nsIStyleRule *animRule = PresContext()->AnimationManager()->
       CheckAnimationRule(result, aElementForAnimation);
-    bool rerun;
     NS_ABORT_IF_FALSE(result->GetRuleNode() == aRuleNode,
                       "unexpected rule node");
     NS_ABORT_IF_FALSE(!result->GetStyleIfVisited() == !aVisitedRuleNode,
                       "unexpected visited rule node");
     NS_ABORT_IF_FALSE(!aVisitedRuleNode ||
                       result->GetStyleIfVisited()->GetRuleNode() ==
                         aVisitedRuleNode,
                       "unexpected visited rule node");
-    if (animRule) {
-      rerun = aRuleNode->GetRule() != animRule;
-    } else {
-      rerun = !aRuleNode->IsRoot() && aRuleNode->GetLevel() == eAnimationSheet;
-    }
-    if (rerun) {
-      nsRuleNode *ruleNode = (aRuleNode->GetLevel() == eAnimationSheet)
-                               ? aRuleNode->GetParent() : aRuleNode;
-      if (animRule) {
-        ruleNode = ruleNode->Transition(animRule, eAnimationSheet, PR_FALSE);
-      }
-
-      nsRuleNode *visitedRuleNode;
-      if (aVisitedRuleNode) {
-        visitedRuleNode = (aVisitedRuleNode->GetLevel() == eAnimationSheet)
-                            ? aVisitedRuleNode->GetParent() : aVisitedRuleNode;
-        if (animRule) {
-          ruleNode = visitedRuleNode->Transition(animRule, eAnimationSheet,
-                                                 PR_FALSE);
-        }
-      } else {
-        visitedRuleNode = nsnull;
-      }
+    if (oldAnimRule != animRule) {
+      nsRuleNode *ruleNode =
+        ReplaceAnimationRule(aRuleNode, oldAnimRule, animRule);
+      nsRuleNode *visitedRuleNode = aVisitedRuleNode
+        ? ReplaceAnimationRule(aVisitedRuleNode, oldAnimRule, animRule)
+        : nsnull;
       result = GetContext(aParentContext, ruleNode, visitedRuleNode,
                           aIsLink, aIsVisitedLink,
                           aPseudoTag, aPseudoType, PR_FALSE, nsnull);
     }
   }
 #endif
 
   return result.forget();
@@ -644,18 +689,20 @@ nsStyleSet::FileRules(nsIStyleRuleProces
   // [least important]
   //  1. UA normal rules                    = Agent        normal
   //  2. User normal rules                  = User         normal
   //  3. Presentation hints                 = PresHint     normal
   //  4. Author normal rules                = Document     normal
   //  5. Override normal rules              = Override     normal
   //  6. Author !important rules            = Document     !important
   //  7. Override !important rules          = Override     !important
+  //  -. animation rules                    = Animation    normal
   //  8. User !important rules              = User         !important
   //  9. UA !important rules                = Agent        !important
+  //  -. transition rules                   = Transition   normal
   // [most important]
 
   aRuleWalker->SetLevel(eAgentSheet, PR_FALSE, PR_TRUE);
   if (mRuleProcessors[eAgentSheet])
     (*aCollectorFunc)(mRuleProcessors[eAgentSheet], aData);
   nsRuleNode* lastAgentRN = aRuleWalker->CurrentNode();
   PRBool haveImportantUARules = !aRuleWalker->GetCheckForImportantRules();
 
@@ -711,16 +758,22 @@ nsStyleSet::FileRules(nsIStyleRuleProces
     AddImportantRules(lastOvrRN, lastDocRN, aRuleWalker);  // override
   }
 #ifdef DEBUG
   else {
     AssertNoImportantRules(lastOvrRN, lastDocRN);
   }
 #endif
 
+#ifdef MOZ_CSS_ANIMATIONS
+  // This needs to match IsMoreSpecificThanAnimation() above.
+  aRuleWalker->SetLevel(eAnimationSheet, PR_FALSE, PR_FALSE);
+  (*aCollectorFunc)(mRuleProcessors[eAnimationSheet], aData);
+#endif
+
 #ifdef DEBUG
   AssertNoCSSRules(lastPresHintRN, lastUserRN);
   AssertNoImportantRules(lastPresHintRN, lastUserRN); // preshints
 #endif
 
   if (haveImportantUserRules) {
     aRuleWalker->SetLevel(eUserSheet, PR_TRUE, PR_FALSE);
     AddImportantRules(lastUserRN, lastAgentRN, aRuleWalker); //user
@@ -741,21 +794,16 @@ nsStyleSet::FileRules(nsIStyleRuleProces
   }
 #endif
 
 #ifdef DEBUG
   nsRuleNode *lastImportantRN = aRuleWalker->CurrentNode();
 #endif
   aRuleWalker->SetLevel(eTransitionSheet, PR_FALSE, PR_FALSE);
   (*aCollectorFunc)(mRuleProcessors[eTransitionSheet], aData);
-#ifdef MOZ_CSS_ANIMATIONS
-  // GetContext() depends on the animation rules being *last*
-  aRuleWalker->SetLevel(eAnimationSheet, PR_FALSE, PR_FALSE);
-  (*aCollectorFunc)(mRuleProcessors[eAnimationSheet], aData);
-#endif
 #ifdef DEBUG
   AssertNoCSSRules(aRuleWalker->CurrentNode(), lastImportantRN);
   AssertNoImportantRules(aRuleWalker->CurrentNode(), lastImportantRN);
 #endif
 
 }
 
 // Enumerate all the rules in a way that doesn't care about the order
@@ -786,21 +834,20 @@ nsStyleSet::WalkRuleProcessors(nsIStyleR
   }
   if (!skipUserStyles && !cutOffInheritance &&
       mRuleProcessors[eDocSheet]) // NOTE: different
     (*aFunc)(mRuleProcessors[eDocSheet], aData);
   if (mRuleProcessors[eStyleAttrSheet])
     (*aFunc)(mRuleProcessors[eStyleAttrSheet], aData);
   if (mRuleProcessors[eOverrideSheet])
     (*aFunc)(mRuleProcessors[eOverrideSheet], aData);
-  (*aFunc)(mRuleProcessors[eTransitionSheet], aData);
 #ifdef MOZ_CSS_ANIMATIONS
-  // GetContext depends on the animation rule being *last*
   (*aFunc)(mRuleProcessors[eAnimationSheet], aData);
 #endif
+  (*aFunc)(mRuleProcessors[eTransitionSheet], aData);
 }
 
 PRBool nsStyleSet::BuildDefaultStyleData(nsPresContext* aPresContext)
 {
   NS_ASSERTION(!mDefaultStyleData.mResetData &&
                !mDefaultStyleData.mInheritedData,
                "leaking default style data");
   mDefaultStyleData.mResetData = new (aPresContext) nsResetStyleData;
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -238,20 +238,20 @@ class nsStyleSet
   // highest (for non-!important rules).
   enum sheetType {
     eAgentSheet, // CSS
     eUserSheet, // CSS
     ePresHintSheet,
     eDocSheet, // CSS
     eStyleAttrSheet,
     eOverrideSheet, // CSS
-    eTransitionSheet,
 #ifdef MOZ_CSS_ANIMATIONS
     eAnimationSheet,
 #endif
+    eTransitionSheet,
     eSheetTypeCount
     // be sure to keep the number of bits in |mDirty| below and in
     // NS_RULE_NODE_LEVEL_MASK updated when changing the number of sheet
     // types
   };
 
   // APIs to manipulate the style sheet lists.  The sheets in each
   // list are stored with the most significant sheet last.
