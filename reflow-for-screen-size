From: L. David Baron <dbaron@dbaron.org>

Reflow for screen size change when font.size.inflation.minTwips is set.  (Bug 747231, patch 3)

diff --git a/dom/base/nsDOMWindowUtils.cpp b/dom/base/nsDOMWindowUtils.cpp
--- a/dom/base/nsDOMWindowUtils.cpp
+++ b/dom/base/nsDOMWindowUtils.cpp
@@ -278,16 +278,29 @@ nsDOMWindowUtils::SetCSSViewport(float a
 
 static void DestroyNsRect(void* aObject, nsIAtom* aPropertyName,
                           void* aPropertyValue, void* aData)
 {
   nsRect* rect = static_cast<nsRect*>(aPropertyValue);
   delete rect;
 }
 
+static void
+ReflowAllRootframes(nsPresContext* aPresContext)
+{
+  nsIPresShell *shell = aPresContext->GetShell();
+  nsIFrame *rootFrame = shell->GetRootFrame();
+  if (rootFrame) {
+    shell->FrameNeedsReflow(rootFrame, nsIPresShell::eResize,
+                            NS_FRAME_IS_DIRTY);
+  }
+
+  // FIXME: Do descendant frame trees (inside iframes, etc.).
+}
+
 NS_IMETHODIMP
 nsDOMWindowUtils::SetDisplayPortForElement(float aXPx, float aYPx,
                                            float aWidthPx, float aHeightPx,
                                            nsIDOMElement* aElement)
 {
   if (!IsUniversalXPConnectCapable()) {
     return NS_ERROR_DOM_SECURITY_ERR;
   }
@@ -327,21 +340,39 @@ nsDOMWindowUtils::SetDisplayPortForEleme
 
   nsIFrame* rootScrollFrame = presShell->GetRootScrollFrame();
   if (rootScrollFrame) {
     if (content == rootScrollFrame->GetContent()) {
       // We are setting a root displayport for a document.
       // The pres shell needs a special flag set.
       presShell->SetIgnoreViewportScrolling(true);
 
+      nsPresContext* presContext = GetPresContext();
+
+      // When the "font.size.inflation.minTwips" preference is set, the
+      // layout depends on the size of the screen.  Since when the size
+      // of the screen changes, the root displayport also changes, we
+      // hook in the needed updates here rather than adding a
+      // separate notification just for this change.
+      if (presContext &&
+          nsLayoutUtils::FontSizeInflationEnabled(presContext) &&
+          nsLayoutUtils::FontSizeInflationMinTwips() != 0) {
+        bool changed;
+        presContext->ScreenWidthInchesForFontInflation(&changed);
+        if (changed) {
+          // Is asynchronous reflow ok?  It certainly has advantages (in
+          // terms of coalescing).
+          ReflowAllRootFrames(presContext);
+        }
+      }
+
       // The root document currently has a widget, but we might end up
       // painting content inside the displayport but outside the widget
       // bounds. This ensures the document's view honors invalidations
       // within the displayport.
-      nsPresContext* presContext = GetPresContext();
       if (presContext && presContext->IsRoot()) {
         nsIFrame* rootFrame = presShell->GetRootFrame();
         nsIView* view = rootFrame->GetView();
         if (view) {
           view->SetInvalidationDimensions(&displayport);
         }
       }
     }
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -127,18 +127,18 @@ using namespace mozilla::layout;
 #ifdef DEBUG
 // TODO: remove, see bug 598468.
 bool nsLayoutUtils::gPreventAssertInCompareTreePosition = false;
 #endif // DEBUG
 
 typedef gfxPattern::GraphicsFilter GraphicsFilter;
 typedef FrameMetrics::ViewID ViewID;
 
-static PRUint32 sFontSizeInflationEmPerLine;
-static PRUint32 sFontSizeInflationMinTwips;
+/* static */ PRUint32 nsLayoutUtils::sFontSizeInflationEmPerLine;
+/* static */ PRUint32 nsLayoutUtils::sFontSizeInflationMinTwips;
 /* static */ PRUint32 nsLayoutUtils::sFontSizeInflationLineThreshold;
 
 static ViewID sScrollIdCounter = FrameMetrics::START_SCROLL_ID;
 
 typedef nsDataHashtable<nsUint64HashKey, nsIContent*> ContentMap;
 static ContentMap* sContentMap = NULL;
 static ContentMap& GetContentMap() {
   if (!sContentMap) {
@@ -4652,36 +4652,38 @@ nsReflowFrameRunnable::Run()
 /**
  * Compute the minimum font size inside of a container with the given
  * width, such that **when the user zooms the container to fill the full
  * width of the device**, the fonts satisfy our minima.
  */
 static nscoord
 MinimumFontSizeFor(nsPresContext* aPresContext, nscoord aContainerWidth)
 {
-  if (sFontSizeInflationEmPerLine == 0 && sFontSizeInflationMinTwips == 0) {
+  PRUint32 emPerLine = nsLayoutUtils::FontSizeInflationEmPerLine();
+  PRUint32 minTwips = nsLayoutUtils::FontSizeInflationMinTwips();
+  if (emPerLine == 0 && minTwips == 0) {
     return 0;
   }
 
   // Clamp the container width to the device dimensions
   nscoord iFrameWidth = aPresContext->GetVisibleArea().width;
   nscoord effectiveContainerWidth = NS_MIN(iFrameWidth, aContainerWidth);
 
   nscoord byLine = 0, byInch = 0;
-  if (sFontSizeInflationEmPerLine != 0) {
-    byLine = effectiveContainerWidth / sFontSizeInflationEmPerLine;
-  }
-  if (sFontSizeInflationMinTwips != 0) {
+  if (emPerLine != 0) {
+    byLine = effectiveContainerWidth / emPerLine;
+  }
+  if (minTwips != 0) {
     // REVIEW: Is this giving us app units and sizes *not* counting
     // viewport scaling?
     float deviceWidthInches =
       aPresContext->ScreenWidthInchesForFontInflation();
     byInch = NSToCoordRound(effectiveContainerWidth /
                             (deviceWidthInches * 1440 /
-                             sFontSizeInflationMinTwips ));
+                             minTwips ));
   }
   return NS_MAX(byLine, byInch);
 }
 
 /* static */ float
 nsLayoutUtils::FontSizeInflationInner(const nsIFrame *aFrame,
                                       nscoord aMinFontSize)
 {
diff --git a/layout/base/nsLayoutUtils.h b/layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h
+++ b/layout/base/nsLayoutUtils.h
@@ -1548,16 +1548,32 @@ public:
    *   InflationMinFontSizeFor methods above.
    */
   static float FontSizeInflationInner(const nsIFrame *aFrame,
                                       nscoord aMinFontSize);
 
   static bool FontSizeInflationEnabled(nsPresContext *aPresContext);
 
   /**
+   * See comment above "font.size.inflation.emPerLine" in
+   * modules/libpref/src/init/all.js .
+   */
+  static PRUint32 FontSizeInflationEmPerLine() {
+    return sFontSizeInflationEmPerLine;
+  }
+
+  /**
+   * See comment above "font.size.inflation.minTwips" in
+   * modules/libpref/src/init/all.js .
+   */
+  static PRUint32 FontSizeInflationMinTwips() {
+    return sFontSizeInflationMinTwips;
+  }
+
+  /**
    * See comment above "font.size.inflation.lineThreshold" in
    * modules/libpref/src/init/all.js .
    */
   static PRUint32 FontSizeInflationLineThreshold() {
     return sFontSizeInflationLineThreshold;
   }
 
   static void Initialize();
@@ -1635,16 +1651,18 @@ public:
    * Assert that the frame tree rooted at |aSubtreeRoot| is empty, i.e.,
    * that it contains no first-in-flows.
    */
   static void
   AssertTreeOnlyEmptyNextInFlows(nsIFrame *aSubtreeRoot);
 #endif
 
 private:
+  static PRUint32 sFontSizeInflationEmPerLine;
+  static PRUint32 sFontSizeInflationMinTwips;
   static PRUint32 sFontSizeInflationLineThreshold;
 };
 
 namespace mozilla {
   namespace layout {
 
     /**
      * An RAII class which will, for the duration of its lifetime,
