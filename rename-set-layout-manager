From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsIFrame::SetLayoutManager to SetXULLayoutManager.  r?dholbert

Written purely with sed, over .h and .cpp files in layout/.

MozReview-Commit-ID: FuOaNWfROKV

diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -1003,17 +1003,17 @@ NS_NewXULScrollFrame(nsIPresShell* aPres
 
 NS_IMPL_FRAMEARENA_HELPERS(nsXULScrollFrame)
 
 nsXULScrollFrame::nsXULScrollFrame(nsStyleContext* aContext,
                                    bool aIsRoot, bool aClipAllDescendants)
   : nsBoxFrame(aContext, aIsRoot),
     mHelper(ALLOW_THIS_IN_INITIALIZER_LIST(this), aIsRoot)
 {
-  SetLayoutManager(nullptr);
+  SetXULLayoutManager(nullptr);
   mHelper.mClipAllDescendants = aClipAllDescendants;
 }
 
 void
 nsXULScrollFrame::ScrollbarActivityStarted() const
 {
   if (mHelper.mScrollbarActivity) {
     mHelper.mScrollbarActivity->ActivityStarted();
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2911,17 +2911,17 @@ public:
                             bool aRemoveOverflowAreas = false) = 0;
   nsresult XULLayout(nsBoxLayoutState& aBoxLayoutState);
   // Box methods.  Note that these do NOT just get the CSS border, padding,
   // etc.  They also talk to nsITheme.
   virtual nsresult GetXULBorderAndPadding(nsMargin& aBorderAndPadding);
   virtual nsresult GetXULBorder(nsMargin& aBorder)=0;
   virtual nsresult GetXULPadding(nsMargin& aBorderAndPadding)=0;
   virtual nsresult GetXULMargin(nsMargin& aMargin)=0;
-  virtual void SetLayoutManager(nsBoxLayout* aLayout) { }
+  virtual void SetXULLayoutManager(nsBoxLayout* aLayout) { }
   virtual nsBoxLayout* GetLayoutManager() { return nullptr; }
   nsresult GetClientRect(nsRect& aContentRect);
 
   // For nsSprocketLayout
   virtual Valignment GetVAlign() const = 0;
   virtual Halignment GetHAlign() const = 0;
 
   bool IsHorizontal() const { return (mState & NS_STATE_IS_HORIZONTAL) != 0; }
diff --git a/layout/xul/nsBoxFrame.cpp b/layout/xul/nsBoxFrame.cpp
--- a/layout/xul/nsBoxFrame.cpp
+++ b/layout/xul/nsBoxFrame.cpp
@@ -131,17 +131,17 @@ nsBoxFrame::nsBoxFrame(nsStyleContext* a
   
   // if no layout manager specified us the static sprocket layout
   nsCOMPtr<nsBoxLayout> layout = aLayoutManager;
 
   if (layout == nullptr) {
     NS_NewSprocketLayout(layout);
   }
 
-  SetLayoutManager(layout);
+  SetXULLayoutManager(layout);
 }
 
 nsBoxFrame::~nsBoxFrame()
 {
 }
 
 void
 nsBoxFrame::SetInitialChildList(ChildListID     aListID,
@@ -953,17 +953,17 @@ nsBoxFrame::DoLayout(nsBoxLayoutState& a
 
 void
 nsBoxFrame::DestroyFrom(nsIFrame* aDestructRoot)
 {
   // unregister access key
   RegUnregAccessKey(false);
 
   // clean up the container box's layout manager and child boxes
-  SetLayoutManager(nullptr);
+  SetXULLayoutManager(nullptr);
 
   nsContainerFrame::DestroyFrom(aDestructRoot);
 } 
 
 #ifdef DEBUG_LAYOUT
 nsresult
 nsBoxFrame::SetDebug(nsBoxLayoutState& aState, bool aDebug)
 {
diff --git a/layout/xul/nsBoxFrame.h b/layout/xul/nsBoxFrame.h
--- a/layout/xul/nsBoxFrame.h
+++ b/layout/xul/nsBoxFrame.h
@@ -51,17 +51,17 @@ public:
                                   bool aIsRoot,
                                   nsBoxLayout* aLayoutManager);
   friend nsIFrame* NS_NewBoxFrame(nsIPresShell* aPresShell,
                                   nsStyleContext* aContext);
 
   // gets the rect inside our border and debug border. If you wish to paint inside a box
   // call this method to get the rect so you don't draw on the debug border or outer border.
 
-  virtual void SetLayoutManager(nsBoxLayout* aLayout) override { mLayoutManager = aLayout; }
+  virtual void SetXULLayoutManager(nsBoxLayout* aLayout) override { mLayoutManager = aLayout; }
   virtual nsBoxLayout* GetLayoutManager() override { return mLayoutManager; }
 
   virtual nsresult RelayoutChildAtOrdinal(nsIFrame* aChild) override;
 
   virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetXULFlex() override;
diff --git a/layout/xul/nsDeckFrame.cpp b/layout/xul/nsDeckFrame.cpp
--- a/layout/xul/nsDeckFrame.cpp
+++ b/layout/xul/nsDeckFrame.cpp
@@ -44,17 +44,17 @@ NS_QUERYFRAME_HEAD(nsDeckFrame)
 NS_QUERYFRAME_TAIL_INHERITING(nsBoxFrame)
 
 
 nsDeckFrame::nsDeckFrame(nsStyleContext* aContext)
   : nsBoxFrame(aContext), mIndex(0)
 {
   nsCOMPtr<nsBoxLayout> layout;
   NS_NewStackLayout(layout);
-  SetLayoutManager(layout);
+  SetXULLayoutManager(layout);
 }
 
 nsIAtom*
 nsDeckFrame::GetType() const
 {
   return nsGkAtoms::deckFrame;
 }
 
diff --git a/layout/xul/nsRootBoxFrame.cpp b/layout/xul/nsRootBoxFrame.cpp
--- a/layout/xul/nsRootBoxFrame.cpp
+++ b/layout/xul/nsRootBoxFrame.cpp
@@ -115,17 +115,17 @@ NS_IMPL_FRAMEARENA_HELPERS(nsRootBoxFram
 
 nsRootBoxFrame::nsRootBoxFrame(nsStyleContext* aContext):
   nsBoxFrame(aContext, true)
 {
   mPopupSetFrame = nullptr;
 
   nsCOMPtr<nsBoxLayout> layout;
   NS_NewStackLayout(layout);
-  SetLayoutManager(layout);
+  SetXULLayoutManager(layout);
 }
 
 void
 nsRootBoxFrame::AppendFrames(ChildListID     aListID,
                              nsFrameList&    aFrameList)
 {
   MOZ_ASSERT(aListID == kPrincipalList, "unexpected child list ID");
   MOZ_ASSERT(mFrames.IsEmpty(), "already have a child frame");
diff --git a/layout/xul/nsStackFrame.cpp b/layout/xul/nsStackFrame.cpp
--- a/layout/xul/nsStackFrame.cpp
+++ b/layout/xul/nsStackFrame.cpp
@@ -29,17 +29,17 @@ NS_NewStackFrame(nsIPresShell* aPresShel
 
 NS_IMPL_FRAMEARENA_HELPERS(nsStackFrame)
 
 nsStackFrame::nsStackFrame(nsStyleContext* aContext):
   nsBoxFrame(aContext)
 {
   nsCOMPtr<nsBoxLayout> layout;
   NS_NewStackLayout(layout);
-  SetLayoutManager(layout);
+  SetXULLayoutManager(layout);
 }
 
 // REVIEW: The old code put everything in the background layer. To be more
 // consistent with the way other frames work, I'm putting everything in the
 // Content() (i.e., foreground) layer (see nsFrame::BuildDisplayListForChild,
 // the case for stacking context but non-positioned, non-floating frames).
 // This could easily be changed back by hacking nsBoxFrame::BuildDisplayListInternal
 // a bit more.
