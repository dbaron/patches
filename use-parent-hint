From: L. David Baron <dbaron@dbaron.org>

Make nsStyleContext::CalcStyleDifference force comparison based on the parent's hint instead of the style struct ForceCompare methods.  (Bug 779968, patch 6, the main patch)

This propagates the non-inherited (in the nsChangeHint sense, not the
CSS inheritance sense) parts of the parent's change hint through
ReResolveStyleContext so that we can use them in
nsStyleContext::CalcDifference.  In the cases where we don't know the
parent's hint, we assume the worst, that all the non-inherited hints
were present in the parent's style change.

This should be a significant performance improvement handling simple
style changes (such as a style attribute change setting a non-inherited
property) on elements with large numbers of descendants that have data
in ForceCompare structs that can't be stored in the rule tree (for
example, margins or widths in em or rem units).

diff --git a/layout/base/nsChangeHint.h b/layout/base/nsChangeHint.h
--- a/layout/base/nsChangeHint.h
+++ b/layout/base/nsChangeHint.h
@@ -4,16 +4,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /* constants for what needs to be recomputed in response to style changes */
 
 #ifndef nsChangeHint_h___
 #define nsChangeHint_h___
 
 #include "prtypes.h"
+#include "nsDebug.h"
 
 // Defines for various style related constants
 
 // For hints that don't guarantee that the change will be applied to all descendant
 // frames, style structs returning those hints from CalcDifference must have
 // their ForceCompare() return true.
 
 enum nsChangeHint {
@@ -159,16 +160,30 @@ inline bool NS_IsHintSubset(nsChangeHint
 
 /**
  * We have an optimization when processing change hints which prevents
  * us from visiting the descendants of a node when a hint on that node
  * is being processed.  This optimization does not apply in some of the
  * cases where applying a hint to an element does not necessarily result
  * in the same hint being handled on the descendants.
  */
+
+// The most hints that NS_HintsNotHandledForDescendantsIn could possibly return:
+#define nsChangeHint_Hints_NotHandledForDescendants nsChangeHint( \
+          nsChangeHint_UpdateTransformLayer | \
+          nsChangeHint_UpdateEffects | \
+          nsChangeHint_UpdateOpacityLayer | \
+          nsChangeHint_UpdateOverflow | \
+          nsChangeHint_ChildrenOnlyTransform | \
+          nsChangeHint_RecomputePosition | \
+          nsChangeHint_AddOrRemoveTransform | \
+          nsChangeHint_BorderStyleNoneChange | \
+          nsChangeHint_NeedReflow | \
+          nsChangeHint_ClearAncestorIntrinsics)
+
 inline nsChangeHint NS_HintsNotHandledForDescendantsIn(nsChangeHint aChangeHint) {
   nsChangeHint result = nsChangeHint(aChangeHint & (
     nsChangeHint_UpdateTransformLayer |
     nsChangeHint_UpdateEffects |
     nsChangeHint_UpdateOpacityLayer |
     nsChangeHint_UpdateOverflow |
     nsChangeHint_ChildrenOnlyTransform |
     nsChangeHint_RecomputePosition |
@@ -187,16 +202,20 @@ inline nsChangeHint NS_HintsNotHandledFo
 
   if (!NS_IsHintSubset(nsChangeHint_ClearDescendantIntrinsics, aChangeHint) &&
       NS_IsHintSubset(nsChangeHint_ClearAncestorIntrinsics, aChangeHint)) {
     // If ClearDescendantIntrinsics is *not* set, then
     // ClearAncestorIntrinsics is a non-inherited hint.
     NS_UpdateHint(result, nsChangeHint_ClearAncestorIntrinsics);
   }
 
+  NS_ABORT_IF_FALSE(NS_IsHintSubset(result,
+                                    nsChangeHint_Hints_NotHandledForDescendants),
+                    "something is inconsistent");
+
   return result;
 }
 
 // Redefine the old NS_STYLE_HINT constants in terms of the new hint structure
 #define NS_STYLE_HINT_NONE \
   nsChangeHint(0)
 #define NS_STYLE_HINT_VISUAL \
   nsChangeHint(nsChangeHint_RepaintFrame | nsChangeHint_SyncFrameView)
diff --git a/layout/base/nsFrameManager.cpp b/layout/base/nsFrameManager.cpp
--- a/layout/base/nsFrameManager.cpp
+++ b/layout/base/nsFrameManager.cpp
@@ -876,17 +876,18 @@ nsFrameManager::ReparentStyleContext(nsI
         if (!copyFromContinuation) {
           TryStartingTransition(GetPresContext(), aFrame->GetContent(),
                                 oldContext, &newContext);
         }
 #endif
 
         // Make sure to call CalcStyleDifference so that the new context ends
         // up resolving all the structs the old context resolved.
-        nsChangeHint styleChange = oldContext->CalcStyleDifference(newContext);
+        nsChangeHint styleChange =
+          oldContext->CalcStyleDifference(newContext, nsChangeHint(0));
         // The style change is always 0 because we have the same rulenode and
         // CalcStyleDifference optimizes us away.  That's OK, though:
         // reparenting should never trigger a frame reconstruct, and whenever
         // it's happening we already plan to reflow and repaint the frames.
         NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
                      "Our frame tree is likely to be bogus!");
         
         aFrame->SetStyleContext(newContext);
@@ -940,17 +941,18 @@ nsFrameManager::ReparentStyleContext(nsI
                                                               newContext,
                                                               nullptr);
             if (newExtraContext) {
               if (newExtraContext != oldExtraContext) {
                 // Make sure to call CalcStyleDifference so that the new
                 // context ends up resolving all the structs the old context
                 // resolved.
                 styleChange =
-                  oldExtraContext->CalcStyleDifference(newExtraContext);
+                  oldExtraContext->CalcStyleDifference(newExtraContext,
+                                                       nsChangeHint(0));
                 // The style change is always 0 because we have the same
                 // rulenode and CalcStyleDifference optimizes us away.  That's
                 // OK, though: reparenting should never trigger a frame
                 // reconstruct, and whenever it's happening we already plan to
                 // reflow and repaint the frames.
                 NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
                              "Our frame tree is likely to be bogus!");
               }
@@ -966,50 +968,58 @@ nsFrameManager::ReparentStyleContext(nsI
         VerifyStyleTree(GetPresContext(), aFrame, newParentContext);
 #endif
       }
     }
   }
   return NS_OK;
 }
 
-static nsChangeHint
+static void
 CaptureChange(nsStyleContext* aOldContext, nsStyleContext* aNewContext,
               nsIFrame* aFrame, nsIContent* aContent,
-              nsStyleChangeList* aChangeList, nsChangeHint aMinChange,
+              nsStyleChangeList* aChangeList,
+              /*inout*/nsChangeHint &aMinChange,
+              /*in*/nsChangeHint aParentHintsNotHandledForDescendants,
+              /*out*/nsChangeHint &aHintsNotHandledForDescendants,
               nsChangeHint aChangeToAssume)
 {
-  nsChangeHint ourChange = aOldContext->CalcStyleDifference(aNewContext);
+  nsChangeHint ourChange = aOldContext->CalcStyleDifference(aNewContext,
+                             aParentHintsNotHandledForDescendants);
   NS_ASSERTION(!(ourChange & nsChangeHint_ReflowFrame) ||
                (ourChange & nsChangeHint_NeedReflow),
                "Reflow hint bits set without actually asking for a reflow");
 
   NS_UpdateHint(ourChange, aChangeToAssume);
   if (NS_UpdateHint(aMinChange, ourChange)) {
     if (!(ourChange & nsChangeHint_ReconstructFrame) || aContent) {
       aChangeList->AppendChange(aFrame, aContent, ourChange);
     }
   }
-  return aMinChange;
+  aHintsNotHandledForDescendants = NS_HintsNotHandledForDescendantsIn(ourChange);
 }
 
 /**
  * Recompute style for aFrame and accumulate changes into aChangeList
  * given that aMinChange is already accumulated for an ancestor.
  * aParentContent is the content node used to resolve the parent style
  * context.  This means that, for pseudo-elements, it is the content
  * that should be used for selector matching (rather than the fake
  * content node attached to the frame).
+ *
+ * For aParentFrameHintsNotHandledForDescendants, see
+ * nsStyleContext::CalcStyleDifference.
  */
 nsChangeHint
 nsFrameManager::ReResolveStyleContext(nsPresContext     *aPresContext,
                                       nsIFrame          *aFrame,
                                       nsIContent        *aParentContent,
                                       nsStyleChangeList *aChangeList, 
                                       nsChangeHint       aMinChange,
+                                      nsChangeHint       aParentFrameHintsNotHandledForDescendants,
                                       nsRestyleHint      aRestyleHint,
                                       RestyleTracker&    aRestyleTracker,
                                       DesiredA11yNotifications aDesiredA11yNotifications,
                                       nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
                                       TreeMatchContext &aTreeMatchContext)
 {
   // We need to generate a new change list entry for every frame whose style
   // comparision returns one of these hints. These hints don't automatically
@@ -1100,30 +1110,39 @@ nsFrameManager::ReResolveStyleContext(ns
       // applied to this frame, no matter what
       // nsStyleContext::CalcStyleDifference says. CalcStyleDifference
       // can't be trusted because it assumes any changes to the parent
       // style context provider will be automatically propagated to
       // the frame(s) with child style contexts.
 
       assumeDifferenceHint = ReResolveStyleContext(aPresContext, providerFrame,
                                                    aParentContent, aChangeList,
-                                                   aMinChange, aRestyleHint,
+                                                   aMinChange,
+                                                   nsChangeHint_Hints_NotHandledForDescendants,
+                                                   aRestyleHint,
                                                    aRestyleTracker,
                                                    aDesiredA11yNotifications,
                                                    aVisibleKidsOfHiddenElement,
                                                    aTreeMatchContext);
 
       // The provider's new context becomes the parent context of
       // aFrame's context.
       parentContext = providerFrame->GetStyleContext();
       // Set |resolvedChild| so we don't bother resolving the
       // provider again.
       resolvedChild = providerFrame;
     }
 
+    if (providerFrame != aFrame->GetParent()) {
+      // We don't actually know what the parent style context's
+      // non-inherited hints were, so assume the worst.
+      aParentFrameHintsNotHandledForDescendants =
+        nsChangeHint_Hints_NotHandledForDescendants;
+    }
+
 #ifdef DEBUG
     {
       // Check that our assumption that continuations of the same
       // pseudo-type and with the same style context parent have the
       // same style context is valid before the reresolution.  (We need
       // to check the pseudo-type and style context parent because of
       // :first-letter and :first-line, where we create styled and
       // unstyled letter/line frames distinguished by pseudo-type, and
@@ -1162,30 +1181,34 @@ nsFrameManager::ReResolveStyleContext(ns
                        "continuations should have the same style context");
         }
       }
     }
 #endif
 
     // do primary context
     nsRefPtr<nsStyleContext> newContext;
+    nsChangeHint nonInheritedHints = nsChangeHint(0);
     nsIFrame *prevContinuation =
       GetPrevContinuationWithPossiblySameStyle(aFrame);
     nsStyleContext *prevContinuationContext;
     bool copyFromContinuation =
       prevContinuation &&
       (prevContinuationContext = prevContinuation->GetStyleContext())
         ->GetPseudo() == oldContext->GetPseudo() &&
        prevContinuationContext->GetParent() == parentContext;
     if (copyFromContinuation) {
       // Just use the style context from the frame's previous
       // continuation (see assertion about aFrame->GetNextContinuation()
       // above, which we would have previously hit for aFrame's previous
       // continuation).
       newContext = prevContinuationContext;
+      // We don't know what changes the previous continuation had, so
+      // assume the worst.
+      nonInheritedHints = nsChangeHint_Hints_NotHandledForDescendants;
     }
     else if (pseudoTag == nsCSSAnonBoxes::mozNonElement) {
       NS_ASSERTION(localContent,
                    "non pseudo-element frame without content node");
       newContext = styleSet->ResolveStyleForNonElement(parentContext);
     }
     else if (!aRestyleHint && !prevContinuation) {
       // Unfortunately, if prevContinuation is non-null then we may have
@@ -1261,19 +1284,19 @@ nsFrameManager::ReResolveStyleContext(ns
       }
 
       if (newContext != oldContext) {
         if (!copyFromContinuation) {
           TryStartingTransition(aPresContext, aFrame->GetContent(),
                                 oldContext, &newContext);
         }
 
-        aMinChange = CaptureChange(oldContext, newContext, aFrame,
-                                   content, aChangeList, aMinChange,
-                                   assumeDifferenceHint);
+        CaptureChange(oldContext, newContext, aFrame, content, aChangeList,
+                      aMinChange, aParentFrameHintsNotHandledForDescendants,
+                      nonInheritedHints, assumeDifferenceHint);
         if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
           // if frame gets regenerated, let it keep old context
           aFrame->SetStyleContext(newContext);
         }
       }
       oldContext->Release();
     }
     else {
@@ -1307,19 +1330,23 @@ nsFrameManager::ReResolveStyleContext(ns
                          nsCSSPseudoElements::ePseudo_PseudoElementCount,
                        "Unexpected type");
           newExtraContext = styleSet->ResolvePseudoElementStyle(content->AsElement(),
                                                                 extraPseudoType,
                                                                 newContext);
         }
         if (newExtraContext) {
           if (oldExtraContext != newExtraContext) {
-            aMinChange = CaptureChange(oldExtraContext, newExtraContext,
-                                       aFrame, content, aChangeList,
-                                       aMinChange, assumeDifferenceHint);
+            nsChangeHint extraHintsNotHandledForDescendants = nsChangeHint(0);
+            CaptureChange(oldExtraContext, newExtraContext, aFrame, content,
+                          aChangeList, aMinChange,
+                          aParentFrameHintsNotHandledForDescendants,
+                          extraHintsNotHandledForDescendants,
+                          assumeDifferenceHint);
+            NS_UpdateHint(nonInheritedHints, extraHintsNotHandledForDescendants);
             if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
               aFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
             }
           }
         }
       }
       else {
         break;
@@ -1533,37 +1560,40 @@ nsFrameManager::ReResolveStyleContext(ns
 
               // |nsFrame::GetParentStyleContextFrame| checks being out
               // of flow so that this works correctly.
               do {
                 ReResolveStyleContext(aPresContext, outOfFlowFrame,
                                       content, aChangeList,
                                       NS_SubtractHint(aMinChange,
                                                       nsChangeHint_ReflowFrame),
+                                      nonInheritedHints,
                                       childRestyleHint,
                                       aRestyleTracker,
                                       kidsDesiredA11yNotification,
                                       aVisibleKidsOfHiddenElement,
                                       aTreeMatchContext);
               } while ((outOfFlowFrame = outOfFlowFrame->GetNextContinuation()));
 
               // reresolve placeholder's context under the same parent
               // as the out-of-flow frame
               ReResolveStyleContext(aPresContext, child, content,
                                     aChangeList, aMinChange,
+                                    nonInheritedHints,
                                     childRestyleHint,
                                     aRestyleTracker,
                                     kidsDesiredA11yNotification,
                                     aVisibleKidsOfHiddenElement,
                                     aTreeMatchContext);
             }
             else {  // regular child frame
               if (child != resolvedChild) {
                 ReResolveStyleContext(aPresContext, child, content,
                                       aChangeList, aMinChange,
+                                      nonInheritedHints,
                                       childRestyleHint,
                                       aRestyleTracker,
                                       kidsDesiredA11yNotification,
                                       aVisibleKidsOfHiddenElement,
                                       aTreeMatchContext);
               } else {
                 NOISY_TRACE_FRAME("child frame already resolved as descendant, skipping",aFrame);
               }
@@ -1643,17 +1673,17 @@ nsFrameManager::ComputeStyleChangeFor(ns
   treeMatchContext.mAncestorFilter.Init(parentElement);
   nsTArray<nsIContent*> visibleKidsOfHiddenElement;
   do {
     // Outer loop over special siblings
     do {
       // Inner loop over next-in-flows of the current frame
       nsChangeHint frameChange =
         ReResolveStyleContext(GetPresContext(), frame, nullptr,
-                              aChangeList, topLevelChange,
+                              aChangeList, topLevelChange, nsChangeHint(0),
                               aRestyleDescendants ?
                                 eRestyle_Subtree : eRestyle_Self,
                               aRestyleTracker,
                               eSendAllNotifications,
                               visibleKidsOfHiddenElement,
                               treeMatchContext);
       NS_UpdateHint(topLevelChange, frameChange);
 
diff --git a/layout/base/nsFrameManager.h b/layout/base/nsFrameManager.h
--- a/layout/base/nsFrameManager.h
+++ b/layout/base/nsFrameManager.h
@@ -186,16 +186,17 @@ private:
   // nsRestyleHint(0) to mean recompute a new style context for our
   // current parent and existing rulenode, and the same for kids.
   NS_HIDDEN_(nsChangeHint)
     ReResolveStyleContext(nsPresContext    *aPresContext,
                           nsIFrame          *aFrame,
                           nsIContent        *aParentContent,
                           nsStyleChangeList *aChangeList, 
                           nsChangeHint       aMinChange,
+                          nsChangeHint       aParentFrameHintsNotHandledForDescendants,
                           nsRestyleHint      aRestyleHint,
                           RestyleTracker&    aRestyleTracker,
                           DesiredA11yNotifications aDesiredA11yNotifications,
                           nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
                           TreeMatchContext &aTreeMatchContext);
 };
 
 #endif
diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -360,18 +360,23 @@ nsStyleContext::ApplyStyleFixups(nsPresC
     }
   }
 
   // Computer User Interface style, to trigger loads of cursors
   GetStyleUserInterface();
 }
 
 nsChangeHint
-nsStyleContext::CalcStyleDifference(nsStyleContext* aOther)
+nsStyleContext::CalcStyleDifference(nsStyleContext* aOther,
+                                    nsChangeHint aParentHintsNotHandledForDescendants)
 {
+  NS_ABORT_IF_FALSE(NS_IsHintSubset(aParentHintsNotHandledForDescendants,
+                                    nsChangeHint_Hints_NotHandledForDescendants),
+                    "caller is passing inherited hints, but shouldn't be");
+
   nsChangeHint hint = NS_STYLE_HINT_NONE;
   NS_ENSURE_TRUE(aOther, hint);
   // We must always ensure that we populate the structs on the new style
   // context that are filled in on the old context, so that if we get
   // two style changes in succession, the second of which causes a real
   // style change, the PeekStyleData doesn't return null (implying that
   // nobody ever looked at that struct's data).  In other words, we
   // can't skip later structs if we get a big change up front, because
@@ -379,32 +384,42 @@ nsStyleContext::CalcStyleDifference(nsSt
   // don't want to miss.
 
   // If our rule nodes are the same, then any differences in style data
   // are already accounted for by differences on ancestors.  We know
   // this because CalcStyleDifference is always called on two style
   // contexts that point to the same element, so we know that our
   // position in the style context tree is the same and our position in
   // the rule node tree is also the same.
+  // However, if there were noninherited style change hints on the
+  // parent, we might produce these same noninherited hints on this
+  // style context's frame due to 'inherit' values, so we do need to
+  // compare.
+  // (Things like 'em' units are handled by the change hint produced
+  // by font-size changing, so we don't need to worry about them like
+  // we worry about 'inherit' values.)
   bool compare = mRuleNode != aOther->mRuleNode;
 
 #define DO_STRUCT_DIFFERENCE(struct_)                                         \
   PR_BEGIN_MACRO                                                              \
     const nsStyle##struct_* this##struct_ = PeekStyle##struct_();             \
     if (this##struct_) {                                                      \
       const nsStyle##struct_* other##struct_ = aOther->GetStyle##struct_();   \
-      if ((compare || nsStyle##struct_::ForceCompare()) &&                    \
-          !NS_IsHintSubset(nsStyle##struct_::MaxDifference(), hint) &&        \
+      nsChangeHint maxDifference = nsStyle##struct_::MaxDifference();         \
+      if ((compare ||                                                         \
+           (maxDifference & aParentHintsNotHandledForDescendants)) &&         \
+          !NS_IsHintSubset(maxDifference, hint) &&                            \
           this##struct_ != other##struct_) {                                  \
         NS_ASSERTION(NS_IsHintSubset(                                         \
              this##struct_->CalcDifference(*other##struct_),                  \
              nsStyle##struct_::MaxDifference()),                              \
              "CalcDifference() returned bigger hint than MaxDifference()");   \
         NS_ASSERTION(nsStyle##struct_::ForceCompare() ||                      \
-             NS_HintsNotHandledForDescendantsIn(nsStyle##struct_::MaxDifference()) == 0,  \
+             NS_HintsNotHandledForDescendantsIn(                              \
+               nsStyle##struct_::MaxDifference()) == 0,                       \
              "Structs that can return non-inherited hints must return true "  \
              "from ForceCompare");                                            \
         NS_UpdateHint(hint, this##struct_->CalcDifference(*other##struct_));  \
       }                                                                       \
     }                                                                         \
   PR_END_MACRO
 
   // In general, we want to examine structs starting with those that can
diff --git a/layout/style/nsStyleContext.h b/layout/style/nsStyleContext.h
--- a/layout/style/nsStyleContext.h
+++ b/layout/style/nsStyleContext.h
@@ -239,17 +239,34 @@ public:
     const nsStyle##name_ * PeekStyle##name_() {           \
       return DoGetStyle##name_(false);                 \
     }
   #include "nsStyleStructList.h"
   #undef STYLE_STRUCT
 
   void* GetUniqueStyleData(const nsStyleStructID& aSID);
 
-  nsChangeHint CalcStyleDifference(nsStyleContext* aOther);
+  /**
+   * Compute the style changes needed during restyling when this style
+   * context is being replaced by aOther.  (This is nonsymmetric since
+   * we optimize by skipping comparison for styles that have never been
+   * requested.)
+   *
+   * This method returns a change hint (see nsChangeHint.h).  All change
+   * hints apply to the frame and its later continuations or special
+   * siblings.  Most (all of those except the "NotHandledForDescendants"
+   * hints) also apply to all descendants.  The caller must pass in any
+   * non-inherited hints that resulted from the parent style context's
+   * style change.  The caller *may* pass more hints than needed, but
+   * must not pass less than needed; therefore if the caller doesn't
+   * know, the caller should pass
+   * nsChangeHint_Hints_NotHandledForDescendants.
+   */
+  nsChangeHint CalcStyleDifference(nsStyleContext* aOther,
+                                   nsChangeHint aParentHintsNotHandledForDescendants);
 
   /**
    * Get a color that depends on link-visitedness using this and
    * this->GetStyleIfVisited().
    *
    * aProperty must be a color-valued property that nsStyleAnimation
    * knows how to extract.  It must also be a property that we know to
    * do change handling for in nsStyleContext::CalcDifference.
