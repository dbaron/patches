From: L. David Baron <dbaron@dbaron.org>

Bug 1087541 - Make RuleNodeWithReplacement handle animations and transitions like RulesMatching codepath does.  r=birtles

I originally wrote this to see if it would fix bug 1086937, but it
didn't.

Note that this conflicts a bit with the patch in bug 1085769; whoever
lands second will have some merging (though it shouldn't be difficult).

diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -171,16 +171,20 @@ void
 CommonAnimationManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
 {
   PRCList* next = PR_LIST_HEAD(&mElementCollections);
   while (next != &mElementCollections) {
     AnimationPlayerCollection* collection =
       static_cast<AnimationPlayerCollection*>(next);
     next = PR_NEXT_LINK(next);
 
+    UpdateStyleAndEvents(collection,
+                         mPresContext->RefreshDriver()->MostRecentRefresh(),
+                         EnsureStyleRule_IsNotThrottled);
+
     dom::Element* elementToRestyle = collection->GetElementToRestyle();
     if (elementToRestyle) {
       nsRestyleHint rshint = collection->IsForTransitions()
         ? eRestyle_CSSTransitions : eRestyle_CSSAnimations;
       aTracker.AddPendingRestyle(elementToRestyle, rshint, nsChangeHint(0));
     }
   }
 }
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -219,16 +219,18 @@ public:
       DoDispatchEvents();
     }
   }
 
   mozilla::AnimationPlayerCollection*
   GetAnimationPlayers(mozilla::dom::Element *aElement,
                       nsCSSPseudoElements::Type aPseudoType,
                       bool aCreateIfNeeded);
+  nsIStyleRule* GetAnimationRule(mozilla::dom::Element* aElement,
+                                 nsCSSPseudoElements::Type aPseudoType);
 
 protected:
   virtual void ElementCollectionRemoved() MOZ_OVERRIDE
   {
     CheckNeedsRefresh();
   }
   virtual void
   AddElementCollection(mozilla::AnimationPlayerCollection* aData) MOZ_OVERRIDE;
@@ -245,18 +247,16 @@ private:
                        mozilla::AnimationPlayerPtrArray& aAnimations);
   bool BuildSegment(InfallibleTArray<mozilla::AnimationPropertySegment>&
                       aSegments,
                     nsCSSProperty aProperty,
                     const mozilla::StyleAnimation& aAnimation,
                     float aFromKey, nsStyleContext* aFromContext,
                     mozilla::css::Declaration* aFromDeclaration,
                     float aToKey, nsStyleContext* aToContext);
-  nsIStyleRule* GetAnimationRule(mozilla::dom::Element* aElement,
-                                 nsCSSPseudoElements::Type aPseudoType);
 
   // The guts of DispatchEvents
   void DoDispatchEvents();
 
   mozilla::EventArray mPendingEvents;
 
   bool mObservingRefreshDriver;
 };
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1362,30 +1362,23 @@ nsStyleSet::RuleNodeWithReplacement(Elem
                                         eRestyle_ChangeAnimationPhase |
                                         eRestyle_Force |
                                         eRestyle_ForceDescendants)),
                     // FIXME: Once bug 979133 lands we'll have a better
                     // way to print these.
                     nsPrintfCString("unexpected replacement bits 0x%lX",
                                     uint32_t(aReplacements)).get());
 
-  bool skipAnimationRules = false;
-  bool postAnimationRestyles = false;
-
   // If we're changing animation phase, we have to reconsider what rules
   // are in these four levels.
   if (aReplacements & eRestyle_ChangeAnimationPhase) {
     aReplacements |= eRestyle_CSSTransitions |
                      eRestyle_CSSAnimations |
                      eRestyle_SVGAttrAnimations |
                      eRestyle_StyleAttribute;
-
-    RestyleManager* restyleManager = PresContext()->RestyleManager();
-    skipAnimationRules = restyleManager->SkipAnimationRules();
-    postAnimationRestyles = restyleManager->PostAnimationRestyles();
   }
 
   // FIXME (perf): This should probably not rebuild the whole path, but
   // only the path from the last change in the rule tree, like
   // ReplaceAnimationRule in nsStyleSet.cpp does.  (That could then
   // perhaps share this code, too?)
   // But if we do that, we'll need to pass whether we are rebuilding the
   // rule tree from ElementRestyler::RestyleSelf to avoid taking that
@@ -1416,63 +1409,33 @@ nsStyleSet::RuleNodeWithReplacement(Elem
     bool doReplace = level->mLevelReplacementHint & aReplacements;
 
     ruleWalker.SetLevel(level->mLevel, level->mIsImportant,
                         level->mCheckForImportantRules && doReplace);
 
     if (doReplace) {
       switch (level->mLevelReplacementHint) {
         case eRestyle_CSSAnimations: {
-          // FIXME: This should probably be more similar to what
-          // FileRules does; this feels like too much poking into the
-          // internals of nsAnimationManager.
-          nsPresContext* presContext = PresContext();
-          nsAnimationManager* animationManager =
-            presContext->AnimationManager();
-          AnimationPlayerCollection* collection =
-            animationManager->GetAnimationPlayers(aElement, aPseudoType, false);
-
-          if (collection) {
-            if (skipAnimationRules) {
-              if (postAnimationRestyles) {
-                collection->PostRestyleForAnimation(presContext);
-              }
-            } else {
-              animationManager->UpdateStyleAndEvents(
-                collection, PresContext()->RefreshDriver()->MostRecentRefresh(),
-                EnsureStyleRule_IsNotThrottled);
-              if (collection->mStyleRule) {
-                ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
-              }
+          if (aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ||
+              aPseudoType == nsCSSPseudoElements::ePseudo_before ||
+              aPseudoType == nsCSSPseudoElements::ePseudo_after) {
+            nsIStyleRule* rule = PresContext()->AnimationManager()->
+              GetAnimationRule(aElement, aPseudoType);
+            if (rule) {
+              ruleWalker.ForwardOnPossiblyCSSRule(rule);
             }
           }
           break;
         }
         case eRestyle_CSSTransitions: {
-          // FIXME: This should probably be more similar to what
-          // FileRules does; this feels like too much poking into the
-          // internals of nsTransitionManager.
-          nsPresContext* presContext = PresContext();
-          AnimationPlayerCollection* collection =
-            presContext->TransitionManager()->GetElementTransitions(
-              aElement, aPseudoType, false);
-
-          if (collection) {
-            if (skipAnimationRules) {
-              if (postAnimationRestyles) {
-                collection->PostRestyleForAnimation(presContext);
-              }
-            } else {
-              collection->EnsureStyleRuleFor(
-                presContext->RefreshDriver()->MostRecentRefresh(),
-                EnsureStyleRule_IsNotThrottled);
-              if (collection->mStyleRule) {
-                ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
-              }
-            }
+          if (aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ||
+              aPseudoType == nsCSSPseudoElements::ePseudo_before ||
+              aPseudoType == nsCSSPseudoElements::ePseudo_after) {
+            PresContext()->TransitionManager()->
+              WalkTransitionRule(aElement, aPseudoType, &ruleWalker);
           }
           break;
         }
         case eRestyle_SVGAttrAnimations: {
           MOZ_ASSERT(aReplacements & eRestyle_ChangeAnimationPhase,
                      "don't know how to do this level without phase change");
 
           SVGAttrAnimationRuleProcessor* ruleProcessor =
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -630,75 +630,77 @@ nsTransitionManager::UpdateStyleAndEvent
   aCollection->EnsureStyleRuleFor(aRefreshTime, aFlags);
 }
 
 /*
  * nsIStyleRuleProcessor implementation
  */
 
 void
-nsTransitionManager::WalkTransitionRule(
-  ElementDependentRuleProcessorData* aData,
-  nsCSSPseudoElements::Type aPseudoType)
+nsTransitionManager::WalkTransitionRule(dom::Element* aElement,
+                                        nsCSSPseudoElements::Type aPseudoType,
+                                        nsRuleWalker* aRuleWalker)
 {
   AnimationPlayerCollection* collection =
-    GetElementTransitions(aData->mElement, aPseudoType, false);
+    GetElementTransitions(aElement, aPseudoType, false);
   if (!collection) {
     return;
   }
 
   if (!mPresContext->IsDynamic()) {
     // For print or print preview, ignore animations.
     return;
   }
 
-  RestyleManager* restyleManager = aData->mPresContext->RestyleManager();
+  RestyleManager* restyleManager = mPresContext->RestyleManager();
   if (restyleManager->SkipAnimationRules()) {
     // If we're processing a normal style change rather than one from
     // animation, don't add the transition rule.  This allows us to
     // compute the new style value rather than having the transition
     // override it, so that we can start transitioning differently.
 
     if (restyleManager->PostAnimationRestyles()) {
       // We need to immediately restyle with animation
       // after doing this.
       collection->PostRestyleForAnimation(mPresContext);
     }
     return;
   }
 
   collection->mNeedsRefreshes = true;
   collection->EnsureStyleRuleFor(
-    aData->mPresContext->RefreshDriver()->MostRecentRefresh(),
+    mPresContext->RefreshDriver()->MostRecentRefresh(),
     EnsureStyleRule_IsNotThrottled);
 
   if (collection->mStyleRule) {
-    aData->mRuleWalker->Forward(collection->mStyleRule);
+    aRuleWalker->Forward(collection->mStyleRule);
   }
 }
 
 /* virtual */ void
 nsTransitionManager::RulesMatching(ElementRuleProcessorData* aData)
 {
   NS_ABORT_IF_FALSE(aData->mPresContext == mPresContext,
                     "pres context mismatch");
-  WalkTransitionRule(aData,
-                     nsCSSPseudoElements::ePseudo_NotPseudoElement);
+  WalkTransitionRule(aData->mElement,
+                     nsCSSPseudoElements::ePseudo_NotPseudoElement,
+                     aData->mRuleWalker);
 }
 
 /* virtual */ void
 nsTransitionManager::RulesMatching(PseudoElementRuleProcessorData* aData)
 {
   NS_ABORT_IF_FALSE(aData->mPresContext == mPresContext,
                     "pres context mismatch");
 
   // Note:  If we're the only thing keeping a pseudo-element frame alive
   // (per ProbePseudoStyleContext), we still want to keep it alive, so
   // this is ok.
-  WalkTransitionRule(aData, aData->mPseudoType);
+  WalkTransitionRule(aData->mElement, aData->mPseudoType,
+                     aData->mRuleWalker);
 }
 
 /* virtual */ void
 nsTransitionManager::RulesMatching(AnonBoxRuleProcessorData* aData)
 {
 }
 
 #ifdef MOZ_XUL
diff --git a/layout/style/nsTransitionManager.h b/layout/style/nsTransitionManager.h
--- a/layout/style/nsTransitionManager.h
+++ b/layout/style/nsTransitionManager.h
@@ -143,16 +143,19 @@ public:
   virtual void WillRefresh(mozilla::TimeStamp aTime) MOZ_OVERRIDE;
 
   void FlushTransitions(FlushFlags aFlags);
 
   AnimationPlayerCollection* GetElementTransitions(
     mozilla::dom::Element *aElement,
     nsCSSPseudoElements::Type aPseudoType,
     bool aCreateIfNeeded);
+  void WalkTransitionRule(mozilla::dom::Element* aElement,
+                          nsCSSPseudoElements::Type aPseudoType,
+                          nsRuleWalker* aRuleWalker);
 
   virtual void UpdateStyleAndEvents(mozilla::AnimationPlayerCollection* aEA,
                                     mozilla::TimeStamp aRefreshTime,
                                     mozilla::EnsureStyleRuleFlags aFlags) MOZ_OVERRIDE;
 protected:
   virtual void ElementCollectionRemoved() MOZ_OVERRIDE;
   virtual void
   AddElementCollection(AnimationPlayerCollection* aCollection) MOZ_OVERRIDE;
@@ -162,15 +165,13 @@ private:
   ConsiderStartingTransition(nsCSSProperty aProperty,
                              const mozilla::StyleTransition& aTransition,
                              mozilla::dom::Element* aElement,
                              AnimationPlayerCollection*& aElementTransitions,
                              nsStyleContext* aOldStyleContext,
                              nsStyleContext* aNewStyleContext,
                              bool* aStartedAny,
                              nsCSSPropertySet* aWhichStarted);
-  void WalkTransitionRule(ElementDependentRuleProcessorData* aData,
-                          nsCSSPseudoElements::Type aPseudoType);
 
   bool mInAnimationOnlyStyleUpdate;
 };
 
 #endif /* !defined(nsTransitionManager_h_) */
