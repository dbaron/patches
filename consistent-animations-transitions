From: L. David Baron <dbaron@dbaron.org>

Bug 1086937 - Make RuleNodeWithReplacement handle animations and transitions like RulesMatching codepath does.

diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1417,64 +1417,26 @@ nsStyleSet::RuleNodeWithReplacement(Elem
     bool doReplace = level->mLevelReplacementHint & aReplacements;
 
     ruleWalker.SetLevel(level->mLevel, level->mIsImportant,
                         level->mCheckForImportantRules && doReplace);
 
     if (doReplace) {
       switch (level->mLevelReplacementHint) {
         case eRestyle_CSSAnimations: {
-          // FIXME: This should probably be more similar to what
-          // FileRules does; this feels like too much poking into the
-          // internals of nsAnimationManager.
-          nsPresContext* presContext = PresContext();
-          nsAnimationManager* animationManager =
-            presContext->AnimationManager();
-          AnimationPlayerCollection* collection =
-            animationManager->GetAnimationPlayers(aElement, aPseudoType, false);
-
-          if (collection) {
-            if (skipAnimationRules) {
-              if (postAnimationRestyles) {
-                collection->PostRestyleForAnimation(presContext);
-              }
-            } else {
-              animationManager->UpdateStyleAndEvents(
-                collection, PresContext()->RefreshDriver()->MostRecentRefresh(),
-                EnsureStyleRule_IsNotThrottled);
-              if (collection->mStyleRule) {
-                ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
-              }
-            }
+          nsIStyleRule* rule = PresContext()->AnimationManager()->
+            GetAnimationRule(aElement, aPseudoType);
+          if (rule) {
+            ruleWalker.ForwardOnPossiblyCSSRule(rule);
           }
           break;
         }
         case eRestyle_CSSTransitions: {
-          // FIXME: This should probably be more similar to what
-          // FileRules does; this feels like too much poking into the
-          // internals of nsTransitionManager.
-          nsPresContext* presContext = PresContext();
-          AnimationPlayerCollection* collection =
-            presContext->TransitionManager()->GetElementTransitions(
-              aElement, aPseudoType, false);
-
-          if (collection) {
-            if (skipAnimationRules) {
-              if (postAnimationRestyles) {
-                collection->PostRestyleForAnimation(presContext);
-              }
-            } else {
-              collection->EnsureStyleRuleFor(
-                presContext->RefreshDriver()->MostRecentRefresh(),
-                EnsureStyleRule_IsNotThrottled);
-              if (collection->mStyleRule) {
-                ruleWalker.ForwardOnPossiblyCSSRule(collection->mStyleRule);
-              }
-            }
-          }
+          PresContext()->TransitionManager()->
+            WalkTransitionRule(aElement, aPseudoType, &ruleWalker);
           break;
         }
         case eRestyle_SVGAttrAnimations: {
           MOZ_ASSERT(aReplacements & eRestyle_ChangeAnimationPhase,
                      "don't know how to do this level without phase change");
 
           SVGAttrAnimationRuleProcessor* ruleProcessor =
             static_cast<SVGAttrAnimationRuleProcessor*>(
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -621,75 +621,77 @@ nsTransitionManager::GetElementTransitio
   return collection;
 }
 
 /*
  * nsIStyleRuleProcessor implementation
  */
 
 void
-nsTransitionManager::WalkTransitionRule(
-  ElementDependentRuleProcessorData* aData,
-  nsCSSPseudoElements::Type aPseudoType)
+nsTransitionManager::WalkTransitionRule(Element* aElement,
+                                        nsCSSPseudoElements::Type aPseudoType,
+                                        nsRuleWakler* aRuleWalker)
 {
   AnimationPlayerCollection* collection =
-    GetElementTransitions(aData->mElement, aPseudoType, false);
+    GetElementTransitions(aElement, aPseudoType, false);
   if (!collection) {
     return;
   }
 
   if (!mPresContext->IsDynamic()) {
     // For print or print preview, ignore animations.
     return;
   }
 
-  RestyleManager* restyleManager = aData->mPresContext->RestyleManager();
+  RestyleManager* restyleManager = mPresContext->RestyleManager();
   if (restyleManager->SkipAnimationRules()) {
     // If we're processing a normal style change rather than one from
     // animation, don't add the transition rule.  This allows us to
     // compute the new style value rather than having the transition
     // override it, so that we can start transitioning differently.
 
     if (restyleManager->PostAnimationRestyles()) {
       // We need to immediately restyle with animation
       // after doing this.
       collection->PostRestyleForAnimation(mPresContext);
     }
     return;
   }
 
   collection->EnsureStyleRuleFor(
-    aData->mPresContext->RefreshDriver()->MostRecentRefresh(),
+    mPresContext->RefreshDriver()->MostRecentRefresh(),
     EnsureStyleRule_IsNotThrottled);
 
   // FIXME: remove null check?
   if (collection->mStyleRule) {
-    aData->mRuleWalker->Forward(collection->mStyleRule);
+    aRuleWalker->Forward(collection->mStyleRule);
   }
 }
 
 /* virtual */ void
 nsTransitionManager::RulesMatching(ElementRuleProcessorData* aData)
 {
   NS_ABORT_IF_FALSE(aData->mPresContext == mPresContext,
                     "pres context mismatch");
-  WalkTransitionRule(aData,
-                     nsCSSPseudoElements::ePseudo_NotPseudoElement);
+  WalkTransitionRule(aData->mElement,
+                     nsCSSPseudoElements::ePseudo_NotPseudoElement,
+                     aData->mRuleWalker);
 }
 
 /* virtual */ void
 nsTransitionManager::RulesMatching(PseudoElementRuleProcessorData* aData)
 {
   NS_ABORT_IF_FALSE(aData->mPresContext == mPresContext,
                     "pres context mismatch");
 
   // Note:  If we're the only thing keeping a pseudo-element frame alive
   // (per ProbePseudoStyleContext), we still want to keep it alive, so
   // this is ok.
-  WalkTransitionRule(aData, aData->mPseudoType);
+  WalkTransitionRule(aData->mElement, aData->mPseudoType,
+                     aData->mRuleWalker);
 }
 
 /* virtual */ void
 nsTransitionManager::RulesMatching(AnonBoxRuleProcessorData* aData)
 {
 }
 
 #ifdef MOZ_XUL
diff --git a/layout/style/nsTransitionManager.h b/layout/style/nsTransitionManager.h
--- a/layout/style/nsTransitionManager.h
+++ b/layout/style/nsTransitionManager.h
@@ -159,15 +159,16 @@ private:
   ConsiderStartingTransition(nsCSSProperty aProperty,
                              const mozilla::StyleTransition& aTransition,
                              mozilla::dom::Element* aElement,
                              AnimationPlayerCollection*& aElementTransitions,
                              nsStyleContext* aOldStyleContext,
                              nsStyleContext* aNewStyleContext,
                              bool* aStartedAny,
                              nsCSSPropertySet* aWhichStarted);
-  void WalkTransitionRule(ElementDependentRuleProcessorData* aData,
-                          nsCSSPseudoElements::Type aPseudoType);
+  void WalkTransitionRule(mozilla::dom::Element* aElement,
+                          nsCSSPseudoElements::Type aPseudoType,
+                          nsRuleWalker* aRuleWalker);
 
   bool mInAnimationOnlyStyleUpdate;
 };
 
 #endif /* !defined(nsTransitionManager_h_) */
