From: L. David Baron <dbaron@dbaron.org>

Bug 91419 patch 2:  Rename IsFrameSpecial to IsFramePartOfBlockInInlineSplit.

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -406,35 +406,35 @@ ReparentFrames(nsCSSFrameConstructor* aF
 
 //----------------------------------------------------------------------
 //
 // When inline frames get weird and have block frames in them, we
 // annotate them to help us respond to incremental content changes
 // more easily.
 
 static inline bool
-IsFrameSpecial(nsIFrame* aFrame)
+IsFramePartOfBlockInInlineSplit(nsIFrame* aFrame)
 {
   return (aFrame->GetStateBits() & NS_FRAME_BLOCK_IN_INLINE_SPLIT) != 0;
 }
 
 static nsIFrame* GetSpecialSibling(nsIFrame* aFrame)
 {
-  NS_PRECONDITION(IsFrameSpecial(aFrame), "Shouldn't call this");
+  NS_PRECONDITION(IsFramePartOfBlockInInlineSplit(aFrame), "Shouldn't call this");
 
   // We only store the "special sibling" annotation with the first
   // frame in the continuation chain. Walk back to find that frame now.
   return static_cast<nsIFrame*>
     (aFrame->FirstContinuation()->
        Properties().Get(nsIFrame::IBSplitSpecialSibling()));
 }
 
 static nsIFrame* GetSpecialPrevSibling(nsIFrame* aFrame)
 {
-  NS_PRECONDITION(IsFrameSpecial(aFrame), "Shouldn't call this");
+  NS_PRECONDITION(IsFramePartOfBlockInInlineSplit(aFrame), "Shouldn't call this");
   
   // We only store the "special sibling" annotation with the first
   // frame in the continuation chain. Walk back to find that frame now.  
   return static_cast<nsIFrame*>
     (aFrame->FirstContinuation()->
        Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
 }
 
@@ -459,17 +459,17 @@ static void
 SetFrameIsSpecial(nsIFrame* aFrame, nsIFrame* aSpecialSibling)
 {
   NS_PRECONDITION(aFrame, "bad args!");
 
   // We should be the only continuation
   NS_ASSERTION(!aFrame->GetPrevContinuation(),
                "assigning special sibling to other than first continuation!");
   NS_ASSERTION(!aFrame->GetNextContinuation() ||
-               IsFrameSpecial(aFrame->GetNextContinuation()),
+               IsFramePartOfBlockInInlineSplit(aFrame->GetNextContinuation()),
                "should have no non-special continuations here");
 
   // Mark the frame as "special".
   aFrame->AddStateBits(NS_FRAME_BLOCK_IN_INLINE_SPLIT);
 
   if (aSpecialSibling) {
     NS_ASSERTION(!aSpecialSibling->GetPrevContinuation(),
                  "assigning something other than the first continuation as the "
@@ -481,33 +481,33 @@ SetFrameIsSpecial(nsIFrame* aFrame, nsIF
     props->Set(aFrame, nsIFrame::IBSplitSpecialSibling(), aSpecialSibling);
     props->Set(aSpecialSibling, nsIFrame::IBSplitSpecialPrevSibling(), aFrame);
   }
 }
 
 static nsIFrame*
 GetIBContainingBlockFor(nsIFrame* aFrame)
 {
-  NS_PRECONDITION(IsFrameSpecial(aFrame),
+  NS_PRECONDITION(IsFramePartOfBlockInInlineSplit(aFrame),
                   "GetIBContainingBlockFor() should only be called on known IB frames");
 
   // Get the first "normal" ancestor of the target frame.
   nsIFrame* parentFrame;
   do {
     parentFrame = aFrame->GetParent();
 
     if (! parentFrame) {
       NS_ERROR("no unsplit block frame in IB hierarchy");
       return aFrame;
     }
 
     // Note that we ignore non-special frames which have a pseudo on their
     // style context -- they're not the frames we're looking for!  In
     // particular, they may be hiding a real parent that _is_ special.
-    if (!IsFrameSpecial(parentFrame) &&
+    if (!IsFramePartOfBlockInInlineSplit(parentFrame) &&
         !parentFrame->StyleContext()->GetPseudo())
       break;
 
     aFrame = parentFrame;
   } while (1);
  
   // post-conditions
   NS_ASSERTION(parentFrame, "no normal ancestor found for special frame in GetIBContainingBlockFor");
@@ -3704,17 +3704,17 @@ nsCSSFrameConstructor::ConstructFrameFro
     }
 #endif
 
     if (bits & FCDATA_WRAP_KIDS_IN_BLOCKS) {
       nsFrameItems newItems;
       nsFrameItems currentBlockItems;
       nsIFrame* f;
       while ((f = childItems.FirstChild()) != nullptr) {
-        bool wrapFrame = IsInlineFrame(f) || IsFrameSpecial(f);
+        bool wrapFrame = IsInlineFrame(f) || IsFramePartOfBlockInInlineSplit(f);
         if (!wrapFrame) {
           FlushAccumulatedBlock(aState, content, newFrame,
                                 currentBlockItems, newItems);
         }
 
         childItems.RemoveFrame(f);
         if (wrapFrame) {
           currentBlockItems.AddChild(f);
@@ -5734,17 +5734,17 @@ AdjustAppendParentForAfterContent(nsPres
     if (afterFrame) {
       *aAfterFrame = afterFrame;
       return afterFrame->GetParent();
     }
   }
 
   *aAfterFrame = nullptr;
 
-  if (IsFrameSpecial(aParentFrame)) {
+  if (IsFramePartOfBlockInInlineSplit(aParentFrame)) {
     // We might be in a situation where the last part of the {ib} split was
     // empty.  Since we have no ::after pseudo-element, we do in fact want to be
     // appending to that last part, so advance to it if needed.  Note that here
     // aParentFrame is the result of a GetLastSpecialSibling call, so must be
     // either the last or next to last special sibling.
     nsIFrame* trailingInline = GetSpecialSibling(aParentFrame);
     if (trailingInline) {
       aParentFrame = trailingInline;
@@ -5804,42 +5804,42 @@ GetInsertNextSibling(nsIFrame* aParentFr
  */
 nsresult
 nsCSSFrameConstructor::AppendFramesToParent(nsFrameConstructorState&       aState,
                                             nsIFrame*                      aParentFrame,
                                             nsFrameItems&                  aFrameList,
                                             nsIFrame*                      aPrevSibling,
                                             bool                           aIsRecursiveCall)
 {
-  NS_PRECONDITION(!IsFrameSpecial(aParentFrame) ||
+  NS_PRECONDITION(!IsFramePartOfBlockInInlineSplit(aParentFrame) ||
                   !GetSpecialSibling(aParentFrame) ||
                   !GetSpecialSibling(aParentFrame)->GetFirstPrincipalChild(),
                   "aParentFrame has a special sibling with kids?");
   NS_PRECONDITION(!aPrevSibling || aPrevSibling->GetParent() == aParentFrame,
                   "Parent and prevsibling don't match");
 
   nsIFrame* nextSibling = ::GetInsertNextSibling(aParentFrame, aPrevSibling);
 
   NS_ASSERTION(nextSibling ||
                !aParentFrame->GetNextContinuation() ||
                !aParentFrame->GetNextContinuation()->GetFirstPrincipalChild() ||
                aIsRecursiveCall,
                "aParentFrame has later continuations with kids?");
   NS_ASSERTION(nextSibling ||
-               !IsFrameSpecial(aParentFrame) ||
+               !IsFramePartOfBlockInInlineSplit(aParentFrame) ||
                (IsInlineFrame(aParentFrame) &&
                 !GetSpecialSibling(aParentFrame) &&
                 !aParentFrame->GetNextContinuation()) ||
                aIsRecursiveCall,
                "aParentFrame is not last?");
 
   // If we're inserting a list of frames at the end of the trailing inline
   // of an {ib} split, we may need to create additional {ib} siblings to parent
   // them.
-  if (!nextSibling && IsFrameSpecial(aParentFrame)) {
+  if (!nextSibling && IsFramePartOfBlockInInlineSplit(aParentFrame)) {
     // When we get here, our frame list might start with a block.  If it does
     // so, and aParentFrame is an inline, and it and all its previous
     // continuations have no siblings, then put the initial blocks from the
     // frame list into the previous block of the {ib} split.  Note that we
     // didn't want to stop at the block part of the split when figuring out
     // initial parent, because that could screw up float parenting; it's easier
     // to do this little fixup here instead.
     if (aFrameList.NotEmpty() && !aFrameList.FirstChild()->IsInlineOutside()) {
@@ -6006,17 +6006,17 @@ nsCSSFrameConstructor::FindFrameForConte
   }
 
   // The frame we have now should never be a continuation
   NS_ASSERTION(!sibling->GetPrevContinuation(), "How did that happen?");
 
   if (aPrevSibling) {
     // The frame may be a special frame (a split inline frame that
     // contains a block).  Get the last part of that split.
-    if (IsFrameSpecial(sibling)) {
+    if (IsFramePartOfBlockInInlineSplit(sibling)) {
       sibling = GetLastSpecialSibling(sibling, true);
     }
 
     // The frame may have a continuation. If so, we want the last
     // non-overflow-container continuation as our previous sibling.
     sibling = sibling->GetTailContinuation();
   }
 
@@ -6146,17 +6146,17 @@ nsCSSFrameConstructor::GetInsertionPrevS
     nsIFrame* nextSibling = FindNextSibling(iter, childDisplay);
 
     if (nextSibling) {
       aParentFrame = nextSibling->GetParent()->GetContentInsertionFrame();
     }
     else {
       // No previous or next sibling, so treat this like an appended frame.
       *aIsAppend = true;
-      if (IsFrameSpecial(aParentFrame)) {
+      if (IsFramePartOfBlockInInlineSplit(aParentFrame)) {
         // Since we're appending, we'll walk to the last anonymous frame
         // that was created for the broken inline frame.  But don't walk
         // to the trailing inline if it's empty; stop at the block.
         aParentFrame = GetLastSpecialSibling(aParentFrame, false);
       }
       // Get continuation that parents the last child.  This MUST be done
       // before the AdjustAppendParentForAfterContent call.
       aParentFrame = nsLayoutUtils::LastContinuationWithChild(aParentFrame);
@@ -6635,17 +6635,17 @@ nsCSSFrameConstructor::ContentAppended(n
     nsresult rv = RecreateFramesForContent(parentFrame->GetContent(), false);
     LAYOUT_PHASE_TEMP_REENTER();
     return rv;
   }
 
   // If the frame we are manipulating is a ``special'' frame (that is, one
   // that's been created as a result of a block-in-inline situation) then we
   // need to append to the last special sibling, not to the frame itself.
-  bool parentSpecial = IsFrameSpecial(parentFrame);
+  bool parentSpecial = IsFramePartOfBlockInInlineSplit(parentFrame);
   if (parentSpecial) {
 #ifdef DEBUG
     if (gNoisyContentUpdates) {
       printf("nsCSSFrameConstructor::ContentAppended: parentFrame=");
       nsFrame::ListTag(stdout, parentFrame);
       printf(" is special\n");
     }
 #endif
@@ -7304,17 +7304,17 @@ nsCSSFrameConstructor::ContentRangeInser
   // XXXbz we should push our frame construction item code up higher, so we
   // know what our items are by the time we start figuring out previous
   // siblings
   if (prevSibling && frameItems.NotEmpty() &&
       frameItems.FirstChild()->GetParent() != prevSibling->GetParent()) {
 #ifdef DEBUG
     nsIFrame* frame1 = frameItems.FirstChild()->GetParent();
     nsIFrame* frame2 = prevSibling->GetParent();
-    NS_ASSERTION(!IsFrameSpecial(frame1) && !IsFrameSpecial(frame2),
+    NS_ASSERTION(!IsFramePartOfBlockInInlineSplit(frame1) && !IsFramePartOfBlockInInlineSplit(frame2),
                  "Neither should be special");
     NS_ASSERTION((frame1->GetType() == nsGkAtoms::tableFrame &&
                   frame2->GetType() == nsGkAtoms::tableOuterFrame) ||
                  (frame1->GetType() == nsGkAtoms::tableOuterFrame &&
                   frame2->GetType() == nsGkAtoms::tableFrame) ||
                  frame1->GetType() == nsGkAtoms::fieldSetFrame ||
                  (frame1->GetParent() &&
                   frame1->GetParent()->GetType() == nsGkAtoms::fieldSetFrame),
@@ -8417,17 +8417,17 @@ nsCSSFrameConstructor::MaybeRecreateCont
                                                              nsresult* aResult)
 {
   NS_PRECONDITION(aFrame, "Must have a frame");
   NS_PRECONDITION(aFrame->GetParent(), "Frame shouldn't be root");
   NS_PRECONDITION(aResult, "Null out param?");
   NS_PRECONDITION(aFrame == aFrame->FirstContinuation(),
                   "aFrame not the result of GetPrimaryFrame()?");
 
-  if (IsFrameSpecial(aFrame)) {
+  if (IsFramePartOfBlockInInlineSplit(aFrame)) {
     // The removal functions can't handle removal of an {ib} split directly; we
     // need to rebuild the containing block.
 #ifdef DEBUG
     if (gNoisyContentUpdates) {
       printf("nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval: "
              "frame=");
       nsFrame::ListTag(stdout, aFrame);
       printf(" is special\n");
@@ -8561,17 +8561,17 @@ nsCSSFrameConstructor::MaybeRecreateCont
        (parent->GetNextContinuation() && !parent->GetNextInFlow()))) {
     *aResult = RecreateFramesForContent(parent->GetContent(), true);
     return true;
   }
 
   // We might still need to reconstruct things if the parent of inFlowFrame is
   // special, since in that case the removal of aFrame might affect the
   // splitting of its parent.
-  if (!IsFrameSpecial(parent)) {
+  if (!IsFramePartOfBlockInInlineSplit(parent)) {
     return false;
   }
 
   // If inFlowFrame is not the only in-flow child of |parent|, then removing
   // it will change nothing about the {ib} split.
   if (inFlowFrame != parent->GetFirstPrincipalChild() ||
       inFlowFrame->LastContinuation()->GetNextSibling()) {
     return false;
@@ -10693,17 +10693,17 @@ nsCSSFrameConstructor::BuildInlineChildI
 // aParentFrame if our nextSibling is aNextSibling.  aParentFrame must
 // be an {ib} special inline.
 static bool
 IsSafeToAppendToSpecialInline(nsIFrame* aParentFrame, nsIFrame* aNextSibling)
 {
   NS_PRECONDITION(IsInlineFrame(aParentFrame),
                   "Must have an inline parent here");
   do {
-    NS_ASSERTION(IsFrameSpecial(aParentFrame), "How is this not special?");
+    NS_ASSERTION(IsFramePartOfBlockInInlineSplit(aParentFrame), "How is this not special?");
     if (aNextSibling || aParentFrame->GetNextContinuation() ||
         GetSpecialSibling(aParentFrame)) {
       return false;
     }
 
     aNextSibling = aParentFrame->GetNextSibling();
     aParentFrame = aParentFrame->GetParent();
   } while (IsInlineFrame(aParentFrame));
@@ -10966,17 +10966,17 @@ nsCSSFrameConstructor::WipeContainingBlo
   // do/while with breaks to take us to the "go and reconstruct" code.
   do {
     if (IsInlineFrame(aFrame)) {
       if (aItems.AreAllItemsInline()) {
         // We can just put the kids in.
         return false;
       }
 
-      if (!IsFrameSpecial(aFrame)) {
+      if (!IsFramePartOfBlockInInlineSplit(aFrame)) {
         // Need to go ahead and reconstruct.
         break;
       }
 
       // Now we're adding kids including some blocks to an inline part of an
       // {ib} split.  If we plan to call AppendFrames, and don't have a next
       // sibling for the new frames, and our parent is the last continuation of
       // the last part of the {ib} split, and the same is true of all our
@@ -10988,17 +10988,17 @@ nsCSSFrameConstructor::WipeContainingBlo
         return false;
       }
 
       // Need to reconstruct.
       break;
     }
 
     // Now we know we have a block parent.  If it's not special, we're all set.
-    if (!IsFrameSpecial(aFrame)) {
+    if (!IsFramePartOfBlockInInlineSplit(aFrame)) {
       return false;
     }
 
     // We're adding some kids to a block part of an {ib} split.  If all the
     // kids are blocks, we don't need to reconstruct.
     if (aItems.AreAllItemsBlock()) {
       return false;
     }
@@ -11019,17 +11019,17 @@ nsCSSFrameConstructor::WipeContainingBlo
   // 3)  Not an inline frame
   // We're guaranteed to find one, since nsStyleContext::ApplyStyleFixups
   // enforces that the root is display:none, display:table, or display:block.
   // Note that walking up "too far" is OK in terms of correctness, even if it
   // might be a little inefficient.  This is why we walk out of all
   // pseudo-frames -- telling which ones are or are not OK to walk out of is
   // too hard (and I suspect that we do in fact need to walk out of all of
   // them).
-  while (IsFrameSpecial(aContainingBlock) || aContainingBlock->IsInlineOutside() ||
+  while (IsFramePartOfBlockInInlineSplit(aContainingBlock) || aContainingBlock->IsInlineOutside() ||
          aContainingBlock->StyleContext()->GetPseudo()) {
     aContainingBlock = aContainingBlock->GetParent();
     NS_ASSERTION(aContainingBlock,
                  "Must have non-inline, non-special, non-pseudo frame as root "
                  "(or child of root, for a table root)!");
   }
 
   // Tell parent of the containing block to reformulate the
