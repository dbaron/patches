From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Remove implementation of nsRestyleHint_ChangeAnimationPhase.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1777,18 +1777,17 @@ RestyleManager::PostRestyleEvent(Element
 
   if (aRestyleHint == 0 && !aMinChangeHint) {
     // Nothing to do here
     return;
   }
 
   mPendingRestyles.AddPendingRestyle(aElement, aRestyleHint, aMinChangeHint);
 
-  if (aRestyleHint & ~(eRestyle_CSSTransitions | eRestyle_CSSAnimations |
-                       eRestyle_ChangeAnimationPhase)) {
+  if (aRestyleHint & ~(eRestyle_CSSTransitions | eRestyle_CSSAnimations)) {
     mHavePendingNonAnimationRestyles = true;
   }
 
   PostRestyleEventInternal(false);
 }
 
 void
 RestyleManager::PostRestyleEventInternal(bool aForLazyConstruction)
@@ -2687,21 +2686,19 @@ ElementRestyler::Restyle(nsRestyleHint a
   // Some changes to animations don't affect the computed style and yet still
   // require the layer to be updated. For example, pausing an animation via
   // the Web Animations API won't affect an element's style but still
   // requires us to pull the animation off the layer.
   AddLayerChangesForAnimation();
 
   // If we are restyling this frame with eRestyle_Self or weaker hints,
   // we restyle children with nsRestyleHint(0).  But we pass the
-  // eRestyle_ChangeAnimationPhaseDescendants and eRestyle_ForceDescendants
-  // flags down too.
+  // eRestyle_ForceDescendants flag down too.
   nsRestyleHint childRestyleHint =
     nsRestyleHint(aRestyleHint & (eRestyle_Subtree |
-                                  eRestyle_ChangeAnimationPhaseDescendants |
                                   eRestyle_ForceDescendants));
 
   nsRefPtr<nsStyleContext> oldContext = mFrame->StyleContext();
 
   // TEMPORARY (until bug 918064):  Call RestyleSelf for each
   // continuation or block-in-inline sibling.
 
   // We must make a single decision on how to process this frame and
@@ -4034,18 +4031,16 @@ RestyleManager::StructsToLog()
 #ifdef DEBUG
 /* static */ nsCString
 RestyleManager::RestyleHintToString(nsRestyleHint aHint)
 {
   nsCString result;
   bool any = false;
   const char* names[] = { "Self", "Subtree", "LaterSiblings", "CSSTransitions",
                           "CSSAnimations", "SVGAttrAnimations", "StyleAttribute",
-                          "ChangeAnimationPhase",
-                          "ChangeAnimationPhaseDescendants",
                           "Force", "ForceDescendants" };
   uint32_t hint = aHint & ((1 << ArrayLength(names)) - 1);
   uint32_t rest = aHint & ~((1 << ArrayLength(names)) - 1);
   for (uint32_t i = 0; i < ArrayLength(names); i++) {
     if (hint & (1 << i)) {
       if (any) {
         result.AppendLiteral(" | ");
       }
diff --git a/layout/base/nsChangeHint.h b/layout/base/nsChangeHint.h
--- a/layout/base/nsChangeHint.h
+++ b/layout/base/nsChangeHint.h
@@ -343,40 +343,26 @@ enum nsRestyleHint {
   // any other style data.  If a new style context results, update style
   // contexts on the descendants.  (Irrelevant if eRestyle_Self or
   // eRestyle_Subtree is also set, since those imply a superset of the
   // work.)  Supported only for element style contexts and not for
   // pseudo-elements or anonymous boxes, on which it converts to
   // eRestyle_Self.
   eRestyle_StyleAttribute = (1<<6),
 
-  // Additional restyle hint to be used along with CSSTransitions,
-  // CSSAnimations, SVGAttrAnimations, or StyleAttribute.  This
-  // indicates that along with the replacement given, appropriate
-  // switching between the style with animation and style without
-  // animation should be performed by adding or removing rules that
-  // should be present only in the style with animation.
-  // This is implied by eRestyle_Self or eRestyle_Subtree.
-  // FIXME: Remove this as part of bug 960465.
-  eRestyle_ChangeAnimationPhase = (1 << 7),
-
-  // Same as the previous, except this applies to the entire subtree.
-  // FIXME: Remove this as part of bug 960465.
-  eRestyle_ChangeAnimationPhaseDescendants = (1 << 8),
-
   // Continue the restyling process to the current frame's children even
   // if this frame's restyling resulted in no style changes.
-  eRestyle_Force = (1<<9),
+  eRestyle_Force = (1<<7),
 
   // Continue the restyling process to all of the current frame's
   // descendants, even if any frame's restyling resulted in no style
   // changes.  (Implies eRestyle_Force.)  Note that this is weaker than
   // eRestyle_Subtree, which makes us rerun selector matching on all
   // descendants rather than just continuing the restyling process.
-  eRestyle_ForceDescendants = (1<<10),
+  eRestyle_ForceDescendants = (1<<8),
 
   // Useful unions:
   eRestyle_AllHintsWithAnimations = eRestyle_CSSTransitions |
                                     eRestyle_CSSAnimations |
                                     eRestyle_SVGAttrAnimations |
                                     eRestyle_StyleAttribute,
 };
 
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1404,32 +1404,23 @@ nsStyleSet::RuleNodeWithReplacement(Elem
               !(nsCSSPseudoElements::PseudoElementSupportsStyleAttribute(aPseudoType) ||
                 nsCSSPseudoElements::PseudoElementSupportsUserActionState(aPseudoType))),
              "should have aPseudoElement only for certain pseudo elements");
 
   NS_ABORT_IF_FALSE(!(aReplacements & ~(eRestyle_CSSTransitions |
                                         eRestyle_CSSAnimations |
                                         eRestyle_SVGAttrAnimations |
                                         eRestyle_StyleAttribute |
-                                        eRestyle_ChangeAnimationPhase |
-                                        eRestyle_ChangeAnimationPhaseDescendants |
                                         eRestyle_Force |
                                         eRestyle_ForceDescendants)),
                     // FIXME: Once bug 979133 lands we'll have a better
                     // way to print these.
                     nsPrintfCString("unexpected replacement bits 0x%lX",
                                     uint32_t(aReplacements)).get());
 
-  // If we're changing animation phase, we have to reconsider what rules
-  // are in these four levels.
-  if (aReplacements & (eRestyle_ChangeAnimationPhase |
-                       eRestyle_ChangeAnimationPhaseDescendants)) {
-    aReplacements |= eRestyle_AllHintsWithAnimations;
-  }
-
   // FIXME (perf): This should probably not rebuild the whole path, but
   // only the path from the last change in the rule tree, like
   // ReplaceAnimationRule in nsStyleSet.cpp does.  (That could then
   // perhaps share this code, too?)
   // But if we do that, we'll need to pass whether we are rebuilding the
   // rule tree from ElementRestyler::RestyleSelf to avoid taking that
   // path when we're rebuilding the rule tree.
 
@@ -1482,34 +1473,26 @@ nsStyleSet::RuleNodeWithReplacement(Elem
               GetAnimationRule(aElement, aPseudoType);
             if (rule) {
               ruleWalker.ForwardOnPossiblyCSSRule(rule);
             }
           }
           break;
         }
         case eRestyle_SVGAttrAnimations: {
-          MOZ_ASSERT(aReplacements & (eRestyle_ChangeAnimationPhase |
-                                      eRestyle_ChangeAnimationPhaseDescendants),
-                     "don't know how to do this level without phase change");
-
           SVGAttrAnimationRuleProcessor* ruleProcessor =
             static_cast<SVGAttrAnimationRuleProcessor*>(
               mRuleProcessors[eSVGAttrAnimationSheet].get());
           if (ruleProcessor &&
               aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
             ruleProcessor->ElementRulesMatching(aElement, &ruleWalker);
           }
           break;
         }
         case eRestyle_StyleAttribute: {
-          MOZ_ASSERT(aReplacements & (eRestyle_ChangeAnimationPhase |
-                                      eRestyle_ChangeAnimationPhaseDescendants),
-                     "don't know how to do this level without phase change");
-
           if (!level->mIsImportant) {
             // First time through, we handle the non-!important rule.
             nsHTMLCSSStyleSheet* ruleProcessor =
               static_cast<nsHTMLCSSStyleSheet*>(
                 mRuleProcessors[eStyleAttrSheet].get());
             if (ruleProcessor) {
               lastScopedRN = ruleWalker.CurrentNode();
               if (aPseudoType ==
