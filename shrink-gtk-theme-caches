From: L. David Baron <dbaron@dbaron.org>

Bug 1367576 - Shrink existing caches to the size that's actually needed.  r=karlt

Now that, thanks to bug 1367577, we have the theme constants in an enum,
we can make these arrays smaller rather than assuming that the constants
might use any valid uint8_t value.

MozReview-Commit-ID: A6GjTarVurc

diff --git a/gfx/src/nsThemeConstants.h b/gfx/src/nsThemeConstants.h
--- a/gfx/src/nsThemeConstants.h
+++ b/gfx/src/nsThemeConstants.h
@@ -293,12 +293,14 @@ enum ThemeWidgetType : uint8_t {
   NS_THEME_MAC_VIBRANCY_LIGHT,
   NS_THEME_MAC_VIBRANCY_DARK,
   NS_THEME_MAC_DISCLOSURE_BUTTON_OPEN,
   NS_THEME_MAC_DISCLOSURE_BUTTON_CLOSED,
 
   NS_THEME_GTK_INFO_BAR,
   NS_THEME_MAC_SOURCE_LIST,
   NS_THEME_MAC_SOURCE_LIST_SELECTION,
-  NS_THEME_MAC_ACTIVE_SOURCE_LIST_SELECTION
+  NS_THEME_MAC_ACTIVE_SOURCE_LIST_SELECTION,
+
+  ThemeWidgetType_COUNT
 };
 
 #endif // nsThemeConstants_h_
diff --git a/widget/gtk/nsNativeThemeGTK.cpp b/widget/gtk/nsNativeThemeGTK.cpp
--- a/widget/gtk/nsNativeThemeGTK.cpp
+++ b/widget/gtk/nsNativeThemeGTK.cpp
@@ -109,20 +109,22 @@ static bool IsFrameContentNodeInNamespac
 {
   nsIContent *content = aFrame ? aFrame->GetContent() : nullptr;
   if (!content)
     return false;
   return content->IsInNamespace(aNamespace);
 }
 
 static bool IsWidgetTypeDisabled(uint8_t* aDisabledVector, uint8_t aWidgetType) {
+  MOZ_ASSERT(aWidgetType < ThemeWidgetType_COUNT);
   return (aDisabledVector[aWidgetType >> 3] & (1 << (aWidgetType & 7))) != 0;
 }
 
 static void SetWidgetTypeDisabled(uint8_t* aDisabledVector, uint8_t aWidgetType) {
+  MOZ_ASSERT(aWidgetType < ThemeWidgetType_COUNT);
   aDisabledVector[aWidgetType >> 3] |= (1 << (aWidgetType & 7));
 }
 
 static inline uint16_t
 GetWidgetStateKey(uint8_t aWidgetType, GtkWidgetState *aWidgetState)
 {
   return (aWidgetState->active |
           aWidgetState->focused << 1 |
@@ -131,24 +133,26 @@ GetWidgetStateKey(uint8_t aWidgetType, G
           aWidgetState->isDefault << 4 |
           aWidgetType << 5);
 }
 
 static bool IsWidgetStateSafe(uint8_t* aSafeVector,
                                 uint8_t aWidgetType,
                                 GtkWidgetState *aWidgetState)
 {
+  MOZ_ASSERT(aWidgetType < ThemeWidgetType_COUNT);
   uint8_t key = GetWidgetStateKey(aWidgetType, aWidgetState);
   return (aSafeVector[key >> 3] & (1 << (key & 7))) != 0;
 }
 
 static void SetWidgetStateSafe(uint8_t *aSafeVector,
                                uint8_t aWidgetType,
                                GtkWidgetState *aWidgetState)
 {
+  MOZ_ASSERT(aWidgetType < ThemeWidgetType_COUNT);
   uint8_t key = GetWidgetStateKey(aWidgetType, aWidgetState);
   aSafeVector[key >> 3] |= (1 << (key & 7));
 }
 
 /* static */ GtkTextDirection
 nsNativeThemeGTK::GetTextDirection(nsIFrame* aFrame)
 {
   // IsFrameRTL() treats vertical-rl modes as right-to-left (in addition to
diff --git a/widget/gtk/nsNativeThemeGTK.h b/widget/gtk/nsNativeThemeGTK.h
--- a/widget/gtk/nsNativeThemeGTK.h
+++ b/widget/gtk/nsNativeThemeGTK.h
@@ -6,16 +6,17 @@
 #ifndef _GTK_NSNATIVETHEMEGTK_H_
 #define _GTK_NSNATIVETHEMEGTK_H_
 
 #include "nsITheme.h"
 #include "nsCOMPtr.h"
 #include "nsIAtom.h"
 #include "nsIObserver.h"
 #include "nsNativeTheme.h"
+#include "nsThemeConstants.h"
 
 #include <gtk/gtk.h>
 #include "gtkdrawing.h"
 
 class nsNativeThemeGTK final : private nsNativeTheme,
                                public nsITheme,
                                public nsIObserver {
 public:
@@ -80,18 +81,18 @@ private:
                             WidgetNodeType& aGtkWidgetType,
                             GtkWidgetState* aState, gint* aWidgetFlags);
   bool GetExtraSizeForWidget(nsIFrame* aFrame, uint8_t aWidgetType,
                                nsIntMargin* aExtra);
 
   void RefreshWidgetWindow(nsIFrame* aFrame);
   WidgetNodeType NativeThemeToGtkTheme(uint8_t aWidgetType, nsIFrame* aFrame);
 
-  uint8_t mDisabledWidgetTypes[32];
-  uint8_t mSafeWidgetStates[1024];    // 256 widgets * 32 bits per widget
+  uint8_t mDisabledWidgetTypes[(ThemeWidgetType_COUNT + 7) / 8];
+  uint8_t mSafeWidgetStates[ThemeWidgetType_COUNT * 4]; // 32 bits per widget
   static const char* sDisabledEngines[];
 
   // Because moz_gtk_get_widget_border can be slow, we cache its results
   // by widget type.  Each bit in mBorderCacheValid says whether the
   // corresponding entry in mBorderCache is valid.
   void GetCachedWidgetBorder(nsIFrame* aFrame, uint8_t aWidgetType,
                              GtkTextDirection aDirection, nsIntMargin* aResult);
   uint8_t mBorderCacheValid[(MOZ_GTK_WIDGET_NODE_COUNT + 7) / 8];
