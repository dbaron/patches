From: L. David Baron <dbaron@dbaron.org>

Bug 809533, patch 3:  Stop handling allocation failures in the style system that no longer need to be handled.

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -2072,214 +2072,169 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
 
 const void*
 nsRuleNode::SetDefaultOnRoot(const nsStyleStructID aSID, nsStyleContext* aContext)
 {
   switch (aSID) {
     case eStyleStruct_Font:
     {
       nsStyleFont* fontData = new (mPresContext) nsStyleFont(mPresContext);
-      if (MOZ_LIKELY(fontData != nullptr)) {
-        nscoord minimumFontSize = mPresContext->MinFontSize(fontData->mLanguage);
-
-        if (minimumFontSize > 0 && !mPresContext->IsChrome()) {
-          fontData->mFont.size = NS_MAX(fontData->mSize, minimumFontSize);
-        }
-        else {
-          fontData->mFont.size = fontData->mSize;
-        }
-        aContext->SetStyle(eStyleStruct_Font, fontData);
+      nscoord minimumFontSize = mPresContext->MinFontSize(fontData->mLanguage);
+
+      if (minimumFontSize > 0 && !mPresContext->IsChrome()) {
+        fontData->mFont.size = NS_MAX(fontData->mSize, minimumFontSize);
       }
+      else {
+        fontData->mFont.size = fontData->mSize;
+      }
+      aContext->SetStyle(eStyleStruct_Font, fontData);
       return fontData;
     }
     case eStyleStruct_Display:
     {
       nsStyleDisplay* disp = new (mPresContext) nsStyleDisplay();
-      if (MOZ_LIKELY(disp != nullptr)) {
-        aContext->SetStyle(eStyleStruct_Display, disp);
-      }
+      aContext->SetStyle(eStyleStruct_Display, disp);
       return disp;
     }
     case eStyleStruct_Visibility:
     {
       nsStyleVisibility* vis = new (mPresContext) nsStyleVisibility(mPresContext);
-      if (MOZ_LIKELY(vis != nullptr)) {
-        aContext->SetStyle(eStyleStruct_Visibility, vis);
-      }
+      aContext->SetStyle(eStyleStruct_Visibility, vis);
       return vis;
     }
     case eStyleStruct_Text:
     {
       nsStyleText* text = new (mPresContext) nsStyleText();
-      if (MOZ_LIKELY(text != nullptr)) {
-        aContext->SetStyle(eStyleStruct_Text, text);
-      }
+      aContext->SetStyle(eStyleStruct_Text, text);
       return text;
     }
     case eStyleStruct_TextReset:
     {
       nsStyleTextReset* text = new (mPresContext) nsStyleTextReset();
-      if (MOZ_LIKELY(text != nullptr)) {
-        aContext->SetStyle(eStyleStruct_TextReset, text);
-      }
+      aContext->SetStyle(eStyleStruct_TextReset, text);
       return text;
     }
     case eStyleStruct_Color:
     {
       nsStyleColor* color = new (mPresContext) nsStyleColor(mPresContext);
-      if (MOZ_LIKELY(color != nullptr)) {
-        aContext->SetStyle(eStyleStruct_Color, color);
-      }
+      aContext->SetStyle(eStyleStruct_Color, color);
       return color;
     }
     case eStyleStruct_Background:
     {
       nsStyleBackground* bg = new (mPresContext) nsStyleBackground();
-      if (MOZ_LIKELY(bg != nullptr)) {
-        aContext->SetStyle(eStyleStruct_Background, bg);
-      }
+      aContext->SetStyle(eStyleStruct_Background, bg);
       return bg;
     }
     case eStyleStruct_Margin:
     {
       nsStyleMargin* margin = new (mPresContext) nsStyleMargin();
-      if (MOZ_LIKELY(margin != nullptr)) {
-        aContext->SetStyle(eStyleStruct_Margin, margin);
-      }
+      aContext->SetStyle(eStyleStruct_Margin, margin);
       return margin;
     }
     case eStyleStruct_Border:
     {
       nsStyleBorder* border = new (mPresContext) nsStyleBorder(mPresContext);
-      if (MOZ_LIKELY(border != nullptr)) {
-        aContext->SetStyle(eStyleStruct_Border, border);
-      }
+      aContext->SetStyle(eStyleStruct_Border, border);
       return border;
     }
     case eStyleStruct_Padding:
     {
       nsStylePadding* padding = new (mPresContext) nsStylePadding();
-      if (MOZ_LIKELY(padding != nullptr)) {
-        aContext->SetStyle(eStyleStruct_Padding, padding);
-      }
+      aContext->SetStyle(eStyleStruct_Padding, padding);
       return padding;
     }
     case eStyleStruct_Outline:
     {
       nsStyleOutline* outline = new (mPresContext) nsStyleOutline(mPresContext);
-      if (MOZ_LIKELY(outline != nullptr)) {
-        aContext->SetStyle(eStyleStruct_Outline, outline);
-      }
+      aContext->SetStyle(eStyleStruct_Outline, outline);
       return outline;
     }
     case eStyleStruct_List:
     {
       nsStyleList* list = new (mPresContext) nsStyleList();
-      if (MOZ_LIKELY(list != nullptr)) {
-        aContext->SetStyle(eStyleStruct_List, list);
-      }
+      aContext->SetStyle(eStyleStruct_List, list);
       return list;
     }
     case eStyleStruct_Position:
     {
       nsStylePosition* pos = new (mPresContext) nsStylePosition();
-      if (MOZ_LIKELY(pos != nullptr)) {
-        aContext->SetStyle(eStyleStruct_Position, pos);
-      }
+      aContext->SetStyle(eStyleStruct_Position, pos);
       return pos;
     }
     case eStyleStruct_Table:
     {
       nsStyleTable* table = new (mPresContext) nsStyleTable();
-      if (MOZ_LIKELY(table != nullptr)) {
-        aContext->SetStyle(eStyleStruct_Table, table);
-      }
+      aContext->SetStyle(eStyleStruct_Table, table);
       return table;
     }
     case eStyleStruct_TableBorder:
     {
       nsStyleTableBorder* table = new (mPresContext) nsStyleTableBorder(mPresContext);
-      if (MOZ_LIKELY(table != nullptr)) {
-        aContext->SetStyle(eStyleStruct_TableBorder, table);
-      }
+      aContext->SetStyle(eStyleStruct_TableBorder, table);
       return table;
     }
     case eStyleStruct_Content:
     {
       nsStyleContent* content = new (mPresContext) nsStyleContent();
-      if (MOZ_LIKELY(content != nullptr)) {
-        aContext->SetStyle(eStyleStruct_Content, content);
-      }
+      aContext->SetStyle(eStyleStruct_Content, content);
       return content;
     }
     case eStyleStruct_Quotes:
     {
       nsStyleQuotes* quotes = new (mPresContext) nsStyleQuotes();
-      if (MOZ_LIKELY(quotes != nullptr)) {
-        aContext->SetStyle(eStyleStruct_Quotes, quotes);
-      }
+      aContext->SetStyle(eStyleStruct_Quotes, quotes);
       return quotes;
     }
     case eStyleStruct_UserInterface:
     {
       nsStyleUserInterface* ui = new (mPresContext) nsStyleUserInterface();
-      if (MOZ_LIKELY(ui != nullptr)) {
-        aContext->SetStyle(eStyleStruct_UserInterface, ui);
-      }
+      aContext->SetStyle(eStyleStruct_UserInterface, ui);
       return ui;
     }
     case eStyleStruct_UIReset:
     {
       nsStyleUIReset* ui = new (mPresContext) nsStyleUIReset();
-      if (MOZ_LIKELY(ui != nullptr)) {
-        aContext->SetStyle(eStyleStruct_UIReset, ui);
-      }
+      aContext->SetStyle(eStyleStruct_UIReset, ui);
       return ui;
     }
 
     case eStyleStruct_XUL:
     {
       nsStyleXUL* xul = new (mPresContext) nsStyleXUL();
-      if (MOZ_LIKELY(xul != nullptr)) {
-        aContext->SetStyle(eStyleStruct_XUL, xul);
-      }
+      aContext->SetStyle(eStyleStruct_XUL, xul);
       return xul;
     }
 
     case eStyleStruct_Column:
     {
       nsStyleColumn* column = new (mPresContext) nsStyleColumn(mPresContext);
-      if (MOZ_LIKELY(column != nullptr)) {
-        aContext->SetStyle(eStyleStruct_Column, column);
-      }
+      aContext->SetStyle(eStyleStruct_Column, column);
       return column;
     }
 
     case eStyleStruct_SVG:
     {
       nsStyleSVG* svg = new (mPresContext) nsStyleSVG();
-      if (MOZ_LIKELY(svg != nullptr)) {
-        aContext->SetStyle(eStyleStruct_SVG, svg);
-      }
+      aContext->SetStyle(eStyleStruct_SVG, svg);
       return svg;
     }
 
     case eStyleStruct_SVGReset:
     {
       nsStyleSVGReset* svgReset = new (mPresContext) nsStyleSVGReset();
-      if (MOZ_LIKELY(svgReset != nullptr)) {
-        aContext->SetStyle(eStyleStruct_SVGReset, svgReset);
-      }
+      aContext->SetStyle(eStyleStruct_SVGReset, svgReset);
       return svgReset;
     }
     default:
       /*
        * unhandled case: nsStyleStructID_Length.
        * last item of nsStyleStructID, to know its length.
        */
+      NS_ABORT_IF_FALSE(false, "unexpected SID");
       return nullptr;
   }
   return nullptr;
 }
 
 /*
  * This function handles cascading of *-left or *-right box properties
  * against *-start (which is L for LTR and R for RTL) or *-end (which is
@@ -2380,18 +2335,16 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
         data_ = new (mPresContext) nsStyle##type_(*parentdata_);              \
       else                                                                    \
         data_ = new (mPresContext) nsStyle##type_ ctorargs_;                  \
     }                                                                         \
     else                                                                      \
       data_ = new (mPresContext) nsStyle##type_ ctorargs_;                    \
   }                                                                           \
                                                                               \
-  if (MOZ_UNLIKELY(!data_))                                                   \
-    return nullptr;  /* Out Of Memory */                                      \
   if (!parentdata_)                                                           \
     parentdata_ = data_;
 
 /**
  * Begin an nsRuleNode::Compute*Data function for a reset struct.
  *
  * @param type_ The nsStyle* type this function computes.
  * @param ctorargs_ The arguments used for the default nsStyle* constructor.
@@ -2416,19 +2369,16 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
   if (aStartStruct)                                                           \
     /* We only need to compute the delta between this computed data and */    \
     /* our computed data. */                                                  \
     data_ = new (mPresContext)                                                \
             nsStyle##type_(*static_cast<nsStyle##type_*>(aStartStruct));      \
   else                                                                        \
     data_ = new (mPresContext) nsStyle##type_ ctorargs_;                      \
                                                                               \
-  if (MOZ_UNLIKELY(!data_))                                                   \
-    return nullptr;  /* Out Of Memory */                                      \
-                                                                              \
   /* If |canStoreInRuleTree| might be true by the time we're done, we */      \
   /* can't call parentContext->GetStyle##type_() since it could recur into */ \
   /* setting the same struct on the same rule node, causing a leak. */        \
   const nsStyle##type_* parentdata_ = data_;                                  \
   if (parentContext &&                                                        \
       aRuleDetail != eRuleFullReset &&                                        \
       aRuleDetail != eRulePartialReset &&                                     \
       aRuleDetail != eRuleNone)                                               \
@@ -2448,20 +2398,16 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
                    "unless all properties have been specified with values "   \
                    "other than inherit");                                     \
   if (canStoreInRuleTree) {                                                   \
     /* We were fully specified and can therefore be cached right on the */    \
     /* rule node. */                                                          \
     if (!aHighestNode->mStyleData.mInheritedData) {                           \
       aHighestNode->mStyleData.mInheritedData =                               \
         new (mPresContext) nsInheritedStyleData;                              \
-      if (MOZ_UNLIKELY(!aHighestNode->mStyleData.mInheritedData)) {           \
-        data_->Destroy(mPresContext);                                         \
-        return nullptr;                                                       \
-      }                                                                       \
     }                                                                         \
     NS_ASSERTION(!aHighestNode->mStyleData.mInheritedData->                   \
                    mStyleStructs[eStyleStruct_##type_],                       \
                  "Going to leak style data");                                 \
     aHighestNode->mStyleData.mInheritedData->                                 \
       mStyleStructs[eStyleStruct_##type_] = data_;                            \
     /* Propagate the bit down. */                                             \
     PropagateDependentBit(eStyleStruct_##type_, aHighestNode, data_);         \
@@ -2492,20 +2438,16 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
     /* on the style context. */                                               \
     aContext->SetStyle(eStyleStruct_##type_, data_);                          \
   else {                                                                      \
     /* We were fully specified and can therefore be cached right on the */    \
     /* rule node. */                                                          \
     if (!aHighestNode->mStyleData.mResetData) {                               \
       aHighestNode->mStyleData.mResetData =                                   \
         new (mPresContext) nsResetStyleData;                                  \
-      if (MOZ_UNLIKELY(!aHighestNode->mStyleData.mResetData)) {               \
-        data_->Destroy(mPresContext);                                         \
-        return nullptr;                                                       \
-      }                                                                       \
     }                                                                         \
     NS_ASSERTION(!aHighestNode->mStyleData.mResetData->                       \
                    mStyleStructs[eStyleStruct_##type_],                       \
                  "Going to leak style data");                                 \
     aHighestNode->mStyleData.mResetData->                                     \
       mStyleStructs[eStyleStruct_##type_] = data_;                            \
     /* Propagate the bit down. */                                             \
     PropagateDependentBit(eStyleStruct_##type_, aHighestNode, data_);         \
@@ -7672,28 +7614,18 @@ nsRuleNode::GetStyleData(nsStyleStructID
     return data; // We have a fully specified struct. Just return it.
 
   if (MOZ_UNLIKELY(!aComputeData))
     return nullptr;
 
   // Nothing is cached.  We'll have to delve further and examine our rules.
   data = WalkRuleTree(aSID, aContext);
 
-  if (MOZ_LIKELY(data != nullptr))
-    return data;
-
-  NS_NOTREACHED("could not create style struct");
-  // To ensure that |GetStyleData| never returns null (even when we're
-  // out of memory), we'll get the style set and get a copy of the
-  // default values for the given style struct from the set.  Note that
-  // this works fine even if |this| is a rule node that has been
-  // destroyed (leftover from a previous rule tree) but is somehow still
-  // used.
-  return mPresContext->PresShell()->StyleSet()->
-    DefaultStyleData()->GetStyleData(aSID);
+  NS_ABORT_IF_FALSE(data, "should have aborted on out-of-memory");
+  return data;
 }
 
 // See comments above in GetStyleData for an explanation of what the
 // code below does.
 #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)                        \
 const nsStyle##name_*                                                         \
 nsRuleNode::GetStyle##name_(nsStyleContext* aContext, bool aComputeData)    \
 {                                                                             \
@@ -7708,24 +7640,18 @@ nsRuleNode::GetStyle##name_(nsStyleConte
     return data;                                                              \
                                                                               \
   if (MOZ_UNLIKELY(!aComputeData))                                            \
     return nullptr;                                                           \
                                                                               \
   data = static_cast<const nsStyle##name_ *>                                  \
            (WalkRuleTree(eStyleStruct_##name_, aContext));                    \
                                                                               \
-  if (MOZ_LIKELY(data != nullptr))                                            \
-    return data;                                                              \
-                                                                              \
-  NS_NOTREACHED("could not create style struct");                             \
-  return                                                                      \
-    static_cast<const nsStyle##name_ *>(                                      \
-                   mPresContext->PresShell()->StyleSet()->                    \
-                     DefaultStyleData()->GetStyleData(eStyleStruct_##name_)); \
+  NS_ABORT_IF_FALSE(data, "should have aborted on out-of-memory");            \
+  return data;                                                                \
 }
 #include "nsStyleStructList.h"
 #undef STYLE_STRUCT
 
 void
 nsRuleNode::Mark()
 {
   for (nsRuleNode *node = this;
diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -253,22 +253,16 @@ nsStyleContext::GetUniqueStyleData(const
 
 #undef UNIQUE_CASE
 
   default:
     NS_ERROR("Struct type not supported.  Please find another way to do this if you can!");
     return nullptr;
   }
 
-  if (!result) {
-    NS_WARNING("Ran out of memory while trying to allocate memory for a unique style struct! "
-               "Returning the non-unique data.");
-    return const_cast<void*>(current);
-  }
-
   SetStyle(aSID, result);
   mBits &= ~nsCachedStyleData::GetBitForSID(aSID);
 
   return result;
 }
 
 void
 nsStyleContext::SetStyle(nsStyleStructID aSID, void* aStruct)
@@ -281,17 +275,16 @@ nsStyleContext::SetStyle(nsStyleStructID
   // NOTE:  nsCachedStyleData::GetStyleData works roughly the same way.
   // See the comments there (in nsRuleNode.h) for more details about
   // what this is doing and why.
 
   void** dataSlot;
   if (nsCachedStyleData::IsReset(aSID)) {
     if (!mCachedResetData) {
       mCachedResetData = new (mRuleNode->GetPresContext()) nsResetStyleData;
-      // XXXbz And if that fails?
     }
     dataSlot = &mCachedResetData->mStyleStructs[aSID];
   } else {
     dataSlot = &mCachedInheritedData.mStyleStructs[aSID];
   }
   NS_ASSERTION(!*dataSlot || (mBits & nsCachedStyleData::GetBitForSID(aSID)),
                "Going to leak style data");
   *dataSlot = aStruct;
@@ -675,18 +668,17 @@ already_AddRefed<nsStyleContext>
 NS_NewStyleContext(nsStyleContext* aParentContext,
                    nsIAtom* aPseudoTag,
                    nsCSSPseudoElements::Type aPseudoType,
                    nsRuleNode* aRuleNode)
 {
   nsStyleContext* context =
     new (aRuleNode->GetPresContext())
       nsStyleContext(aParentContext, aPseudoTag, aPseudoType, aRuleNode);
-  if (context)
-    context->AddRef();
+  context->AddRef();
   return context;
 }
 
 static inline void
 ExtractAnimationValue(nsCSSProperty aProperty,
                       nsStyleContext* aStyleContext,
                       nsStyleAnimation::Value& aResult)
 {
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -124,30 +124,18 @@ nsStyleSet::SizeOfIncludingThis(nsMalloc
   return n;
 }
 
 nsresult
 nsStyleSet::Init(nsPresContext *aPresContext)
 {
   mFirstLineRule = new nsEmptyStyleRule;
   mFirstLetterRule = new nsEmptyStyleRule;
-  if (!mFirstLineRule || !mFirstLetterRule) {
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-
-  if (!BuildDefaultStyleData(aPresContext)) {
-    mDefaultStyleData.Destroy(0, aPresContext);
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
 
   mRuleTree = nsRuleNode::CreateRootNode(aPresContext);
-  if (!mRuleTree) {
-    mDefaultStyleData.Destroy(0, aPresContext);
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
 
   GatherRuleProcessors(eAnimationSheet);
   GatherRuleProcessors(eTransitionSheet);
 
   return NS_OK;
 }
 
 nsresult
@@ -911,49 +899,16 @@ nsStyleSet::WalkRuleProcessors(nsIStyleR
   if (mRuleProcessors[eStyleAttrSheet])
     (*aFunc)(mRuleProcessors[eStyleAttrSheet], aData);
   if (mRuleProcessors[eOverrideSheet])
     (*aFunc)(mRuleProcessors[eOverrideSheet], aData);
   (*aFunc)(mRuleProcessors[eAnimationSheet], aData);
   (*aFunc)(mRuleProcessors[eTransitionSheet], aData);
 }
 
-bool nsStyleSet::BuildDefaultStyleData(nsPresContext* aPresContext)
-{
-  NS_ASSERTION(!mDefaultStyleData.mResetData &&
-               !mDefaultStyleData.mInheritedData,
-               "leaking default style data");
-  mDefaultStyleData.mResetData = new (aPresContext) nsResetStyleData;
-  if (!mDefaultStyleData.mResetData)
-    return false;
-  mDefaultStyleData.mInheritedData = new (aPresContext) nsInheritedStyleData;
-  if (!mDefaultStyleData.mInheritedData)
-    return false;
-
-#define SSARG_PRESCONTEXT aPresContext
-
-#define CREATE_DATA(name, type, args) \
-  if (!(mDefaultStyleData.m##type##Data->mStyleStructs[eStyleStruct_##name] = \
-          new (aPresContext) nsStyle##name args)) \
-    return false;
-
-#define STYLE_STRUCT_INHERITED(name, checkdata_cb, ctor_args) \
-  CREATE_DATA(name, Inherited, ctor_args)
-#define STYLE_STRUCT_RESET(name, checkdata_cb, ctor_args) \
-  CREATE_DATA(name, Reset, ctor_args)
-
-#include "nsStyleStructList.h"
-
-#undef STYLE_STRUCT_INHERITED
-#undef STYLE_STRUCT_RESET
-#undef SSARG_PRESCONTEXT
-
-  return true;
-}
-
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleFor(Element* aElement,
                             nsStyleContext* aParentContext)
 {
   TreeMatchContext treeContext(true, nsRuleWalker::eRelevantLinkUnvisited,
                                aElement->OwnerDoc());
   return ResolveStyleFor(aElement, aParentContext, treeContext);
 }
@@ -1300,18 +1255,16 @@ nsStyleSet::Shutdown(nsPresContext* aPre
   // We can have old rule trees either because:
   //   (1) we failed the assertions in EndReconstruct, or
   //   (2) we're shutting down within a reconstruct (see bug 462392)
   for (uint32_t i = mOldRuleTrees.Length(); i > 0; ) {
     --i;
     mOldRuleTrees[i]->Destroy();
   }
   mOldRuleTrees.Clear();
-
-  mDefaultStyleData.Destroy(0, aPresContext);
 }
 
 static const uint32_t kGCInterval = 300;
 
 void
 nsStyleSet::NotifyStyleContextDestroyed(nsPresContext* aPresContext,
                                         nsStyleContext* aStyleContext)
 {
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -62,20 +62,16 @@ class nsStyleSet
 
   size_t SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf) const;
 
   // Initialize the object.  You must check the return code and not use
   // the nsStyleSet if Init() fails.
 
   nsresult Init(nsPresContext *aPresContext);
 
-  // For getting the cached default data in case we hit out-of-memory.
-  // To be used only by nsRuleNode.
-  nsCachedStyleData* DefaultStyleData() { return &mDefaultStyleData; }
-
   nsRuleNode* GetRuleTree() { return mRuleTree; }
 
   // enable / disable the Quirk style sheet
   void EnableQuirkStyleSheet(bool aEnable);
 
   // get a style context for a non-pseudo frame.
   already_AddRefed<nsStyleContext>
   ResolveStyleFor(mozilla::dom::Element* aElement,
@@ -289,19 +285,16 @@ class nsStyleSet
   nsCSSStyleSheet::EnsureUniqueInnerResult EnsureUniqueInnerOnCSSSheets();
 
   nsIStyleRule* InitialStyleRule();
 
  private:
   nsStyleSet(const nsStyleSet& aCopy) MOZ_DELETE;
   nsStyleSet& operator=(const nsStyleSet& aCopy) MOZ_DELETE;
 
-  // Returns false on out-of-memory.
-  bool BuildDefaultStyleData(nsPresContext* aPresContext);
-
   // Run mark-and-sweep GC on mRuleTree and mOldRuleTrees, based on mRoots.
   void GCRuleTrees();
 
   // Update the rule processor list after a change to the style sheet list.
   nsresult GatherRuleProcessors(sheetType aType);
 
   void AddImportantRules(nsRuleNode* aCurrLevelNode,
                          nsRuleNode* aLastPrevLevelNode,
@@ -359,21 +352,16 @@ class nsStyleSet
 
   nsCOMPtr<nsIStyleRuleProcessor> mRuleProcessors[eSheetTypeCount];
 
   // cached instance for enabling/disabling
   nsCOMPtr<nsIStyleSheet> mQuirkStyleSheet;
 
   nsRefPtr<nsBindingManager> mBindingManager;
 
-  // To be used only in case of emergency, such as being out of memory
-  // or operating on a deleted rule node.  The latter should never
-  // happen, of course.
-  nsCachedStyleData mDefaultStyleData;
-
   nsRuleNode* mRuleTree; // This is the root of our rule tree.  It is a
                          // lexicographic tree of matched rules that style
                          // contexts use to look up properties.
 
   uint16_t mBatching;
 
   unsigned mInShutdown : 1;
   unsigned mAuthorStyleDisabled: 1;
