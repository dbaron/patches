From: L. David Baron <dbaron@dbaron.org>

Bug 898333:  Change ReResolveStyleContext to reach next-continuations from their prev-continuation rather than from their parent.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1720,18 +1720,24 @@ ElementForStyleContext(nsIContent* aPare
     nsBlockFrame* block = nsBlockFrame::GetNearestAncestorBlock(aFrame);
     return block->GetContent()->AsElement();
   }
 
   nsIContent* content = aParentContent ? aParentContent : aFrame->GetContent();
   return content->AsElement();
 }
 
+/**
+ * Get the previous continuation or similar special sibling (assuming
+ * block/inline alternation), conditionally on it having the same style.
+ * This assumes that we're not between resolving the two (i.e., that
+ * they're both already resolved.
+ */
 static nsIFrame*
-GetPrevContinuationWithPossiblySameStyle(nsIFrame* aFrame)
+GetPrevContinuationWithSameStyle(nsIFrame* aFrame)
 {
   // Account for {ib} splits when looking for "prevContinuation".  In
   // particular, for the first-continuation of a part of an {ib} split we
   // want to use the special prevsibling of the special prevsibling of
   // aFrame, which should have the same style context as aFrame itself.
   // In particular, if aFrame is the first continuation of an inline part
   // of an {ib} split then its special prevsibling is a block, and the
   // special prevsibling of _that_ is an inline, just like aFrame.
@@ -1745,19 +1751,53 @@ GetPrevContinuationWithPossiblySameStyle
     // property directly
     prevContinuation = static_cast<nsIFrame*>(
       aFrame->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
     if (prevContinuation) {
       prevContinuation = static_cast<nsIFrame*>(
         prevContinuation->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
     }
   }
+  if (prevContinuation->StyleContext() != aFrame->StyleContext()) {
+    prevContinuation = nullptr;
+  }
   return prevContinuation;
 }
 
+/**
+ * Get the next continuation or similar special sibling (assuming
+ * block/inline alternation), conditionally on it having the same style.
+ *
+ * Since this is used when deciding to copy the new style context, it
+ * takes as an argument the old style context to check if the style is
+ * the same.
+ */
+static nsIFrame*
+GetNextContinuationWithSameStyle(nsIFrame* aFrame,
+                                 nsStyleContext* aOldStyleContext)
+{
+  // See GetPrevContinuationWithSameStyle about {ib} splits.
+
+  nsIFrame *nextContinuation = aFrame->GetNextContinuation();
+  if (!nextContinuation && (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
+    // We're the last continuation, so we have to hop back to the first
+    // before getting the frame property
+    nextContinuation = static_cast<nsIFrame*>(aFrame->GetFirstContinuation()->
+      Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+    if (nextContinuation) {
+      nextContinuation = static_cast<nsIFrame*>(
+        nextContinuation->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+    }
+  }
+  if (nextContinuation->StyleContext() != aOldStyleContext) {
+    nextContinuation = nullptr;
+  }
+  return nextContinuation;
+}
+
 nsresult
 RestyleManager::ReparentStyleContext(nsIFrame* aFrame)
 {
   if (nsGkAtoms::placeholderFrame == aFrame->GetType()) {
     // Also reparent the out-of-flow and all its continuations.
     nsIFrame* outOfFlow =
       nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
     NS_ASSERTION(outOfFlow, "no out-of-flow frame");
@@ -2049,18 +2089,22 @@ ElementRestyler::CaptureChange(nsStyleCo
       mChangeList->AppendChange(mFrame, mContent, ourChange);
     }
   }
   NS_UpdateHint(mHintsNotHandledForDescendants,
                 NS_HintsNotHandledForDescendantsIn(ourChange));
 }
 
 /**
- * Recompute style for mFrame and accumulate changes into mChangeList
- * given that mMinChange is already accumulated for an ancestor.
+ * Recompute style for mFrame (which should not have a prev continuation
+ * with the same style) all of its next continuations with the same
+ * style, and all special siblings of the same type (either block or
+ * inline, skipping the intermediates of the other type) and accumulate
+ * changes into mChangeList given that mMinChange is already accumulated
+ * for an ancestor.
  * mParentContent is the content node used to resolve the parent style
  * context.  This means that, for pseudo-elements, it is the content
  * that should be used for selector matching (rather than the fake
  * content node attached to the frame).
  */
 void
 ElementRestyler::Restyle(nsRestyleHint aRestyleHint)
 {
@@ -2671,62 +2715,62 @@ RestyleManager::ComputeStyleChangeFor(ns
   PROFILER_LABEL("CSS", "ComputeStyleChangeFor");
 
   nsIContent *content = aFrame->GetContent();
   if (aMinChange) {
     aChangeList->AppendChange(aFrame, content, aMinChange);
   }
 
   nsIFrame* frame = aFrame;
-  nsIFrame* frame2 = aFrame;
 
   NS_ASSERTION(!frame->GetPrevContinuation(), "must start with the first in flow");
 
-  // We want to start with this frame and walk all its next-in-flows,
-  // as well as all its special siblings and their next-in-flows,
-  // reresolving style on all the frames we encounter in this walk.
+  // We need to handle aFrame and all of its continuations and special
+  // siblings and their continuations.  ReResolveStyleContext loops over
+  // the continuations, and also loops over the similar-type sequences
+  // in block-in-inline splits (i.e., either all the blocks or all the
+  // inlines), so here we only have to advance one step to the other set
+  // of special siblings (i.e., switch from blocks to inlines, or
+  // vice-versa).
 
   FramePropertyTable* propTable = mPresContext->PropertyTable();
 
   TreeMatchContext treeMatchContext(true,
                                     nsRuleWalker::eRelevantLinkUnvisited,
                                     mPresContext->Document());
   nsIContent *parent = content ? content->GetParent() : nullptr;
   Element *parentElement =
     parent && parent->IsElement() ? parent->AsElement() : nullptr;
   treeMatchContext.InitAncestors(parentElement);
   nsTArray<nsIContent*> visibleKidsOfHiddenElement;
-  do {
-    // Outer loop over special siblings
-    do {
-      // Inner loop over next-in-flows of the current frame
-      ElementRestyler restyler(mPresContext, frame, aChangeList,
-                               aMinChange, aRestyleTracker,
-                               treeMatchContext,
-                               visibleKidsOfHiddenElement);
+  for (int ibSet = 0; ibSet < 2; ++ibSet) {
+    // loop over the two sets (blocks, inlines) of special siblings
+    ElementRestyler restyler(mPresContext, frame, aChangeList,
+                             aMinChange, aRestyleTracker,
+                             treeMatchContext,
+                             visibleKidsOfHiddenElement);
 
-      restyler.Restyle(aRestyleDescendants ? eRestyle_Subtree : eRestyle_Self);
+    restyler.Restyle(aRestyleDescendants ? eRestyle_Subtree : eRestyle_Self);
 
-      if (restyler.MinChange() & nsChangeHint_ReconstructFrame) {
-        // If it's going to cause a framechange, then don't bother
-        // with the continuations or special siblings since they'll be
-        // clobbered by the frame reconstruct anyway.
-        NS_ASSERTION(!frame->GetPrevContinuation(),
-                     "continuing frame had more severe impact than first-in-flow");
-        return;
-      }
-
-      frame = frame->GetNextContinuation();
-    } while (frame);
+    if (restyler.MinChange() & nsChangeHint_ReconstructFrame) {
+      // If it's going to cause a framechange, then don't bother
+      // with the continuations or special siblings since they'll be
+      // clobbered by the frame reconstruct anyway.
+      NS_ASSERTION(!frame->GetPrevContinuation(),
+                   "continuing frame had more severe impact than first-in-flow");
+      return;
+    }
 
     // Might we have special siblings?
-    if (!(frame2->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
+    if (!(frame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
       // nothing more to do here
       return;
     }
 
-    frame2 = static_cast<nsIFrame*>
-      (propTable->Get(frame2, nsIFrame::IBSplitSpecialSibling()));
-    frame = frame2;
-  } while (frame2);
+    frame = static_cast<nsIFrame*>
+      (propTable->Get(frame, nsIFrame::IBSplitSpecialSibling()));
+    if (!frame) {
+      return;
+    }
+  }
 }
 
 } // namespace mozilla
