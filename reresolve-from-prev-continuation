From: L. David Baron <dbaron@dbaron.org>

Bug 828312 patch 11:  Change ReResolveStyleContext to reach next-continuations from their prev-continuation rather than from their parent.

diff --git a/layout/base/nsFrameManager.cpp b/layout/base/nsFrameManager.cpp
--- a/layout/base/nsFrameManager.cpp
+++ b/layout/base/nsFrameManager.cpp
@@ -726,18 +726,24 @@ ElementForStyleContext(nsIContent* aPare
     nsBlockFrame* block = nsBlockFrame::GetNearestAncestorBlock(aFrame);
     return block->GetContent()->AsElement();
   }
 
   nsIContent* content = aParentContent ? aParentContent : aFrame->GetContent();
   return content->AsElement();
 }
 
+/**
+ * Get the previous continuation or similar special sibling (assuming
+ * block/inline alternation), conditionally on it having the same style.
+ * This assumes that we're not between resolving the two (i.e., that
+ * they're both already resolved.
+ */
 static nsIFrame*
-GetPrevContinuationWithPossiblySameStyle(nsIFrame* aFrame)
+GetPrevContinuationWithSameStyle(nsIFrame* aFrame)
 {
   // Account for {ib} splits when looking for "prevContinuation".  In
   // particular, for the first-continuation of a part of an {ib} split we
   // want to use the special prevsibling of the special prevsibling of
   // aFrame, which should have the same style context as aFrame itself.
   // In particular, if aFrame is the first continuation of an inline part
   // of an {ib} split then its special prevsibling is a block, and the
   // special prevsibling of _that_ is an inline, just like aFrame.
@@ -751,19 +757,53 @@ GetPrevContinuationWithPossiblySameStyle
     // property directly
     prevContinuation = static_cast<nsIFrame*>(
       aFrame->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
     if (prevContinuation) {
       prevContinuation = static_cast<nsIFrame*>(
         prevContinuation->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
     }
   }
+  if (prevContinuation->StyleContext() != aFrame->StyleContext()) {
+    prevContinuation = nullptr;
+  }
   return prevContinuation;
 }
 
+/**
+ * Get the next continuation or similar special sibling (assuming
+ * block/inline alternation), conditionally on it having the same style.
+ *
+ * Since this is used when deciding to copy the new style context, it
+ * takes as an argument the old style context to check if the style is
+ * the same.
+ */
+static nsIFrame*
+GetNextContinuationWithSameStyle(nsIFrame* aFrame,
+                                 nsStyleContext* aOldStyleContext)
+{
+  // See GetPrevContinuationWithSameStyle about {ib} splits.
+
+  nsIFrame *nextContinuation = aFrame->GetNextContinuation();
+  if (!nextContinuation && (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
+    // We're the last continuation, so we have to hop back to the first
+    // before getting the frame property
+    nextContinuation = static_cast<nsIFrame*>(aFrame->GetFirstContinuation()->
+      Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+    if (nextContinuation) {
+      nextContinuation = static_cast<nsIFrame*>(
+        nextContinuation->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
+    }
+  }
+  if (nextContinuation->StyleContext() != aOldStyleContext) {
+    nextContinuation = nullptr;
+  }
+  return nextContinuation;
+}
+
 nsresult
 nsFrameManager::ReparentStyleContext(nsIFrame* aFrame)
 {
   if (nsGkAtoms::placeholderFrame == aFrame->GetType()) {
     // Also reparent the out-of-flow and all its continuations.
     nsIFrame* outOfFlow =
       nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
     NS_ASSERTION(outOfFlow, "no out-of-flow frame");
@@ -983,18 +1023,21 @@ CaptureChange(nsStyleContext* aOldContex
     if (!(ourChange & nsChangeHint_ReconstructFrame) || aContent) {
       aChangeList->AppendChange(aFrame, aContent, ourChange);
     }
   }
   aHintsNotHandledForDescendants = NS_HintsNotHandledForDescendantsIn(ourChange);
 }
 
 /**
- * Recompute style for aFrame and accumulate changes into aChangeList
- * given that aMinChange is already accumulated for an ancestor.
+ * Recompute style for aFrame (which must be a first-continuation) and
+ * all of its next continuations (but not special siblings!) and
+ * accumulate changes into aChangeList given that aMinChange is already
+ * accumulated for an ancestor.
+ *
  * aParentContent is the content node used to resolve the parent style
  * context.  This means that, for pseudo-elements, it is the content
  * that should be used for selector matching (rather than the fake
  * content node attached to the frame).
  *
  * For aParentFrameHintsNotHandledForDescendants, see
  * nsStyleContext::CalcStyleDifference.
  */
@@ -1665,70 +1708,64 @@ nsFrameManager::ComputeStyleChangeFor(ns
   PROFILER_LABEL("CSS", "ComputeStyleChangeFor");
 
   nsIContent *content = aFrame->GetContent();
   if (aMinChange) {
     aChangeList->AppendChange(aFrame, content, aMinChange);
   }
 
   nsIFrame* frame = aFrame;
-  nsIFrame* frame2 = aFrame;
 
   NS_ASSERTION(!frame->GetPrevContinuation(), "must start with the first in flow");
 
-  // We want to start with this frame and walk all its next-in-flows,
-  // as well as all its special siblings and their next-in-flows,
-  // reresolving style on all the frames we encounter in this walk.
+  // We need to handle aFrame and all of its continuations and special
+  // siblings and their continuations.  ReResolveStyleContext loops over
+  // the continuations, so here we only have to loop over special
+  // siblings (i.e., block-inside-inline splits).
 
   FramePropertyTable *propTable = GetPresContext()->PropertyTable();
 
   TreeMatchContext treeMatchContext(true,
                                     nsRuleWalker::eRelevantLinkUnvisited,
                                     mPresShell->GetDocument());
   nsIContent *parent = content ? content->GetParent() : nullptr;
   Element *parentElement =
     parent && parent->IsElement() ? parent->AsElement() : nullptr;
   treeMatchContext.InitAncestors(parentElement);
   nsTArray<nsIContent*> visibleKidsOfHiddenElement;
   do {
-    // Outer loop over special siblings
-    do {
-      // Inner loop over next-in-flows of the current frame
-      nsChangeHint frameChange =
-        ReResolveStyleContext(GetPresContext(), frame, nullptr,
-                              aChangeList, aMinChange, nsChangeHint(0),
-                              aRestyleDescendants ?
-                                eRestyle_Subtree : eRestyle_Self,
-                              aRestyleTracker,
-                              eSendAllNotifications,
-                              visibleKidsOfHiddenElement,
-                              treeMatchContext);
+    // loop over special siblings
+    nsChangeHint frameChange =
+      ReResolveStyleContext(GetPresContext(), frame, nullptr,
+                            aChangeList, aMinChange, nsChangeHint(0),
+                            aRestyleDescendants ?
+                              eRestyle_Subtree : eRestyle_Self,
+                            aRestyleTracker,
+                            eSendAllNotifications,
+                            visibleKidsOfHiddenElement,
+                            treeMatchContext);
 
-      if (frameChange & nsChangeHint_ReconstructFrame) {
-        // If it's going to cause a framechange, then don't bother
-        // with the continuations or special siblings since they'll be
-        // clobbered by the frame reconstruct anyway.
-        NS_ASSERTION(!frame->GetPrevContinuation(),
-                     "continuing frame had more severe impact than first-in-flow");
-        return;
-      }
-
-      frame = frame->GetNextContinuation();
-    } while (frame);
+    if (frameChange & nsChangeHint_ReconstructFrame) {
+      // If it's going to cause a framechange, then don't bother
+      // with the continuations or special siblings since they'll be
+      // clobbered by the frame reconstruct anyway.
+      NS_ASSERTION(!frame->GetPrevContinuation(),
+                   "continuing frame had more severe impact than first-in-flow");
+      return;
+    }
 
     // Might we have special siblings?
-    if (!(frame2->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
+    if (!(frame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
       // nothing more to do here
       return;
     }
-    
-    frame2 = static_cast<nsIFrame*>
-      (propTable->Get(frame2, nsIFrame::IBSplitSpecialSibling()));
-    frame = frame2;
-  } while (frame2);
+
+    frame = static_cast<nsIFrame*>
+      (propTable->Get(frame, nsIFrame::IBSplitSpecialSibling()));
+  } while (frame);
 }
 
 // Capture state for a given frame.
 // Accept a content id here, in some cases we may not have content (scroll position)
 void
 nsFrameManager::CaptureFrameStateFor(nsIFrame* aFrame,
                                      nsILayoutHistoryState* aState)
 {
