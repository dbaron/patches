From: L. David Baron <dbaron@dbaron.org>

Do unicode conversion separately for each byte in the encoding so encoder/decoder errors don't skew the results or leave them uninitialized.  (Bug 525581)

diff --git a/extensions/spellcheck/hunspell/src/csutil.cpp b/extensions/spellcheck/hunspell/src/csutil.cpp
--- a/extensions/spellcheck/hunspell/src/csutil.cpp
+++ b/extensions/spellcheck/hunspell/src/csutil.cpp
@@ -5226,71 +5226,84 @@ struct cs_info * get_current_cs(const ch
   nsCOMPtr<nsICaseConversion> caseConv;
 
   nsresult rv;
   nsCOMPtr<nsICharsetConverterManager> ccm = do_GetService(kCharsetConverterManagerCID, &rv);
   if (NS_FAILED(rv))
     return nsnull;
 
   rv = ccm->GetUnicodeEncoder(es, getter_AddRefs(encoder));
-  if (encoder && NS_SUCCEEDED(rv))
-    encoder->SetOutputErrorBehavior(encoder->kOnError_Replace, nsnull, '?');
-  if (NS_FAILED(rv))
+  if (NS_FAILED(rv) || !encoder)
     return nsnull;
+  encoder->SetOutputErrorBehavior(encoder->kOnError_Signal, nsnull, '?');
   rv = ccm->GetUnicodeDecoder(es, getter_AddRefs(decoder));
+  if (NS_FAILED(rv) || !decoder)
+    return nsnull;
+  decoder->SetInputErrorBehavior(decoder->kOnError_Signal);
 
   caseConv = do_GetService(kUnicharUtilCID, &rv);
   if (NS_FAILED(rv))
     return nsnull;
 
   ccs = (struct cs_info *) malloc(256 * sizeof(cs_info));
 
-  PRInt32 charLength = 256;
-  PRInt32 uniLength = 512;
-  char *source = (char *)malloc(charLength * sizeof(char));
-  PRUnichar *uni = (PRUnichar *)malloc(uniLength * sizeof(PRUnichar));
-  char *lower = (char *)malloc(charLength * sizeof(char));
-  char *upper = (char *)malloc(charLength * sizeof(char));
+  for (unsigned int i = 0; i <= 0xff; ++i) {
+    PRBool success = PR_FALSE;
+    // We want to find the upper/lowercase equivalents of each byte
+    // in this 1-byte character encoding.  Call our encoding/decoding
+    // APIs separately for each byte since they may reject some of the
+    // bytes, and we want to handle errors separately for each byte.
+    char lower, upper;
+    do {
+      if (i == 0)
+        break;
+      const char source = char(i);
+      PRUnichar uni, uniCased;
+      PRInt32 charLength = 1, uniLength = 1;
 
-  // Create a long string of all chars.
-  unsigned int i;
-  for (i = 0x00; i <= 0xff ; ++i) {
-    source[i] = i;
-  }
+      rv = decoder->Convert(&source, &charLength, &uni, &uniLength);
+      // Explicitly check NS_OK because we don't want to allow
+      // NS_OK_UDEC_MOREOUTPUT or NS_OK_UDEC_MOREINPUT.
+      if (rv != NS_OK || charLength != 1 || uniLength != 1)
+        break;
+      rv = caseConv->ToLower(uni, &uniCased);
+      if (NS_FAILED(rv))
+        break;
+      rv = encoder->Convert(&uniCased, &uniLength, &lower, &charLength);
+      // Explicitly check NS_OK because we don't want to allow
+      // NS_OK_UDEC_MOREOUTPUT or NS_OK_UDEC_MOREINPUT.
+      if (rv != NS_OK || charLength != 1 || uniLength != 1)
+        break;
 
-  // Convert this long string to unicode
-  rv = decoder->Convert(source, &charLength, uni, &uniLength);
+      rv = caseConv->ToUpper(uni, &uniCased);
+      if (NS_FAILED(rv))
+        break;
+      rv = encoder->Convert(&uniCased, &uniLength, &upper, &charLength);
+      // Explicitly check NS_OK because we don't want to allow
+      // NS_OK_UDEC_MOREOUTPUT or NS_OK_UDEC_MOREINPUT.
+      if (rv != NS_OK || charLength != 1 || uniLength != 1)
+        break;
 
-  // Do case conversion stuff, and convert back.
-  caseConv->ToUpper(uni, uni, uniLength);
-  encoder->Convert(uni, &uniLength, upper, &charLength);
+      success = PR_TRUE;
+    } while (0);
 
-  uniLength = 512;
-  charLength = 256;
-  rv = decoder->Convert(source, &charLength, uni, &uniLength);
-  caseConv->ToLower(uni, uni, uniLength);
-  encoder->Convert(uni, &uniLength, lower, &charLength);
+    if (success) {
+      ccs[i].cupper = upper;
+      ccs[i].clower = lower;
+    } else {
+      ccs[i].cupper = i;
+      ccs[i].clower = i;
+    }
 
-  // Store
-  for (i = 0x00; i <= 0xff ; ++i) {
-    ccs[i].cupper = upper[i];
-    ccs[i].clower = lower[i];
-    
     if (ccs[i].clower != (unsigned char)i)
       ccs[i].ccase = true;
     else
       ccs[i].ccase = false;
-      
   }
 
-  free(source);
-  free(uni);
-  free(lower);
-  free(upper);
-
   return ccs;
 }
 #endif
 
 // primitive isalpha() replacement for tokenization
 char * get_casechars(const char * enc) {
     struct cs_info * csconv = get_current_cs(enc);
     char expw[MAXLNLEN];
