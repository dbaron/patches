From: Jim Mathies <jmathies@mozilla.com>, L. David Baron <dbaron@dbaron.org>

Set vertical resize flags on the root's reflow state when we're doing SizeToContent reflows.  (Bug 562955)  r=bzbarsky  a2.0=blocking2.0:betaN

diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -1148,16 +1148,18 @@ protected:
 
   PRPackedBool mDocumentLoading;
 
   PRPackedBool mIgnoreFrameDestruction;
   PRPackedBool mHaveShutDown;
 
   PRPackedBool mViewportOverridden;
 
+  PRPackedBool mLastRootReflowHadUnconstrainedHeight;
+
   // This is used to protect ourselves from triggering reflow while in the
   // middle of frame construction and the like... it really shouldn't be
   // needed, one hopes, but it is for now.
   PRUint32  mChangeNestCount;
   
   nsIFrame*   mCurrentEventFrame;
   nsCOMPtr<nsIContent> mCurrentEventContent;
   nsTArray<nsIFrame*> mCurrentEventFrameStack;
@@ -7711,16 +7713,33 @@ PresShell::DoReflow(nsIFrame* target, PR
   NS_ASSERTION(!target->GetNextInFlow() && !target->GetPrevInFlow(),
                "reflow roots should never split");
 
   // Don't pass size directly to the reflow state, since a
   // constrained height implies page/column breaking.
   nsSize reflowSize(size.width, NS_UNCONSTRAINEDSIZE);
   nsHTMLReflowState reflowState(mPresContext, target, rcx, reflowSize);
 
+  if (rootFrame == target) {
+    // When the root frame is being reflowed with unconstrained height
+    // (which happens when we're called from
+    // DocumentViewerImpl::SizeToContent), we're effectively doing a
+    // vertical resize, since it changes the meaning of percentage
+    // heights even if no heights actually changed.  The same applies
+    // when we reflow again after that computation.  This is an unusual
+    // case, and isn't caught by nsHTMLReflowState::InitResizeFlags.
+    PRBool hasUnconstrainedHeight = size.height == NS_UNCONSTRAINEDSIZE;
+
+    if (hasUnconstrainedHeight || mLastRootReflowHadUnconstrainedHeight) {
+      reflowState.mFlags.mVResize = PR_TRUE;
+    }
+
+    mLastRootReflowHadUnconstrainedHeight = hasUnconstrainedHeight;
+  }
+
   // fix the computed height
   NS_ASSERTION(reflowState.mComputedMargin == nsMargin(0, 0, 0, 0),
                "reflow state should not set margin for reflow roots");
   if (size.height != NS_UNCONSTRAINEDSIZE) {
     nscoord computedHeight =
       size.height - reflowState.mComputedBorderPadding.TopBottom();
     computedHeight = NS_MAX(computedHeight, 0);
     reflowState.SetComputedHeight(computedHeight);
diff --git a/layout/base/tests/Makefile.in b/layout/base/tests/Makefile.in
--- a/layout/base/tests/Makefile.in
+++ b/layout/base/tests/Makefile.in
@@ -78,16 +78,17 @@ _TEST_FILES =	\
 		test_bug399951.html \
 		test_bug404209.xhtml \
 		test_bug416896.html \
 		test_bug420499.xul \
 		test_bug423523.html \
 		test_bug445810.html \
 		test_bug449781.html \
 		test_bug450930.xhtml \
+		test_bug458898.html \
 		test_bug465448.xul \
 		test_bug469170.html \
 		test_bug471126.html \
 		test_bug435293-scale.html \
 		test_bug435293-interaction.html \
 		test_bug435293-skew.html \
 		test_bug495648.xul \
 		test_reftests_with_caret.html \
@@ -111,20 +112,18 @@ _TEST_FILES =	\
 		test_bug558663.html \
 		test_bug559499.html \
 		test_flush_on_paint.html \
 		test_mozPaintCount.html \
 		test_scroll_selection_into_view.html \
 		$(NULL)
 
 # Tests for bugs 441782, 467672 and 570378 don't pass reliably on Windows, because of bug 469208
-# Test for bug 458898 doesn't pass on Windows 7. See bug 562955.
 ifeq (,$(filter windows,$(MOZ_WIDGET_TOOLKIT)))
 _TEST_FILES += \
-		test_bug458898.html \
 		bidi_numeral_test.js \
 		test_bug332655-1.html \
 		test_bug332655-2.html \
 		test_bug441782-1a.html \
 		test_bug441782-1b.html \
 		test_bug441782-1c.html \
 		test_bug441782-1d.html \
 		test_bug441782-1e.html \
