From: L. David Baron <dbaron@dbaron.org>

Bug 847287 patch 9 - Use fully-updated style rule for animations when updating cascade results for transitions.

diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -610,17 +610,17 @@ nsTransitionManager::UpdateCascadeResult
     mPresContext->AnimationManager()->
       GetAnimationPlayers(aTransitions->mElement,
                           aTransitions->PseudoElementType(), false);
   UpdateCascadeResults(aTransitions, animations);
 }
 
 void
 nsTransitionManager::UpdateCascadeResultsWithAnimations(
-                       const AnimationPlayerCollection* aAnimations)
+                       AnimationPlayerCollection* aAnimations)
 {
   AnimationPlayerCollection* transitions =
     mPresContext->TransitionManager()->
       GetAnimationPlayers(aAnimations->mElement,
                           aAnimations->PseudoElementType(), false);
   UpdateCascadeResults(transitions, aAnimations);
 }
 
@@ -636,33 +636,40 @@ nsTransitionManager::UpdateCascadeResult
       GetAnimationPlayers(aAnimations->mElement,
                           aAnimations->PseudoElementType(), false);
   UpdateCascadeResults(transitions, nullptr);
 }
 
 void
 nsTransitionManager::UpdateCascadeResults(
                        AnimationPlayerCollection* aTransitions,
-                       const AnimationPlayerCollection* aAnimations)
+                       AnimationPlayerCollection* aAnimations)
 {
   if (!aTransitions) {
     // Nothing to do.
     return;
   }
 
   nsCSSPropertySet propertiesUsed;
 #ifdef DEBUG
   nsCSSPropertySet propertiesWithTransitions;
 #endif
 
   // http://dev.w3.org/csswg/css-transitions/#application says that
   // transitions do not apply when the same property has a CSS Animation
   // on that element (even though animations are lower in the cascade).
-  if (aAnimations && aAnimations->mStyleRule) {
-    aAnimations->mStyleRule->AddPropertiesToSet(propertiesUsed);
+  if (aAnimations) {
+    TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
+    // Passing EnsureStyleRule_IsThrottled is OK since we will
+    // unthrottle when animations are finishing.
+    aAnimations->EnsureStyleRuleFor(now, EnsureStyleRule_IsThrottled);
+
+    if (aAnimations->mStyleRule) {
+      aAnimations->mStyleRule->AddPropertiesToSet(propertiesUsed);
+    }
   }
 
   // Since we should never have more than one transition for the same
   // property, it doesn't matter what order we iterate the transitions.
   // But let's go the same way as animations.
   bool changed = false;
   AnimationPlayerPtrArray& players = aTransitions->mPlayers;
   for (size_t playerIdx = players.Length(); playerIdx-- != 0; ) {
diff --git a/layout/style/nsTransitionManager.h b/layout/style/nsTransitionManager.h
--- a/layout/style/nsTransitionManager.h
+++ b/layout/style/nsTransitionManager.h
@@ -126,21 +126,21 @@ public:
    */
   void StyleContextChanged(mozilla::dom::Element *aElement,
                            nsStyleContext *aOldStyleContext,
                            nsRefPtr<nsStyleContext>* aNewStyleContext /* inout */);
 
   void UpdateCascadeResultsWithTransitions(
          AnimationPlayerCollection* aTransitions);
   void UpdateCascadeResultsWithAnimations(
-         const AnimationPlayerCollection* aAnimations);
+         AnimationPlayerCollection* aAnimations);
   void UpdateCascadeResultsWithAnimationsToBeDestroyed(
          const AnimationPlayerCollection* aAnimations);
   void UpdateCascadeResults(AnimationPlayerCollection* aTransitions,
-                            const AnimationPlayerCollection* aAnimations);
+                            AnimationPlayerCollection* aAnimations);
 
   void SetInAnimationOnlyStyleUpdate(bool aInAnimationOnlyUpdate) {
     mInAnimationOnlyStyleUpdate = aInAnimationOnlyUpdate;
   }
 
   bool InAnimationOnlyStyleUpdate() const {
     return mInAnimationOnlyStyleUpdate;
   }
