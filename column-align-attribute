From: L. David Baron <dbaron@dbaron.org>

Follow HTML rules for inheritance of presentational attributes in tables and then map the final result into CSS, associated with the table cell.  (Bug 915)

diff --git a/content/html/content/src/nsHTMLTableCellElement.cpp b/content/html/content/src/nsHTMLTableCellElement.cpp
--- a/content/html/content/src/nsHTMLTableCellElement.cpp
+++ b/content/html/content/src/nsHTMLTableCellElement.cpp
@@ -39,18 +39,22 @@
 #include "nsIDOMHTMLCollection.h"
 #include "nsIDOMEventTarget.h"
 #include "nsMappedAttributes.h"
 #include "nsGenericHTMLElement.h"
 #include "nsGkAtoms.h"
 #include "nsStyleConsts.h"
 #include "nsPresContext.h"
 #include "nsRuleData.h"
+#include "nsRuleWalker.h"
 #include "nsIDocument.h"
 #include "celldata.h"
+#include "nsHTMLStyleSheet.h"
+
+#define TABLE_ATTRS_DIRTY ((nsMappedAttributes*)0x1)
 
 class nsHTMLTableCellElement : public nsGenericHTMLElement,
                                public nsIDOMHTMLTableCellElement
 {
 public:
   nsHTMLTableCellElement(already_AddRefed<nsINodeInfo> aNodeInfo);
   virtual ~nsHTMLTableCellElement();
 
@@ -72,37 +76,56 @@ public:
   virtual PRBool ParseAttribute(PRInt32 aNamespaceID,
                                 nsIAtom* aAttribute,
                                 const nsAString& aValue,
                                 nsAttrValue& aResult);
   virtual nsMapRuleToAttributesFunc GetAttributeMappingFunction() const;
   NS_IMETHOD WalkContentStyleRules(nsRuleWalker* aRuleWalker);
   NS_IMETHOD_(PRBool) IsAttributeMapped(const nsIAtom* aAttribute) const;
 
+  // XXX Override AttributeChanged here and on other table elements
+  // to cause marking mTableInheritedAttributes dirty.
+
   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
 
   virtual nsXPCClassInfo* GetClassInfo();
 protected:
   // This does not return a nsresult since all we care about is if we
   // found the row element that this cell is in or not.
   void GetRow(nsIDOMHTMLTableRowElement** aRow);
   nsIContent * GetTable();
+  nsIContent * GetRow();
+  nsIContent * GetRowGroup();
+
+  // Sentinel value of 0x1 indicates that this is dirty and needs to be
+  // recalculated.
+  nsMappedAttributes *mTableInheritedAttributes;
+  void ReleaseInheritedAttributes() {
+    if (mTableInheritedAttributes &&
+        mTableInheritedAttributes != TABLE_ATTRS_DIRTY)
+      NS_RELEASE(mTableInheritedAttributes);
+  }
+  void BuildInheritedAttributes();
+  static const nsAttrValue* FindInheritedAttr(nsIAtom *aAttribute,
+                                              nsIContent **aElements);
 };
 
 
 NS_IMPL_NS_NEW_HTML_ELEMENT(TableCell)
 
 
 nsHTMLTableCellElement::nsHTMLTableCellElement(already_AddRefed<nsINodeInfo> aNodeInfo)
   : nsGenericHTMLElement(aNodeInfo)
+  , mTableInheritedAttributes(TABLE_ATTRS_DIRTY)
 {
 }
 
 nsHTMLTableCellElement::~nsHTMLTableCellElement()
 {
+  ReleaseInheritedAttributes();
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLTableCellElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLTableCellElement, nsGenericElement) 
 
 
 DOMCI_NODE_DATA(HTMLTableCellElement, nsHTMLTableCellElement)
@@ -120,19 +143,17 @@ NS_IMPL_ELEMENT_CLONE(nsHTMLTableCellEle
 
 
 // protected method
 void
 nsHTMLTableCellElement::GetRow(nsIDOMHTMLTableRowElement** aRow)
 {
   *aRow = nsnull;
 
-  nsCOMPtr<nsIDOMNode> rowNode;
-  GetParentNode(getter_AddRefs(rowNode));
-
+  nsIContent *rowNode = GetRow();
   if (rowNode) {
     CallQueryInterface(rowNode, aRow);
   }
 }
 
 // protected method
 nsIContent*
 nsHTMLTableCellElement::GetTable()
@@ -151,16 +172,43 @@ nsHTMLTableCellElement::GetTable()
         // we have a row group.
         result = section->GetParent();
       }
     }
   }
   return result;
 }
 
+nsIContent*
+nsHTMLTableCellElement::GetRow()
+{
+  nsIContent *row = GetParent();
+  if (!row ||
+      !row->IsHTML() ||
+      !row->NodeInfo()->Equals(nsGkAtoms::tr))
+    row = nsnull;
+  return row;
+}
+
+nsIContent*
+nsHTMLTableCellElement::GetRowGroup()
+{
+  nsIContent *row = GetRow();
+  if (!row)
+    return nsnull;
+  nsIContent *rowGroup = row->GetParent();
+  if (!rowGroup ||
+      !rowGroup->IsHTML() ||
+      !(rowGroup->NodeInfo()->Equals(nsGkAtoms::tbody) ||
+        rowGroup->NodeInfo()->Equals(nsGkAtoms::thead) ||
+        rowGroup->NodeInfo()->Equals(nsGkAtoms::tfoot)))
+    rowGroup = nsnull;
+  return rowGroup;
+}
+
 NS_IMETHODIMP
 nsHTMLTableCellElement::GetCellIndex(PRInt32* aCellIndex)
 {
   *aCellIndex = -1;
 
   nsCOMPtr<nsIDOMHTMLTableRowElement> row;
 
   GetRow(getter_AddRefs(row));
@@ -208,19 +256,28 @@ nsHTMLTableCellElement::WalkContentStyle
   // |MapAttributesIntoRule| in nsHTMLTableElement.cpp, which is
   // technically incorrect since it's violating the nsIStyleRule
   // contract.  However, things are OK (except for the incorrect
   // dependence on display type rather than tag) since tables and cells
   // match different, less specific, rules.
   nsIContent* table = GetTable();
   if (table) {
     rv = table->WalkContentStyleRules(aRuleWalker);
+    NS_ENSURE_SUCCESS(rv, rv);
   }
 
-  return rv;
+  if (mTableInheritedAttributes) {
+    if (mTableInheritedAttributes == TABLE_ATTRS_DIRTY)
+      BuildInheritedAttributes();
+
+    if (mTableInheritedAttributes)
+      aRuleWalker->Forward(mTableInheritedAttributes);
+  }
+
+  return NS_OK;
 }
 
 
 NS_IMPL_STRING_ATTR(nsHTMLTableCellElement, Abbr, abbr)
 NS_IMPL_STRING_ATTR(nsHTMLTableCellElement, Axis, axis)
 NS_IMPL_STRING_ATTR(nsHTMLTableCellElement, BgColor, bgcolor)
 NS_IMPL_STRING_ATTR_DEFAULT_VALUE(nsHTMLTableCellElement, Ch, _char, ".")
 NS_IMPL_STRING_ATTR(nsHTMLTableCellElement, ChOff, charoff)
@@ -232,16 +289,18 @@ NS_IMPL_INT_ATTR_DEFAULT_VALUE(nsHTMLTab
 NS_IMPL_STRING_ATTR(nsHTMLTableCellElement, Scope, scope)
 NS_IMPL_STRING_ATTR_DEFAULT_VALUE(nsHTMLTableCellElement, VAlign, valign, "middle")
 NS_IMPL_STRING_ATTR(nsHTMLTableCellElement, Width, width)
 
 
 NS_IMETHODIMP
 nsHTMLTableCellElement::GetAlign(nsAString& aValue)
 {
+  // XXX What is this supposed to do!
+
   if (!GetAttr(kNameSpaceID_None, nsGkAtoms::align, aValue)) {
     // There's no align attribute, ask the row for the alignment.
 
     nsCOMPtr<nsIDOMHTMLTableRowElement> row;
     GetRow(getter_AddRefs(row));
 
     if (row) {
       return row->GetAlign(aValue);
@@ -361,48 +420,31 @@ void MapAttributesIntoRule(const nsMappe
       else if (value && value->Type() == nsAttrValue::ePercent) {
         if (value->GetPercentValue() > 0.0f)
           height->SetPercentValue(value->GetPercentValue());
         // else 0 implies auto for compatibility
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
-    nsCSSValue* textAlign = aData->ValueForTextAlign();
-    if (textAlign->GetUnit() == eCSSUnit_Null) {
-      // align: enum
-      const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
-      if (value && value->Type() == nsAttrValue::eEnum)
-        textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
-    }
-
     nsCSSValue* whiteSpace = aData->ValueForWhiteSpace();
     if (whiteSpace->GetUnit() == eCSSUnit_Null) {
       // nowrap: enum
       if (aAttributes->GetAttr(nsGkAtoms::nowrap)) {
         // See if our width is not a nonzero integer width.
         const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
         nsCompatibility mode = aData->mPresContext->CompatibilityMode();
         if (!value || value->Type() != nsAttrValue::eInteger ||
             value->GetIntegerValue() == 0 ||
             eCompatibility_NavQuirks != mode) {
           whiteSpace->SetIntValue(NS_STYLE_WHITESPACE_NOWRAP, eCSSUnit_Enumerated);
         }
       }
     }
   }
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
-    nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
-    if (verticalAlign->GetUnit() == eCSSUnit_Null) {
-      // valign: enum
-      const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
-      if (value && value->Type() == nsAttrValue::eEnum)
-        verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
-    }
-  }
   
   nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(PRBool)
 nsHTMLTableCellElement::IsAttributeMapped(const nsIAtom* aAttribute) const
 {
@@ -432,8 +474,228 @@ nsHTMLTableCellElement::IsAttributeMappe
   return FindAttributeDependence(aAttribute, map, NS_ARRAY_LENGTH(map));
 }
 
 nsMapRuleToAttributesFunc
 nsHTMLTableCellElement::GetAttributeMappingFunction() const
 {
   return &MapAttributesIntoRule;
 }
+
+static void
+MapInheritedTableAttributesIntoRule(const nsMappedAttributes* aAttributes,
+                                    nsRuleData* aData)
+{
+  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
+    nsCSSValue* textAlign = aData->ValueForTextAlign();
+    if (textAlign->GetUnit() == eCSSUnit_Null) {
+      // align: enum
+      const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
+      if (value && value->Type() == nsAttrValue::eEnum)
+        textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+    }
+  }
+  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
+    nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
+    if (verticalAlign->GetUnit() == eCSSUnit_Null) {
+      // valign: enum
+      const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
+      if (value && value->Type() == nsAttrValue::eEnum)
+        verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+    }
+  }
+}
+
+#define INHERIT_ELEMENTS (6)
+
+/* static */ const nsAttrValue*
+nsHTMLTableCellElement::FindInheritedAttr(nsIAtom *aAttribute,
+                                          nsIContent **aElements)
+{
+  for (nsIContent **elementp = aElements,
+              **elementp_end = aElements + INHERIT_ELEMENTS;
+       elementp < elementp_end; ++elementp) {
+    nsIContent *element = *elementp;
+    if (element) {
+      // XXX It's really just nsGenericHTMLElement, but we have to cast
+      // to nsHTMLTableCellElement to make it compile because C++ says
+      // so.
+      const nsAttrValue* value =
+        static_cast<nsHTMLTableCellElement*>(element)->
+          mAttrsAndChildren.GetAttr(aAttribute);
+      if (value) {
+        return value;
+      }
+    }
+  }
+  return nsnull;
+}
+
+void
+nsHTMLTableCellElement::BuildInheritedAttributes()
+{
+  NS_ASSERTION(mTableInheritedAttributes == TABLE_ATTRS_DIRTY,
+               "potential leak, plus waste of work");
+
+  // These attributes are all guaranteed to be mapped, but the attribute
+  // mapping functions don't actually do anything with them; we do.
+  // XXX Make this actually true by removing code!
+
+  nsIContent *row = GetRow();
+  nsIContent *rowGroup = GetRowGroup();
+  nsIContent *table = GetTable();
+
+  nsIContent *col = nsnull, *colGroup = nsnull;
+
+  // Find col and colGroup.
+  // XXX This doesn't account for rowspans.  We really just need a cellmap.
+  if (row && table) {
+    // XXX Only do this work if there are actually col or colgroup
+    // elements with style information!
+    PRInt32 colNumber = -1;
+    PRInt32 curCol = 0;
+    for (PRUint32 i = 0, i_end = row->GetChildCount();
+         i < i_end; ++i) {
+      nsIContent *child = row->GetChildAt(i);
+      if (child == this) {
+        colNumber = curCol;
+        break;
+      }
+
+      nsIAtom *tag = child->Tag();
+      if (child->IsHTML() &&
+          (tag == nsGkAtoms::td || tag == nsGkAtoms::th)) {
+        PRInt32 span = 1;
+        GetIntAttr(nsGkAtoms::colspan, 1, &span);
+        curCol += span;
+      }
+    }
+    NS_ASSERTION(colNumber != -1, "we're not a child of our parent");
+
+    // We have a column index, so look for a col or colGroup element.
+    curCol = 0;
+    for (PRUint32 i = 0, i_end = table->GetChildCount();
+         i < i_end; ++i) {
+      nsIContent *child = table->GetChildAt(i);
+      if (child->IsHTML()) {
+        nsIAtom *tag = child->Tag();
+        if (tag == nsGkAtoms::col) {
+          PRInt32 span = 1;
+          // XXX It's really just nsGenericHTMLElement, but we have
+          // to cast to nsHTMLTableCellElement to make it compile because
+          // C++ says so.
+          static_cast<nsHTMLTableCellElement*>(child)->
+            GetIntAttr(nsGkAtoms::span, 1, &span);
+          if (curCol + span > colNumber) {
+            col = child;
+            break;
+          }
+          curCol += span;
+        } else if (tag == nsGkAtoms::colgroup) {
+          // If the colgroup contains col elements, ignore the |span|
+          // and walk them!
+          PRBool haveCols = PR_FALSE;
+          for (PRUint32 j = 0, j_end = child->GetChildCount();
+               j < j_end; ++j) {
+            nsIContent *cgchild = child->GetChildAt(j);
+            if (cgchild->IsHTML() &&
+                cgchild->Tag() == nsGkAtoms::col) {
+              haveCols = PR_TRUE;
+
+              PRInt32 span = 1;
+              // XXX It's really just nsGenericHTMLElement, but we have
+              // to cast to nsHTMLTableCellElement to make it compile
+              // because C++ says so.
+              static_cast<nsHTMLTableCellElement*>(cgchild)->
+                GetIntAttr(nsGkAtoms::span, 1, &span);
+              if (curCol + span > colNumber) {
+                colGroup = child;
+                col = cgchild;
+                break;
+              }
+              curCol += span;
+            }
+          }
+          if (col)
+            break;
+
+          if (!haveCols) {
+            PRInt32 span = 1;
+            // XXX It's really just nsGenericHTMLElement, but we have to
+            // cast to nsHTMLTableCellElement to make it compile because
+            // C++ says so.
+            static_cast<nsHTMLTableCellElement*>(child)->
+              GetIntAttr(nsGkAtoms::span, 1, &span);
+            if (curCol + span > colNumber) {
+              colGroup = child;
+              break;
+            }
+            curCol += span;
+          }
+        } else if (tag == nsGkAtoms::tr || 
+                   tag == nsGkAtoms::tbody || 
+                   tag == nsGkAtoms::thead || 
+                   tag == nsGkAtoms::tfoot) {
+          // There shouldn't be any more columns after this point.
+          break;
+        }
+      }
+    }
+  }
+
+  // According to HTML 4.01, section 11.3.2, the priority for:
+  //   Attributes: align, char, charoff
+  //   Is:  cell, col, col group, row, row group, table
+  // and for
+  //   Attributes: valign  (we'll ignore what it says about lang, dir, style)
+  //     XXX We probably should pay attention for lang and dir.
+  //   Is: cell, row, row group, col, col group, table
+  nsIContent *colPriority[INHERIT_ELEMENTS] =
+    { this, col, colGroup, row, rowGroup, table};
+  nsIContent *rowPriority[INHERIT_ELEMENTS] =
+    { this, row, rowGroup, col, colGroup, table};
+
+  nsIDocument *document = GetCurrentDoc();
+  nsHTMLStyleSheet* sheet = document ?
+                              document->GetAttributeStyleSheet() : nsnull;
+  nsRefPtr<nsMappedAttributes> newAttrs;
+  if (sheet) {
+    const nsAttrValue *align =
+      FindInheritedAttr(nsGkAtoms::align, colPriority);
+    const nsAttrValue *valign =
+      FindInheritedAttr(nsGkAtoms::valign, rowPriority);
+    // XXX Implement char and charoff here.
+
+    PRUint32 count = (align != nsnull) + (valign != nsnull);
+
+    if (count) {
+      nsRefPtr<nsMappedAttributes> modifiableMapped = new (count)
+        nsMappedAttributes(sheet, MapInheritedTableAttributesIntoRule);
+
+      if (modifiableMapped) {
+        if (align) {
+          nsAttrValue val(*align);
+          modifiableMapped->SetAndTakeAttr(nsGkAtoms::align, val);
+        }
+        if (valign) {
+          nsAttrValue val(*valign);
+          modifiableMapped->SetAndTakeAttr(nsGkAtoms::valign, val);
+        }
+
+        newAttrs = sheet->UniqueMappedAttributes(modifiableMapped);
+        NS_ASSERTION(newAttrs, "out of memory, but handling gracefully");
+
+        if (newAttrs != modifiableMapped) {
+          // Reset the stylesheet of modifiableMapped so that it doesn't
+          // spend time trying to remove itself from the hash. There is no
+          // risk that modifiableMapped is in the hash since it will
+          // always have come from GetModifiableMapped, which never
+          // returns maps that are in the hash (such hashes are by nature
+          // not modifiable).
+          modifiableMapped->DropStyleSheetReference();
+        }
+      }
+    }
+  }
+
+  mTableInheritedAttributes = newAttrs;
+  NS_IF_ADDREF(mTableInheritedAttributes);
+}
diff --git a/content/html/content/src/nsHTMLTableColElement.cpp b/content/html/content/src/nsHTMLTableColElement.cpp
--- a/content/html/content/src/nsHTMLTableColElement.cpp
+++ b/content/html/content/src/nsHTMLTableColElement.cpp
@@ -133,19 +133,23 @@ nsHTMLTableColElement::ParseAttribute(PR
     if (aAttribute == nsGkAtoms::span) {
       /* protection from unrealistic large colspan values */
       return aResult.ParseIntWithBounds(aValue, 1, MAX_COLSPAN);
     }
     if (aAttribute == nsGkAtoms::width) {
       return aResult.ParseSpecialIntValue(aValue);
     }
     if (aAttribute == nsGkAtoms::align) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableCellHAlignValue(aValue, aResult);
     }
     if (aAttribute == nsGkAtoms::valign) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableVAlignValue(aValue, aResult);
     }
   }
 
   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
                                               aResult);
 }
 
@@ -188,25 +192,29 @@ void MapAttributesIntoRule(const nsMappe
         }
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
     nsCSSValue* textAlign = aData->ValueForTextAlign();
     if (textAlign->GetUnit() == eCSSUnit_Null) {
       // align: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
         textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
     nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
     if (verticalAlign->GetUnit() == eCSSUnit_Null) {
       // valign: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
       if (value && value->Type() == nsAttrValue::eEnum)
         verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
diff --git a/content/html/content/src/nsHTMLTableElement.cpp b/content/html/content/src/nsHTMLTableElement.cpp
--- a/content/html/content/src/nsHTMLTableElement.cpp
+++ b/content/html/content/src/nsHTMLTableElement.cpp
@@ -83,28 +83,34 @@ public:
 
   virtual PRBool ParseAttribute(PRInt32 aNamespaceID,
                                 nsIAtom* aAttribute,
                                 const nsAString& aValue,
                                 nsAttrValue& aResult);
   virtual nsMapRuleToAttributesFunc GetAttributeMappingFunction() const;
   NS_IMETHOD_(PRBool) IsAttributeMapped(const nsIAtom* aAttribute) const;
 
+  virtual nsresult InsertChildAt(nsIContent* aKid, PRUint32 aIndex,
+                                 PRBool aNotify);
+  virtual nsresult AppendChildTo(nsIContent* aKid, PRBool aNotify);
+  virtual nsresult RemoveChildAt(PRUint32 aIndex, PRBool aNotify);
+
   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
 
   virtual nsXPCClassInfo* GetClassInfo();
 
   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_NO_UNLINK(nsHTMLTableElement,
                                                      nsGenericHTMLElement)
 
 protected:
   already_AddRefed<nsIDOMHTMLTableSectionElement> GetSection(nsIAtom *aTag);
 
   nsRefPtr<nsContentList> mTBodies;
   nsRefPtr<TableRowsCollection> mRows;
+  PRPackedBool mHaveColumnMarkup;
 };
 
 
 /* ------------------------------ TableRowsCollection -------------------------------- */
 /**
  * This class provides a late-bound collection of rows in a table.
  * mParent is NOT ref-counted to avoid circular references
  */
@@ -1303,8 +1309,41 @@ nsHTMLTableElement::IsAttributeMapped(co
   return FindAttributeDependence(aAttribute, map, NS_ARRAY_LENGTH(map));
 }
 
 nsMapRuleToAttributesFunc
 nsHTMLTableElement::GetAttributeMappingFunction() const
 {
   return &MapAttributesIntoRule;
 }
+
+/* virtual */ nsresult
+nsHTMLTableElement::InsertChildAt(nsIContent* aKid, PRUint32 aIndex,
+                                  PRBool aNotify)
+{
+  if (aKid->IsHTML() &&
+      (aKid->Tag() == nsGkAtoms::col ||
+       aKid->Tag() == nsGkAtoms::colgroup))
+    mHaveColumnMarkup = PR_TRUE;
+  // else invalidate cellmap
+
+  return nsGenericHTMLElement::InsertChildAt(aKid, aIndex, aNotify);
+}
+
+/* virtual */ nsresult
+nsHTMLTableElement::AppendChildTo(nsIContent* aKid, PRBool aNotify)
+{
+  if (aKid->IsHTML() &&
+      (aKid->Tag() == nsGkAtoms::col ||
+       aKid->Tag() == nsGkAtoms::colgroup))
+    mHaveColumnMarkup = PR_TRUE;
+  // else invalidate cellmap
+
+  return nsGenericHTMLElement::AppendChildTo(aKid, aNotify);
+}
+
+/* virtual */ nsresult
+nsHTMLTableElement::RemoveChildAt(PRUint32 aIndex, PRBool aNotify)
+{
+  // invalidate cellmap if needed
+
+  return nsGenericHTMLElement::RemoveChildAt(aIndex, aNotify);
+}
diff --git a/content/html/content/src/nsHTMLTableRowElement.cpp b/content/html/content/src/nsHTMLTableRowElement.cpp
--- a/content/html/content/src/nsHTMLTableRowElement.cpp
+++ b/content/html/content/src/nsHTMLTableRowElement.cpp
@@ -384,22 +384,26 @@ nsHTMLTableRowElement::ParseAttribute(PR
     }
     if (aAttribute == nsGkAtoms::height) {
       return aResult.ParseSpecialIntValue(aValue);
     }
     if (aAttribute == nsGkAtoms::width) {
       return aResult.ParseSpecialIntValue(aValue);
     }
     if (aAttribute == nsGkAtoms::align) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableCellHAlignValue(aValue, aResult);
     }
     if (aAttribute == nsGkAtoms::bgcolor) {
       return aResult.ParseColor(aValue);
     }
     if (aAttribute == nsGkAtoms::valign) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableVAlignValue(aValue, aResult);
     }
   }
 
   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
                                               aResult);
 }
 
@@ -416,25 +420,29 @@ void MapAttributesIntoRule(const nsMappe
       else if (value && value->Type() == nsAttrValue::ePercent)
         height->SetPercentValue(value->GetPercentValue());
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
     nsCSSValue* textAlign = aData->ValueForTextAlign();
     if (textAlign->GetUnit() == eCSSUnit_Null) {
       // align: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
         textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
     nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
     if (verticalAlign->GetUnit() == eCSSUnit_Null) {
       // valign: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
       if (value && value->Type() == nsAttrValue::eEnum)
         verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
diff --git a/content/html/content/src/nsHTMLTableSectionElement.cpp b/content/html/content/src/nsHTMLTableSectionElement.cpp
--- a/content/html/content/src/nsHTMLTableSectionElement.cpp
+++ b/content/html/content/src/nsHTMLTableSectionElement.cpp
@@ -250,22 +250,26 @@ nsHTMLTableSectionElement::ParseAttribut
     */
     if (aAttribute == nsGkAtoms::charoff) {
       return aResult.ParseIntWithBounds(aValue, 0);
     }
     if (aAttribute == nsGkAtoms::height) {
       return aResult.ParseSpecialIntValue(aValue);
     }
     if (aAttribute == nsGkAtoms::align) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableCellHAlignValue(aValue, aResult);
     }
     if (aAttribute == nsGkAtoms::bgcolor) {
       return aResult.ParseColor(aValue);
     }
     if (aAttribute == nsGkAtoms::valign) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableVAlignValue(aValue, aResult);
     }
   }
 
   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
                                               aResult);
 }
 
@@ -280,25 +284,29 @@ void MapAttributesIntoRule(const nsMappe
       if (value && value->Type() == nsAttrValue::eInteger)
         height->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
     nsCSSValue* textAlign = aData->ValueForTextAlign();
     if (textAlign->GetUnit() == eCSSUnit_Null) {
       // align: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
         textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
     nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
     if (verticalAlign->GetUnit() == eCSSUnit_Null) {
       // valign: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
       if (value && value->Type() == nsAttrValue::eEnum)
         verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
