From: L. David Baron <dbaron@dbaron.org>

Follow HTML rules for inheritance of presentational attributes in tables and then map the final result into CSS, associated with the table cell.  (Bug 915)

diff --git a/content/html/content/src/HTMLTableCellElement.cpp b/content/html/content/src/HTMLTableCellElement.cpp
--- a/content/html/content/src/HTMLTableCellElement.cpp
+++ b/content/html/content/src/HTMLTableCellElement.cpp
@@ -17,16 +17,17 @@
 
 NS_IMPL_NS_NEW_HTML_ELEMENT(TableCell)
 
 namespace mozilla {
 namespace dom {
 
 HTMLTableCellElement::~HTMLTableCellElement()
 {
+  ReleaseInheritedAttributes();
 }
 
 JSObject*
 HTMLTableCellElement::WrapNode(JSContext *aCx, JSObject *aScope,
                                bool *aTriedToWrap)
 {
   return HTMLTableCellElementBinding::Wrap(aCx, aScope, this, aTriedToWrap);
 }
@@ -49,16 +50,33 @@ NS_IMPL_ELEMENT_CLONE(HTMLTableCellEleme
 // protected method
 HTMLTableRowElement*
 HTMLTableCellElement::GetRow() const
 {
   return HTMLTableRowElement::FromContentOrNull(GetParent());
 }
 
 // protected method
+nsIContent*
+HTMLTableCellElement::GetRowGroup() const
+{
+  nsIContent *row = GetRow();
+  if (!row)
+    return nullptr;
+  nsIContent *rowGroup = row->GetParent();
+  if (!rowGroup ||
+      !rowGroup->IsHTML() ||
+      !(rowGroup->NodeInfo()->Equals(nsGkAtoms::tbody) ||
+        rowGroup->NodeInfo()->Equals(nsGkAtoms::thead) ||
+        rowGroup->NodeInfo()->Equals(nsGkAtoms::tfoot)))
+    rowGroup = nullptr;
+  return rowGroup;
+}
+
+// protected method
 HTMLTableElement*
 HTMLTableCellElement::GetTable() const
 {
   nsIContent *parent = GetParent();
   if (!parent) {
     return nullptr;
   }
 
@@ -120,16 +138,25 @@ HTMLTableCellElement::WalkContentStyleRu
 
   if (HTMLTableElement* table = GetTable()) {
     nsMappedAttributes* tableInheritedAttributes =
       table->GetAttributesMappedForCell();
     if (tableInheritedAttributes) {
       aRuleWalker->Forward(tableInheritedAttributes);
     }
   }
+
+  if (mTableInheritedAttributes) {
+    if (mTableInheritedAttributes == TABLE_ATTRS_DIRTY)
+      BuildInheritedAttributes();
+
+    if (mTableInheritedAttributes)
+      aRuleWalker->Forward(mTableInheritedAttributes);
+  }
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLTableCellElement::SetAbbr(const nsAString& aAbbr)
 {
   ErrorResult rv;
   SetAbbr(aAbbr, rv);
@@ -358,16 +385,18 @@ HTMLTableCellElement::GetRowSpan(int32_t
 {
   *aRowSpan = RowSpan();
   return NS_OK;
 }
 
 void
 HTMLTableCellElement::GetAlign(nsString& aValue)
 {
+  // XXX What is this supposed to do!
+
   if (!GetAttr(kNameSpaceID_None, nsGkAtoms::align, aValue)) {
     // There's no align attribute, ask the row for the alignment.
     HTMLTableRowElement* row = GetRow();
     if (row) {
       row->GetAlign(aValue);
     }
   }
 }
@@ -478,48 +507,31 @@ void MapAttributesIntoRule(const nsMappe
       else if (value && value->Type() == nsAttrValue::ePercent) {
         if (value->GetPercentValue() > 0.0f)
           height->SetPercentValue(value->GetPercentValue());
         // else 0 implies auto for compatibility
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
-    nsCSSValue* textAlign = aData->ValueForTextAlign();
-    if (textAlign->GetUnit() == eCSSUnit_Null) {
-      // align: enum
-      const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
-      if (value && value->Type() == nsAttrValue::eEnum)
-        textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
-    }
-
     nsCSSValue* whiteSpace = aData->ValueForWhiteSpace();
     if (whiteSpace->GetUnit() == eCSSUnit_Null) {
       // nowrap: enum
       if (aAttributes->GetAttr(nsGkAtoms::nowrap)) {
         // See if our width is not a nonzero integer width.
         const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
         nsCompatibility mode = aData->mPresContext->CompatibilityMode();
         if (!value || value->Type() != nsAttrValue::eInteger ||
             value->GetIntegerValue() == 0 ||
             eCompatibility_NavQuirks != mode) {
           whiteSpace->SetIntValue(NS_STYLE_WHITESPACE_NOWRAP, eCSSUnit_Enumerated);
         }
       }
     }
   }
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
-    nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
-    if (verticalAlign->GetUnit() == eCSSUnit_Null) {
-      // valign: enum
-      const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
-      if (value && value->Type() == nsAttrValue::eEnum)
-        verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
-    }
-  }
   
   nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(bool)
 HTMLTableCellElement::IsAttributeMapped(const nsIAtom* aAttribute) const
 {
@@ -550,10 +562,226 @@ HTMLTableCellElement::IsAttributeMapped(
 }
 
 nsMapRuleToAttributesFunc
 HTMLTableCellElement::GetAttributeMappingFunction() const
 {
   return &MapAttributesIntoRule;
 }
 
+static void
+MapInheritedTableAttributesIntoRule(const nsMappedAttributes* aAttributes,
+                                    nsRuleData* aData)
+{
+  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
+    nsCSSValue* textAlign = aData->ValueForTextAlign();
+    if (textAlign->GetUnit() == eCSSUnit_Null) {
+      // align: enum
+      const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
+      if (value && value->Type() == nsAttrValue::eEnum)
+        textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+    }
+  }
+  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
+    nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
+    if (verticalAlign->GetUnit() == eCSSUnit_Null) {
+      // valign: enum
+      const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
+      if (value && value->Type() == nsAttrValue::eEnum)
+        verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+    }
+  }
+}
+
+#define INHERIT_ELEMENTS (6)
+
+/* static */ const nsAttrValue*
+HTMLTableCellElement::FindInheritedAttr(nsIAtom *aAttribute,
+                                        nsIContent **aElements)
+{
+  for (nsIContent **elementp = aElements,
+              **elementp_end = aElements + INHERIT_ELEMENTS;
+       elementp < elementp_end; ++elementp) {
+    nsIContent *element = *elementp;
+    if (element) {
+      // XXX It's really just nsGenericHTMLElement, but we have to cast
+      // to HTMLTableCellElement to make it compile because C++ says
+      // so.
+      const nsAttrValue* value =
+        static_cast<HTMLTableCellElement*>(element)->
+          mAttrsAndChildren.GetAttr(aAttribute);
+      if (value) {
+        return value;
+      }
+    }
+  }
+  return nullptr;
+}
+
+void
+HTMLTableCellElement::BuildInheritedAttributes()
+{
+  NS_ASSERTION(mTableInheritedAttributes == TABLE_ATTRS_DIRTY,
+               "potential leak, plus waste of work");
+
+  // These attributes are all guaranteed to be mapped, but the attribute
+  // mapping functions don't actually do anything with them; we do.
+  // XXX Make this actually true by removing code!
+
+  nsIContent *row = GetRow();
+  nsIContent *rowGroup = GetRowGroup();
+  nsIContent *table = GetTable();
+
+  nsIContent *col = nullptr, *colGroup = nullptr;
+
+  // Find col and colGroup.
+  // XXX This doesn't account for rowspans.  We really just need a cellmap.
+  if (row && table) {
+    // XXX Only do this work if there are actually col or colgroup
+    // elements with style information!
+    int32_t colNumber = -1;
+    int32_t curCol = 0;
+    for (uint32_t i = 0, i_end = row->GetChildCount();
+         i < i_end; ++i) {
+      nsIContent *child = row->GetChildAt(i);
+      if (child == this) {
+        colNumber = curCol;
+        break;
+      }
+
+      nsIAtom *tag = child->Tag();
+      if (child->IsHTML() &&
+          (tag == nsGkAtoms::td || tag == nsGkAtoms::th)) {
+        int32_t span = GetIntAttr(nsGkAtoms::colspan, 1);
+        curCol += span;
+      }
+    }
+    NS_ASSERTION(colNumber != -1, "we're not a child of our parent");
+
+    // We have a column index, so look for a col or colGroup element.
+    curCol = 0;
+    for (uint32_t i = 0, i_end = table->GetChildCount();
+         i < i_end; ++i) {
+      nsIContent *child = table->GetChildAt(i);
+      if (child->IsHTML()) {
+        nsIAtom *tag = child->Tag();
+        if (tag == nsGkAtoms::col) {
+          // XXX It's really just nsGenericHTMLElement, but we have
+          // to cast to HTMLTableCellElement to make it compile because
+          // C++ says so.
+          int32_t span = static_cast<HTMLTableCellElement*>(child)->
+            GetIntAttr(nsGkAtoms::span, 1);
+          if (curCol + span > colNumber) {
+            col = child;
+            break;
+          }
+          curCol += span;
+        } else if (tag == nsGkAtoms::colgroup) {
+          // If the colgroup contains col elements, ignore the |span|
+          // and walk them!
+          bool haveCols = false;
+          for (uint32_t j = 0, j_end = child->GetChildCount();
+               j < j_end; ++j) {
+            nsIContent *cgchild = child->GetChildAt(j);
+            if (cgchild->IsHTML() &&
+                cgchild->Tag() == nsGkAtoms::col) {
+              haveCols = true;
+
+              // XXX It's really just nsGenericHTMLElement, but we have
+              // to cast to HTMLTableCellElement to make it compile
+              // because C++ says so.
+              int32_t span = static_cast<HTMLTableCellElement*>(cgchild)->
+                GetIntAttr(nsGkAtoms::span, 1);
+              if (curCol + span > colNumber) {
+                colGroup = child;
+                col = cgchild;
+                break;
+              }
+              curCol += span;
+            }
+          }
+          if (col)
+            break;
+
+          if (!haveCols) {
+            // XXX It's really just nsGenericHTMLElement, but we have to
+            // cast to HTMLTableCellElement to make it compile because
+            // C++ says so.
+            int32_t span = static_cast<HTMLTableCellElement*>(child)->
+              GetIntAttr(nsGkAtoms::span, 1);
+            if (curCol + span > colNumber) {
+              colGroup = child;
+              break;
+            }
+            curCol += span;
+          }
+        } else if (tag == nsGkAtoms::tr || 
+                   tag == nsGkAtoms::tbody || 
+                   tag == nsGkAtoms::thead || 
+                   tag == nsGkAtoms::tfoot) {
+          // There shouldn't be any more columns after this point.
+          break;
+        }
+      }
+    }
+  }
+
+  // According to HTML 4.01, section 11.3.2, the priority for:
+  //   Attributes: align, char, charoff
+  //   Is:  cell, col, col group, row, row group, table
+  // and for
+  //   Attributes: valign  (we'll ignore what it says about lang, dir, style)
+  //     XXX We probably should pay attention for lang and dir.
+  //   Is: cell, row, row group, col, col group, table
+  nsIContent *colPriority[INHERIT_ELEMENTS] =
+    { this, col, colGroup, row, rowGroup, table};
+  nsIContent *rowPriority[INHERIT_ELEMENTS] =
+    { this, row, rowGroup, col, colGroup, table};
+
+  nsIDocument *document = GetCurrentDoc();
+  nsHTMLStyleSheet* sheet = document ?
+                              document->GetAttributeStyleSheet() : nullptr;
+  nsRefPtr<nsMappedAttributes> newAttrs;
+  if (sheet) {
+    const nsAttrValue *align =
+      FindInheritedAttr(nsGkAtoms::align, colPriority);
+    const nsAttrValue *valign =
+      FindInheritedAttr(nsGkAtoms::valign, rowPriority);
+    // XXX Implement char and charoff here.
+
+    uint32_t count = (align != nullptr) + (valign != nullptr);
+
+    if (count) {
+      nsRefPtr<nsMappedAttributes> modifiableMapped = new (count)
+        nsMappedAttributes(sheet, MapInheritedTableAttributesIntoRule);
+
+      if (modifiableMapped) {
+        if (align) {
+          nsAttrValue val(*align);
+          modifiableMapped->SetAndTakeAttr(nsGkAtoms::align, val);
+        }
+        if (valign) {
+          nsAttrValue val(*valign);
+          modifiableMapped->SetAndTakeAttr(nsGkAtoms::valign, val);
+        }
+
+        newAttrs = sheet->UniqueMappedAttributes(modifiableMapped);
+        NS_ASSERTION(newAttrs, "out of memory, but handling gracefully");
+
+        if (newAttrs != modifiableMapped) {
+          // Reset the stylesheet of modifiableMapped so that it doesn't
+          // spend time trying to remove itself from the hash. There is no
+          // risk that modifiableMapped is in the hash since it will
+          // always have come from GetModifiableMapped, which never
+          // returns maps that are in the hash (such hashes are by nature
+          // not modifiable).
+          modifiableMapped->DropStyleSheetReference();
+        }
+      }
+    }
+  }
+
+  mTableInheritedAttributes = newAttrs;
+  NS_IF_ADDREF(mTableInheritedAttributes);
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/content/html/content/src/HTMLTableCellElement.h b/content/html/content/src/HTMLTableCellElement.h
--- a/content/html/content/src/HTMLTableCellElement.h
+++ b/content/html/content/src/HTMLTableCellElement.h
@@ -2,30 +2,33 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef mozilla_dom_HTMLTableCellElement_h
 #define mozilla_dom_HTMLTableCellElement_h
 
 #include "nsGenericHTMLElement.h"
 #include "nsIDOMHTMLTableCellElement.h"
+#include "nsHTMLStyleSheet.h"
+#include "mozilla/dom/HTMLTableElement.h"
 
 class nsIDOMHTMLTableRowElement;
 
 namespace mozilla {
 namespace dom {
 
 class HTMLTableElement;
 
 class HTMLTableCellElement : public nsGenericHTMLElement,
                              public nsIDOMHTMLTableCellElement
 {
 public:
   HTMLTableCellElement(already_AddRefed<nsINodeInfo> aNodeInfo)
     : nsGenericHTMLElement(aNodeInfo)
+    , mTableInheritedAttributes(TABLE_ATTRS_DIRTY)
   {
     SetIsDOMBinding();
   }
   virtual ~HTMLTableCellElement();
 
   // nsISupports
   NS_DECL_ISUPPORTS_INHERITED
 
@@ -157,24 +160,39 @@ public:
   virtual bool ParseAttribute(int32_t aNamespaceID,
                               nsIAtom* aAttribute,
                               const nsAString& aValue,
                               nsAttrValue& aResult);
   virtual nsMapRuleToAttributesFunc GetAttributeMappingFunction() const;
   NS_IMETHOD WalkContentStyleRules(nsRuleWalker* aRuleWalker);
   NS_IMETHOD_(bool) IsAttributeMapped(const nsIAtom* aAttribute) const;
 
+  // XXX Override AttributeChanged here and on other table elements
+  // to cause marking mTableInheritedAttributes dirty.
+
   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
 
   virtual nsIDOMNode* AsDOMNode() { return this; }
 protected:
   virtual JSObject* WrapNode(JSContext *aCx, JSObject *aScope,
                              bool *aTriedToWrap) MOZ_OVERRIDE;
 
   HTMLTableElement* GetTable() const;
+  HTMLTableRowElement* GetRow() const;
+  nsIContent* GetRowGroup() const;
 
-  HTMLTableRowElement* GetRow() const;
+  // Sentinel value of 0x1 indicates that this is dirty and needs to be
+  // recalculated.
+  nsMappedAttributes *mTableInheritedAttributes;
+  void ReleaseInheritedAttributes() {
+    if (mTableInheritedAttributes &&
+        mTableInheritedAttributes != TABLE_ATTRS_DIRTY)
+      NS_RELEASE(mTableInheritedAttributes);
+  }
+  void BuildInheritedAttributes();
+  static const nsAttrValue* FindInheritedAttr(nsIAtom *aAttribute,
+                                              nsIContent **aElements);
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif /* mozilla_dom_HTMLTableCellElement_h */
diff --git a/content/html/content/src/HTMLTableColElement.cpp b/content/html/content/src/HTMLTableColElement.cpp
--- a/content/html/content/src/HTMLTableColElement.cpp
+++ b/content/html/content/src/HTMLTableColElement.cpp
@@ -158,19 +158,23 @@ HTMLTableColElement::ParseAttribute(int3
     if (aAttribute == nsGkAtoms::span) {
       /* protection from unrealistic large colspan values */
       return aResult.ParseIntWithBounds(aValue, 1, MAX_COLSPAN);
     }
     if (aAttribute == nsGkAtoms::width) {
       return aResult.ParseSpecialIntValue(aValue);
     }
     if (aAttribute == nsGkAtoms::align) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableCellHAlignValue(aValue, aResult);
     }
     if (aAttribute == nsGkAtoms::valign) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableVAlignValue(aValue, aResult);
     }
   }
 
   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
                                               aResult);
 }
 
@@ -213,25 +217,29 @@ void MapAttributesIntoRule(const nsMappe
         }
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
     nsCSSValue* textAlign = aData->ValueForTextAlign();
     if (textAlign->GetUnit() == eCSSUnit_Null) {
       // align: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
         textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
     nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
     if (verticalAlign->GetUnit() == eCSSUnit_Null) {
       // valign: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
       if (value && value->Type() == nsAttrValue::eEnum)
         verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
diff --git a/content/html/content/src/HTMLTableElement.cpp b/content/html/content/src/HTMLTableElement.cpp
--- a/content/html/content/src/HTMLTableElement.cpp
+++ b/content/html/content/src/HTMLTableElement.cpp
@@ -1124,16 +1124,37 @@ HTMLTableElement::IsAttributeMapped(cons
 }
 
 nsMapRuleToAttributesFunc
 HTMLTableElement::GetAttributeMappingFunction() const
 {
   return &MapAttributesIntoRule;
 }
 
+/* virtual */ nsresult
+HTMLTableElement::InsertChildAt(nsIContent* aKid, uint32_t aIndex,
+                                bool aNotify)
+{
+  if (aKid->IsHTML() &&
+      (aKid->Tag() == nsGkAtoms::col ||
+       aKid->Tag() == nsGkAtoms::colgroup))
+    mHaveColumnMarkup = true;
+  // else invalidate cellmap
+
+  return nsGenericHTMLElement::InsertChildAt(aKid, aIndex, aNotify);
+}
+
+/* virtual */ void
+HTMLTableElement::RemoveChildAt(uint32_t aIndex, bool aNotify)
+{
+  // invalidate cellmap if needed
+
+  nsGenericHTMLElement::RemoveChildAt(aIndex, aNotify);
+}
+
 static void
 MapInheritedTableAttributesIntoRule(const nsMappedAttributes* aAttributes,
                                     nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Padding)) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::cellpadding);
     if (value && value->Type() == nsAttrValue::eInteger) {
       // We have cellpadding.  This will override our padding values if we
diff --git a/content/html/content/src/HTMLTableElement.h b/content/html/content/src/HTMLTableElement.h
--- a/content/html/content/src/HTMLTableElement.h
+++ b/content/html/content/src/HTMLTableElement.h
@@ -174,16 +174,20 @@ public:
 
   virtual bool ParseAttribute(int32_t aNamespaceID,
                                 nsIAtom* aAttribute,
                                 const nsAString& aValue,
                                 nsAttrValue& aResult);
   virtual nsMapRuleToAttributesFunc GetAttributeMappingFunction() const;
   NS_IMETHOD_(bool) IsAttributeMapped(const nsIAtom* aAttribute) const;
 
+  virtual nsresult InsertChildAt(nsIContent* aKid, uint32_t aIndex,
+                                 bool aNotify);
+  virtual void RemoveChildAt(uint32_t aIndex, bool aNotify);
+
   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
 
   virtual nsIDOMNode* AsDOMNode() { return this; }
   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
                               nsIContent* aBindingParent,
                               bool aCompileEventHandlers);
   virtual void UnbindFromTree(bool aDeep = true,
                               bool aNullParent = true);
@@ -215,16 +219,18 @@ protected:
         return cur;
       }
     }
     return nullptr;
   }
 
   nsRefPtr<nsContentList> mTBodies;
   nsRefPtr<TableRowsCollection> mRows;
+  bool mHaveColumnMarkup;
+
   // Sentinel value of TABLE_ATTRS_DIRTY indicates that this is dirty and needs
   // to be recalculated.
   nsMappedAttributes *mTableInheritedAttributes;
   void BuildInheritedAttributes();
   void ReleaseInheritedAttributes() {
     if (mTableInheritedAttributes &&
         mTableInheritedAttributes != TABLE_ATTRS_DIRTY)
       NS_RELEASE(mTableInheritedAttributes);
diff --git a/content/html/content/src/HTMLTableRowElement.cpp b/content/html/content/src/HTMLTableRowElement.cpp
--- a/content/html/content/src/HTMLTableRowElement.cpp
+++ b/content/html/content/src/HTMLTableRowElement.cpp
@@ -363,22 +363,26 @@ HTMLTableRowElement::ParseAttribute(int3
     }
     if (aAttribute == nsGkAtoms::height) {
       return aResult.ParseSpecialIntValue(aValue);
     }
     if (aAttribute == nsGkAtoms::width) {
       return aResult.ParseSpecialIntValue(aValue);
     }
     if (aAttribute == nsGkAtoms::align) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableCellHAlignValue(aValue, aResult);
     }
     if (aAttribute == nsGkAtoms::bgcolor) {
       return aResult.ParseColor(aValue);
     }
     if (aAttribute == nsGkAtoms::valign) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableVAlignValue(aValue, aResult);
     }
   }
 
   return nsGenericHTMLElement::ParseBackgroundAttribute(aNamespaceID,
                                                         aAttribute, aValue,
                                                         aResult) ||
          nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
@@ -398,25 +402,29 @@ void MapAttributesIntoRule(const nsMappe
       else if (value && value->Type() == nsAttrValue::ePercent)
         height->SetPercentValue(value->GetPercentValue());
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
     nsCSSValue* textAlign = aData->ValueForTextAlign();
     if (textAlign->GetUnit() == eCSSUnit_Null) {
       // align: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
         textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
     nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
     if (verticalAlign->GetUnit() == eCSSUnit_Null) {
       // valign: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
       if (value && value->Type() == nsAttrValue::eEnum)
         verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
diff --git a/content/html/content/src/HTMLTableSectionElement.cpp b/content/html/content/src/HTMLTableSectionElement.cpp
--- a/content/html/content/src/HTMLTableSectionElement.cpp
+++ b/content/html/content/src/HTMLTableSectionElement.cpp
@@ -234,22 +234,26 @@ HTMLTableSectionElement::ParseAttribute(
     */
     if (aAttribute == nsGkAtoms::charoff) {
       return aResult.ParseIntWithBounds(aValue, 0);
     }
     if (aAttribute == nsGkAtoms::height) {
       return aResult.ParseSpecialIntValue(aValue);
     }
     if (aAttribute == nsGkAtoms::align) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableCellHAlignValue(aValue, aResult);
     }
     if (aAttribute == nsGkAtoms::bgcolor) {
       return aResult.ParseColor(aValue);
     }
     if (aAttribute == nsGkAtoms::valign) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableVAlignValue(aValue, aResult);
     }
   }
 
   return nsGenericHTMLElement::ParseBackgroundAttribute(aNamespaceID,
                                                         aAttribute, aValue,
                                                         aResult) ||
          nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
@@ -267,25 +271,29 @@ void MapAttributesIntoRule(const nsMappe
       if (value && value->Type() == nsAttrValue::eInteger)
         height->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
     nsCSSValue* textAlign = aData->ValueForTextAlign();
     if (textAlign->GetUnit() == eCSSUnit_Null) {
       // align: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
         textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
     nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
     if (verticalAlign->GetUnit() == eCSSUnit_Null) {
       // valign: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
       if (value && value->Type() == nsAttrValue::eEnum)
         verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
