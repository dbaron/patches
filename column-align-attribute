From: L. David Baron <dbaron@dbaron.org>

Follow HTML rules for inheritance of presentational attributes in tables and then map the final result into CSS, associated with the table cell.  (Bug 915)

diff --git a/content/html/content/src/nsHTMLTableCellElement.cpp b/content/html/content/src/nsHTMLTableCellElement.cpp
--- a/content/html/content/src/nsHTMLTableCellElement.cpp
+++ b/content/html/content/src/nsHTMLTableCellElement.cpp
@@ -13,16 +13,17 @@
 #include "nsMappedAttributes.h"
 #include "nsGenericHTMLElement.h"
 #include "nsGkAtoms.h"
 #include "nsStyleConsts.h"
 #include "nsPresContext.h"
 #include "nsRuleData.h"
 #include "nsRuleWalker.h"
 #include "celldata.h"
+#include "nsHTMLStyleSheet.h"
 
 using namespace mozilla;
 
 class nsHTMLTableCellElement : public nsGenericHTMLElement,
                                public nsIDOMHTMLTableCellElement
 {
 public:
   nsHTMLTableCellElement(already_AddRefed<nsINodeInfo> aNodeInfo);
@@ -46,38 +47,56 @@ public:
   virtual bool ParseAttribute(int32_t aNamespaceID,
                               nsIAtom* aAttribute,
                               const nsAString& aValue,
                               nsAttrValue& aResult);
   virtual nsMapRuleToAttributesFunc GetAttributeMappingFunction() const;
   NS_IMETHOD WalkContentStyleRules(nsRuleWalker* aRuleWalker);
   NS_IMETHOD_(bool) IsAttributeMapped(const nsIAtom* aAttribute) const;
 
+  // XXX Override AttributeChanged here and on other table elements
+  // to cause marking mTableInheritedAttributes dirty.
+
   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
 
   virtual nsXPCClassInfo* GetClassInfo();
 
   virtual nsIDOMNode* AsDOMNode() { return this; }
 protected:
   nsHTMLTableElement* GetTable() const;
 
-  already_AddRefed<nsIDOMHTMLTableRowElement> GetRow() const;
+  nsIContent* GetRow() const;
+  nsIContent* GetRowGroup() const;
+
+  // Sentinel value of 0x1 indicates that this is dirty and needs to be
+  // recalculated.
+  nsMappedAttributes *mTableInheritedAttributes;
+  void ReleaseInheritedAttributes() {
+    if (mTableInheritedAttributes &&
+        mTableInheritedAttributes != TABLE_ATTRS_DIRTY)
+      NS_RELEASE(mTableInheritedAttributes);
+  }
+  void BuildInheritedAttributes();
+  static const nsAttrValue* FindInheritedAttr(nsIAtom *aAttribute,
+                                              nsIContent **aElements);
 };
 
 
 NS_IMPL_NS_NEW_HTML_ELEMENT(TableCell)
 
 
 nsHTMLTableCellElement::nsHTMLTableCellElement(already_AddRefed<nsINodeInfo> aNodeInfo)
   : nsGenericHTMLElement(aNodeInfo)
+  , mTableInheritedAttributes(TABLE_ATTRS_DIRTY)
 {
 }
 
 nsHTMLTableCellElement::~nsHTMLTableCellElement()
 {
+  ReleaseInheritedAttributes();
 }
 
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLTableCellElement, nsGenericElement) 
 NS_IMPL_RELEASE_INHERITED(nsHTMLTableCellElement, nsGenericElement) 
 
 
 DOMCI_NODE_DATA(HTMLTableCellElement, nsHTMLTableCellElement)
@@ -90,24 +109,16 @@ NS_INTERFACE_TABLE_HEAD(nsHTMLTableCellE
                                                nsGenericHTMLElement)
 NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLTableCellElement)
 
 
 NS_IMPL_ELEMENT_CLONE(nsHTMLTableCellElement)
 
 
 // protected method
-already_AddRefed<nsIDOMHTMLTableRowElement>
-nsHTMLTableCellElement::GetRow() const
-{
-  nsCOMPtr<nsIDOMHTMLTableRowElement> row = do_QueryInterface(GetParent());
-  return row.forget();
-}
-
-// protected method
 nsHTMLTableElement*
 nsHTMLTableCellElement::GetTable() const
 {
   nsIContent *parent = GetParent();
   if (!parent) {
     return nullptr;
   }
 
@@ -126,22 +137,51 @@ nsHTMLTableCellElement::GetTable() const
   nsIContent* result = section->GetParent();
   if (result && result->IsHTML(nsGkAtoms::table)) {
     return static_cast<nsHTMLTableElement*>(result);
   }
 
   return nullptr;
 }
 
+// protected method
+nsIContent*
+nsHTMLTableCellElement::GetRow() const
+{
+  nsIContent *row = GetParent();
+  if (!row ||
+      !row->IsHTML() ||
+      !row->NodeInfo()->Equals(nsGkAtoms::tr))
+    row = nullptr;
+  return row;
+}
+
+// protected method
+nsIContent*
+nsHTMLTableCellElement::GetRowGroup() const
+{
+  nsIContent *row = GetRow();
+  if (!row)
+    return nullptr;
+  nsIContent *rowGroup = row->GetParent();
+  if (!rowGroup ||
+      !rowGroup->IsHTML() ||
+      !(rowGroup->NodeInfo()->Equals(nsGkAtoms::tbody) ||
+        rowGroup->NodeInfo()->Equals(nsGkAtoms::thead) ||
+        rowGroup->NodeInfo()->Equals(nsGkAtoms::tfoot)))
+    rowGroup = nullptr;
+  return rowGroup;
+}
+
 NS_IMETHODIMP
 nsHTMLTableCellElement::GetCellIndex(int32_t* aCellIndex)
 {
   *aCellIndex = -1;
 
-  nsCOMPtr<nsIDOMHTMLTableRowElement> row = GetRow();
+  nsCOMPtr<nsIDOMHTMLTableRowElement> row = do_QueryInterface(GetRow());
   if (!row) {
     return NS_OK;
   }
 
   nsCOMPtr<nsIDOMHTMLCollection> cells;
 
   row->GetCells(getter_AddRefs(cells));
 
@@ -174,16 +214,25 @@ nsHTMLTableCellElement::WalkContentStyle
 
   if (nsHTMLTableElement* table = GetTable()) {
     nsMappedAttributes* tableInheritedAttributes =
       table->GetAttributesMappedForCell();
     if (tableInheritedAttributes) {
       aRuleWalker->Forward(tableInheritedAttributes);
     }
   }
+
+  if (mTableInheritedAttributes) {
+    if (mTableInheritedAttributes == TABLE_ATTRS_DIRTY)
+      BuildInheritedAttributes();
+
+    if (mTableInheritedAttributes)
+      aRuleWalker->Forward(mTableInheritedAttributes);
+  }
+
   return NS_OK;
 }
 
 
 NS_IMPL_STRING_ATTR(nsHTMLTableCellElement, Abbr, abbr)
 NS_IMPL_STRING_ATTR(nsHTMLTableCellElement, Axis, axis)
 NS_IMPL_STRING_ATTR(nsHTMLTableCellElement, BgColor, bgcolor)
 NS_IMPL_STRING_ATTR(nsHTMLTableCellElement, Ch, _char)
@@ -196,19 +245,21 @@ NS_IMPL_INT_ATTR_DEFAULT_VALUE(nsHTMLTab
 NS_IMPL_STRING_ATTR(nsHTMLTableCellElement, Scope, scope)
 NS_IMPL_STRING_ATTR(nsHTMLTableCellElement, VAlign, valign)
 NS_IMPL_STRING_ATTR(nsHTMLTableCellElement, Width, width)
 
 
 NS_IMETHODIMP
 nsHTMLTableCellElement::GetAlign(nsAString& aValue)
 {
+  // XXX What is this supposed to do!
+
   if (!GetAttr(kNameSpaceID_None, nsGkAtoms::align, aValue)) {
     // There's no align attribute, ask the row for the alignment.
-    nsCOMPtr<nsIDOMHTMLTableRowElement> row = GetRow();
+    nsCOMPtr<nsIDOMHTMLTableRowElement> row = do_QueryInterface(GetRow());
     if (row) {
       return row->GetAlign(aValue);
     }
   }
 
   return NS_OK;
 }
 
@@ -325,48 +376,31 @@ void MapAttributesIntoRule(const nsMappe
       else if (value && value->Type() == nsAttrValue::ePercent) {
         if (value->GetPercentValue() > 0.0f)
           height->SetPercentValue(value->GetPercentValue());
         // else 0 implies auto for compatibility
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
-    nsCSSValue* textAlign = aData->ValueForTextAlign();
-    if (textAlign->GetUnit() == eCSSUnit_Null) {
-      // align: enum
-      const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
-      if (value && value->Type() == nsAttrValue::eEnum)
-        textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
-    }
-
     nsCSSValue* whiteSpace = aData->ValueForWhiteSpace();
     if (whiteSpace->GetUnit() == eCSSUnit_Null) {
       // nowrap: enum
       if (aAttributes->GetAttr(nsGkAtoms::nowrap)) {
         // See if our width is not a nonzero integer width.
         const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
         nsCompatibility mode = aData->mPresContext->CompatibilityMode();
         if (!value || value->Type() != nsAttrValue::eInteger ||
             value->GetIntegerValue() == 0 ||
             eCompatibility_NavQuirks != mode) {
           whiteSpace->SetIntValue(NS_STYLE_WHITESPACE_NOWRAP, eCSSUnit_Enumerated);
         }
       }
     }
   }
-  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
-    nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
-    if (verticalAlign->GetUnit() == eCSSUnit_Null) {
-      // valign: enum
-      const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
-      if (value && value->Type() == nsAttrValue::eEnum)
-        verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
-    }
-  }
   
   nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
 NS_IMETHODIMP_(bool)
 nsHTMLTableCellElement::IsAttributeMapped(const nsIAtom* aAttribute) const
 {
@@ -396,8 +430,228 @@ nsHTMLTableCellElement::IsAttributeMappe
   return FindAttributeDependence(aAttribute, map);
 }
 
 nsMapRuleToAttributesFunc
 nsHTMLTableCellElement::GetAttributeMappingFunction() const
 {
   return &MapAttributesIntoRule;
 }
+
+static void
+MapInheritedTableAttributesIntoRule(const nsMappedAttributes* aAttributes,
+                                    nsRuleData* aData)
+{
+  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
+    nsCSSValue* textAlign = aData->ValueForTextAlign();
+    if (textAlign->GetUnit() == eCSSUnit_Null) {
+      // align: enum
+      const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
+      if (value && value->Type() == nsAttrValue::eEnum)
+        textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+    }
+  }
+  if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
+    nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
+    if (verticalAlign->GetUnit() == eCSSUnit_Null) {
+      // valign: enum
+      const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
+      if (value && value->Type() == nsAttrValue::eEnum)
+        verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
+    }
+  }
+}
+
+#define INHERIT_ELEMENTS (6)
+
+/* static */ const nsAttrValue*
+nsHTMLTableCellElement::FindInheritedAttr(nsIAtom *aAttribute,
+                                          nsIContent **aElements)
+{
+  for (nsIContent **elementp = aElements,
+              **elementp_end = aElements + INHERIT_ELEMENTS;
+       elementp < elementp_end; ++elementp) {
+    nsIContent *element = *elementp;
+    if (element) {
+      // XXX It's really just nsGenericHTMLElement, but we have to cast
+      // to nsHTMLTableCellElement to make it compile because C++ says
+      // so.
+      const nsAttrValue* value =
+        static_cast<nsHTMLTableCellElement*>(element)->
+          mAttrsAndChildren.GetAttr(aAttribute);
+      if (value) {
+        return value;
+      }
+    }
+  }
+  return nullptr;
+}
+
+void
+nsHTMLTableCellElement::BuildInheritedAttributes()
+{
+  NS_ASSERTION(mTableInheritedAttributes == TABLE_ATTRS_DIRTY,
+               "potential leak, plus waste of work");
+
+  // These attributes are all guaranteed to be mapped, but the attribute
+  // mapping functions don't actually do anything with them; we do.
+  // XXX Make this actually true by removing code!
+
+  nsIContent *row = GetRow();
+  nsIContent *rowGroup = GetRowGroup();
+  nsIContent *table = GetTable();
+
+  nsIContent *col = nullptr, *colGroup = nullptr;
+
+  // Find col and colGroup.
+  // XXX This doesn't account for rowspans.  We really just need a cellmap.
+  if (row && table) {
+    // XXX Only do this work if there are actually col or colgroup
+    // elements with style information!
+    int32_t colNumber = -1;
+    int32_t curCol = 0;
+    for (uint32_t i = 0, i_end = row->GetChildCount();
+         i < i_end; ++i) {
+      nsIContent *child = row->GetChildAt(i);
+      if (child == this) {
+        colNumber = curCol;
+        break;
+      }
+
+      nsIAtom *tag = child->Tag();
+      if (child->IsHTML() &&
+          (tag == nsGkAtoms::td || tag == nsGkAtoms::th)) {
+        int32_t span = 1;
+        GetIntAttr(nsGkAtoms::colspan, 1, &span);
+        curCol += span;
+      }
+    }
+    NS_ASSERTION(colNumber != -1, "we're not a child of our parent");
+
+    // We have a column index, so look for a col or colGroup element.
+    curCol = 0;
+    for (uint32_t i = 0, i_end = table->GetChildCount();
+         i < i_end; ++i) {
+      nsIContent *child = table->GetChildAt(i);
+      if (child->IsHTML()) {
+        nsIAtom *tag = child->Tag();
+        if (tag == nsGkAtoms::col) {
+          int32_t span = 1;
+          // XXX It's really just nsGenericHTMLElement, but we have
+          // to cast to nsHTMLTableCellElement to make it compile because
+          // C++ says so.
+          static_cast<nsHTMLTableCellElement*>(child)->
+            GetIntAttr(nsGkAtoms::span, 1, &span);
+          if (curCol + span > colNumber) {
+            col = child;
+            break;
+          }
+          curCol += span;
+        } else if (tag == nsGkAtoms::colgroup) {
+          // If the colgroup contains col elements, ignore the |span|
+          // and walk them!
+          bool haveCols = false;
+          for (uint32_t j = 0, j_end = child->GetChildCount();
+               j < j_end; ++j) {
+            nsIContent *cgchild = child->GetChildAt(j);
+            if (cgchild->IsHTML() &&
+                cgchild->Tag() == nsGkAtoms::col) {
+              haveCols = true;
+
+              int32_t span = 1;
+              // XXX It's really just nsGenericHTMLElement, but we have
+              // to cast to nsHTMLTableCellElement to make it compile
+              // because C++ says so.
+              static_cast<nsHTMLTableCellElement*>(cgchild)->
+                GetIntAttr(nsGkAtoms::span, 1, &span);
+              if (curCol + span > colNumber) {
+                colGroup = child;
+                col = cgchild;
+                break;
+              }
+              curCol += span;
+            }
+          }
+          if (col)
+            break;
+
+          if (!haveCols) {
+            int32_t span = 1;
+            // XXX It's really just nsGenericHTMLElement, but we have to
+            // cast to nsHTMLTableCellElement to make it compile because
+            // C++ says so.
+            static_cast<nsHTMLTableCellElement*>(child)->
+              GetIntAttr(nsGkAtoms::span, 1, &span);
+            if (curCol + span > colNumber) {
+              colGroup = child;
+              break;
+            }
+            curCol += span;
+          }
+        } else if (tag == nsGkAtoms::tr || 
+                   tag == nsGkAtoms::tbody || 
+                   tag == nsGkAtoms::thead || 
+                   tag == nsGkAtoms::tfoot) {
+          // There shouldn't be any more columns after this point.
+          break;
+        }
+      }
+    }
+  }
+
+  // According to HTML 4.01, section 11.3.2, the priority for:
+  //   Attributes: align, char, charoff
+  //   Is:  cell, col, col group, row, row group, table
+  // and for
+  //   Attributes: valign  (we'll ignore what it says about lang, dir, style)
+  //     XXX We probably should pay attention for lang and dir.
+  //   Is: cell, row, row group, col, col group, table
+  nsIContent *colPriority[INHERIT_ELEMENTS] =
+    { this, col, colGroup, row, rowGroup, table};
+  nsIContent *rowPriority[INHERIT_ELEMENTS] =
+    { this, row, rowGroup, col, colGroup, table};
+
+  nsIDocument *document = GetCurrentDoc();
+  nsHTMLStyleSheet* sheet = document ?
+                              document->GetAttributeStyleSheet() : nullptr;
+  nsRefPtr<nsMappedAttributes> newAttrs;
+  if (sheet) {
+    const nsAttrValue *align =
+      FindInheritedAttr(nsGkAtoms::align, colPriority);
+    const nsAttrValue *valign =
+      FindInheritedAttr(nsGkAtoms::valign, rowPriority);
+    // XXX Implement char and charoff here.
+
+    uint32_t count = (align != nullptr) + (valign != nullptr);
+
+    if (count) {
+      nsRefPtr<nsMappedAttributes> modifiableMapped = new (count)
+        nsMappedAttributes(sheet, MapInheritedTableAttributesIntoRule);
+
+      if (modifiableMapped) {
+        if (align) {
+          nsAttrValue val(*align);
+          modifiableMapped->SetAndTakeAttr(nsGkAtoms::align, val);
+        }
+        if (valign) {
+          nsAttrValue val(*valign);
+          modifiableMapped->SetAndTakeAttr(nsGkAtoms::valign, val);
+        }
+
+        newAttrs = sheet->UniqueMappedAttributes(modifiableMapped);
+        NS_ASSERTION(newAttrs, "out of memory, but handling gracefully");
+
+        if (newAttrs != modifiableMapped) {
+          // Reset the stylesheet of modifiableMapped so that it doesn't
+          // spend time trying to remove itself from the hash. There is no
+          // risk that modifiableMapped is in the hash since it will
+          // always have come from GetModifiableMapped, which never
+          // returns maps that are in the hash (such hashes are by nature
+          // not modifiable).
+          modifiableMapped->DropStyleSheetReference();
+        }
+      }
+    }
+  }
+
+  mTableInheritedAttributes = newAttrs;
+  NS_IF_ADDREF(mTableInheritedAttributes);
+}
diff --git a/content/html/content/src/nsHTMLTableColElement.cpp b/content/html/content/src/nsHTMLTableColElement.cpp
--- a/content/html/content/src/nsHTMLTableColElement.cpp
+++ b/content/html/content/src/nsHTMLTableColElement.cpp
@@ -108,19 +108,23 @@ nsHTMLTableColElement::ParseAttribute(in
     if (aAttribute == nsGkAtoms::span) {
       /* protection from unrealistic large colspan values */
       return aResult.ParseIntWithBounds(aValue, 1, MAX_COLSPAN);
     }
     if (aAttribute == nsGkAtoms::width) {
       return aResult.ParseSpecialIntValue(aValue);
     }
     if (aAttribute == nsGkAtoms::align) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableCellHAlignValue(aValue, aResult);
     }
     if (aAttribute == nsGkAtoms::valign) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableVAlignValue(aValue, aResult);
     }
   }
 
   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
                                               aResult);
 }
 
@@ -163,25 +167,29 @@ void MapAttributesIntoRule(const nsMappe
         }
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
     nsCSSValue* textAlign = aData->ValueForTextAlign();
     if (textAlign->GetUnit() == eCSSUnit_Null) {
       // align: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
         textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
     nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
     if (verticalAlign->GetUnit() == eCSSUnit_Null) {
       // valign: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
       if (value && value->Type() == nsAttrValue::eEnum)
         verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
diff --git a/content/html/content/src/nsHTMLTableElement.cpp b/content/html/content/src/nsHTMLTableElement.cpp
--- a/content/html/content/src/nsHTMLTableElement.cpp
+++ b/content/html/content/src/nsHTMLTableElement.cpp
@@ -1108,16 +1108,37 @@ nsHTMLTableElement::IsAttributeMapped(co
 }
 
 nsMapRuleToAttributesFunc
 nsHTMLTableElement::GetAttributeMappingFunction() const
 {
   return &MapAttributesIntoRule;
 }
 
+/* virtual */ nsresult
+nsHTMLTableElement::InsertChildAt(nsIContent* aKid, uint32_t aIndex,
+                                  bool aNotify)
+{
+  if (aKid->IsHTML() &&
+      (aKid->Tag() == nsGkAtoms::col ||
+       aKid->Tag() == nsGkAtoms::colgroup))
+    mHaveColumnMarkup = true;
+  // else invalidate cellmap
+
+  return nsGenericHTMLElement::InsertChildAt(aKid, aIndex, aNotify);
+}
+
+/* virtual */ void
+nsHTMLTableElement::RemoveChildAt(uint32_t aIndex, bool aNotify)
+{
+  // invalidate cellmap if needed
+
+  nsGenericHTMLElement::RemoveChildAt(aIndex, aNotify);
+}
+
 static void
 MapInheritedTableAttributesIntoRule(const nsMappedAttributes* aAttributes,
                                     nsRuleData* aData)
 {
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Padding)) {
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::cellpadding);
     if (value && value->Type() == nsAttrValue::eInteger) {
       // We have cellpadding.  This will override our padding values if we
diff --git a/content/html/content/src/nsHTMLTableElement.h b/content/html/content/src/nsHTMLTableElement.h
--- a/content/html/content/src/nsHTMLTableElement.h
+++ b/content/html/content/src/nsHTMLTableElement.h
@@ -35,16 +35,20 @@ public:
 
   virtual bool ParseAttribute(int32_t aNamespaceID,
                                 nsIAtom* aAttribute,
                                 const nsAString& aValue,
                                 nsAttrValue& aResult);
   virtual nsMapRuleToAttributesFunc GetAttributeMappingFunction() const;
   NS_IMETHOD_(bool) IsAttributeMapped(const nsIAtom* aAttribute) const;
 
+  virtual nsresult InsertChildAt(nsIContent* aKid, uint32_t aIndex,
+                                 bool aNotify);
+  virtual void RemoveChildAt(uint32_t aIndex, bool aNotify);
+
   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
 
   virtual nsXPCClassInfo* GetClassInfo();
   virtual nsIDOMNode* AsDOMNode() { return this; }
   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
                               nsIContent* aBindingParent,
                               bool aCompileEventHandlers);
   virtual void UnbindFromTree(bool aDeep = true,
@@ -72,16 +76,18 @@ public:
   }
   already_AddRefed<nsIDOMHTMLTableCaptionElement> GetCaption();
   nsContentList* TBodies();
 protected:
   already_AddRefed<nsIDOMHTMLTableSectionElement> GetSection(nsIAtom *aTag);
 
   nsRefPtr<nsContentList> mTBodies;
   nsRefPtr<TableRowsCollection> mRows;
+  bool mHaveColumnMarkup;
+
   // Sentinel value of TABLE_ATTRS_DIRTY indicates that this is dirty and needs
   // to be recalculated.
   nsMappedAttributes *mTableInheritedAttributes;
   void BuildInheritedAttributes();
   void ReleaseInheritedAttributes() {
     if (mTableInheritedAttributes &&
         mTableInheritedAttributes != TABLE_ATTRS_DIRTY)
       NS_RELEASE(mTableInheritedAttributes);
diff --git a/content/html/content/src/nsHTMLTableRowElement.cpp b/content/html/content/src/nsHTMLTableRowElement.cpp
--- a/content/html/content/src/nsHTMLTableRowElement.cpp
+++ b/content/html/content/src/nsHTMLTableRowElement.cpp
@@ -328,22 +328,26 @@ nsHTMLTableRowElement::ParseAttribute(in
     }
     if (aAttribute == nsGkAtoms::height) {
       return aResult.ParseSpecialIntValue(aValue);
     }
     if (aAttribute == nsGkAtoms::width) {
       return aResult.ParseSpecialIntValue(aValue);
     }
     if (aAttribute == nsGkAtoms::align) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableCellHAlignValue(aValue, aResult);
     }
     if (aAttribute == nsGkAtoms::bgcolor) {
       return aResult.ParseColor(aValue);
     }
     if (aAttribute == nsGkAtoms::valign) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableVAlignValue(aValue, aResult);
     }
   }
 
   return nsGenericHTMLElement::ParseBackgroundAttribute(aNamespaceID,
                                                         aAttribute, aValue,
                                                         aResult) ||
          nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
@@ -363,25 +367,29 @@ void MapAttributesIntoRule(const nsMappe
       else if (value && value->Type() == nsAttrValue::ePercent)
         height->SetPercentValue(value->GetPercentValue());
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
     nsCSSValue* textAlign = aData->ValueForTextAlign();
     if (textAlign->GetUnit() == eCSSUnit_Null) {
       // align: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
         textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
     nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
     if (verticalAlign->GetUnit() == eCSSUnit_Null) {
       // valign: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
       if (value && value->Type() == nsAttrValue::eEnum)
         verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
diff --git a/content/html/content/src/nsHTMLTableSectionElement.cpp b/content/html/content/src/nsHTMLTableSectionElement.cpp
--- a/content/html/content/src/nsHTMLTableSectionElement.cpp
+++ b/content/html/content/src/nsHTMLTableSectionElement.cpp
@@ -223,22 +223,26 @@ nsHTMLTableSectionElement::ParseAttribut
     */
     if (aAttribute == nsGkAtoms::charoff) {
       return aResult.ParseIntWithBounds(aValue, 0);
     }
     if (aAttribute == nsGkAtoms::height) {
       return aResult.ParseSpecialIntValue(aValue);
     }
     if (aAttribute == nsGkAtoms::align) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableCellHAlignValue(aValue, aResult);
     }
     if (aAttribute == nsGkAtoms::bgcolor) {
       return aResult.ParseColor(aValue);
     }
     if (aAttribute == nsGkAtoms::valign) {
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       return ParseTableVAlignValue(aValue, aResult);
     }
   }
 
   return nsGenericHTMLElement::ParseBackgroundAttribute(aNamespaceID,
                                                         aAttribute, aValue,
                                                         aResult) ||
          nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
@@ -256,25 +260,29 @@ void MapAttributesIntoRule(const nsMappe
       if (value && value->Type() == nsAttrValue::eInteger)
         height->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
     nsCSSValue* textAlign = aData->ValueForTextAlign();
     if (textAlign->GetUnit() == eCSSUnit_Null) {
       // align: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
       if (value && value->Type() == nsAttrValue::eEnum)
         textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
     nsCSSValue* verticalAlign = aData->ValueForVerticalAlign();
     if (verticalAlign->GetUnit() == eCSSUnit_Null) {
       // valign: enum
+      // XXX Should we be doing this only for computed style now that
+      // the table cell handles it?
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::valign);
       if (value && value->Type() == nsAttrValue::eEnum)
         verticalAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     }
   }
 
   nsGenericHTMLElement::MapBackgroundAttributesInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
