From: L. David Baron <dbaron@dbaron.org>

@media rules do not allow empty media lists, per http://lists.w3.org/Archives/Public/www-style/2009Aug/0128.html .

diff --git a/layout/reftests/bugs/449171-1.html b/layout/reftests/bugs/449171-1.html
--- a/layout/reftests/bugs/449171-1.html
+++ b/layout/reftests/bugs/449171-1.html
@@ -1,16 +1,16 @@
 <!DOCTYPE html>
 <html>
   <head>
     <style>
       @import url("data:text/css,.import { color: green }");
-      div { color: red }
+      div { color: blue }
       @media {
-        .media { color: green }
+        .media { color: red }
       }
     </style>
   </head>
   <body>
     <div class="import">test</div>
     <div class="media">test</div>
   <body>
 </html>
diff --git a/layout/reftests/bugs/449171-ref.html b/layout/reftests/bugs/449171-ref.html
--- a/layout/reftests/bugs/449171-ref.html
+++ b/layout/reftests/bugs/449171-ref.html
@@ -1,12 +1,7 @@
 <!DOCTYPE html>
 <html>
-  <head>
-    <style>
-      div { color: green }
-    </style>
-  </head>
   <body>
-    <div>test</div>
-    <div>test</div>
+    <div style="color: green">test</div>
+    <div style="color: blue">test</div>
   <body>
 </html>
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -2004,17 +2004,18 @@ PRBool
 CSSParserImpl::ParseMediaRule(RuleAppendFunc aAppendFunc, void* aData)
 {
   nsCOMPtr<nsMediaList> media = new nsMediaList();
   if (!media) {
     mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
     return PR_FALSE;
   }
 
-  if (GatherMedia(media, '{')) {
+  // @media rules do not allow empty media lists
+  if (GatherMedia(media, '{') && !media->IsEmpty()) {
     // XXXbz this could use better error reporting throughout the method
     nsRefPtr<nsCSSMediaRule> rule(new nsCSSMediaRule());
     // Append first, so when we do SetMedia() the rule
     // knows what its stylesheet is.
     if (rule && ParseGroupRule(rule, aAppendFunc, aData)) {
       rule->SetMedia(media);
       return PR_TRUE;
     }
diff --git a/layout/style/nsIMediaList.h b/layout/style/nsIMediaList.h
--- a/layout/style/nsIMediaList.h
+++ b/layout/style/nsIMediaList.h
@@ -199,19 +199,23 @@ public:
   }
 
   nsresult Clone(nsMediaList** aResult);
 
   PRInt32 Count() { return mArray.Length(); }
   nsMediaQuery* MediumAt(PRInt32 aIndex) { return mArray[aIndex]; }
   void Clear() { mArray.Clear(); mIsEmpty = PR_TRUE; }
   // a media list with no items may not represent the lack of a media
-  // list; it could represent the empty string or something with parser
-  // errors, which means that the media list should never match
+  // list (such as one parsed from an empty string); it could represent
+  // a media list with items with parser errors, which means that the
+  // media list should never match.  So the parser calls SetNonEmpty()
+  // if it parses anything, whether that thing is dropped for being
+  // invalid or not.
   void SetNonEmpty() { mIsEmpty = PR_FALSE; }
+  PRBool IsEmpty() const { return mIsEmpty; }
 
 protected:
   ~nsMediaList();
 
   nsresult Delete(const nsAString & aOldMedium);
   nsresult Append(const nsAString & aOldMedium);
 
   nsTArray<nsAutoPtr<nsMediaQuery> > mArray;
