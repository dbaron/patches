From: L. David Baron <dbaron@dbaron.org>

Debugging patch to get more information about bug 997506.

diff --git a/layout/base/RestyleTracker.cpp b/layout/base/RestyleTracker.cpp
--- a/layout/base/RestyleTracker.cpp
+++ b/layout/base/RestyleTracker.cpp
@@ -67,29 +67,51 @@ CollectRestyles(nsISupports* aElement,
   // haven't, for example, already been restyled).
   // It's important to not mess with the flags on entries not in our
   // document.
   if (element->GetCurrentDoc() != collector->tracker->Document() ||
       !element->HasFlag(collector->tracker->RestyleBit())) {
     return PL_DHASH_NEXT;
   }
 
-  NS_ASSERTION(!element->HasFlag(collector->tracker->RootBit()) ||
+#ifdef DEBUG
+  if (!(!element->HasFlag(collector->tracker->RootBit()) ||
                // Maybe we're just not reachable via the frame tree?
                (element->GetFlattenedTreeParent() &&
                 (!element->GetFlattenedTreeParent()->GetPrimaryFrame()||
                  element->GetFlattenedTreeParent()->GetPrimaryFrame()->IsLeaf())) ||
                // Or not reachable due to an async reinsert we have
                // pending?  If so, we'll have a reframe hint around.
                // That incidentally makes it safe that we still have
                // the bit, since any descendants that didn't get added
                // to the roots list because we had the bits will be
                // completely restyled in a moment.
-               (aData.mChangeHint & nsChangeHint_ReconstructFrame),
-               "Why did this not get handled while processing mRestyleRoots?");
+               (aData.mChangeHint & nsChangeHint_ReconstructFrame))) {
+    NS_NOTREACHED("Why did this not get handled while processing mRestyleRoots?");
+    printf("Element is %p, restyle hint is %lX change hint is %lX.\n",
+           (void*) element,
+           (unsigned long) aData.mRestyleHint,
+           (unsigned long) aData.mChangeHint);
+    element->List();
+    nsIContent* content = element;
+    content->DumpContent();
+    nsIFrame* f = element->GetPrimaryFrame();
+    if (f) {
+      f->List();
+    }
+    mozilla::dom::Element* root = element->OwnerDoc()->GetRootElement();
+    if (root) {
+      root->List();
+      f = root->GetPrimaryFrame();
+      if (f) {
+        f->List();
+      }
+    }
+  }
+#endif
 
   // Unset the restyle bits now, so if they get readded later as we
   // process we won't clobber that adding of the bit.
   element->UnsetFlags(collector->tracker->RestyleBit() |
                       collector->tracker->RootBit());
 
   RestyleTracker::RestyleEnumerateData** restyleArrayPtr =
     collector->restyleArrayPtr;
diff --git a/layout/base/RestyleTracker.h b/layout/base/RestyleTracker.h
--- a/layout/base/RestyleTracker.h
+++ b/layout/base/RestyleTracker.h
@@ -10,16 +10,17 @@
 
 #ifndef mozilla_RestyleTracker_h
 #define mozilla_RestyleTracker_h
 
 #include "mozilla/dom/Element.h"
 #include "nsDataHashtable.h"
 #include "nsIFrame.h"
 #include "mozilla/SplayTree.h"
+#include "nsTraceRefcnt.h"
 
 namespace mozilla {
 
 class RestyleManager;
 class ElementRestyler;
 
 /** 
  * Helper class that collects a list of frames that need
@@ -362,16 +363,32 @@ inline bool
 RestyleTracker::AddPendingRestyleToTable(Element* aElement,
                                          nsRestyleHint aRestyleHint,
                                          nsChangeHint aMinChangeHint)
 {
   RestyleData existingData;
   existingData.mRestyleHint = nsRestyleHint(0);
   existingData.mChangeHint = NS_STYLE_HINT_NONE;
 
+//#ifdef DEBUG
+#if 0
+  if (aElement->AttrValueIs(kNameSpaceID_None, nsGkAtoms::_class,
+                            NS_LITERAL_STRING("newtab-site"), eCaseMatters)) {
+    printf("Adding restyle to table for\n");
+    aElement->List();
+    nsIContent* content = aElement;
+    content->DumpContent();
+    nsIFrame* f = aElement->GetPrimaryFrame();
+    if (f) {
+      f->List();
+    }
+    nsTraceRefcnt::WalkTheStack(stdout);
+  }
+#endif
+
   // Check the RestyleBit() flag before doing the hashtable Get, since
   // it's possible that the data in the hashtable isn't actually
   // relevant anymore (if the flag is not set).
   if (aElement->HasFlag(RestyleBit())) {
     mPendingRestyles.Get(aElement, &existingData);
   } else {
     aElement->SetFlags(RestyleBit());
   }
