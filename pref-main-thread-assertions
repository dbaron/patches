From: L. David Baron <dbaron@dbaron.org>

Bug 619487 - Add assertions for prefs being accessed off the main thread to debug recursion-level assertions that I see after running for a long time.

diff --git a/modules/libpref/src/prefapi.cpp b/modules/libpref/src/prefapi.cpp
--- a/modules/libpref/src/prefapi.cpp
+++ b/modules/libpref/src/prefapi.cpp
@@ -5,16 +5,17 @@
 
 #include "base/basictypes.h"
 
 #include "prefapi.h"
 #include "prefapi_private_data.h"
 #include "prefread.h"
 #include "nsReadableUtils.h"
 #include "nsCRT.h"
+#include "nsThreadUtils.h"
 
 #define PL_ARENA_CONST_ALIGN_MASK 3
 #include "plarena.h"
 
 #ifdef _WIN32
   #include "windows.h"
 #endif /* _WIN32 */
 
@@ -142,16 +143,18 @@ enum {
     kPrefForceSet = 2
 };
 static nsresult pref_HashPref(const char *key, PrefValue value, PrefType type, uint32_t flags);
 
 #define PREF_HASHTABLE_INITIAL_SIZE	2048
 
 nsresult PREF_Init()
 {
+    NS_ASSERTION(NS_IsMainThread(),
+                 "pref hashtable is main thread only");
     if (!gHashTable.ops) {
         if (!PL_DHashTableInit(&gHashTable, &pref_HashTableOps, nullptr,
                                sizeof(PrefHashEntry), PREF_HASHTABLE_INITIAL_SIZE,
                                fallible_t())) {
             gHashTable.ops = nullptr;
             return NS_ERROR_OUT_OF_MEMORY;
         }
 
@@ -179,16 +182,18 @@ void PREF_Cleanup()
     gCallbacks = nullptr;
 
     PREF_CleanupPrefs();
 }
 
 /* Frees up all the objects except the callback list. */
 void PREF_CleanupPrefs()
 {
+    NS_ASSERTION(NS_IsMainThread(),
+                 "pref hashtable is main thread only");
     if (gHashTable.ops) {
         PL_DHashTableFinish(&gHashTable);
         gHashTable.ops = nullptr;
         PL_FinishArenaPool(&gPrefNameArena);
     }
 }
 
 // note that this appends to aResult, and does not assign!
@@ -570,16 +575,18 @@ pref_DeleteItem(PLDHashTable *table, PLD
         return PL_DHASH_REMOVE;
 
     return PL_DHASH_NEXT;
 }
 
 nsresult
 PREF_DeleteBranch(const char *branch_name)
 {
+    NS_ASSERTION(NS_IsMainThread(),
+                 "pref hashtable is main thread only");
     int len = (int)strlen(branch_name);
 
     if (!gHashTable.ops)
         return NS_ERROR_NOT_INITIALIZED;
 
     /* The following check insures that if the branch name already has a "."
      * at the end, we don't end up with a "..". This fixes an incompatibility
      * between nsIPref, which needs the period added, and nsIPrefBranch which
@@ -637,16 +644,18 @@ pref_ClearUserPref(PLDHashTable *table, 
         pref_DoCallback(pref->key);
     }
     return nextOp;
 }
 
 nsresult
 PREF_ClearAllUserPrefs()
 {
+    NS_ASSERTION(NS_IsMainThread(),
+                 "pref hashtable is main thread only");
     if (!gHashTable.ops)
         return NS_ERROR_NOT_INITIALIZED;
 
     PL_DHashTableEnumerate(&gHashTable, pref_ClearUserPref, nullptr);
 
     gDirty = true;
     return NS_OK;
 }
@@ -711,27 +720,31 @@ static void pref_SetValue(PrefValue* old
         default:
             *oldValue = newValue;
     }
     gDirty = true;
 }
 
 PrefHashEntry* pref_HashTableLookup(const void *key)
 {
+    NS_ASSERTION(NS_IsMainThread(),
+                 "pref hashtable is main thread only");
     PrefHashEntry* result =
         static_cast<PrefHashEntry*>(PL_DHashTableOperate(&gHashTable, key, PL_DHASH_LOOKUP));
 
     if (PL_DHASH_ENTRY_IS_FREE(result))
         return nullptr;
 
     return result;
 }
 
 nsresult pref_HashPref(const char *key, PrefValue value, PrefType type, uint32_t flags)
 {
+    NS_ASSERTION(NS_IsMainThread(),
+                 "pref hashtable is main thread only");
     if (!gHashTable.ops)
         return NS_ERROR_OUT_OF_MEMORY;
 
     PrefHashEntry* pref = static_cast<PrefHashEntry*>(PL_DHashTableOperate(&gHashTable, key, PL_DHASH_ADD));
 
     if (!pref)
         return NS_ERROR_OUT_OF_MEMORY;
 
