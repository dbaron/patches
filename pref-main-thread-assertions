From: L. David Baron <dbaron@dbaron.org>

Bug 619487 / 980419 - Add assertions for prefs being accessed off the main thread to debug recursion-level assertions that I see after running for a long time.

diff --git a/modules/libpref/prefapi.cpp b/modules/libpref/prefapi.cpp
--- a/modules/libpref/prefapi.cpp
+++ b/modules/libpref/prefapi.cpp
@@ -156,16 +156,18 @@ enum {
     kPrefStickyDefault = 4,
 };
 static nsresult pref_HashPref(const char *key, PrefValue value, PrefType type, uint32_t flags);
 
 #define PREF_HASHTABLE_INITIAL_LENGTH   1024
 
 void PREF_Init()
 {
+    NS_ASSERTION(NS_IsMainThread(),
+                 "pref hashtable is main thread only");
     if (!gHashTable) {
         gHashTable = new PLDHashTable(&pref_HashTableOps,
                                       sizeof(PrefHashEntry),
                                       PREF_HASHTABLE_INITIAL_LENGTH);
 
         PL_INIT_ARENA_POOL(&gPrefNameArena, "PrefNameArena",
                            PREFNAME_ARENA_SIZE);
     }
@@ -189,16 +191,18 @@ void PREF_Cleanup()
     gCallbacks = nullptr;
 
     PREF_CleanupPrefs();
 }
 
 /* Frees up all the objects except the callback list. */
 void PREF_CleanupPrefs()
 {
+    NS_ASSERTION(NS_IsMainThread(),
+                 "pref hashtable is main thread only");
     if (gHashTable) {
         delete gHashTable;
         gHashTable = nullptr;
         PL_FinishArenaPool(&gPrefNameArena);
     }
 }
 
 // note that this appends to aResult, and does not assign!
@@ -569,19 +573,17 @@ nsresult PREF_GetBoolPref(const char *pr
         }
     }
     return rv;
 }
 
 nsresult
 PREF_DeleteBranch(const char *branch_name)
 {
-#ifndef MOZ_B2G
     MOZ_ASSERT(NS_IsMainThread());
-#endif
 
     int len = (int)strlen(branch_name);
 
     if (!gHashTable)
         return NS_ERROR_NOT_INITIALIZED;
 
     /* The following check insures that if the branch name already has a "."
      * at the end, we don't end up with a "..". This fixes an incompatibility
@@ -632,19 +634,17 @@ PREF_ClearUserPref(const char *pref_name
         MakeDirtyCallback();
     }
     return NS_OK;
 }
 
 nsresult
 PREF_ClearAllUserPrefs()
 {
-#ifndef MOZ_B2G
     MOZ_ASSERT(NS_IsMainThread());
-#endif
 
     if (!gHashTable)
         return NS_ERROR_NOT_INITIALIZED;
 
     std::vector<std::string> prefStrings;
     for (auto iter = gHashTable->Iter(); !iter.Done(); iter.Next()) {
         auto pref = static_cast<PrefHashEntry*>(iter.Get());
 
@@ -763,35 +763,31 @@ inInitArray(const char* key)
     const char** list = mozilla::dom::ContentPrefs::GetContentPrefs(&prefsLen);
     return BinarySearchIf(list, 0, prefsLen,
                           StringComparator(key), &found);
 }
 #endif
 
 PrefHashEntry* pref_HashTableLookup(const char *key)
 {
-#ifndef MOZ_B2G
     MOZ_ASSERT(NS_IsMainThread());
-#endif
     MOZ_ASSERT((!XRE_IsContentProcess() || gPhase != START),
                "pref access before commandline prefs set");
     /* If you're hitting this assertion, you've added a pref access to start up.
      * Consider moving it later or add it to the whitelist in ContentPrefs.cpp
      * and get review from a DOM peer
      */
     MOZ_ASSERT((!XRE_IsContentProcess() || gPhase > END_INIT_PREFS || inInitArray(key)),
                "accessing non-init pref before the rest of the prefs are sent");
     return static_cast<PrefHashEntry*>(gHashTable->Search(key));
 }
 
 nsresult pref_HashPref(const char *key, PrefValue value, PrefType type, uint32_t flags)
 {
-#ifndef MOZ_B2G
     MOZ_ASSERT(NS_IsMainThread());
-#endif
 
     if (!gHashTable)
         return NS_ERROR_OUT_OF_MEMORY;
 
     auto pref = static_cast<PrefHashEntry*>(gHashTable->Add(key, fallible));
     if (!pref)
         return NS_ERROR_OUT_OF_MEMORY;
 
