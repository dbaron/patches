From: L. David Baron <dbaron@dbaron.org>

Allow eRestyle_Force{,Descendants} in RuleNodeWithReplacement.

This is fine since the assertion is just checking that we're not calling
RuleNodeWithReplacement in cases when stronger restyling (i.e.,
restyling that does more work) is needed; the new eRestyle_Force and
eRestyle_ForceDescendants flags control whether we restyle at all.

This probably should have been done in bug 931668, but it doesn't
actually show up in our test suite until bug 977991 (or maybe slightly
earlier in bug 1057231 or bug 1058346).

diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1330,17 +1330,19 @@ static const CascadeLevel gCascadeLevels
 
 nsRuleNode*
 nsStyleSet::RuleNodeWithReplacement(Element* aElement,
                                     nsRuleNode* aOldRuleNode,
                                     nsCSSPseudoElements::Type aPseudoType,
                                     nsRestyleHint aReplacements)
 {
   NS_ABORT_IF_FALSE(!(aReplacements & ~(eRestyle_CSSTransitions |
-                                        eRestyle_CSSAnimations)),
+                                        eRestyle_CSSAnimations |
+                                        eRestyle_Force |
+                                        eRestyle_ForceDescendants)),
                     // FIXME: Once bug 931668 lands we'll have a better
                     // way to print these.
                     nsPrintfCString("unexpected replacement bits 0x%lX",
                                     uint32_t(aReplacements)).get());
 
   // FIXME (perf): This should probably not rebuild the whole path, but
   // only the path from the last change in the rule tree, like
   // ReplaceAnimationRule in nsStyleSet.cpp does.  (That could then
