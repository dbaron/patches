From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Allow pseudo-elements for style attribute replacement in RuleNodeWithReplacement.

I confirmed that we're actually using this codepath by manually testing
<input type=color>:  it works with the patch, but if I comment out the
call to nsHTMLCSSStyleSheet::PseudoElementRulesMatching from
nsStyleSet::RuleNodeWithReplacement, then the color swatch breaks, which
proves that we're depending on the code.

diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1928,17 +1928,17 @@ RestyleManager::TryStartingTransition(ns
   }
 
   // Notify the transition manager.  If it starts a transition,
   // it might modify the new style context.
   aPresContext->TransitionManager()->StyleContextChanged(
     aContent->AsElement(), aOldStyleContext, aNewStyleContext);
 }
 
-static inline dom::Element*
+static dom::Element*
 ElementForStyleContext(nsIContent* aParentContent,
                        nsIFrame* aFrame,
                        nsCSSPseudoElements::Type aPseudoType)
 {
   // We don't expect XUL tree stuff here.
   NS_PRECONDITION(aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ||
                   aPseudoType == nsCSSPseudoElements::ePseudo_AnonBox ||
                   aPseudoType < nsCSSPseudoElements::ePseudo_PseudoElementCount,
@@ -1991,16 +1991,32 @@ ElementForStyleContext(nsIContent* aPare
     return aParentContent->AsElement();
   }
 
   MOZ_ASSERT(aFrame->GetContent()->GetParent(),
              "should not have got here for the root element");
   return aFrame->GetContent()->GetParent()->AsElement();
 }
 
+static dom::Element*
+PseudoElementForStyleContext(nsIFrame* aFrame,
+                             nsCSSPseudoElements::Type aPseudoType)
+{
+  if (aPseudoType >= nsCSSPseudoElements::ePseudo_PseudoElementCount) {
+    return nullptr;
+  }
+
+  if (nsCSSPseudoElements::PseudoElementSupportsStyleAttribute(aPseudoType) ||
+      nsCSSPseudoElements::PseudoElementSupportsUserActionState(aPseudoType)) {
+    return aFrame->GetContent()->AsElement();
+  }
+
+  return nullptr;
+}
+
 /**
  * FIXME: Temporary.  Should merge with following function.
  */
 static nsIFrame*
 GetPrevContinuationWithPossiblySameStyle(nsIFrame* aFrame)
 {
   // Account for {ib} splits when looking for "prevContinuation".  In
   // particular, for the first-continuation of a part of an {ib} split
@@ -2953,25 +2969,16 @@ ElementRestyler::RestyleSelf(nsIFrame* a
 
   if (providerFrame != aSelf->GetParent()) {
     // We don't actually know what the parent style context's
     // non-inherited hints were, so assume the worst.
     mParentFrameHintsNotHandledForDescendants =
       nsChangeHint_Hints_NotHandledForDescendants;
   }
 
-  // We don't support using eRestyle_StyleAttribute when pseudo-elements
-  // are involved.  This is mostly irrelevant since style attribute
-  // changes on pseudo-elements are very rare, though it does mean we
-  // don't get the optimization for table elements.
-  if (pseudoType != nsCSSPseudoElements::ePseudo_NotPseudoElement &&
-      (aRestyleHint & eRestyle_StyleAttribute)) {
-    aRestyleHint = (aRestyleHint & ~eRestyle_StyleAttribute) | eRestyle_Self;
-  }
-
   LOG_RESTYLE("parentContext = %p", parentContext);
 
   // do primary context
   nsRefPtr<nsStyleContext> newContext;
   nsIFrame *prevContinuation =
     GetPrevContinuationWithPossiblySameStyle(aSelf);
   nsStyleContext *prevContinuationContext;
   bool copyFromContinuation =
@@ -2999,19 +3006,22 @@ ElementRestyler::RestyleSelf(nsIFrame* a
       newContext =
         styleSet->ReparentStyleContext(oldContext, parentContext, element);
     } else {
       // Use ResolveStyleWithReplacement either for actual replacements
       // or, with no replacements, as a substitute for
       // ReparentStyleContext that rebuilds the path in the rule tree
       // rather than reusing the rule node, as we need to do during a
       // rule tree reconstruct.
+      Element* pseudoElement = PseudoElementForStyleContext(aSelf, pseudoType);
+      MOZ_ASSERT(!element || element != pseudoElement);
       LOG_RESTYLE("resolving style with replacement");
       newContext =
-        styleSet->ResolveStyleWithReplacement(element, parentContext, oldContext,
+        styleSet->ResolveStyleWithReplacement(element, pseudoElement,
+                                              parentContext, oldContext,
                                               aRestyleHint);
     }
   } else if (pseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
     newContext = styleSet->ResolveAnonymousBoxStyle(pseudoTag,
                                                     parentContext);
   }
   else {
     Element* element = ElementForStyleContext(mParentContent, aSelf, pseudoType);
@@ -3043,19 +3053,17 @@ ElementRestyler::RestyleSelf(nsIFrame* a
         }
       } else {
         // Don't expect XUL tree stuff here, since it needs a comparator and
         // all.
         NS_ASSERTION(pseudoType <
                        nsCSSPseudoElements::ePseudo_PseudoElementCount,
                      "Unexpected pseudo type");
         Element* pseudoElement =
-          nsCSSPseudoElements::PseudoElementSupportsStyleAttribute(pseudoType) ||
-          nsCSSPseudoElements::PseudoElementSupportsUserActionState(pseudoType) ?
-            aSelf->GetContent()->AsElement() : nullptr;
+          PseudoElementForStyleContext(aSelf, pseudoType);
         MOZ_ASSERT(element != pseudoElement);
         newContext = styleSet->ResolvePseudoElementStyle(element,
                                                          pseudoType,
                                                          parentContext,
                                                          pseudoElement);
       }
     }
     else {
@@ -3246,19 +3254,22 @@ ElementRestyler::RestyleSelf(nsIFrame* a
     if (!(aRestyleHint & (eRestyle_Self | eRestyle_Subtree))) {
       Element* element = extraPseudoType != nsCSSPseudoElements::ePseudo_AnonBox
                            ? mContent->AsElement() : nullptr;
       if (styleSet->IsInRuleTreeReconstruct()) {
         // Use ResolveStyleWithReplacement as a substitute for
         // ReparentStyleContext that rebuilds the path in the rule tree
         // rather than reusing the rule node, as we need to do during a
         // rule tree reconstruct.
+        Element* pseudoElement =
+          PseudoElementForStyleContext(aSelf, extraPseudoType);
+        MOZ_ASSERT(!element || element != pseudoElement);
         newExtraContext =
-          styleSet->ResolveStyleWithReplacement(element, newContext,
-                                                oldExtraContext,
+          styleSet->ResolveStyleWithReplacement(element, pseudoElement,
+                                                newContext, oldExtraContext,
                                                 nsRestyleHint(0));
       } else {
         newExtraContext =
           styleSet->ReparentStyleContext(oldExtraContext, newContext, element);
       }
     } else if (extraPseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
       newExtraContext = styleSet->ResolveAnonymousBoxStyle(extraPseudoTag,
                                                            newContext);
@@ -3565,17 +3576,17 @@ ElementRestyler::RestyleUndisplayedNodes
     } else if (thisChildHint ||
                styleSet->IsInRuleTreeReconstruct()) {
       // Use ResolveStyleWithReplacement either for actual
       // replacements, or as a substitute for ReparentStyleContext
       // that rebuilds the path in the rule tree rather than reusing
       // the rule node, as we need to do during a rule tree
       // reconstruct.
       undisplayedContext =
-        styleSet->ResolveStyleWithReplacement(element,
+        styleSet->ResolveStyleWithReplacement(element, nullptr,
                                               aParentContext,
                                               undisplayed->mStyle,
                                               thisChildHint);
     } else {
       undisplayedContext =
         styleSet->ReparentStyleContext(undisplayed->mStyle,
                                        aParentContext,
                                        element);
diff --git a/layout/style/nsHTMLCSSStyleSheet.cpp b/layout/style/nsHTMLCSSStyleSheet.cpp
--- a/layout/style/nsHTMLCSSStyleSheet.cpp
+++ b/layout/style/nsHTMLCSSStyleSheet.cpp
@@ -78,30 +78,44 @@ nsHTMLCSSStyleSheet::ElementRulesMatchin
       // Animation restyle (or non-restyle traversal of rules)
       // Now we can walk SMIL overrride style, without triggering transitions.
       rule->RuleMatched();
       aRuleWalker->Forward(rule);
     }
   }
 }
 
+void
+nsHTMLCSSStyleSheet::PseudoElementRulesMatching(Element* aPseudoElement,
+                                                nsCSSPseudoElements::Type
+                                                  aPseudoType,
+                                                nsRuleWalker* aRuleWalker)
+{
+  MOZ_ASSERT(nsCSSPseudoElements::
+               PseudoElementSupportsStyleAttribute(aPseudoType));
+  MOZ_ASSERT(aPseudoElement);
+
+  // just get the one and only style rule from the content's STYLE attribute
+  css::StyleRule* rule = aPseudoElement->GetInlineStyleRule();
+  if (rule) {
+    rule->RuleMatched();
+    aRuleWalker->Forward(rule);
+  }
+}
+
 /* virtual */ void
 nsHTMLCSSStyleSheet::RulesMatching(PseudoElementRuleProcessorData* aData)
 {
   if (nsCSSPseudoElements::PseudoElementSupportsStyleAttribute(aData->mPseudoType)) {
     MOZ_ASSERT(aData->mPseudoElement,
         "If pseudo element is supposed to support style attribute, it must "
         "have a pseudo element set");
 
-    // just get the one and only style rule from the content's STYLE attribute
-    css::StyleRule* rule = aData->mPseudoElement->GetInlineStyleRule();
-    if (rule) {
-      rule->RuleMatched();
-      aData->mRuleWalker->Forward(rule);
-    }
+    PseudoElementRulesMatching(aData->mPseudoElement, aData->mPseudoType,
+                               aData->mRuleWalker);
   }
 }
 
 /* virtual */ void
 nsHTMLCSSStyleSheet::RulesMatching(AnonBoxRuleProcessorData* aData)
 {
 }
 
diff --git a/layout/style/nsHTMLCSSStyleSheet.h b/layout/style/nsHTMLCSSStyleSheet.h
--- a/layout/style/nsHTMLCSSStyleSheet.h
+++ b/layout/style/nsHTMLCSSStyleSheet.h
@@ -45,21 +45,26 @@ public:
   virtual nsRestyleHint
     HasAttributeDependentStyle(AttributeRuleProcessorData* aData) MOZ_OVERRIDE;
   virtual bool MediumFeaturesChanged(nsPresContext* aPresContext) MOZ_OVERRIDE;
   virtual size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf)
     const MOZ_MUST_OVERRIDE MOZ_OVERRIDE;
   virtual size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf)
     const MOZ_MUST_OVERRIDE MOZ_OVERRIDE;
 
-  // Variant of RulesMatching method above that is specific to this
+  // Variants of RulesMatching method above that is specific to this
   // rule processor.
   void ElementRulesMatching(nsPresContext* aPresContext,
                             mozilla::dom::Element* aElement,
                             nsRuleWalker* aRuleWalker);
+  // aPseudoElement here is the content node for the pseudo-element, not
+  // its corresponding real element.
+  void PseudoElementRulesMatching(mozilla::dom::Element* aPseudoElement,
+                                  nsCSSPseudoElements::Type aPseudoType,
+                                  nsRuleWalker* aRuleWalker);
 
   void CacheStyleAttr(const nsAString& aSerialized, MiscContainer* aValue);
   void EvictStyleAttr(const nsAString& aSerialized, MiscContainer* aValue);
   MiscContainer* LookupStyleAttr(const nsAString& aSerialized);
 
 private: 
   ~nsHTMLCSSStyleSheet();
 
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -1387,22 +1387,29 @@ static const CascadeLevel gCascadeLevels
   { nsStyleSet::eOverrideSheet,         true,  false, nsRestyleHint(0) },
   { nsStyleSet::eUserSheet,             true,  false, nsRestyleHint(0) },
   { nsStyleSet::eAgentSheet,            true,  false, nsRestyleHint(0) },
   { nsStyleSet::eTransitionSheet,       false, false, eRestyle_CSSTransitions },
 };
 
 nsRuleNode*
 nsStyleSet::RuleNodeWithReplacement(Element* aElement,
+                                    Element* aPseudoElement,
                                     nsRuleNode* aOldRuleNode,
                                     nsCSSPseudoElements::Type aPseudoType,
                                     nsRestyleHint aReplacements)
 {
   NS_ASSERTION(mBatching == 0, "rule processors out of date");
 
+  MOZ_ASSERT(!aPseudoElement ==
+             (aPseudoType >= nsCSSPseudoElements::ePseudo_PseudoElementCount ||
+              !(nsCSSPseudoElements::PseudoElementSupportsStyleAttribute(aPseudoType) ||
+                nsCSSPseudoElements::PseudoElementSupportsUserActionState(aPseudoType))),
+             "should have aPseudoElement only for certain pseudo elements");
+
   NS_ABORT_IF_FALSE(!(aReplacements & ~(eRestyle_CSSTransitions |
                                         eRestyle_CSSAnimations |
                                         eRestyle_SVGAttrAnimations |
                                         eRestyle_StyleAttribute |
                                         eRestyle_ChangeAnimationPhase |
                                         eRestyle_ChangeAnimationPhaseDescendants |
                                         eRestyle_Force |
                                         eRestyle_ForceDescendants)),
@@ -1410,35 +1417,20 @@ nsStyleSet::RuleNodeWithReplacement(Elem
                     // way to print these.
                     nsPrintfCString("unexpected replacement bits 0x%lX",
                                     uint32_t(aReplacements)).get());
 
   // If we're changing animation phase, we have to reconsider what rules
   // are in these four levels.
   if (aReplacements & (eRestyle_ChangeAnimationPhase |
                        eRestyle_ChangeAnimationPhaseDescendants)) {
-    // Animations are only on elements and on :before and :after
-    // pseudo-elements, so those are the only things we need to consider
-    // when changing animation phase.  Furthermore, the :before and
-    // :after pseudo-elements cannot have style attributes (although
-    // some other pseudo-elements can).  This lets us avoid the problem
-    // that the eRestyle_StyleAttribute case below can't handle
-    // pseudo-elements, but not adding that bit to aReplacements for
-    // pseudo-elements, since we don't need it.
-    if (aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
-      aReplacements |= eRestyle_CSSTransitions |
-                       eRestyle_CSSAnimations |
-                       eRestyle_SVGAttrAnimations |
-                       eRestyle_StyleAttribute;
-    } else if (aPseudoType == nsCSSPseudoElements::ePseudo_before ||
-               aPseudoType == nsCSSPseudoElements::ePseudo_after) {
-      aReplacements |= eRestyle_CSSTransitions |
-                       eRestyle_CSSAnimations |
-                       eRestyle_SVGAttrAnimations;
-    }
+    aReplacements |= eRestyle_CSSTransitions |
+                     eRestyle_CSSAnimations |
+                     eRestyle_SVGAttrAnimations |
+                     eRestyle_StyleAttribute;
   }
 
   // FIXME (perf): This should probably not rebuild the whole path, but
   // only the path from the last change in the rule tree, like
   // ReplaceAnimationRule in nsStyleSet.cpp does.  (That could then
   // perhaps share this code, too?)
   // But if we do that, we'll need to pass whether we are rebuilding the
   // rule tree from ElementRestyler::RestyleSelf to avoid taking that
@@ -1513,30 +1505,34 @@ nsStyleSet::RuleNodeWithReplacement(Elem
         }
         case eRestyle_StyleAttribute: {
           MOZ_ASSERT(aReplacements & (eRestyle_ChangeAnimationPhase |
                                       eRestyle_ChangeAnimationPhaseDescendants),
                      "don't know how to do this level without phase change");
 
           if (!level->mIsImportant) {
             // First time through, we handle the non-!important rule.
-            MOZ_ASSERT(aPseudoType ==
-                         nsCSSPseudoElements::ePseudo_NotPseudoElement,
-                       "this code doesn't know how to replace "
-                       "pseudo-element rules");
             nsHTMLCSSStyleSheet* ruleProcessor =
               static_cast<nsHTMLCSSStyleSheet*>(
                 mRuleProcessors[eStyleAttrSheet].get());
-            if (ruleProcessor &&
-                // check condition we asserted above (belt & braces security)
-                aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
+            if (ruleProcessor) {
               lastScopedRN = ruleWalker.CurrentNode();
-              ruleProcessor->ElementRulesMatching(PresContext(),
-                                                  aElement,
-                                                  &ruleWalker);
+              if (aPseudoType ==
+                    nsCSSPseudoElements::ePseudo_NotPseudoElement) {
+                ruleProcessor->ElementRulesMatching(PresContext(),
+                                                    aElement,
+                                                    &ruleWalker);
+              } else if (aPseudoType <
+                           nsCSSPseudoElements::ePseudo_PseudoElementCount &&
+                         nsCSSPseudoElements::
+                           PseudoElementSupportsStyleAttribute(aPseudoType)) {
+                ruleProcessor->PseudoElementRulesMatching(aPseudoElement,
+                                                          aPseudoType,
+                                                          &ruleWalker);
+              }
               lastStyleAttrRN = ruleWalker.CurrentNode();
               haveImportantStyleAttrRules =
                 !ruleWalker.GetCheckForImportantRules();
             }
           } else {
             // Second time through, we handle the !important rule(s).
             if (haveImportantStyleAttrRules) {
               AddImportantRules(lastStyleAttrRN, lastScopedRN, &ruleWalker);
@@ -1570,33 +1566,36 @@ nsStyleSet::RuleNodeWithReplacement(Elem
                "rules are in incorrect cascading order, "
                "which means we replaced them incorrectly");
 
   return ruleWalker.CurrentNode();
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleWithReplacement(Element* aElement,
+                                        Element* aPseudoElement,
                                         nsStyleContext* aNewParentContext,
                                         nsStyleContext* aOldStyleContext,
                                         nsRestyleHint aReplacements,
                                         uint32_t aFlags)
 {
   nsRuleNode* ruleNode =
-    RuleNodeWithReplacement(aElement, aOldStyleContext->RuleNode(),
+    RuleNodeWithReplacement(aElement, aPseudoElement,
+                            aOldStyleContext->RuleNode(),
                             aOldStyleContext->GetPseudoType(), aReplacements);
 
   nsRuleNode* visitedRuleNode = nullptr;
   nsStyleContext* oldStyleIfVisited = aOldStyleContext->GetStyleIfVisited();
   if (oldStyleIfVisited) {
     if (oldStyleIfVisited->RuleNode() == aOldStyleContext->RuleNode()) {
       visitedRuleNode = ruleNode;
     } else {
       visitedRuleNode =
-        RuleNodeWithReplacement(aElement, oldStyleIfVisited->RuleNode(),
+        RuleNodeWithReplacement(aElement, aPseudoElement,
+                                oldStyleIfVisited->RuleNode(),
                                 oldStyleIfVisited->GetPseudoType(),
                                 aReplacements);
     }
   }
 
   uint32_t flags = eNoFlags;
   if (aOldStyleContext->IsLinkContext()) {
     flags |= eIsLink;
@@ -1649,23 +1648,30 @@ nsStyleSet::ResolveStyleWithReplacement(
                     elementForAnimation, flags);
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ResolveStyleWithoutAnimation(dom::Element* aTarget,
                                          nsStyleContext* aStyleContext,
                                          nsRestyleHint aWhichToRemove)
 {
+#ifdef DEBUG
+  nsCSSPseudoElements::Type pseudoType = aStyleContext->GetPseudoType();
+#endif
+  MOZ_ASSERT(pseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ||
+             pseudoType == nsCSSPseudoElements::ePseudo_before ||
+             pseudoType == nsCSSPseudoElements::ePseudo_after,
+             "unexpected type for animations");
   RestyleManager* restyleManager = PresContext()->RestyleManager();
 
   bool oldSkipAnimationRules = restyleManager->SkipAnimationRules();
   restyleManager->SetSkipAnimationRules(true);
 
   nsRefPtr<nsStyleContext> result =
-    ResolveStyleWithReplacement(aTarget, aStyleContext->GetParent(),
+    ResolveStyleWithReplacement(aTarget, nullptr, aStyleContext->GetParent(),
                                 aStyleContext, aWhichToRemove,
                                 eSkipStartingAnimations);
 
   restyleManager->SetSkipAnimationRules(oldSkipAnimationRules);
 
   return result.forget();
 }
 
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -134,16 +134,17 @@ class nsStyleSet
   // described by aReplacements, but otherwise maintaining the status
   // quo.
   enum {
     // flags for paramete below
     eSkipStartingAnimations = (1<<0),
   };
   already_AddRefed<nsStyleContext>
   ResolveStyleWithReplacement(mozilla::dom::Element* aElement,
+                              mozilla::dom::Element* aPseudoElement,
                               nsStyleContext* aNewParentContext,
                               nsStyleContext* aOldStyleContext,
                               nsRestyleHint aReplacements,
                               uint32_t aFlags = 0);
 
   // Resolve style by returning a style context with the animation data
   // removed.  It is allowable to remove all animation data with
   // eRestyle_ChangeAnimationPhase, or by using any othe hints that
@@ -426,16 +427,17 @@ class nsStyleSet
   // Enumerate all the rules in a way that doesn't care about the order
   // of the rules and break out if the enumeration is halted.
   void WalkRuleProcessors(nsIStyleRuleProcessor::EnumFunc aFunc,
                           ElementDependentRuleProcessorData* aData,
                           bool aWalkAllXBLStylesheets);
 
   // Helper for ResolveStyleWithReplacement
   nsRuleNode* RuleNodeWithReplacement(mozilla::dom::Element* aElement,
+                                      mozilla::dom::Element* aPseudoElement,
                                       nsRuleNode* aOldRuleNode,
                                       nsCSSPseudoElements::Type aPseudoType,
                                       nsRestyleHint aReplacements);
 
   /**
    * Bit-flags that can be passed to GetContext() in its parameter 'aFlags'.
    */
   enum {
