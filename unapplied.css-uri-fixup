From: Ben Karel <eschew@gmail.com>, L. David Baron <dbaron@dbaron.org>

Bug 115107 - Fixup URIs in CSS style sheets during "Save Page As, Complete" by serializing the style sheets from our data structures and performing URI fixup on URIs in them.

diff --git a/dom/base/nsIDocumentEncoder.idl b/dom/base/nsIDocumentEncoder.idl
--- a/dom/base/nsIDocumentEncoder.idl
+++ b/dom/base/nsIDocumentEncoder.idl
@@ -38,35 +38,44 @@
 
 #include "nsISupports.idl"
 
 interface nsIDOMDocument;
 interface nsIDOMRange;
 interface nsISelection;
 interface nsIDOMNode;
 interface nsIOutputStream;
+interface nsIURI;
 
-[scriptable, uuid(3c556e41-0f73-4e1d-b724-1474884fe2e3)]
-interface nsIDocumentEncoderNodeFixup : nsISupports
+[scriptable, uuid(24cf5707-3805-4b65-a85d-ea80f5665659)]
+interface nsIDocumentEncoderFixup : nsISupports
 {
   /**
    * Create a fixed up version of a node. This method is called before
    * each node in a document is about to be persisted. The implementor
    * may return a new node with fixed up attributes or null. If null is
    * returned the node should be used as-is.
    * @param aNode Node to fixup.
    * @param [OUT] aSerializeCloneKids True if the document encoder should
    * apply recursive serialization to the children of the fixed up node
    * instead of the children of the original node.
    * @return The resulting fixed up node.
    */
   nsIDOMNode fixupNode(in nsIDOMNode aNode, out boolean aSerializeCloneKids);
+  /**
+   * Determine better URI to use when persisting linked content.
+   * @param aURI URI to fixup.
+   * @param aMimeType A mime type to use as a suggestion for determining
+     the file extension to use when persisting aURI.
+   * @return A string to be serialized in place of aURI's spec.
+   */
+  AString fixupURI(in nsIURI aURI, in ACString aMimeType);
 };
 
-[scriptable, uuid(f85c5a20-258d-11db-a98b-0800200c9a66)]
+[scriptable, uuid(ba541a86-aa8e-4fc3-b154-29755e6633d4)]
 interface nsIDocumentEncoder : nsISupports
 {
   // Output methods flag bits. There are a frightening number of these,
   // because everyone wants something a little bit different
    
 
   /** 
    * Output only the selection (as opposed to the whole document).
@@ -304,10 +313,10 @@ interface nsIDocumentEncoder : nsISuppor
    */
   AString encodeToStringWithContext( out AString aContextString,
                                      out AString aInfoString);
 
   /**
    * Set the fixup object associated with node persistence.
    * @param aFixup The fixup object.
    */
-  void setNodeFixup(in nsIDocumentEncoderNodeFixup aFixup);
+  void setFixup(in nsIDocumentEncoderFixup aFixup);
 };
diff --git a/dom/base/nsAttrValue.cpp b/dom/base/nsAttrValue.cpp
--- a/dom/base/nsAttrValue.cpp
+++ b/dom/base/nsAttrValue.cpp
@@ -432,17 +432,17 @@ nsAttrValue::ToString(nsAString& aResult
       break;
     }
     case eCSSStyleRule:
     {
       aResult.Truncate();
       MiscContainer *container = GetMiscContainer();
       nsCSSDeclaration* decl = container->mCSSStyleRule->GetDeclaration();
       if (decl) {
-        decl->ToString(aResult);
+        decl->ToString(nullptr, aResult);
       }
 
       break;
     }
 #ifdef MOZ_SVG
     case eSVGValue:
     {
       GetMiscContainer()->mSVGValue->GetValueString(aResult);
diff --git a/dom/base/nsDocumentEncoder.cpp b/dom/base/nsDocumentEncoder.cpp
--- a/dom/base/nsDocumentEncoder.cpp
+++ b/dom/base/nsDocumentEncoder.cpp
@@ -124,17 +124,17 @@ protected:
   nsCOMPtr<nsIDocument>          mDocument;
   nsCOMPtr<nsISelection>         mSelection;
   nsCOMPtr<nsIDOMRange>          mRange;
   nsCOMPtr<nsIDOMNode>           mNode;
   nsCOMPtr<nsIOutputStream>      mStream;
   nsCOMPtr<nsIContentSerializer> mSerializer;
   nsCOMPtr<nsIUnicodeEncoder>    mUnicodeEncoder;
   nsCOMPtr<nsIDOMNode>           mCommonParent;
-  nsCOMPtr<nsIDocumentEncoderNodeFixup> mNodeFixup;
+  nsCOMPtr<nsIDocumentEncoderFixup> mFixup;
   nsCOMPtr<nsICharsetConverterManager> mCharsetConverterManager;
 
   nsString          mMimeType;
   nsCString         mCharset;
   PRUint32          mFlags;
   PRUint32          mWrapColumn;
   PRUint32          mStartDepth;
   PRUint32          mEndDepth;
@@ -269,19 +269,19 @@ nsDocumentEncoder::SerializeNodeStart(ns
 {
   PRUint16 type;
 
   nsCOMPtr<nsIDOMNode> node;
 
   // Caller didn't do fixup, so we'll do it ourselves
   if (!aOriginalNode) {
     aOriginalNode = aNode;
-    if (mNodeFixup) { 
+    if (mFixup) { 
       bool dummy;
-      mNodeFixup->FixupNode(aNode, &dummy, getter_AddRefs(node));
+      mFixup->FixupNode(aNode, &dummy, getter_AddRefs(node));
     }
   }
 
   // Either there was no fixed-up node,
   // or the caller did fixup themselves and aNode is already fixed
   if (!node)
     node = aNode;
 
@@ -353,18 +353,18 @@ nsresult
 nsDocumentEncoder::SerializeToStringRecursive(nsIDOMNode* aNode,
                                               nsAString& aStr,
                                               bool aDontSerializeRoot)
 {
   nsresult rv = NS_OK;
   bool serializeClonedChildren = false;
   nsCOMPtr<nsIDOMNode> maybeFixedNode;
   
-  if (mNodeFixup)
-    mNodeFixup->FixupNode(aNode, &serializeClonedChildren, getter_AddRefs(maybeFixedNode));
+  if (mFixup)
+    mFixup->FixupNode(aNode, &serializeClonedChildren, getter_AddRefs(maybeFixedNode));
 
   if (!maybeFixedNode)
     maybeFixedNode = aNode;
 
   if (!aDontSerializeRoot) {
     rv = SerializeNodeStart(maybeFixedNode, 0, -1, aStr, aNode);
     NS_ENSURE_SUCCESS(rv, rv);
   }
@@ -1024,19 +1024,19 @@ NS_IMETHODIMP
 nsDocumentEncoder::EncodeToStringWithContext(nsAString& aContextString,
                                              nsAString& aInfoString,
                                              nsAString& aEncodedString)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
-nsDocumentEncoder::SetNodeFixup(nsIDocumentEncoderNodeFixup *aFixup)
+nsDocumentEncoder::SetFixup(nsIDocumentEncoderFixup *aFixup)
 {
-  mNodeFixup = aFixup;
+  mFixup = aFixup;
   return NS_OK;
 }
 
 
 nsresult NS_NewTextEncoder(nsIDocumentEncoder** aResult); // make mac compiler happy
 
 nsresult
 NS_NewTextEncoder(nsIDocumentEncoder** aResult)
diff --git a/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp b/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp
--- a/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp
+++ b/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp
@@ -59,16 +59,17 @@
 #include "nsEscape.h"
 #include "nsUnicharUtils.h"
 #include "nsIStringEnumerator.h"
 #include "nsCRT.h"
 #include "nsSupportsArray.h"
 #include "nsInt64.h"
 #include "nsContentCID.h"
 #include "nsStreamUtils.h"
+#include "nsIConverterOutputStream.h"
 
 #include "nsCExternalHandlerService.h"
 
 #include "nsIURL.h"
 #include "nsIFileURL.h"
 #include "nsIDocument.h"
 #include "nsIDOMDocument.h"
 #include "nsIDOMXMLDocument.h"
@@ -104,16 +105,25 @@
 #include "nsIDOMHTMLInputElement.h"
 #include "nsIDOMHTMLEmbedElement.h"
 #include "nsIDOMHTMLObjectElement.h"
 #include "nsIDOMHTMLAppletElement.h"
 #include "nsIDOMHTMLOptionElement.h"
 #include "nsIDOMHTMLTextAreaElement.h"
 #include "nsIDOMHTMLDocument.h"
 #include "nsIDOMText.h"
+
+#include "nsIDOMHTMLStyleElement.h"
+#include "nsIStyleSheet.h"
+#include "nsIDOMCSSStyleSheet.h"
+#include "nsICSSStyleSheet.h"
+#include "nsIDOMLinkStyle.h"
+#include "nsIDOMStyleSheet.h"
+#include "nsIStyleSheetLinkingElement.h"
+
 #ifdef MOZ_SVG
 #include "nsIDOMSVGImageElement.h"
 #include "nsIDOMSVGScriptElement.h"
 #endif // MOZ_SVG
 
 #include "nsIImageLoadingContent.h"
 
 #include "ftpCore.h"
@@ -150,16 +160,19 @@ struct URIData
     bool mDataPathIsRelative;
     bool mNeedsFixup;
     nsString mFilename;
     nsString mSubFrameExt;
     nsCOMPtr<nsIURI> mFile;
     nsCOMPtr<nsIURI> mDataPath;
     nsCString mRelativePathToData;
     nsCString mCharset;
+    // mContents and mContentsType should be set together.
+    nsString mContents; // possibly pre-serialized file contents
+    nsCString mContentsType; // possibly a mime type, to get file extension
 };
 
 // Information about the output stream
 struct OutputData
 {
     nsCOMPtr<nsIURI> mFile;
     nsCOMPtr<nsIURI> mOriginalLocation;
     nsCOMPtr<nsIOutputStream> mStream;
@@ -236,16 +249,18 @@ nsWebBrowserPersist::nsWebBrowserPersist
     mStartSaving(false),
     mReplaceExisting(true),
     mSerializingOutput(false),
     mPersistFlags(kDefaultPersistFlags),
     mPersistResult(NS_OK),
     mWrapColumn(72),
     mEncodingFlags(0)
 {
+    mFixup = new nsEncoderFixup;
+    mFixup->mWebBrowserPersist = this;
 }
 
 nsWebBrowserPersist::~nsWebBrowserPersist()
 {
     Cleanup();
 }
 
 //*****************************************************************************
@@ -1681,19 +1696,16 @@ nsresult nsWebBrowserPersist::SaveDocume
                     mCurrentBaseURI->GetSpec(url);
                     localFileOS2->SetFileSource(url);
                 }
 #endif
             }
         }
 
         mCurrentThingsToPersist = oldThingsToPersist;
-        mCurrentDataPath = oldDataPath;
-        mCurrentDataPathIsRelative = oldDataPathIsRelative;
-        mCurrentRelativePathToData = oldCurrentRelativePathToData;
     }
     else
     {
         // Set the document base to ensure relative links still work
         SetDocumentBase(aDocument, mCurrentBaseURI);
 
         // Get the content type to save with
         nsXPIDLString realContentType;
@@ -1740,35 +1752,30 @@ nsresult nsWebBrowserPersist::SaveDocume
             rv = NS_ERROR_FAILURE;
             break;
         }
 
         mCurrentBaseURI = docData->mBaseURI;
         mCurrentCharset = docData->mCharset;
 
         // Save the document, fixing it up with the new URIs as we do
-        
-        nsEncoderNodeFixup *nodeFixup;
-        nodeFixup = new nsEncoderNodeFixup;
-        if (nodeFixup)
-            nodeFixup->mWebBrowserPersist = this;
 
         // Get the content type
         nsXPIDLString realContentType;
         GetDocEncoderContentType(docData->mDocument,
             !mContentType.IsEmpty() ? mContentType.get() : nullptr,
             getter_Copies(realContentType));
 
         nsAutoCString contentType; contentType.AssignWithConversion(realContentType.get());
         nsAutoCString charType; // Empty
 
         // Save the document, fixing up the links as it goes out
         rv = SaveDocumentWithFixup(
             docData->mDocument,
-            nodeFixup,
+            mFixup,
             docData->mFile,
             mReplaceExisting,
             contentType,
             charType,
             mEncodingFlags);
 
         if (NS_FAILED(rv))
             break;
@@ -1790,16 +1797,19 @@ nsresult nsWebBrowserPersist::SaveDocume
         }
     }
 
     if (!mSerializingOutput)
     {
         mDocList.Clear();
     }
 
+    // In case anything was queued for persisting from node/URI fixup...
+    rv = SaveGatheredURIs(nullptr);
+
     return rv;
 }
 
 void nsWebBrowserPersist::Cleanup()
 {
     mURIMap.Enumerate(EnumCleanupURIMap, this);
     mURIMap.Reset();
     mOutputMap.Enumerate(EnumCleanupOutputMap, this);
@@ -2174,16 +2184,30 @@ nsWebBrowserPersist::CalculateAndAppendF
     // Get the content type from the MIME service
     if (contentType.IsEmpty())
     {
         nsCOMPtr<nsIURI> uri;
         aChannel->GetOriginalURI(getter_AddRefs(uri));
         mMIMEService->GetTypeFromURI(uri, contentType);
     }
 
+    return AppendFileExt(contentType, aURI, aOriginalURIWithExtension);
+}
+
+nsresult
+nsWebBrowserPersist::AppendFileExt(nsACString& contentType, nsIURI *aURI, nsIURI *aOriginalURIWithExtension)
+{
+    nsresult rv;
+
+    if (!mMIMEService)
+    {
+        mMIMEService = do_GetService(NS_MIMESERVICE_CONTRACTID, &rv);
+        NS_ENSURE_TRUE(mMIMEService, NS_ERROR_FAILURE);
+    }
+
     // Append the extension onto the file
     if (!contentType.IsEmpty())
     {
         nsCOMPtr<nsIMIMEInfo> mimeInfo;
         mMIMEService->GetFromTypeAndExtension(
             contentType, EmptyCString(), getter_AddRefs(mimeInfo));
 
         nsCOMPtr<nsILocalFile> localFile;
@@ -2206,22 +2230,25 @@ nsWebBrowserPersist::CalculateAndAppendF
             }
 
             // Append the mime file extension
             nsAutoCString fileExt;
             if (!hasExtension)
             {
                 // Test if previous extension is acceptable
                 nsCOMPtr<nsIURL> oldurl(do_QueryInterface(aOriginalURIWithExtension));
-                NS_ENSURE_TRUE(oldurl, NS_ERROR_FAILURE);
-                oldurl->GetFileExtension(fileExt);
+                          
                 bool useOldExt = false;
-                if (!fileExt.IsEmpty())
-                {
-                    mimeInfo->ExtensionExists(fileExt, &useOldExt);
+                if (oldurl)
+                {
+                  oldurl->GetFileExtension(fileExt);
+                  if (!fileExt.IsEmpty())
+                  {
+                      mimeInfo->ExtensionExists(fileExt, &useOldExt);
+                  }
                 }
 
                 // can't use old extension so use primary extension
                 if (!useOldExt)
                 {
                     mimeInfo->GetPrimaryExtension(fileExt);
                 } 
 
@@ -2517,17 +2544,38 @@ nsWebBrowserPersist::EnumPersistURIs(nsH
 
     // Make a URI to save the data to
     nsCOMPtr<nsIURI> fileAsURI;
     rv = data->mDataPath->Clone(getter_AddRefs(fileAsURI));
     NS_ENSURE_SUCCESS(rv, false);
     rv = pthis->AppendPathToURI(fileAsURI, data->mFilename);
     NS_ENSURE_SUCCESS(rv, false);
 
-    rv = pthis->SaveURIInternal(uri, nullptr, nullptr, nullptr, nullptr, fileAsURI, true);
+    // Common case: no pre-serialized content, so persist by downloading from URL
+    if (data->mContents.IsEmpty())
+        rv = pthis->SaveURIInternal(uri, nullptr, nullptr, nullptr, nullptr, fileAsURI, true);
+    else {
+        // flush string to stream
+        nsCOMPtr<nsIOutputStream> outputStream;
+        rv = pthis->MakeOutputStream(fileAsURI, getter_AddRefs(outputStream));
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        nsCOMPtr<nsIConverterOutputStream> cos
+          = do_CreateInstance("@mozilla.org/intl/converter-output-stream;1", &rv);
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        rv = cos->Init(outputStream, nullptr, 0, 0);
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        bool wroteFullString = false;
+        cos->WriteString(data->mContents, &wroteFullString);
+        cos->Flush();
+        outputStream->Flush();
+        cos->Close();
+    }
     // if SaveURIInternal fails, then it will have called EndDownload,
     // which means that |aData| is no longer valid memory.  we MUST bail.
     NS_ENSURE_SUCCESS(rv, false);
 
     if (rv == NS_OK)
     {
         // Store the actual object because once it's persisted this
         // will be fixed up with the right file extension.
@@ -2831,22 +2879,19 @@ nsresult nsWebBrowserPersist::OnWalkDOMN
     if (nodeAsApplet)
     {
         // For an applet, relative URIs are resolved relative to the
         // codebase (which is resolved relative to the base URI).
         nsCOMPtr<nsIURI> oldBase = mCurrentBaseURI;
         nsAutoString codebase;
         nodeAsApplet->GetCodeBase(codebase);
         if (!codebase.IsEmpty()) {
-            nsCOMPtr<nsIURI> baseURI;
-            NS_NewURI(getter_AddRefs(baseURI), codebase,
-                      mCurrentCharset.get(), mCurrentBaseURI);
-            if (baseURI) {
+            nsCOMPtr<nsIURI> baseURI = ResolveSpec(codebase);
+            if (baseURI)
                 mCurrentBaseURI = baseURI;
-            }
         }
 
         URIData *archiveURIData = nullptr;
         StoreURIAttribute(aNode, "archive", true, &archiveURIData);
         // We only store 'code' locally if there is no 'archive',
         // otherwise we assume the archive file(s) contains it (bug 430283).
         if (!archiveURIData)
             StoreURIAttribute(aNode, "code");
@@ -2883,17 +2928,64 @@ nsresult nsWebBrowserPersist::OnWalkDOMN
                     ++current;
                 } while (current != end && !nsCRT::IsAsciiSpace(*current));
 
                 // Store the link for fix up if it says "stylesheet"
                 if (Substring(startWord, current)
                         .LowerCaseEqualsLiteral("stylesheet"))
                 {
                     StoreURIAttribute(aNode, "href");
-                    return NS_OK;
+                    
+                    // Instead of just (re-)downloading the linked file directly,
+                    // we want to let the link's stylesheet serialize itself
+                    // (with URI fixup from us) to a string.
+
+                    nsCOMPtr<nsIDOMLinkStyle> domlink = do_QueryInterface(aNode);
+                    if (!domlink) return NS_OK;
+
+                    nsCOMPtr<nsIDOMStyleSheet> domss;
+                    domlink->GetSheet(getter_AddRefs(domss));
+                    if (!domss) return NS_OK; // No DOM stylesheet means nothing to serialize 
+                    
+                    nsCOMPtr<nsICSSStyleSheet> ss = do_QueryInterface(domss);
+                    if (!ss) return NS_OK;
+
+                    // Set the node's file contents in the URI map
+                    nsAutoString href;
+                    nodeAsLink->GetHref(href);
+                    URIData *data = GetDataForURI(href);
+                    if (!data) return NS_OK;
+
+                    ss->Serialize(data->mContents, mFixup);
+
+                    // Literal type OK if we only serialize CSS stylesheets.
+                    // This MIME type will eventually be used to get the
+                    // right extension when we need a filename to return
+                    // to serialized content through FixupURI.
+                    data->mContentsType.AssignLiteral("text/css");
+
+                    // We won't get a chance to call FixupURI before we
+                    // persist the link (from SaveGatheredURIs) so instead,
+                    // since we know the proper file extension already,
+                    // we'll just append it by hand.
+                    // Yes, this is a hack, but it's easier than tearing
+                    // apart and rewriting all of webbrowserpersist...
+                    nsXPIDLString ext;
+                    GetExtensionForContentType(NS_LITERAL_STRING("text/css").get(),
+                                               getter_Copies(ext));
+                    // At this point, data->mFilename has no extension, and we
+                    // need it to have the right extension when it is persisted.
+                    // For downloaded content like images, the extension is
+                    // derived from the channel MIME type and added to the
+                    // filename when it is being downloaded.
+                    // We don't download stylesheets, we fix up their in-memory
+                    // representation and persist that; therefore, we need to
+                    // add the correct extension to the 
+                    data->mFilename.AppendLiteral(".");
+                    data->mFilename.Append(ext);
                 }
                 if (current == end)
                     break;
             }
         }
         return NS_OK;
     }
 
@@ -3193,22 +3285,19 @@ nsWebBrowserPersist::CloneNodeWithFixedU
             nsCOMPtr<nsIDOMHTMLAppletElement> newApplet =
                 do_QueryInterface(*aNodeOut);
             // For an applet, relative URIs are resolved relative to the
             // codebase (which is resolved relative to the base URI).
             nsCOMPtr<nsIURI> oldBase = mCurrentBaseURI;
             nsAutoString codebase;
             nodeAsApplet->GetCodeBase(codebase);
             if (!codebase.IsEmpty()) {
-                nsCOMPtr<nsIURI> baseURI;
-                NS_NewURI(getter_AddRefs(baseURI), codebase,
-                          mCurrentCharset.get(), mCurrentBaseURI);
-                if (baseURI) {
+                nsCOMPtr<nsIURI> baseURI = ResolveSpec(codebase);
+                if (baseURI)
                     mCurrentBaseURI = baseURI;
-                }
             }
             // Unset the codebase too, since we'll correctly relativize the
             // code and archive paths.
             newApplet->RemoveAttribute(NS_LITERAL_STRING("codebase"));
             FixupNodeAttribute(*aNodeOut, "code");
             FixupNodeAttribute(*aNodeOut, "archive");
             // restore the base URI we really want to have
             mCurrentBaseURI = oldBase;
@@ -3224,18 +3313,16 @@ nsWebBrowserPersist::CloneNodeWithFixedU
         {
             // First see if the link represents linked content
             rv = FixupNodeAttribute(*aNodeOut, "href");
             if (NS_FAILED(rv))
             {
                 // Perhaps this link is actually an anchor to related content
                 FixupAnchor(*aNodeOut);
             }
-            // TODO if "type" attribute == "text/css"
-            //        fixup stylesheet
         }
         return rv;
     }
 
     nsCOMPtr<nsIDOMHTMLFrameElement> nodeAsFrame = do_QueryInterface(aNodeIn);
     if (nodeAsFrame)
     {
         rv = GetNodeToFixup(aNodeIn, aNodeOut);
@@ -3325,32 +3412,56 @@ nsWebBrowserPersist::CloneNodeWithFixedU
             nsCOMPtr<nsIDOMHTMLOptionElement> outElt = do_QueryInterface(*aNodeOut);
             bool selected;
             nodeAsOption->GetSelected(&selected);
             outElt->SetDefaultSelected(selected);
         }
         return rv;
     }
 
+    nsCOMPtr<nsIDOMHTMLStyleElement> nodeAsStyle = do_QueryInterface(aNodeIn);
+    if (nodeAsStyle)
+    {
+        rv = GetNodeToFixup(aNodeIn, aNodeOut);
+        if (NS_SUCCEEDED(rv) && *aNodeOut)
+        {
+            // Tell the document encoder to serialize the text child we create below
+            *aSerializeCloneKids = true;
+
+            nsCOMPtr<nsIDOMLinkStyle> domlink(do_QueryInterface(aNodeIn));
+            nsCOMPtr<nsIDOMStyleSheet> domss;
+            if (!domlink)
+              return NS_OK;
+            domlink->GetSheet(getter_AddRefs(domss));
+            nsCOMPtr<nsICSSStyleSheet> ss(do_QueryInterface(domss));
+       
+            nsAutoString content;
+            ss->Serialize(content, mFixup);
+
+            nsCOMPtr<nsIDOM3Node> out = do_QueryInterface(*aNodeOut);
+            if (!out)
+              return NS_ERROR_FAILURE;
+            out->SetTextContent(content);
+        }
+    }
+
     return NS_OK;
 }
 
 nsresult
 nsWebBrowserPersist::StoreURI(
     const char *aURI, bool aNeedsPersisting, URIData **aData)
 {
     NS_ENSURE_ARG_POINTER(aURI);
 
     nsCOMPtr<nsIURI> uri;
     nsresult rv = NS_NewURI(getter_AddRefs(uri),
                             nsDependentCString(aURI),
                             mCurrentCharset.get(),
                             mCurrentBaseURI);
-    NS_ENSURE_SUCCESS(rv, rv);
-
     return StoreURI(uri, aNeedsPersisting, aData);
 }
 
 nsresult
 nsWebBrowserPersist::StoreURI(
     nsIURI *aURI, bool aNeedsPersisting, URIData **aData)
 {
     NS_ENSURE_ARG_POINTER(aURI);
@@ -3416,87 +3527,121 @@ nsWebBrowserPersist::StoreURIAttributeNS
             NS_ConvertUTF16toUTF8 oldCValue(oldValue);
             return StoreURI(oldCValue.get(), aNeedsPersisting, aData);
         }
     }
 
     return NS_OK;
 }
 
-nsresult
-nsWebBrowserPersist::FixupURI(nsAString &aURI)
+already_AddRefed<nsIURI>
+nsWebBrowserPersist::ResolveSpec(nsAString& aSpec)
+{
+    nsIURI *result = nullptr;
+    nsresult rv = NS_NewURI(&result, aSpec, 
+                            mCurrentCharset.get(), mCurrentBaseURI);
+    return result;
+}
+
+URIData*
+nsWebBrowserPersist::GetDataForURI(nsAString &aURI)
 {
     // get the current location of the file (absolutized)
-    nsCOMPtr<nsIURI> uri;
-    nsresult rv = NS_NewURI(getter_AddRefs(uri), aURI, 
-                            mCurrentCharset.get(), mCurrentBaseURI);
-    NS_ENSURE_SUCCESS(rv, rv);
+    nsCOMPtr<nsIURI> uri = ResolveSpec(aURI);
+    return GetDataForURI(uri);
+}
+
+URIData*
+nsWebBrowserPersist::GetDataForURI(nsIURI* aURI)
+{
     nsAutoCString spec;
-    rv = uri->GetSpec(spec);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    // Search for the URI in the map and replace it with the local file
+    nsresult rv = aURI->GetSpec(spec);
+    NS_ENSURE_SUCCESS(rv, nullptr);
+
     nsCStringKey key(spec.get());
     if (!mURIMap.Exists(&key))
     {
-        return NS_ERROR_FAILURE;
-    }
-    URIData *data = (URIData *) mURIMap.Get(&key);
-    if (!data->mNeedsFixup)
-    {
-        return NS_OK;
-    }
-    nsCOMPtr<nsIURI> fileAsURI;
-    if (data->mFile)
-    {
-        rv = data->mFile->Clone(getter_AddRefs(fileAsURI)); 
-        NS_ENSURE_SUCCESS(rv, rv);
-    }
-    else
-    {
-        rv = data->mDataPath->Clone(getter_AddRefs(fileAsURI));
-        NS_ENSURE_SUCCESS(rv, rv);
-        rv = AppendPathToURI(fileAsURI, data->mFilename);
-        NS_ENSURE_SUCCESS(rv, rv);
+        return nullptr;
+    }
+    return (URIData *) mURIMap.Get(&key);
+}
+
+nsresult
+nsWebBrowserPersist::FixupURI(nsAString &aSpec)
+{
+    URIData *data = GetDataForURI(aSpec);
+    return FixupURIData(data, nullptr, aSpec);
+}
+
+nsresult
+nsWebBrowserPersist::FixupURIData(URIData *aData, nsIURI *aOriginalURI, nsAString &aSpec)
+{
+    nsresult rv;
+
+    if (!aData)
+        return NS_ERROR_FAILURE;
+
+    if (!aData->mNeedsFixup)
+        return NS_OK;
+
+    // Replace the URI from the map with the local file
+    nsCOMPtr<nsIURI> fileAsURI;
+    if (aData->mFile)
+    {
+        rv = aData->mFile->Clone(getter_AddRefs(fileAsURI)); 
+        NS_ENSURE_SUCCESS(rv, rv);
+    }
+    else
+    {
+        rv = aData->mDataPath->Clone(getter_AddRefs(fileAsURI));
+        NS_ENSURE_SUCCESS(rv, rv);
+        rv = AppendPathToURI(fileAsURI, aData->mFilename);
+        NS_ENSURE_SUCCESS(rv, rv);
+        // This doesn't affect the the downloaded file name, it only affects the
+        // out string
+        if (!aData->mContentsType.IsEmpty()) {
+          rv = AppendFileExt(aData->mContentsType, fileAsURI, aOriginalURI);
+          NS_ENSURE_SUCCESS(rv, rv);
+        }
     }
     nsAutoString newValue;
 
     // remove username/password if present
     fileAsURI->SetUserPass(EmptyCString());
 
     // reset node attribute 
     // Use relative or absolute links
-    if (data->mDataPathIsRelative)
+    if (aData->mDataPathIsRelative)
     {
         nsCOMPtr<nsIURL> url(do_QueryInterface(fileAsURI));
         if (!url)
           return NS_ERROR_FAILURE;
           
         nsAutoCString filename;
         url->GetFileName(filename);
 
-        nsAutoCString rawPathURL(data->mRelativePathToData);
+        nsAutoCString rawPathURL(aData->mRelativePathToData);
         rawPathURL.Append(filename);
 
         nsAutoCString buf;
         AppendUTF8toUTF16(NS_EscapeURL(rawPathURL, esc_FilePath, buf),
                           newValue);
     }
     else
     {
         nsAutoCString fileurl;
         fileAsURI->GetSpec(fileurl);
         AppendUTF8toUTF16(fileurl, newValue);
     }
-    if (data->mIsSubFrame)
-    {
-        newValue.Append(data->mSubFrameExt);
-    }
-
-    aURI = newValue;
+    if (aData->mIsSubFrame)
+    {
+        newValue.Append(aData->mSubFrameExt);
+    }
+
+    aSpec = newValue;
     return NS_OK;
 }
 
 nsresult
 nsWebBrowserPersist::FixupNodeAttributeNS(nsIDOMNode *aNode,
                                         const char *aNamespaceURI,
                                         const char *aAttribute)
 {
@@ -3520,16 +3665,18 @@ nsWebBrowserPersist::FixupNodeAttributeN
     if (attrNode)
     {
         nsString uri;
         attrNode->GetNodeValue(uri);
         rv = FixupURI(uri);
         if (NS_SUCCEEDED(rv))
         {
             attrNode->SetNodeValue(uri);
+        } else {
+            attrNode = nullptr; // URI not in map?
         }
     }
 
     return rv;
 }
 
 nsresult
 nsWebBrowserPersist::FixupAnchor(nsIDOMNode *aNode)
@@ -3722,17 +3869,17 @@ nsWebBrowserPersist::CreateChannelFromUR
 
     rv = (*aChannel)->SetNotificationCallbacks(static_cast<nsIInterfaceRequestor *>(this));
     NS_ENSURE_SUCCESS(rv, rv);
     return NS_OK;
 } 
 
 nsresult
 nsWebBrowserPersist::SaveDocumentWithFixup(
-    nsIDOMDocument *aDocument, nsIDocumentEncoderNodeFixup *aNodeFixup,
+    nsIDOMDocument *aDocument, nsIDocumentEncoderFixup *aNodeFixup,
     nsIURI *aFile, bool aReplaceExisting, const nsACString &aFormatType,
     const nsCString &aSaveCharset, PRUint32 aFlags)
 {
     NS_ENSURE_ARG_POINTER(aFile);
     
     nsresult  rv = NS_OK;
     nsCOMPtr<nsILocalFile> localFile;
     GetLocalFileFromURI(aFile, getter_AddRefs(localFile));
@@ -3766,17 +3913,17 @@ nsWebBrowserPersist::SaveDocumentWithFix
 
     NS_ConvertASCIItoUTF16 newContentType(aFormatType);
     rv = encoder->Init(aDocument, newContentType, aFlags);
     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
 
     mTargetBaseURI = aFile;
 
     // Set the node fixup callback
-    encoder->SetNodeFixup(aNodeFixup);
+    encoder->SetFixup(aNodeFixup);
 
     if (mWrapColumn && (aFlags & ENCODE_FLAGS_WRAP))
         encoder->SetWrapColumn(mWrapColumn);
 
     nsAutoCString charsetStr(aSaveCharset);
     if (charsetStr.IsEmpty())
     {
         nsCOMPtr<nsIDocument> doc = do_QueryInterface(aDocument);
@@ -3851,25 +3998,30 @@ nsWebBrowserPersist::MakeAndStoreLocalFi
     nsString filename;
     rv = MakeFilenameFromURI(aURI, filename);
     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
 
     // Store the file name
     data = new URIData;
     NS_ENSURE_TRUE(data, NS_ERROR_OUT_OF_MEMORY);
 
+    nsString contents;
+    nsCString contentsType;
+
     data->mNeedsPersisting = aNeedsPersisting;
     data->mNeedsFixup = true;
     data->mFilename = filename;
     data->mSaved = false;
     data->mIsSubFrame = false;
     data->mDataPath = mCurrentDataPath;
     data->mDataPathIsRelative = mCurrentDataPathIsRelative;
     data->mRelativePathToData = mCurrentRelativePathToData;
     data->mCharset = mCurrentCharset;
+    data->mContents = contents;
+    data->mContentsType = contentsType;
 
     if (aNeedsPersisting)
         mCurrentThingsToPersist++;
 
     mURIMap.Put(&key, data);
     if (aData)
     {
         *aData = data;
@@ -4137,37 +4289,28 @@ void nsWebBrowserPersist::SetApplyConver
                 encChannel->SetApplyConversion(applyConversion);
         }
     }
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 
 
-nsEncoderNodeFixup::nsEncoderNodeFixup() : mWebBrowserPersist(nullptr)
-{
-}
-
-
-nsEncoderNodeFixup::~nsEncoderNodeFixup()
-{
-}
-
-
-NS_IMPL_ADDREF(nsEncoderNodeFixup)
-NS_IMPL_RELEASE(nsEncoderNodeFixup)
-
-
-NS_INTERFACE_MAP_BEGIN(nsEncoderNodeFixup)
-    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDocumentEncoderNodeFixup)
-    NS_INTERFACE_MAP_ENTRY(nsIDocumentEncoderNodeFixup)
-NS_INTERFACE_MAP_END
-
-
-NS_IMETHODIMP nsEncoderNodeFixup::FixupNode(
+nsEncoderFixup::nsEncoderFixup() : mWebBrowserPersist(nullptr)
+{
+}
+
+
+nsEncoderFixup::~nsEncoderFixup()
+{
+}
+
+NS_IMPL_ISUPPORTS(nsEncoderFixup, nsIDocumentEncoderFixup)
+
+NS_IMETHODIMP nsEncoderFixup::FixupNode(
     nsIDOMNode *aNode, bool *aSerializeCloneKids, nsIDOMNode **aOutNode)
 {
     NS_ENSURE_ARG_POINTER(aNode);
     NS_ENSURE_ARG_POINTER(aOutNode);
     NS_ENSURE_TRUE(mWebBrowserPersist, NS_ERROR_FAILURE);
 
     *aOutNode = nullptr;
     
@@ -4177,8 +4320,18 @@ NS_IMETHODIMP nsEncoderNodeFixup::FixupN
     if (type == nsIDOMNode::ELEMENT_NODE ||
         type == nsIDOMNode::PROCESSING_INSTRUCTION_NODE)
     {
         return mWebBrowserPersist->CloneNodeWithFixedUpAttributes(aNode, aSerializeCloneKids, aOutNode);
     }
 
     return NS_OK;
 }
+
+NS_IMETHODIMP
+nsEncoderFixup::FixupURI(nsIURI *aURI, const nsACString& aMimeType,
+                         nsAString& aSpec)
+{
+    URIData *data;
+    mWebBrowserPersist->StoreURI(aURI, true, &data);
+    data->mContentsType.Assign(aMimeType);
+    return mWebBrowserPersist->FixupURIData(data, aURI, aSpec);
+}
diff --git a/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.h b/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.h
--- a/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.h
+++ b/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.h
@@ -57,30 +57,30 @@
 #include "nsIWebProgressListener2.h"
 
 #include "nsHashtable.h"
 #include "nsTArray.h"
 #include "nsInt64.h"
 
 #include "nsCWebBrowserPersist.h"
 
-class nsEncoderNodeFixup;
+class nsEncoderFixup;
 class nsIStorageStream;
 
 struct URIData;
 struct CleanupData;
 struct DocData;
 
 class nsWebBrowserPersist : public nsIInterfaceRequestor,
                             public nsIWebBrowserPersist,
                             public nsIStreamListener,
                             public nsIProgressEventSink,
                             public nsSupportsWeakReference
 {
-    friend class nsEncoderNodeFixup;
+    friend class nsEncoderFixup;
 
 // Public members
 public:
     nsWebBrowserPersist();
     
     NS_DECL_ISUPPORTS
     NS_DECL_NSIINTERFACEREQUESTOR
     NS_DECL_NSICANCELABLE
@@ -124,16 +124,18 @@ private:
     nsresult MakeOutputStreamFromFile(
         nsILocalFile *aFile, nsIOutputStream **aOutputStream);
     nsresult MakeOutputStreamFromURI(nsIURI *aURI, nsIOutputStream  **aOutStream);
     nsresult CreateChannelFromURI(nsIURI *aURI, nsIChannel **aChannel);
     nsresult StartUpload(nsIStorageStream *aOutStream, nsIURI *aDestinationURI,
         const nsACString &aContentType);
     nsresult CalculateAndAppendFileExt(nsIURI *aURI, nsIChannel *aChannel,
         nsIURI *aOriginalURIWithExtension);
+    nsresult AppendFileExt(nsACString& contentType, nsIURI *aURI,
+        nsIURI *aOriginalURIWithExtension);
     nsresult CalculateUniqueFilename(nsIURI *aURI);
     nsresult MakeFilenameFromURI(
         nsIURI *aURI, nsString &aFilename);
     nsresult StoreURI(
         const char *aURI,
         bool aNeedsPersisting = true,
         URIData **aData = nullptr);
     nsresult StoreURI(
@@ -151,29 +153,33 @@ private:
     {
         return StoreURIAttributeNS(aNode, "", aAttribute, aNeedsPersisting, aData);
     }
     bool GetQuotedAttributeValue(
     const nsAString &aSource, const nsAString &aAttribute, nsAString &aValue);
     bool DocumentEncoderExists(const char16_t *aContentType);
 
     nsresult GetNodeToFixup(nsIDOMNode *aNodeIn, nsIDOMNode **aNodeOut);
+    already_AddRefed<nsIURI> ResolveSpec(nsAString& aSpec);
+    URIData* GetDataForURI(nsAString &aURI);
+    URIData* GetDataForURI(nsIURI* aURI);
     nsresult FixupURI(nsAString &aURI);
+    nsresult FixupURIData(URIData *aData, nsIURI *aOriginalURI, nsAString &aSpec);
     nsresult FixupNodeAttributeNS(nsIDOMNode *aNode, const char *aNamespaceURI, const char *aAttribute);
     nsresult FixupNodeAttribute(nsIDOMNode *aNode, const char *aAttribute)
     {
         return FixupNodeAttributeNS(aNode, "", aAttribute);
     }
     nsresult FixupAnchor(nsIDOMNode *aNode);
     nsresult FixupXMLStyleSheetLink(nsIDOMProcessingInstruction *aPI, const nsAString &aHref);
     nsresult GetXMLStyleSheetLink(nsIDOMProcessingInstruction *aPI, nsAString &aHref);
 
     nsresult StoreAndFixupStyleSheet(nsIStyleSheet *aStyleSheet);
     nsresult SaveDocumentWithFixup(
-        nsIDOMDocument *pDocument, nsIDocumentEncoderNodeFixup *pFixup,
+        nsIDOMDocument *pDocument, nsIDocumentEncoderFixup *pFixup,
         nsIURI *aFile, bool aReplaceExisting, const nsACString &aFormatType,
         const nsCString &aSaveCharset, PRUint32  aFlags);
     nsresult SaveSubframeContent(
         nsIDOMDocument *aFrameContent, URIData *aData);
     nsresult SetDocumentBase(nsIDOMDocument *aDocument, nsIURI *aBaseURI);
     nsresult SendErrorStatusChange(
         bool aIsReadError, nsresult aResult, nsIRequest *aRequest, nsIURI *aURI);
     nsresult OnWalkDOMNode(nsIDOMNode *aNode);
@@ -238,26 +244,27 @@ private:
     bool                      mSerializingOutput;
     PRUint32                  mPersistFlags;
     PRUint32                  mPersistResult;
     nsInt64                   mTotalCurrentProgress;
     nsInt64                   mTotalMaxProgress;
     PRInt16                   mWrapColumn;
     PRUint32                  mEncodingFlags;
     nsString                  mContentType;
+    RefPtr<nsEncoderFixup>    mFixup;
 };
 
 // Helper class does node fixup during persistence
-class nsEncoderNodeFixup : public nsIDocumentEncoderNodeFixup
+class nsEncoderFixup : public nsIDocumentEncoderFixup
 {
 public:
-    nsEncoderNodeFixup();
+    nsEncoderFixup();
     
     NS_DECL_ISUPPORTS
-    NS_IMETHOD FixupNode(nsIDOMNode *aNode, bool *aSerializeCloneKids, nsIDOMNode **aOutNode);
+    NS_DECL_NSIDOCUMENTENCODERFIXUP
     
     nsWebBrowserPersist *mWebBrowserPersist;
 
 protected:    
-    virtual ~nsEncoderNodeFixup();
+    virtual ~nsEncoderFixup();
 };
 
 #endif
diff --git a/layout/style/nsCSSDeclaration.cpp b/layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp
+++ b/layout/style/nsCSSDeclaration.cpp
@@ -49,18 +49,20 @@
 #include "nsIAtom.h"
 #include "nsUnicharUtils.h"
 #include "nsReadableUtils.h"
 #include "nsCRT.h"
 #include "nsCSSProps.h"
 #include "nsFont.h"
 #include "nsReadableUtils.h"
 #include "nsStyleUtil.h"
+#include "imgIRequest.h"
 
 #include "nsStyleConsts.h"
+#include "nsIDocumentEncoder.h"
 
 #include "nsCOMPtr.h"
 
 nsCSSDeclaration::nsCSSDeclaration() 
   : mData(nullptr),
     mImportantData(nullptr)
 {
   // check that we can fit all the CSS properties into a PRUint8
@@ -124,101 +126,103 @@ nsCSSDeclaration::RemoveProperty(nsCSSPr
 }
 
 nsresult
 nsCSSDeclaration::AppendComment(const nsAString& aComment)
 {
   return /* NS_ERROR_NOT_IMPLEMENTED, or not any longer that is */ NS_OK;
 }
 
-bool nsCSSDeclaration::AppendValueToString(nsCSSProperty aProperty, nsAString& aResult) const
+bool nsCSSDeclaration::AppendValueToString(nsCSSProperty aProperty,
+                                             nsIDocumentEncoderFixup *aFixup,
+                                             nsAString& aResult) const
 {
   nsCSSCompressedDataBlock *data = GetValueIsImportant(aProperty)
                                       ? mImportantData : mData;
   const void *storage = data->StorageFor(aProperty);
   if (storage) {
     switch (nsCSSProps::kTypeTable[aProperty]) {
       case eCSSType_Value: {
         const nsCSSValue *val = static_cast<const nsCSSValue*>(storage);
-        AppendCSSValueToString(aProperty, *val, aResult);
+        AppendCSSValueToString(aProperty, *val, aFixup, aResult);
       } break;
       case eCSSType_Rect: {
         const nsCSSRect *rect = static_cast<const nsCSSRect*>(storage);
         const nsCSSUnit topUnit = rect->mTop.GetUnit();
         if (topUnit == eCSSUnit_Inherit ||
             topUnit == eCSSUnit_Initial ||
             topUnit == eCSSUnit_RectIsAuto) {
           NS_ASSERTION(rect->mRight.GetUnit() == topUnit &&
                        rect->mBottom.GetUnit() == topUnit &&
                        rect->mLeft.GetUnit() == topUnit,
                        "parser should make all sides have the same unit");
           if (topUnit == eCSSUnit_RectIsAuto)
             aResult.AppendLiteral("auto");
           else
-            AppendCSSValueToString(aProperty, rect->mTop, aResult);
+            AppendCSSValueToString(aProperty, rect->mTop, aFixup, aResult);
         } else {
           aResult.AppendLiteral("rect(");
-          AppendCSSValueToString(aProperty, rect->mTop, aResult);
+          AppendCSSValueToString(aProperty, rect->mTop, aFixup, aResult);
           NS_NAMED_LITERAL_STRING(comma, ", ");
           aResult.Append(comma);
-          AppendCSSValueToString(aProperty, rect->mRight, aResult);
+          AppendCSSValueToString(aProperty, rect->mRight, aFixup, aResult);
           aResult.Append(comma);
-          AppendCSSValueToString(aProperty, rect->mBottom, aResult);
+          AppendCSSValueToString(aProperty, rect->mBottom, aFixup, aResult);
           aResult.Append(comma);
-          AppendCSSValueToString(aProperty, rect->mLeft, aResult);
+          AppendCSSValueToString(aProperty, rect->mLeft, aFixup, aResult);
           aResult.Append(char16_t(')'));
         }
       } break;
       case eCSSType_ValuePair: {
         const nsCSSValuePair *pair = static_cast<const nsCSSValuePair*>(storage);
-        AppendCSSValueToString(aProperty, pair->mXValue, aResult);
+        AppendCSSValueToString(aProperty, pair->mXValue, aFixup, aResult);
         if (pair->mYValue != pair->mXValue ||
             ((aProperty == eCSSProperty_background_position ||
               aProperty == eCSSProperty__moz_transform_origin) &&
              pair->mXValue.GetUnit() != eCSSUnit_Inherit &&
              pair->mXValue.GetUnit() != eCSSUnit_Initial) ||
             (aProperty == eCSSProperty__moz_background_size &&
              pair->mXValue.GetUnit() != eCSSUnit_Inherit &&
              pair->mXValue.GetUnit() != eCSSUnit_Initial &&
              pair->mXValue.GetUnit() != eCSSUnit_Enumerated)) {
           // Only output a Y value if it's different from the X value,
           // or if it's a background-position value other than 'initial'
           // or 'inherit', or if it's a -moz-transform-origin value other
           // than 'initial' or 'inherit', or if it's a -moz-background-size
           // value other than 'initial' or 'inherit' or 'contain' or 'cover'.
           aResult.Append(char16_t(' '));
-          AppendCSSValueToString(aProperty, pair->mYValue, aResult);
+          AppendCSSValueToString(aProperty, pair->mYValue, aFixup, aResult);
         }
       } break;
       case eCSSType_ValueList: {
         const nsCSSValueList* val =
             *static_cast<nsCSSValueList*const*>(storage);
         do {
-          AppendCSSValueToString(aProperty, val->mValue, aResult);
+          AppendCSSValueToString(aProperty, val->mValue, aFixup, aResult);
           val = val->mNext;
           if (val) {
             if (nsCSSProps::PropHasFlags(aProperty,
                                          CSS_PROPERTY_VALUE_LIST_USES_COMMAS))
               aResult.Append(char16_t(','));
             aResult.Append(char16_t(' '));
           }
         } while (val);
       } break;
       case eCSSType_ValuePairList: {
         const nsCSSValuePairList* item =
             *static_cast<nsCSSValuePairList*const*>(storage);
         do {
           NS_ASSERTION(item->mXValue.GetUnit() != eCSSUnit_Null,
                        "unexpected null unit");
-          AppendCSSValueToString(aProperty, item->mXValue, aResult);
+          AppendCSSValueToString(aProperty, item->mXValue, aFixup, aResult);
           if (item->mXValue.GetUnit() != eCSSUnit_Inherit &&
               item->mXValue.GetUnit() != eCSSUnit_Initial &&
               item->mYValue.GetUnit() != eCSSUnit_Null) {
             aResult.Append(char16_t(' '));
-            AppendCSSValueToString(aProperty, item->mYValue, aResult);
+            AppendCSSValueToString(aProperty, item->mYValue, aFixup, aResult);
           }
           item = item->mNext;
           if (item) {
             if (nsCSSProps::PropHasFlags(aProperty,
                                          CSS_PROPERTY_VALUE_LIST_USES_COMMAS))
               aResult.Append(char16_t(','));
             aResult.Append(char16_t(' '));
           }
@@ -227,16 +231,17 @@ bool nsCSSDeclaration::AppendValueToSt
     }
   }
   return storage != nullptr;
 }
 
 /* static */ bool
 nsCSSDeclaration::AppendCSSValueToString(nsCSSProperty aProperty,
                                          const nsCSSValue& aValue,
+                                         nsIDocumentEncoderFixup *aFixup,
                                          nsAString& aResult)
 {
   nsCSSUnit unit = aValue.GetUnit();
 
   if (eCSSUnit_Null == unit) {
     return false;
   }
 
@@ -275,35 +280,35 @@ nsCSSDeclaration::AppendCSSValueToString
           aResult.AppendLiteral(" ");
         else
           aResult.AppendLiteral(", ");
       }
       nsCSSProperty prop =
         ((eCSSUnit_Counter <= unit && unit <= eCSSUnit_Counters) &&
          i == array->Count() - 1)
         ? eCSSProperty_list_style_type : aProperty;
-      if (AppendCSSValueToString(prop, array->Item(i), aResult)) {
+      if (AppendCSSValueToString(prop, array->Item(i), aFixup, aResult)) {
         mark = true;
       }
     }
   }
   /* Although Function is backed by an Array, we'll handle it separately
    * because it's a bit quirky.
    */
   else if (eCSSUnit_Function == unit) {
     const nsCSSValue::Array* array = aValue.GetArrayValue();
     NS_ASSERTION(array->Count() >= 1, "Functions must have at least one element for the name.");
 
     /* Append the function name. */
-    AppendCSSValueToString(aProperty, array->Item(0), aResult);
+    AppendCSSValueToString(aProperty, array->Item(0), aFixup, aResult);
     aResult.AppendLiteral("(");
 
     /* Now, step through the function contents, writing each of them as we go. */
     for (PRUint16 index = 1; index < array->Count(); ++index) {
-      AppendCSSValueToString(aProperty, array->Item(index), aResult);
+      AppendCSSValueToString(aProperty, array->Item(index), aFixup, aResult);
 
       /* If we're not at the final element, append a comma. */
       if (index + 1 != array->Count())
         aResult.AppendLiteral(", ");
     }
 
     /* Finally, append the closing parenthesis. */
     aResult.AppendLiteral(")");
@@ -394,18 +399,37 @@ nsCSSDeclaration::AppendCSSValueToString
       }
       tmpStr.Append(char16_t(')'));
 
       aResult.Append(tmpStr);
     }
   }
   else if (eCSSUnit_URL == unit || eCSSUnit_Image == unit) {
     aResult.Append(NS_LITERAL_STRING("url("));
-    nsStyleUtil::AppendEscapedCSSString(
-      nsDependentString(aValue.GetOriginalURLValue()), aResult);
+
+    if (aFixup) {
+      nsXPIDLCString type;
+      if (eCSSUnit_Image == unit) {
+        imgIRequest *req = aValue.GetImageValue();
+        if (req) {
+          req->GetMimeType(getter_Copies(type));
+        }
+      }
+
+      nsIURI *uri = aValue.GetURLValue();
+      nsAutoString fixedSpec;
+      nsresult rv = aFixup->FixupURI(uri, type, fixedSpec);
+      NS_ENSURE_SUCCESS(rv, rv);
+                    
+      nsStyleUtil::AppendEscapedCSSString(fixedSpec, aResult);
+    } else {
+      nsStyleUtil::AppendEscapedCSSString(
+        nsDependentString(aValue.GetOriginalURLValue()), aResult);
+    }
+
     aResult.Append(NS_LITERAL_STRING(")"));
   }
   else if (eCSSUnit_Percent == unit) {
     nsAutoString tmpStr;
     tmpStr.AppendFloat(aValue.GetPercentValue() * 100.0f);
     aResult.Append(tmpStr);
   }
   else if (eCSSUnit_Percent < unit) {  // length unit
@@ -417,45 +441,49 @@ nsCSSDeclaration::AppendCSSValueToString
     nsCSSValueGradient* gradient = aValue.GetGradientValue();
 
     if (gradient->mIsRadial)
       aResult.AppendLiteral("-moz-radial-gradient(");
     else
       aResult.AppendLiteral("-moz-linear-gradient(");
 
     AppendCSSValueToString(eCSSProperty_background_position,
-                           gradient->mStartX, aResult);
+                           gradient->mStartX, aFixup, aResult);
     aResult.AppendLiteral(" ");
 
     AppendCSSValueToString(eCSSProperty_background_position,
-                           gradient->mStartY, aResult);
+                           gradient->mStartY, aFixup, aResult);
     aResult.AppendLiteral(", ");
 
     if (gradient->mIsRadial) {
-      AppendCSSValueToString(aProperty, gradient->mStartRadius, aResult);
+      AppendCSSValueToString(aProperty, gradient->mStartRadius, aFixup,
+                             aResult);
       aResult.AppendLiteral(", ");
     }
 
     AppendCSSValueToString(eCSSProperty_background_position,
-                           gradient->mEndX, aResult);
+                           gradient->mEndX, aFixup, aResult);
     aResult.AppendLiteral(" ");
 
     AppendCSSValueToString(eCSSProperty_background_position,
-                           gradient->mEndY, aResult);
+                           gradient->mEndY, aFixup, aResult);
 
     if (gradient->mIsRadial) {
       aResult.AppendLiteral(", ");
-      AppendCSSValueToString(aProperty, gradient->mEndRadius, aResult);
+      AppendCSSValueToString(aProperty, gradient->mEndRadius, aFixup,
+                             aResult);
     }
 
     for (PRUint32 i = 0; i < gradient->mStops.Length(); i++) {
       aResult.AppendLiteral(", color-stop(");
-      AppendCSSValueToString(aProperty, gradient->mStops[i].mLocation, aResult);
+      AppendCSSValueToString(aProperty, gradient->mStops[i].mLocation,
+                             aFixup, aResult);
       aResult.AppendLiteral(", ");
-      AppendCSSValueToString(aProperty, gradient->mStops[i].mColor, aResult);
+      AppendCSSValueToString(aProperty, gradient->mStops[i].mColor,
+                             aFixup, aResult);
       aResult.AppendLiteral(")");
     }
 
     aResult.AppendLiteral(")");
   }
 
   switch (unit) {
     case eCSSUnit_Null:         break;
@@ -515,23 +543,24 @@ nsCSSDeclaration::AppendCSSValueToString
     case eCSSUnit_Milliseconds: aResult.AppendLiteral("ms");   break;
   }
 
   return true;
 }
 
 nsresult
 nsCSSDeclaration::GetValue(nsCSSProperty aProperty,
+                           nsIDocumentEncoderFixup *aFixup,
                            nsAString& aValue) const
 {
   aValue.Truncate(0);
 
   // simple properties are easy.
   if (!nsCSSProps::IsShorthand(aProperty)) {
-    AppendValueToString(aProperty, aValue);
+    AppendValueToString(aProperty, aFixup, aValue);
     return NS_OK;
   }
 
   // DOM Level 2 Style says (when describing CSS2Properties, although
   // not CSSStyleDeclaration.getPropertyValue):
   //   However, if there is no shorthand declaration that could be added
   //   to the ruleset without changing in any way the rules already
   //   declared in the ruleset (i.e., by adding longhand rules that were
@@ -606,23 +635,23 @@ nsCSSDeclaration::GetValue(nsCSSProperty
   }
   if (importantCount != 0 && importantCount != totalCount) {
     // Case (3), no consistent importance.
     return NS_OK;
   }
   if (initialCount == totalCount) {
     // Simplify serialization below by serializing initial up-front.
     AppendCSSValueToString(eCSSProperty_UNKNOWN, nsCSSValue(eCSSUnit_Initial),
-                           aValue);
+                           aFixup, aValue);
     return NS_OK;
   }
   if (inheritCount == totalCount) {
     // Simplify serialization below by serializing inherit up-front.
     AppendCSSValueToString(eCSSProperty_UNKNOWN, nsCSSValue(eCSSUnit_Inherit),
-                           aValue);
+                           aFixup, aValue);
     return NS_OK;
   }
   if (initialCount != 0 || inheritCount != 0) {
     // Case (2): partially initial or inherit.
     return NS_OK;
   }
 
   nsCSSCompressedDataBlock *data = importantCount ? mImportantData : mData;
@@ -647,30 +676,34 @@ nsCSSDeclaration::GetValue(nsCSSProperty
                      kNotFound, "third subprop must be bottom");
       NS_ASSERTION(nsCSSProps::GetStringValue(subprops[3]).Find("-left") !=
                      kNotFound, "fourth subprop must be left");
       const nsCSSValue &topValue = *data->ValueStorageFor(subprops[0]);
       const nsCSSValue &rightValue = *data->ValueStorageFor(subprops[1]);
       const nsCSSValue &bottomValue = *data->ValueStorageFor(subprops[2]);
       const nsCSSValue &leftValue = *data->ValueStorageFor(subprops[3]);
       bool haveValue;
-      haveValue = AppendCSSValueToString(subprops[0], topValue, aValue);
+      haveValue = AppendCSSValueToString(subprops[0], topValue, aFixup,
+                                         aValue);
       NS_ASSERTION(haveValue, "should have bailed before");
       if (topValue != rightValue || topValue != leftValue ||
           topValue != bottomValue) {
         aValue.Append(char16_t(' '));
-        haveValue = AppendCSSValueToString(subprops[1], rightValue, aValue);
+        haveValue = AppendCSSValueToString(subprops[1], rightValue, aFixup,
+                                           aValue);
         NS_ASSERTION(haveValue, "should have bailed before");
         if (topValue != bottomValue || rightValue != leftValue) {
           aValue.Append(char16_t(' '));
-          haveValue = AppendCSSValueToString(subprops[2], bottomValue, aValue);
+          haveValue = AppendCSSValueToString(subprops[2], bottomValue, aFixup,
+                                             aValue);
           NS_ASSERTION(haveValue, "should have bailed before");
           if (rightValue != leftValue) {
             aValue.Append(char16_t(' '));
-            haveValue = AppendCSSValueToString(subprops[3], leftValue, aValue);
+            haveValue = AppendCSSValueToString(subprops[3], leftValue, aFixup,
+                                               aValue);
             NS_ASSERTION(haveValue, "should have bailed before");
           }
         }
       }
       break;
     }
     case eCSSProperty__moz_border_radius: 
     case eCSSProperty__moz_outline_radius: {
@@ -683,38 +716,38 @@ nsCSSDeclaration::GetValue(nsCSSProperty
                    "type mismatch");
       const nsCSSValuePair* vals[4] = {
         data->ValuePairStorageFor(subprops[0]),
         data->ValuePairStorageFor(subprops[1]),
         data->ValuePairStorageFor(subprops[2]),
         data->ValuePairStorageFor(subprops[3])
       };
 
-      AppendCSSValueToString(aProperty, vals[0]->mXValue, aValue);
+      AppendCSSValueToString(aProperty, vals[0]->mXValue, aFixup, aValue);
       aValue.Append(char16_t(' '));
-      AppendCSSValueToString(aProperty, vals[1]->mXValue, aValue);
+      AppendCSSValueToString(aProperty, vals[1]->mXValue, aFixup, aValue);
       aValue.Append(char16_t(' '));
-      AppendCSSValueToString(aProperty, vals[2]->mXValue, aValue);
+      AppendCSSValueToString(aProperty, vals[2]->mXValue, aFixup, aValue);
       aValue.Append(char16_t(' '));
-      AppendCSSValueToString(aProperty, vals[3]->mXValue, aValue);
+      AppendCSSValueToString(aProperty, vals[3]->mXValue, aFixup, aValue);
         
       // For compatibility, only write a slash and the y-values
       // if they're not identical to the x-values.
       if (vals[0]->mXValue != vals[0]->mYValue ||
           vals[1]->mXValue != vals[1]->mYValue ||
           vals[2]->mXValue != vals[2]->mYValue ||
           vals[3]->mXValue != vals[3]->mYValue) {
         aValue.AppendLiteral(" / ");
-        AppendCSSValueToString(aProperty, vals[0]->mYValue, aValue);
+        AppendCSSValueToString(aProperty, vals[0]->mYValue, aFixup, aValue);
         aValue.Append(char16_t(' '));
-        AppendCSSValueToString(aProperty, vals[1]->mYValue, aValue);
+        AppendCSSValueToString(aProperty, vals[1]->mYValue, aFixup, aValue);
         aValue.Append(char16_t(' '));
-        AppendCSSValueToString(aProperty, vals[2]->mYValue, aValue);
+        AppendCSSValueToString(aProperty, vals[2]->mYValue, aFixup, aValue);
         aValue.Append(char16_t(' '));
-        AppendCSSValueToString(aProperty, vals[3]->mYValue, aValue);
+        AppendCSSValueToString(aProperty, vals[3]->mYValue, aFixup, aValue);
       }
       break;
     }
     case eCSSProperty_border: {
       const nsCSSProperty* subproptables[3] = {
         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_color),
         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_style),
         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_width)
@@ -758,23 +791,23 @@ nsCSSDeclaration::GetValue(nsCSSProperty
                                   NS_LITERAL_CSTRING("-color")) ||
                    StringEndsWith(nsCSSProps::GetStringValue(subprops[2]),
                                   NS_LITERAL_CSTRING("-color-value")),
                    "third subprop must be the color property");
       const nsCSSValue *colorValue = data->ValueStorageFor(subprops[2]);
       bool isMozUseTextColor =
         colorValue->GetUnit() == eCSSUnit_Enumerated &&
         colorValue->GetIntValue() == NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR;
-      if (!AppendValueToString(subprops[0], aValue) ||
+      if (!AppendValueToString(subprops[0], aFixup, aValue) ||
           !(aValue.Append(char16_t(' ')),
-            AppendValueToString(subprops[1], aValue)) ||
+            AppendValueToString(subprops[1], aFixup, aValue)) ||
           // Don't output a third value when it's -moz-use-text-color.
           !(isMozUseTextColor ||
             (aValue.Append(char16_t(' ')),
-             AppendValueToString(subprops[2], aValue)))) {
+             AppendValueToString(subprops[2], aFixup, aValue)))) {
         aValue.Truncate();
       }
       break;
     }
     case eCSSProperty_margin_left:
     case eCSSProperty_margin_right:
     case eCSSProperty_margin_start:
     case eCSSProperty_margin_end:
@@ -793,17 +826,17 @@ nsCSSDeclaration::GetValue(nsCSSProperty
     case eCSSProperty_border_start_width:
     case eCSSProperty_border_end_color:
     case eCSSProperty_border_end_style:
     case eCSSProperty_border_end_width: {
       const nsCSSProperty* subprops =
         nsCSSProps::SubpropertyEntryFor(aProperty);
       NS_ASSERTION(subprops[3] == eCSSProperty_UNKNOWN,
                    "not box property with physical vs. logical cascading");
-      AppendValueToString(subprops[0], aValue);
+      AppendValueToString(subprops[0], aFixup, aValue);
       break;
     }
     case eCSSProperty_background: {
       // We know from above that all subproperties were specified.
       // However, we still can't represent that in the shorthand unless
       // they're all lists of the same length.  So if they're different
       // lengths, we need to bail out.
       // We also need to bail out if an item has background-clip and
@@ -820,29 +853,29 @@ nsCSSDeclaration::GetValue(nsCSSProperty
       const nsCSSValueList *clip =
         * data->ValueListStorageFor(eCSSProperty__moz_background_clip);
       const nsCSSValueList *origin =
         * data->ValueListStorageFor(eCSSProperty__moz_background_origin);
       const nsCSSValuePairList *size =
         * data->ValuePairListStorageFor(eCSSProperty__moz_background_size);
       for (;;) {
         AppendCSSValueToString(eCSSProperty_background_image,
-                               image->mValue, aValue);
+                               image->mValue, aFixup, aValue);
         aValue.Append(char16_t(' '));
         AppendCSSValueToString(eCSSProperty_background_repeat,
-                               repeat->mValue, aValue);
+                               repeat->mValue, aFixup, aValue);
         aValue.Append(char16_t(' '));
         AppendCSSValueToString(eCSSProperty_background_attachment,
-                               attachment->mValue, aValue);
+                               attachment->mValue, aFixup, aValue);
         aValue.Append(char16_t(' '));
         AppendCSSValueToString(eCSSProperty_background_position,
-                               position->mXValue, aValue);
+                               position->mXValue, aFixup, aValue);
         aValue.Append(char16_t(' '));
         AppendCSSValueToString(eCSSProperty_background_position,
-                               position->mYValue, aValue);
+                               position->mYValue, aFixup, aValue);
         NS_ASSERTION(clip->mValue.GetUnit() == eCSSUnit_Enumerated &&
                      origin->mValue.GetUnit() == eCSSUnit_Enumerated,
                      "should not be inherit/initial within list and "
                      "should have returned early for real inherit/initial");
         if (clip->mValue.GetIntValue() != NS_STYLE_BG_CLIP_BORDER ||
             origin->mValue.GetIntValue() != NS_STYLE_BG_ORIGIN_PADDING) {
 #if 0
     // This is commented out for now until we change
@@ -857,17 +890,17 @@ nsCSSDeclaration::GetValue(nsCSSProperty
           //                  NS_STYLE_BG_ORIGIN_CONTENT);
           if (clip->mValue != origin->mValue) {
             aValue.Truncate();
             return NS_OK;
           }
 
           aValue.Append(char16_t(' '));
           AppendCSSValueToString(eCSSProperty__moz_background_clip,
-                                 clip->mValue, aValue);
+                                 clip->mValue, aFixup, aValue);
 #else
           aValue.Truncate();
           return NS_OK;
 #endif
         }
 
         image = image->mNext;
         repeat = repeat->mNext;
@@ -890,23 +923,23 @@ nsCSSDeclaration::GetValue(nsCSSProperty
           aValue.Truncate();
           return NS_OK;
         }
         aValue.Append(char16_t(','));
         aValue.Append(char16_t(' '));
       }
 
       aValue.Append(char16_t(' '));
-      AppendValueToString(eCSSProperty_background_color, aValue);
+      AppendValueToString(eCSSProperty_background_color, aFixup, aValue);
       break;
     }
     case eCSSProperty_cue: {
-      if (AppendValueToString(eCSSProperty_cue_before, aValue)) {
+      if (AppendValueToString(eCSSProperty_cue_before, aFixup, aValue)) {
         aValue.Append(char16_t(' '));
-        if (!AppendValueToString(eCSSProperty_cue_after, aValue))
+        if (!AppendValueToString(eCSSProperty_cue_after, aFixup, aValue))
           aValue.Truncate();
       }
       break;
     }
     case eCSSProperty_font: {
       // systemFont might not be present; the others are guaranteed to be
       // based on the shorthand check at the beginning of the function
       const nsCSSValue *systemFont =
@@ -938,82 +971,89 @@ nsCSSDeclaration::GetValue(nsCSSProperty
             lh.GetUnit() != eCSSUnit_System_Font ||
             family.GetUnit() != eCSSUnit_System_Font ||
             stretch.GetUnit() != eCSSUnit_System_Font ||
             sizeAdjust.GetUnit() != eCSSUnit_System_Font) {
           // This can't be represented as a shorthand.
           return NS_OK;
         }
         AppendCSSValueToString(eCSSProperty__x_system_font, *systemFont,
-                               aValue);
+                               aFixup, aValue);
       } else {
         // The font-stretch and font-size-adjust
         // properties are reset by this shorthand property to their
         // initial values, but can't be represented in its syntax.
         if (stretch != nsCSSValue(eCSSUnit_Normal) ||
             sizeAdjust != nsCSSValue(eCSSUnit_None)) {
           return NS_OK;
         }
 
         if (style.GetUnit() != eCSSUnit_Normal) {
-          AppendCSSValueToString(eCSSProperty_font_style, style, aValue);
+          AppendCSSValueToString(eCSSProperty_font_style, style, aFixup,
+                                 aValue);
           aValue.Append(char16_t(' '));
         }
         if (variant.GetUnit() != eCSSUnit_Normal) {
-          AppendCSSValueToString(eCSSProperty_font_variant, variant, aValue);
+          AppendCSSValueToString(eCSSProperty_font_variant, variant, aFixup,
+                                 aValue);
           aValue.Append(char16_t(' '));
         }
         if (weight.GetUnit() != eCSSUnit_Normal) {
-          AppendCSSValueToString(eCSSProperty_font_weight, weight, aValue);
+          AppendCSSValueToString(eCSSProperty_font_weight, weight, aFixup,
+                                 aValue);
           aValue.Append(char16_t(' '));
         }
-        AppendCSSValueToString(eCSSProperty_font_size, size, aValue);
+        AppendCSSValueToString(eCSSProperty_font_size, size, aFixup, aValue);
         if (lh.GetUnit() != eCSSUnit_Normal) {
           aValue.Append(char16_t('/'));
-          AppendCSSValueToString(eCSSProperty_line_height, lh, aValue);
+          AppendCSSValueToString(eCSSProperty_line_height, lh, aFixup,
+                                 aValue);
         }
         aValue.Append(char16_t(' '));
-        AppendCSSValueToString(eCSSProperty_font_family, family, aValue);
+        AppendCSSValueToString(eCSSProperty_font_family, family, aFixup,
+                               aValue);
       }
       break;
     }
     case eCSSProperty_list_style:
-      if (AppendValueToString(eCSSProperty_list_style_type, aValue))
+      if (AppendValueToString(eCSSProperty_list_style_type, aFixup, aValue))
         aValue.Append(char16_t(' '));
-      if (AppendValueToString(eCSSProperty_list_style_position, aValue))
+      if (AppendValueToString(eCSSProperty_list_style_position, aFixup,
+                              aValue))
         aValue.Append(char16_t(' '));
-      AppendValueToString(eCSSProperty_list_style_image, aValue);
+      AppendValueToString(eCSSProperty_list_style_image, aFixup, aValue);
       break;
     case eCSSProperty_overflow: {
       const nsCSSValue &xValue =
         *data->ValueStorageFor(eCSSProperty_overflow_x);
       const nsCSSValue &yValue =
         *data->ValueStorageFor(eCSSProperty_overflow_y);
       if (xValue == yValue)
-        AppendCSSValueToString(eCSSProperty_overflow_x, xValue, aValue);
+        AppendCSSValueToString(eCSSProperty_overflow_x, xValue, aFixup,
+                               aValue);
       break;
     }
     case eCSSProperty_pause: {
-      if (AppendValueToString(eCSSProperty_pause_before, aValue)) {
+      if (AppendValueToString(eCSSProperty_pause_before, aFixup, aValue)) {
         aValue.Append(char16_t(' '));
-        if (!AppendValueToString(eCSSProperty_pause_after, aValue))
+        if (!AppendValueToString(eCSSProperty_pause_after, aFixup, aValue))
           aValue.Truncate();
       }
       break;
     }
 #ifdef MOZ_SVG
     case eCSSProperty_marker: {
       const nsCSSValue &endValue =
         *data->ValueStorageFor(eCSSProperty_marker_end);
       const nsCSSValue &midValue =
         *data->ValueStorageFor(eCSSProperty_marker_mid);
       const nsCSSValue &startValue =
         *data->ValueStorageFor(eCSSProperty_marker_start);
       if (endValue == midValue && midValue == startValue)
-        AppendValueToString(eCSSProperty_marker_end, aValue);
+        AppendValueToString(eCSSProperty_marker_end, aFixup, aValue);
       break;
     }
 #endif
     default:
       NS_NOTREACHED("no other shorthands");
       break;
   }
   return NS_OK;
@@ -1058,36 +1098,39 @@ nsCSSDeclaration::AppendImportanceToStri
   if (aIsImportant) {
    aString.AppendLiteral(" ! important");
   }
 }
 
 void
 nsCSSDeclaration::AppendPropertyAndValueToString(nsCSSProperty aProperty,
                                                  nsAutoString& aValue,
+                                                 nsIDocumentEncoderFixup
+                                                                      *aFixup,
                                                  nsAString& aResult) const
 {
   NS_ASSERTION(0 <= aProperty && aProperty < eCSSProperty_COUNT,
                "property enum out of range");
   NS_ASSERTION((aProperty < eCSSProperty_COUNT_no_shorthands) ==
                  aValue.IsEmpty(),
                "aValue should be given for shorthands but not longhands");
   AppendASCIItoUTF16(nsCSSProps::GetStringValue(aProperty), aResult);
   aResult.AppendLiteral(": ");
   if (aValue.IsEmpty())
-    AppendValueToString(aProperty, aResult);
+    AppendValueToString(aProperty, aFixup, aResult);
   else
     aResult.Append(aValue);
   bool    isImportant = GetValueIsImportant(aProperty);
   AppendImportanceToString(isImportant, aResult);
   aResult.AppendLiteral("; ");
 }
 
 nsresult
-nsCSSDeclaration::ToString(nsAString& aString) const
+nsCSSDeclaration::ToString(nsIDocumentEncoderFixup *aFixup,
+                           nsAString& aString) const
 {
   nsCSSCompressedDataBlock *systemFontData =
     GetValueIsImportant(eCSSProperty__x_system_font) ? mImportantData : mData;
   const nsCSSValue *systemFont = 
     systemFontData->ValueStorageFor(eCSSProperty__x_system_font);
   const bool haveSystemFont = systemFont &&
                                 systemFont->GetUnit() != eCSSUnit_None &&
                                 systemFont->GetUnit() != eCSSUnit_Null;
@@ -1121,35 +1164,36 @@ nsCSSDeclaration::ToString(nsAString& aS
          *shorthands != eCSSProperty_UNKNOWN; ++shorthands) {
       // ShorthandsContaining returns the shorthands in order from those
       // that contain the most subproperties to those that contain the
       // least, which is exactly the order we want to test them.
       nsCSSProperty shorthand = *shorthands;
 
       // If GetValue gives us a non-empty string back, we can use that
       // value; otherwise it's not possible to use this shorthand.
-      GetValue(shorthand, value);
+      GetValue(shorthand, aFixup, value);
       if (!value.IsEmpty()) {
-        AppendPropertyAndValueToString(shorthand, value, aString);
+        AppendPropertyAndValueToString(shorthand, value, aFixup, aString);
         shorthandsUsed.AppendElement(shorthand);
         doneProperty = true;
         break;
       }
 
       NS_ASSERTION(shorthand != eCSSProperty_font ||
                    *(shorthands + 1) == eCSSProperty_UNKNOWN,
                    "font should always be the only containing shorthand");
       if (shorthand == eCSSProperty_font) {
         if (haveSystemFont && !didSystemFont) {
           // Output the shorthand font declaration that we will
           // partially override later.  But don't add it to
           // |shorthandsUsed|, since we will have to override it.
           AppendCSSValueToString(eCSSProperty__x_system_font, *systemFont,
-                                 value);
-          AppendPropertyAndValueToString(eCSSProperty_font, value, aString);
+                                 aFixup, value);
+          AppendPropertyAndValueToString(eCSSProperty_font, value,
+                                         aFixup, aString);
           value.Truncate();
           didSystemFont = true;
         }
 
         // That we output the system font is enough for this property if:
         //   (1) it's the hidden system font subproperty (which either
         //       means we output it or we don't have it), or
         //   (2) its value is the hidden system font value and it matches
@@ -1164,33 +1208,33 @@ nsCSSDeclaration::ToString(nsAString& aS
           doneProperty = true;
         }
       }
     }
     if (doneProperty)
       continue;
     
     NS_ASSERTION(value.IsEmpty(), "value should be empty now");
-    AppendPropertyAndValueToString(property, value, aString);
+    AppendPropertyAndValueToString(property, value, aFixup, aString);
   }
   if (! aString.IsEmpty()) {
     // if the string is not empty, we have a trailing whitespace we should remove
     aString.Truncate(aString.Length() - 1);
   }
   return NS_OK;
 }
 
 #ifdef DEBUG
 void nsCSSDeclaration::List(FILE* out, PRInt32 aIndent) const
 {
   for (PRInt32 index = aIndent; --index >= 0; ) fputs("  ", out);
 
   fputs("{ ", out);
   nsAutoString s;
-  ToString(s);
+  ToString(nullptr, s);
   fputs(NS_ConvertUTF16toUTF8(s).get(), out);
   fputs("}", out);
 }
 #endif
 
 nsresult
 nsCSSDeclaration::GetNthProperty(PRUint32 aIndex, nsAString& aReturn) const
 {
diff --git a/layout/style/nsCSSDeclaration.h b/layout/style/nsCSSDeclaration.h
--- a/layout/style/nsCSSDeclaration.h
+++ b/layout/style/nsCSSDeclaration.h
@@ -50,16 +50,18 @@
 #include "nsString.h"
 #include "nsCoord.h"
 #include "nsCSSValue.h"
 #include "nsCSSProps.h"
 #include "nsTArray.h"
 #include "nsCSSDataBlock.h"
 #include "nsCSSStruct.h"
 
+class nsIDocumentEncoderFixup;
+
 class nsCSSDeclaration {
 public:
   /**
    * Construct an |nsCSSDeclaration| that is in an invalid state (null
    * |mData|) and cannot be used until its |CompressFrom| method or
    * |InitializeEmpty| method is called.
    */
   nsCSSDeclaration();
@@ -71,28 +73,31 @@ public:
    * |mOrder| whenever a property is parsed into an expanded data block
    * for this declaration.  aProperty must not be a shorthand.
    */
   nsresult ValueAppended(nsCSSProperty aProperty);
 
   nsresult AppendComment(const nsAString& aComment);
   nsresult RemoveProperty(nsCSSProperty aProperty);
 
-  nsresult GetValue(nsCSSProperty aProperty, nsAString& aValue) const;
+  nsresult GetValue(nsCSSProperty aProperty,
+                    nsIDocumentEncoderFixup *aFixup,
+                    nsAString& aValue) const;
 
   bool HasImportantData() const { return mImportantData != nullptr; }
   bool GetValueIsImportant(nsCSSProperty aProperty) const;
   bool GetValueIsImportant(const nsAString& aProperty) const;
 
   PRUint32 Count() const {
     return mOrder.Length(); 
   }
   nsresult GetNthProperty(PRUint32 aIndex, nsAString& aReturn) const;
 
-  nsresult ToString(nsAString& aString) const;
+  nsresult ToString(nsIDocumentEncoderFixup *aFixup,
+                    nsAString& aString) const;
 
   nsCSSDeclaration* Clone() const;
 
   nsresult MapRuleInfoInto(nsRuleData *aRuleData) const {
     return mData->MapRuleInfoInto(aRuleData);
   }
 
   nsresult MapImportantRuleInfoInto(nsRuleData *aRuleData) const {
@@ -168,29 +173,33 @@ public:
 
 #ifdef DEBUG
   void List(FILE* out = stdout, PRInt32 aIndent = 0) const;
 #endif
   
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
   static bool AppendCSSValueToString(nsCSSProperty aProperty,
                                        const nsCSSValue& aValue,
+                                       nsIDocumentEncoderFixup *aFixup,
                                        nsAString& aResult);
 
 private:
   // Not implemented, and not supported.
   nsCSSDeclaration& operator=(const nsCSSDeclaration& aCopy);
   bool operator==(const nsCSSDeclaration& aCopy) const;
 
   static void AppendImportanceToString(bool aIsImportant, nsAString& aString);
   // return whether there was a value in |aValue| (i.e., it had a non-null unit)
-  bool     AppendValueToString(nsCSSProperty aProperty, nsAString& aResult) const;
+  bool     AppendValueToString(nsCSSProperty aProperty,
+                               nsIDocumentEncoderFixup *aFixup,
+                               nsAString& aResult) const;
   // Helper for ToString with strange semantics regarding aValue.
   void     AppendPropertyAndValueToString(nsCSSProperty aProperty,
                                           nsAutoString& aValue,
+                                          nsIDocumentEncoderFixup *aFixup,
                                           nsAString& aResult) const;
 
 private:
     //
     // Specialized ref counting.
     // We do not want everyone to ref count us, only the rules which hold
     //  onto us (our well defined lifetime is when the last rule releases
     //  us).
diff --git a/layout/style/nsCSSRules.cpp b/layout/style/nsCSSRules.cpp
--- a/layout/style/nsCSSRules.cpp
+++ b/layout/style/nsCSSRules.cpp
@@ -198,16 +198,18 @@ public:
   // nsIStyleRule methods
 #ifdef DEBUG
   NS_IMETHOD List(FILE* out = stdout, PRInt32 aIndent = 0) const;
 #endif
 
   // nsICSSRule methods
   NS_IMETHOD GetType(PRInt32& aType) const;
   NS_IMETHOD Clone(nsICSSRule*& aClone) const;
+  NS_IMETHOD Serialize(nsAString& aCssText,
+                       nsIDocumentEncoderFixup *aFixup);
 
   // nsIDOMCSSRule interface
   NS_DECL_NSIDOMCSSRULE
   
   // nsIDOMCSSCharsetRule methods
   NS_IMETHOD GetEncoding(nsAString& aEncoding);
   NS_IMETHOD SetEncoding(const nsAString& aEncoding);
 
@@ -275,16 +277,24 @@ CSSCharsetRuleImpl::Clone(nsICSSRule*& a
   if (clone) {
     return CallQueryInterface(clone, &aClone);
   }
   aClone = nullptr;
   return NS_ERROR_OUT_OF_MEMORY;
 }
 
 NS_IMETHODIMP
+CSSCharsetRuleImpl::Serialize(nsAString& aCssText,
+                              nsIDocumentEncoderFixup *aFixup)
+{
+  // FIXME: WRITE ME!
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
 CSSCharsetRuleImpl::GetEncoding(nsAString& aEncoding)
 {
   aEncoding = mEncoding;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 CSSCharsetRuleImpl::SetEncoding(const nsAString& aEncoding)
@@ -375,16 +385,18 @@ public:
   // nsIStyleRule methods
 #ifdef DEBUG
   NS_IMETHOD List(FILE* out = stdout, PRInt32 aIndent = 0) const;
 #endif
 
   // nsICSSRule methods
   NS_IMETHOD GetType(PRInt32& aType) const;
   NS_IMETHOD Clone(nsICSSRule*& aClone) const;
+  NS_IMETHOD Serialize(nsAString& aCssText,
+                       nsIDocumentEncoderFixup *aFixup);
 
   // nsICSSImportRule methods
   NS_IMETHOD SetURLSpec(const nsString& aURLSpec);
   NS_IMETHOD GetURLSpec(nsString& aURLSpec) const;
 
   NS_IMETHOD SetMedia(const nsString& aMedia);
   NS_IMETHOD GetMedia(nsString& aMedia) const;
 
@@ -482,16 +494,24 @@ CSSImportRuleImpl::Clone(nsICSSRule*& aC
   if (clone) {
     return CallQueryInterface(clone, &aClone);
   }
   aClone = nullptr;
   return NS_ERROR_OUT_OF_MEMORY;
 }
 
 NS_IMETHODIMP
+CSSImportRuleImpl::Serialize(nsAString& aCssText,
+                             nsIDocumentEncoderFixup *aFixup)
+{
+  // FIXME: WRITE ME!
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
 CSSImportRuleImpl::SetURLSpec(const nsString& aURLSpec)
 {
   mURLSpec = aURLSpec;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 CSSImportRuleImpl::GetURLSpec(nsString& aURLSpec) const
@@ -971,16 +991,24 @@ nsCSSMediaRule::Clone(nsICSSRule*& aClon
   nsCSSMediaRule* clone = new nsCSSMediaRule(*this);
   if (clone) {
     return CallQueryInterface(clone, &aClone);
   }
   aClone = nullptr;
   return NS_ERROR_OUT_OF_MEMORY;
 }
 
+NS_IMETHODIMP
+nsCSSMediaRule::Serialize(nsAString& aCssText,
+                          nsIDocumentEncoderFixup *aFixup)
+{
+  // FIXME: WRITE ME!
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
 nsresult
 nsCSSMediaRule::SetMedia(nsMediaList* aMedia)
 {
   mMedia = aMedia;
   if (aMedia)
     mMedia->SetStyleSheet(mSheet);
   return NS_OK;
 }
@@ -1141,16 +1169,24 @@ nsCSSDocumentRule::Clone(nsICSSRule*& aC
   nsCSSDocumentRule* clone = new nsCSSDocumentRule(*this);
   if (clone) {
     return CallQueryInterface(clone, &aClone);
   }
   aClone = nullptr;
   return NS_ERROR_OUT_OF_MEMORY;
 }
 
+NS_IMETHODIMP
+nsCSSDocumentRule::Serialize(nsAString& aCssText,
+                             nsIDocumentEncoderFixup *aFixup)
+{
+  // FIXME: WRITE ME!
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
 // nsIDOMCSSRule methods
 NS_IMETHODIMP
 nsCSSDocumentRule::GetType(PRUint16* aType)
 {
   // XXX What should really happen here?
   *aType = nsIDOMCSSRule::UNKNOWN_RULE;
   return NS_OK;
 }
@@ -1280,16 +1316,18 @@ public:
   // nsIStyleRule methods
 #ifdef DEBUG
   NS_IMETHOD List(FILE* out = stdout, PRInt32 aIndent = 0) const;
 #endif
 
   // nsICSSRule methods
   NS_IMETHOD GetType(PRInt32& aType) const;
   NS_IMETHOD Clone(nsICSSRule*& aClone) const;
+  NS_IMETHOD Serialize(nsAString& aCssText,
+                       nsIDocumentEncoderFixup *aFixup);
 
   // nsICSSNameSpaceRule methods
   NS_IMETHOD GetPrefix(nsIAtom*& aPrefix) const;
   NS_IMETHOD SetPrefix(nsIAtom* aPrefix);
 
   NS_IMETHOD GetURLSpec(nsString& aURLSpec) const;
   NS_IMETHOD SetURLSpec(const nsString& aURLSpec);
 
@@ -1373,16 +1411,24 @@ CSSNameSpaceRuleImpl::Clone(nsICSSRule*&
   if (clone) {
     return CallQueryInterface(clone, &aClone);
   }
   aClone = nullptr;
   return NS_ERROR_OUT_OF_MEMORY;
 }
 
 NS_IMETHODIMP
+CSSNameSpaceRuleImpl::Serialize(nsAString& aCssText,
+                                nsIDocumentEncoderFixup *aFixup)
+{
+  // FIXME: WRITE ME!
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
 CSSNameSpaceRuleImpl::GetPrefix(nsIAtom*& aPrefix) const
 {
   aPrefix = mPrefix;
   NS_IF_ADDREF(aPrefix);
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -1583,30 +1629,35 @@ nsCSSFontFaceStyleDecl::GetPropertyValue
       NS_ASSERTION(val.GetUnit() == eCSSUnit_String, "unexpected unit");
       nsDependentString family(val.GetStringBufferValue());
       nsStyleUtil::AppendEscapedCSSString(family, aResult);
       return NS_OK;
     }
 
   case eCSSFontDesc_Style:
     nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_font_style, val,
-                                             aResult);
+                                             nullptr, aResult);
     return NS_OK;
 
   case eCSSFontDesc_Weight:
     nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_font_weight, val,
-                                             aResult);
+                                             nullptr, aResult);
     return NS_OK;
     
   case eCSSFontDesc_Stretch:
     nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_font_stretch, val,
-                                             aResult);
+                                             nullptr, aResult);
     return NS_OK;
 
   case eCSSFontDesc_Src:
+    // FIXME: When we're serializing for save page as, complete, we need
+    // to get the nsIDocumentEncoderFixup passed through to here so we
+    // can give it to AppendSerializedFontSrc (at which point we could
+    // pass it to the AppendCSSValueToString calls above, for
+    // completeness).
     AppendSerializedFontSrc(val, aResult);
     return NS_OK;
 
   case eCSSFontDesc_UnicodeRange:
     // these are not implemented, so always return an empty string
     return NS_OK;
 
   case eCSSFontDesc_UNKNOWN:
@@ -1823,16 +1874,24 @@ nsCSSFontFaceRule::GetType(PRInt32& aTyp
 NS_IMETHODIMP
 nsCSSFontFaceRule::GetType(PRUint16* aType)
 {
   *aType = nsIDOMCSSRule::FONT_FACE_RULE;
   return NS_OK;
 }
 
 NS_IMETHODIMP
+nsCSSFontFaceRule::Serialize(nsAString& aCssText,
+                             nsIDocumentEncoderFixup *aFixup)
+{
+  // FIXME: WRITE ME!
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
 nsCSSFontFaceRule::GetCssText(nsAString& aCssText)
 {
   nsAutoString propText;
   mDecl.GetCssText(propText);
 
   aCssText.AssignLiteral("@font-face {\n");
   aCssText.Append(propText);
   aCssText.Append('}');
diff --git a/layout/style/nsCSSRules.h b/layout/style/nsCSSRules.h
--- a/layout/style/nsCSSRules.h
+++ b/layout/style/nsCSSRules.h
@@ -131,16 +131,18 @@ public:
   NS_IMETHOD SetStyleSheet(nsICSSStyleSheet* aSheet); //override nsCSSGroupRule
   NS_IMETHOD GetType(PRInt32& aType) const;
   NS_IMETHOD Clone(nsICSSRule*& aClone) const;
   nsIDOMCSSRule* GetDOMRuleWeak(nsresult *aResult)
   {
     *aResult = NS_OK;
     return this;
   }
+  NS_IMETHOD Serialize(nsAString& aCssText,
+                       nsIDocumentEncoderFixup *aFixup);
 
   // nsIDOMCSSRule interface
   NS_DECL_NSIDOMCSSRULE
 
   // nsIDOMCSSMediaRule interface
   NS_DECL_NSIDOMCSSMEDIARULE
 
   // rest of nsICSSGroupRule interface
@@ -172,16 +174,18 @@ public:
   // nsICSSRule methods
   NS_IMETHOD GetType(PRInt32& aType) const;
   NS_IMETHOD Clone(nsICSSRule*& aClone) const;
   nsIDOMCSSRule* GetDOMRuleWeak(nsresult *aResult)
   {
     *aResult = NS_OK;
     return this;
   }
+  NS_IMETHOD Serialize(nsAString& aCssText,
+                       nsIDocumentEncoderFixup *aFixup);
 
   // nsIDOMCSSRule interface
   NS_DECL_NSIDOMCSSRULE
 
   // nsIDOMCSSMozDocumentRule interface
   NS_DECL_NSIDOMCSSMOZDOCUMENTRULE
 
   // rest of nsICSSGroupRule interface
@@ -258,16 +262,18 @@ public:
   NS_IMETHOD List(FILE* out = stdout, PRInt32 aIndent = 0) const;
 #endif
 
   // nsICSSRule methods
   DECL_STYLE_RULE_INHERIT
 
   NS_IMETHOD GetType(PRInt32& aType) const;
   NS_IMETHOD Clone(nsICSSRule*& aClone) const;
+  NS_IMETHOD Serialize(nsAString& aCssText,
+                       nsIDocumentEncoderFixup *aFixup);
 
   // nsIDOMCSSRule interface
   NS_DECL_NSIDOMCSSRULE
 
   // nsIDOMCSSFontFaceRule interface
   NS_DECL_NSIDOMCSSFONTFACERULE
 
   void SetDesc(nsCSSFontDesc aDescID, nsCSSValue const & aValue);
diff --git a/layout/style/nsCSSStyleRule.cpp b/layout/style/nsCSSStyleRule.cpp
--- a/layout/style/nsCSSStyleRule.cpp
+++ b/layout/style/nsCSSStyleRule.cpp
@@ -1215,16 +1215,19 @@ public:
   virtual nsresult GetSelectorText(nsAString& aSelectorText);
   virtual nsresult SetSelectorText(const nsAString& aSelectorText);
 
   NS_IMETHOD GetType(PRInt32& aType) const;
   NS_IMETHOD Clone(nsICSSRule*& aClone) const;
 
   nsIDOMCSSRule* GetDOMRuleWeak(nsresult* aResult);
 
+  NS_IMETHOD Serialize(nsAString& aCssText,
+                       nsIDocumentEncoderFixup *aFixup);
+
   virtual already_AddRefed<nsICSSStyleRule>
     DeclarationChanged(bool aHandleContainer);
 
   // The new mapping function.
   NS_IMETHOD MapRuleInfoInto(nsRuleData* aRuleData);
 
 #ifdef DEBUG
   NS_IMETHOD List(FILE* out = stdout, PRInt32 aIndent = 0) const;
@@ -1422,16 +1425,24 @@ CSSStyleRuleImpl::GetDOMRuleWeak(nsresul
       *aResult = NS_ERROR_OUT_OF_MEMORY;
       return nullptr;
     }
     NS_ADDREF(mDOMRule);
   }
   return mDOMRule;
 }
 
+NS_IMETHODIMP
+CSSStyleRuleImpl::Serialize(nsAString& aCssText,
+                            nsIDocumentEncoderFixup *aFixup)
+{
+  // FIXME: WRITE ME!
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
 /* virtual */ already_AddRefed<nsICSSStyleRule>
 CSSStyleRuleImpl::DeclarationChanged(bool aHandleContainer)
 {
   CSSStyleRuleImpl* clone = new CSSStyleRuleImpl(*this, mDeclaration);
   if (!clone) {
     return nullptr;
   }
 
@@ -1484,21 +1495,20 @@ CSSStyleRuleImpl::List(FILE* out, PRInt3
 CSSStyleRuleImpl::GetCssText(nsAString& aCssText)
 {
   if (mSelector) {
     mSelector->ToString(aCssText, mSheet);
     aCssText.Append(char16_t(' '));
   }
   aCssText.Append(char16_t('{'));
   aCssText.Append(char16_t(' '));
-  if (mDeclaration)
-  {
-    nsAutoString   tempString;
-    mDeclaration->ToString( tempString );
-    aCssText.Append( tempString );
+  if (mDeclaration) {
+    nsAutoString tempString;
+    mDeclaration->ToString(nullptr, tempString);
+    aCssText.Append(tempString);
   }
   aCssText.Append(char16_t(' '));
   aCssText.Append(char16_t('}'));
   return NS_OK;
 }
 
 /* virtual */ nsresult    
 CSSStyleRuleImpl::SetCssText(const nsAString& aCssText)
diff --git a/layout/style/CSSStyleSheet.cpp b/layout/style/CSSStyleSheet.cpp
--- a/layout/style/CSSStyleSheet.cpp
+++ b/layout/style/CSSStyleSheet.cpp
@@ -412,42 +412,46 @@ nsMediaQuery::AppendToString(nsAString& 
     if (expr.mValue.GetUnit() != eCSSUnit_Null) {
       aString.AppendLiteral(": ");
       switch (feature->mValueType) {
         case nsMediaFeature::eLength:
           NS_ASSERTION(expr.mValue.IsLengthUnit(), "bad unit");
           // Use 'width' as a property that takes length values
           // written in the normal way.
           nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_width,
-                                                   expr.mValue, aString);
+                                                   expr.mValue, nullptr,
+                                                   aString);
           break;
         case nsMediaFeature::eInteger:
         case nsMediaFeature::eBoolInteger:
           NS_ASSERTION(expr.mValue.GetUnit() == eCSSUnit_Integer,
                        "bad unit");
           // Use 'z-index' as a property that takes integer values
           // written without anything extra.
           nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
-                                                   expr.mValue, aString);
+                                                   expr.mValue, nullptr,
+                                                   aString);
           break;
         case nsMediaFeature::eIntRatio:
           {
             NS_ASSERTION(expr.mValue.GetUnit() == eCSSUnit_Array,
                          "bad unit");
             nsCSSValue::Array *array = expr.mValue.GetArrayValue();
             NS_ASSERTION(array->Count() == 2, "unexpected length");
             NS_ASSERTION(array->Item(0).GetUnit() == eCSSUnit_Integer,
                          "bad unit");
             NS_ASSERTION(array->Item(1).GetUnit() == eCSSUnit_Integer,
                          "bad unit");
             nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
-                                                     array->Item(0), aString);
+                                                     array->Item(0), nullptr,
+                                                     aString);
             aString.AppendLiteral("/");
             nsCSSDeclaration::AppendCSSValueToString(eCSSProperty_z_index,
-                                                     array->Item(1), aString);
+                                                     array->Item(1), nullptr,
+                                                     aString);
           }
           break;
         case nsMediaFeature::eResolution:
           buffer.AppendFloat(expr.mValue.GetFloatValue());
           aString.Append(buffer);
           buffer.Truncate();
           if (expr.mValue.GetUnit() == eCSSUnit_Inch) {
             aString.AppendLiteral("dpi");
@@ -1259,16 +1263,36 @@ CSSStyleSheet::SetOwningDocument(nsIDo
     if (child->mParent == this) {
       child->SetOwningDocument(aDocument);
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
+CSSStyleSheet::Serialize(nsAString& aContent, nsIDocumentEncoderFixup *aFixup)
+{
+  nsresult rv;
+
+  PRInt32 styleRules = 0;
+  StyleRuleCount(styleRules);
+  for (PRInt32 i = 0; i < styleRules; ++i) {
+    nsCOMPtr<nsICSSRule> rule;
+    rv = GetStyleRuleAt(i, *getter_AddRefs(rule));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsAutoString ruleText;
+    rule->Serialize(ruleText, aFixup);
+    aContent.Append(ruleText);
+    aContent.Append(NS_LITERAL_STRING("\n"));
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 CSSStyleSheet::SetOwningNode(nsIDOMNode* aOwningNode)
 { // not ref counted
   mOwningNode = aOwningNode;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 CSSStyleSheet::SetOwnerRule(nsICSSImportRule* aOwnerRule)
diff --git a/layout/style/CSSStyleSheet.h b/layout/style/CSSStyleSheet.h
--- a/layout/style/CSSStyleSheet.h
+++ b/layout/style/CSSStyleSheet.h
@@ -52,16 +52,17 @@
 #include "nsICSSLoaderObserver.h"
 #include "nsTArray.h"
 #include "nsCOMArray.h"
 
 class nsIURI;
 class nsMediaList;
 class nsMediaQueryResultCacheKey;
 class CSSStyleSheet;
+class nsIDocumentEncoderFixup;
 
 // -------------------------------
 // CSS Style Sheet Inner Data Container
 //
 
 class CSSStyleSheetInner {
 public:
   CSSStyleSheetInner(nsICSSStyleSheet* aPrimarySheet);
@@ -162,16 +163,17 @@ public:
                    nsICSSStyleSheet** aClone) const;
   NS_IMETHOD IsModified(bool* aSheetModified) const;
   NS_IMETHOD SetModified(bool aModified);
   NS_IMETHOD AddRuleProcessor(nsCSSRuleProcessor* aProcessor);
   NS_IMETHOD DropRuleProcessor(nsCSSRuleProcessor* aProcessor);
   NS_IMETHOD InsertRuleInternal(const nsAString& aRule,
                                 PRUint32 aIndex, PRUint32* aReturn);
   NS_IMETHOD_(nsIURI*) GetOriginalURI() const;
+  NS_IMETHOD Serialize(nsAString& aContent, nsIDocumentEncoderFixup *aFixup);
 
   // nsICSSLoaderObserver interface
   NS_IMETHOD StyleSheetLoaded(nsICSSStyleSheet* aSheet, bool aWasAlternate,
                               nsresult aStatus);
   
   nsresult EnsureUniqueInner();
 
   bool UseForPresentation(nsPresContext* aPresContext,
diff --git a/layout/style/nsDOMCSSDeclaration.cpp b/layout/style/nsDOMCSSDeclaration.cpp
--- a/layout/style/nsDOMCSSDeclaration.cpp
+++ b/layout/style/nsDOMCSSDeclaration.cpp
@@ -81,17 +81,17 @@ nsDOMCSSDeclaration::GetPropertyValue(co
   NS_PRECONDITION(aPropID != eCSSProperty_UNKNOWN,
                   "Should never pass eCSSProperty_UNKNOWN around");
   
   nsCSSDeclaration *decl;
   nsresult result = GetCSSDeclaration(&decl, false);
 
   aValue.Truncate();
   if (decl) {
-    result = decl->GetValue(aPropID, aValue);
+    result = decl->GetValue(aPropID, nullptr, aValue);
   }
 
   return result;
 }
 
 NS_IMETHODIMP
 nsDOMCSSDeclaration::SetPropertyValue(const nsCSSProperty aPropID,
                                       const nsAString& aValue)
@@ -109,17 +109,17 @@ nsDOMCSSDeclaration::SetPropertyValue(co
 NS_IMETHODIMP
 nsDOMCSSDeclaration::GetCssText(nsAString& aCssText)
 {
   nsCSSDeclaration* decl;
   aCssText.Truncate();
   GetCSSDeclaration(&decl, false);
 
   if (decl) {
-    decl->ToString(aCssText);
+    decl->ToString(nullptr, aCssText);
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDOMCSSDeclaration::SetCssText(const nsAString& aCssText)
 {
diff --git a/layout/style/nsICSSRule.h b/layout/style/nsICSSRule.h
--- a/layout/style/nsICSSRule.h
+++ b/layout/style/nsICSSRule.h
@@ -41,21 +41,22 @@
 #define nsICSSRule_h___
 
 #include "nsIStyleRule.h"
 #include "nsIDOMCSSRule.h"
 
 class nsICSSStyleSheet;
 class nsICSSGroupRule;
 class nsAString;
+class nsIDocumentEncoderFixup;
 
-// IID for the nsICSSRule interface {98d426f7-2ef9-44f5-8d06-e064f486a18c}
+// 57f1dee6-8d31-4709-8d36-8ea4a7ae59d9
 #define NS_ICSS_RULE_IID     \
-{ 0x98d426f7, 0x2ef9, 0x44f5, \
- { 0x8d, 0x06, 0xe0, 0x64, 0xf4, 0x86, 0xa1, 0x8c } }
+{ 0x57f1dee6, 0x8d31, 0x4709, \
+  { 0x8d, 0x36, 0x8e, 0xa4, 0xa7, 0xae, 0x59, 0xd9 } }
 
 // inheriting from nsIStyleRule is only for style rules, not other rule types
 class nsICSSRule : public nsIStyleRule {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICSS_RULE_IID)
   // The constants in this list must maintain the following invariants:
   //   If a rule of type N must appear before a rule of type M in stylesheets
   //   then N < M
@@ -85,16 +86,19 @@ public:
   // supposed to have a DOM rule representation (and our code wouldn't work).
   nsresult GetDOMRule(nsIDOMCSSRule** aDOMRule)
   {
     nsresult rv;
     NS_IF_ADDREF(*aDOMRule = GetDOMRuleWeak(&rv));
     return rv;
   }
   virtual nsIDOMCSSRule* GetDOMRuleWeak(nsresult* aResult) = 0;
+
+  NS_IMETHOD Serialize(nsAString& aCssText,
+                       nsIDocumentEncoderFixup *aFixup) = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsICSSRule, NS_ICSS_RULE_IID)
 
 /* Define global NS_New* functions for rules that don't need their own
    interfaces here */
 nsresult
 NS_NewCSSCharsetRule(nsICSSRule** aInstancePtrResult,
diff --git a/layout/style/nsICSSStyleSheet.h b/layout/style/nsICSSStyleSheet.h
--- a/layout/style/nsICSSStyleSheet.h
+++ b/layout/style/nsICSSStyleSheet.h
@@ -46,22 +46,22 @@
 class nsICSSRule;
 class nsIDOMNode;
 class nsXMLNameSpaceMap;
 class nsCSSRuleProcessor;
 class nsMediaList;
 class nsICSSGroupRule;
 class nsICSSImportRule;
 class nsIPrincipal;
+class nsIDocumentEncoderFixup;
 
-// IID for the nsICSSStyleSheet interface
-// ba09b3a4-4a29-495d-987b-cfbb58c5c6ec
+// dd024df4-d23b-4be5-a6fa-d4a192c88857
 #define NS_ICSS_STYLE_SHEET_IID     \
-{ 0xba09b3a4, 0x4a29, 0x495d, \
- { 0x98, 0x7b, 0xcf, 0xbb, 0x58, 0xc5, 0xc6, 0xec } }
+{ 0xdd024df4, 0xd23b, 0x4be5, \
+  { 0xa6, 0xfa, 0xd4, 0xa1, 0x92, 0xc8, 0x88, 0x57 } }
 
 class nsICSSStyleSheet : public nsIStyleSheet {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICSS_STYLE_SHEET_IID)
 
   NS_IMETHOD  AppendStyleSheet(nsICSSStyleSheet* aSheet) = 0;
   NS_IMETHOD  InsertStyleSheetAt(nsICSSStyleSheet* aSheet, PRInt32 aIndex) = 0;
 
@@ -124,16 +124,19 @@ public:
    * Like the DOM insertRule() method, but doesn't do any security checks
    */
   NS_IMETHOD InsertRuleInternal(const nsAString& aRule,
                                 PRUint32 aIndex, PRUint32* aReturn) = 0;
 
   /* Get the URI this sheet was originally loaded from, if any.  Can
      return null */
   NS_IMETHOD_(nsIURI*) GetOriginalURI() const = 0;
+
+  NS_IMETHOD Serialize(nsAString& aContent,
+                       nsIDocumentEncoderFixup *aFixup) = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsICSSStyleSheet, NS_ICSS_STYLE_SHEET_IID)
 
 nsresult
 NS_NewCSSStyleSheet(nsICSSStyleSheet** aInstancePtrResult);
 
 #endif /* nsICSSStyleSheet_h___ */
