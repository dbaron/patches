From: L. David Baron <dbaron@dbaron.org>

Require whitespace around 'not', 'and', and 'or' keywords in @supports rules.

Matches spec change in https://dvcs.w3.org/hg/csswg/rev/34b185ae3bac .

diff --git a/dom/locales/en-US/chrome/layout/css.properties b/dom/locales/en-US/chrome/layout/css.properties
--- a/dom/locales/en-US/chrome/layout/css.properties
+++ b/dom/locales/en-US/chrome/layout/css.properties
@@ -114,13 +114,14 @@ PEMQNoMinMaxWithoutValue=Media features 
 PEMQExpectedFeatureValue=Found invalid value for media feature.
 PEBadFontBlockStart=Expected '{' to begin @font-face rule but found '%1$S'.
 PEBadFontBlockEnd=Expected '}' to end @font-face rule but found '%1$S'.
 PEAnonBoxNotAlone=Did not expect anonymous box.
 PEBadDirValue=Expected 'ltr' or 'rtl' in direction selector but found '%1$S'.
 PESupportsConditionStartEOF2='not', '(', or function
 PESupportsConditionInParensEOF=')'
 PESupportsConditionNotEOF='not'
+PESupportsWhitespaceRequired=Expected whitespace after 'not', 'and', or 'or'.
 PESupportsConditionExpectedOpenParenOrFunction=Expected '(' or function while parsing supports condition but found '%1$S'.
 PESupportsConditionExpectedCloseParen=Expected ')' while parsing supports condition but found '%1$S'.
 PESupportsConditionExpectedStart2=Expected 'not', '(', or function while parsing supports condition but found '%1$S'.
 PESupportsConditionExpectedNot=Expected 'not' while parsing supports condition but found '%1$S'.
 PESupportsGroupRuleStart=Expected '{' to begin @supports rule but found '%1$S'.
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -2587,16 +2587,21 @@ CSSParserImpl::ParseSupportsConditionNeg
   }
 
   if (mToken.mType != eCSSToken_Ident ||
       !mToken.mIdent.LowerCaseEqualsLiteral("not")) {
     REPORT_UNEXPECTED_TOKEN(PESupportsConditionExpectedNot);
     return false;
   }
 
+  if (!RequireWhitespace()) {
+    REPORT_UNEXPECTED(PESupportsWhitespaceRequired);
+    return false;
+  }
+
   if (ParseSupportsConditionInParens(aConditionMet)) {
     aConditionMet = !aConditionMet;
     return true;
   }
 
   return false;
 }
 
@@ -2706,17 +2711,17 @@ CSSParserImpl::ParseSupportsConditionInP
 // supports_condition_terms
 //   : 'and' S* supports_condition_terms_after_operator('and')
 //   | 'or' S* supports_condition_terms_after_operator('or')
 //   |
 //   ;
 bool
 CSSParserImpl::ParseSupportsConditionTerms(bool& aConditionMet)
 {
-  if (!GetToken(true)) {
+  if (!RequireWhitespace() || !GetToken(false)) {
     return true;
   }
 
   if (mToken.mType != eCSSToken_Ident) {
     UngetToken();
     return true;
   }
 
@@ -2735,16 +2740,21 @@ CSSParserImpl::ParseSupportsConditionTer
 // supports_condition_terms_after_operator(operator)
 //   : supports_condition_in_parens ( <operator> supports_condition_in_parens )*
 //   ;
 bool
 CSSParserImpl::ParseSupportsConditionTermsAfterOperator(
                          bool& aConditionMet,
                          CSSParserImpl::SupportsConditionTermOperator aOperator)
 {
+  if (!RequireWhitespace()) {
+    REPORT_UNEXPECTED(PESupportsWhitespaceRequired);
+    return false;
+  }
+
   const char* token = aOperator == eAnd ? "and" : "or";
   for (;;) {
     bool termConditionMet = false;
     if (!ParseSupportsConditionInParens(termConditionMet)) {
       return false;
     }
     aConditionMet = aOperator == eAnd ? aConditionMet && termConditionMet :
                                         aConditionMet || termConditionMet;
