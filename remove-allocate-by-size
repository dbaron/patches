From: L. David Baron <dbaron@dbaron.org>

Bug 1367190 patch 2 - Remove nsPresArena::AllocateBySize, nsIPresShell::AllocateMisc, and nsPresContext::AllocateFromShell.  r=mats

MozReview-Commit-ID: l2UQC7qOQ0

diff --git a/layout/base/ArenaObjectID.h b/layout/base/ArenaObjectID.h
--- a/layout/base/ArenaObjectID.h
+++ b/layout/base/ArenaObjectID.h
@@ -15,22 +15,14 @@ namespace mozilla {
 enum ArenaObjectID {
   eArenaObjectID_DummyBeforeFirstObjectID = nsQueryFrame::NON_FRAME_MARKER - 1,
 
 #define PRES_ARENA_OBJECT(name_) \
   eArenaObjectID_##name_,
 #include "nsPresArenaObjectList.h"
 #undef PRES_ARENA_OBJECT
 
-  /**
-   * The PresArena implementation uses this bit to distinguish objects
-   * allocated by size from objects allocated by type ID (that is, frames
-   * using AllocateByFrameID and other objects using AllocateByObjectID).
-   * It should not collide with any Object ID (above) or frame ID (in
-   * nsQueryFrame.h).  It is not 0x80000000 to avoid the question of
-   * whether enumeration constants are signed.
-   */
-  eArenaObjectID_NON_OBJECT_MARKER = 0x40000000
+  eArenaObjectID_COUNT
 };
 
 };
 
 #endif
diff --git a/layout/base/nsIPresShell.h b/layout/base/nsIPresShell.h
--- a/layout/base/nsIPresShell.h
+++ b/layout/base/nsIPresShell.h
@@ -240,39 +240,16 @@ public:
 
   void FreeByObjectID(mozilla::ArenaObjectID aID, void* aPtr)
   {
     RecordFree(aPtr);
     if (!mIsDestroying)
       mFrameArena.FreeByObjectID(aID, aPtr);
   }
 
-  /**
-   * Other objects closely related to the frame tree that are allocated
-   * from a separate set of per-size free lists.  Note that different types
-   * of objects that has the same size are allocated from the same list.
-   * AllocateMisc does *not* clear the memory that it returns.
-   * AllocateMisc is infallible and will abort on out-of-memory.
-   *
-   * @deprecated use AllocateByObjectID/FreeByObjectID instead
-   */
-  void* AllocateMisc(size_t aSize)
-  {
-    void* result = mFrameArena.AllocateBySize(aSize);
-    RecordAlloc(result);
-    return result;
-  }
-
-  void FreeMisc(size_t aSize, void* aPtr)
-  {
-    RecordFree(aPtr);
-    if (!mIsDestroying)
-      mFrameArena.FreeBySize(aSize, aPtr);
-  }
-
   template<typename T>
   void RegisterArenaRefPtr(mozilla::ArenaRefPtr<T>* aPtr)
   {
     mFrameArena.RegisterArenaRefPtr(aPtr);
   }
 
   template<typename T>
   void DeregisterArenaRefPtr(mozilla::ArenaRefPtr<T>* aPtr)
diff --git a/layout/base/nsPresArena.h b/layout/base/nsPresArena.h
--- a/layout/base/nsPresArena.h
+++ b/layout/base/nsPresArena.h
@@ -25,30 +25,16 @@
 struct nsArenaMemoryStats;
 
 class nsPresArena {
 public:
   nsPresArena();
   ~nsPresArena();
 
   /**
-   * Pool allocation with recycler lists indexed by object size, aSize.
-   */
-  void* AllocateBySize(size_t aSize)
-  {
-    return Allocate(uint32_t(aSize) |
-                    uint32_t(mozilla::eArenaObjectID_NON_OBJECT_MARKER), aSize);
-  }
-  void FreeBySize(size_t aSize, void* aPtr)
-  {
-    Free(uint32_t(aSize) |
-         uint32_t(mozilla::eArenaObjectID_NON_OBJECT_MARKER), aPtr);
-  }
-
-  /**
    * Pool allocation with recycler lists indexed by frame-type ID.
    * Every aID must always be used with the same object size, aSize.
    */
   void* AllocateByFrameID(nsQueryFrame::FrameIID aID, size_t aSize)
   {
     return Allocate(aID, aSize);
   }
   void FreeByFrameID(nsQueryFrame::FrameIID aID, void* aPtr)
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -340,30 +340,16 @@ public:
    */
   void EmulateMedium(const nsAString& aMediaType);
 
   /*
    * Restore the viewer's natural medium
    */
   void StopEmulatingMedium();
 
-  void* AllocateFromShell(size_t aSize)
-  {
-    if (mShell)
-      return mShell->AllocateMisc(aSize);
-    return nullptr;
-  }
-
-  void FreeToShell(size_t aSize, void* aFreeChunk)
-  {
-    NS_ASSERTION(mShell, "freeing after shutdown");
-    if (mShell)
-      mShell->FreeMisc(aSize, aFreeChunk);
-  }
-
   /**
    * Get the default font for the given language and generic font ID.
    * If aLanguage is nullptr, the document's language is used.
    *
    * See the comment in StaticPresData::GetDefaultFont.
    */
   const nsFont* GetDefaultFont(uint8_t aFontID,
                                nsIAtom *aLanguage) const
