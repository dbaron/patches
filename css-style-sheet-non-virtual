From: L. David Baron <dbaron@dbaron.org>

Make nsCSSStyleSheet functions that used to be on nsICSSStyleSheet be non-virtual.  (Bug 239008)

diff --git a/layout/style/nsCSSStyleSheet.cpp b/layout/style/nsCSSStyleSheet.cpp
--- a/layout/style/nsCSSStyleSheet.cpp
+++ b/layout/style/nsCSSStyleSheet.cpp
@@ -1069,42 +1069,42 @@ NS_INTERFACE_MAP_BEGIN(nsCSSStyleSheet)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(CSSStyleSheet)
 NS_INTERFACE_MAP_END
 
 
 NS_IMPL_ADDREF(nsCSSStyleSheet)
 NS_IMPL_RELEASE(nsCSSStyleSheet)
 
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::AddRuleProcessor(nsCSSRuleProcessor* aProcessor)
 {
   if (! mRuleProcessors) {
     mRuleProcessors = new nsAutoTArray<nsCSSRuleProcessor*, 8>();
     if (!mRuleProcessors)
       return NS_ERROR_OUT_OF_MEMORY;
   }
   NS_ASSERTION(mRuleProcessors->NoIndex == mRuleProcessors->IndexOf(aProcessor),
                "processor already registered");
   mRuleProcessors->AppendElement(aProcessor); // weak ref
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::DropRuleProcessor(nsCSSRuleProcessor* aProcessor)
 {
   if (!mRuleProcessors)
     return NS_ERROR_FAILURE;
   return mRuleProcessors->RemoveElement(aProcessor)
            ? NS_OK
            : NS_ERROR_FAILURE;
 }
 
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::SetURIs(nsIURI* aSheetURI, nsIURI* aOriginalSheetURI,
                          nsIURI* aBaseURI)
 {
   NS_PRECONDITION(aSheetURI && aBaseURI, "null ptr");
 
   NS_ASSERTION(mInner->mOrderedRules.Count() == 0 && !mInner->mComplete,
                "Can't call SetURL on sheets that are complete or have rules");
 
@@ -1167,17 +1167,17 @@ nsCSSStyleSheet::UseForPresentation(nsPr
 {
   if (mMedia) {
     return mMedia->Matches(aPresContext, aKey);
   }
   return PR_TRUE;
 }
 
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::SetMedia(nsMediaList* aMedia)
 {
   mMedia = aMedia;
   return NS_OK;
 }
 
 NS_IMETHODIMP_(PRBool)
 nsCSSStyleSheet::HasRules() const
@@ -1260,39 +1260,39 @@ nsCSSStyleSheet::SetOwningDocument(nsIDo
        child; child = child->mNext) {
     if (child->mParent == this) {
       child->SetOwningDocument(aDocument);
     }
   }
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::SetOwningNode(nsIDOMNode* aOwningNode)
 { // not ref counted
   mOwningNode = aOwningNode;
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::SetOwnerRule(nsICSSImportRule* aOwnerRule)
 { // not ref counted
   mOwnerRule = aOwnerRule;
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::GetOwnerRule(nsICSSImportRule** aOwnerRule)
 {
   *aOwnerRule = mOwnerRule;
   NS_IF_ADDREF(*aOwnerRule);
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::AppendStyleSheet(nsICSSStyleSheet* aSheet)
 {
   NS_PRECONDITION(nsnull != aSheet, "null arg");
 
   if (NS_SUCCEEDED(WillDirty())) {
     nsCSSStyleSheet* sheet = (nsCSSStyleSheet*)aSheet;
 
     nsRefPtr<nsCSSStyleSheet>* tail = &mInner->mFirstChild;
@@ -1305,17 +1305,17 @@ nsCSSStyleSheet::AppendStyleSheet(nsICSS
     // it's going away.
     sheet->mParent = this;
     sheet->mDocument = mDocument;
     DidDirty();
   }
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::InsertStyleSheetAt(nsICSSStyleSheet* aSheet, PRInt32 aIndex)
 {
   NS_PRECONDITION(nsnull != aSheet, "null arg");
 
   nsresult result = WillDirty();
 
   if (NS_SUCCEEDED(result)) {
     nsCSSStyleSheet* sheet = (nsCSSStyleSheet*)aSheet;
@@ -1332,17 +1332,17 @@ nsCSSStyleSheet::InsertStyleSheetAt(nsIC
     // it's going away.
     sheet->mParent = this;
     sheet->mDocument = mDocument;
     DidDirty();
   }
   return result;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::PrependStyleRule(nsICSSRule* aRule)
 {
   NS_PRECONDITION(nsnull != aRule, "null arg");
 
   if (NS_SUCCEEDED(WillDirty())) {
     mInner->mOrderedRules.InsertObjectAt(aRule, 0);
     aRule->SetStyleSheet(this);
     DidDirty();
@@ -1352,17 +1352,17 @@ nsCSSStyleSheet::PrependStyleRule(nsICSS
     if (nsICSSRule::NAMESPACE_RULE == type) {
       // no api to prepend a namespace (ugh), release old ones and re-create them all
       mInner->RebuildNameSpaces();
     }
   }
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::AppendStyleRule(nsICSSRule* aRule)
 {
   NS_PRECONDITION(nsnull != aRule, "null arg");
 
   if (NS_SUCCEEDED(WillDirty())) {
     mInner->mOrderedRules.AppendObject(aRule);
     aRule->SetStyleSheet(this);
     DidDirty();
@@ -1372,17 +1372,17 @@ nsCSSStyleSheet::AppendStyleRule(nsICSSR
     if (nsICSSRule::NAMESPACE_RULE == type) {
       nsresult rv = RegisterNamespaceRule(aRule);
       NS_ENSURE_SUCCESS(rv, rv);
     }
   }
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::ReplaceStyleRule(nsICSSRule* aOld, nsICSSRule* aNew)
 {
   NS_PRECONDITION(mInner->mOrderedRules.Count() != 0, "can't have old rule");
   NS_PRECONDITION(mInner->mComplete, "No replacing in an incomplete sheet!");
 
   if (NS_SUCCEEDED(WillDirty())) {
     PRInt32 index = mInner->mOrderedRules.IndexOf(aOld);
     NS_ENSURE_TRUE(index != -1, NS_ERROR_UNEXPECTED);
@@ -1397,24 +1397,24 @@ nsCSSStyleSheet::ReplaceStyleRule(nsICSS
     NS_ASSERTION(nsICSSRule::NAMESPACE_RULE != type, "not yet implemented");
     aOld->GetType(type);
     NS_ASSERTION(nsICSSRule::NAMESPACE_RULE != type, "not yet implemented");
 #endif
   }
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::StyleRuleCount(PRInt32& aCount) const
 {
   aCount = mInner->mOrderedRules.Count();
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::GetStyleRuleAt(PRInt32 aIndex, nsICSSRule*& aRule) const
 {
   // Important: If this function is ever made scriptable, we must add
   // a security check here. See GetCssRules below for an example.
   aRule = mInner->mOrderedRules.SafeObjectAt(aIndex);
   if (aRule) {
     NS_ADDREF(aRule);
     return NS_OK;
@@ -1424,34 +1424,34 @@ nsCSSStyleSheet::GetStyleRuleAt(PRInt32 
 }
 
 nsXMLNameSpaceMap*
 nsCSSStyleSheet::GetNameSpaceMap() const
 {
   return mInner->mNameSpaceMap;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::StyleSheetCount(PRInt32& aCount) const
 {
   // XXX Far from an ideal way to do this, but the hope is that
   // it won't be done too often. If it is, we might want to 
   // consider storing the children in an array.
   aCount = 0;
 
   const nsCSSStyleSheet* child = mInner->mFirstChild;
   while (child) {
     aCount++;
     child = child->mNext;
   }
 
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::GetStyleSheetAt(PRInt32 aIndex, nsICSSStyleSheet*& aSheet) const
 {
   // XXX Ughh...an O(n^2) method for doing iteration. Again, we hope
   // that this isn't done too often. If it is, we need to change the
   // underlying storage mechanism
   aSheet = nsnull;
 
   nsCSSStyleSheet* child = mInner->mFirstChild;
@@ -1476,17 +1476,17 @@ nsCSSStyleSheet::EnsureUniqueInner()
     }
     else {
       return NS_ERROR_OUT_OF_MEMORY;
     }
   }
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::Clone(nsICSSStyleSheet* aCloneParent,
                        nsICSSImportRule* aCloneOwnerRule,
                        nsIDocument* aCloneDocument,
                        nsIDOMNode* aCloneOwningNode,
                        nsICSSStyleSheet** aClone) const
 {
   NS_PRECONDITION(aClone, "Null out param!");
   nsCSSStyleSheet* clone = new nsCSSStyleSheet(*this,
@@ -1624,24 +1624,24 @@ nsCSSStyleSheet::RegisterNamespaceRule(n
     nsresult rv = mInner->CreateNamespaceMap();
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   AddNamespaceRuleToMap(aRule, mInner->mNameSpaceMap);
   return NS_OK;
 }
 
-NS_IMETHODIMP 
+nsresult 
 nsCSSStyleSheet::IsModified(PRBool* aSheetModified) const
 {
   *aSheetModified = mDirty;
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::SetModified(PRBool aModified)
 {
   mDirty = aModified;
   return NS_OK;
 }
 
   // nsIDOMStyleSheet interface
 NS_IMETHODIMP    
@@ -1787,17 +1787,17 @@ nsCSSStyleSheet::InsertRule(const nsAStr
   //-- Security check: Only scripts whose principal subsumes that of the
   //   style sheet can modify rule collections.
   nsresult rv = SubjectSubsumesInnerPrincipal();
   NS_ENSURE_SUCCESS(rv, rv);
 
   return InsertRuleInternal(aRule, aIndex, aReturn);
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::InsertRuleInternal(const nsAString& aRule, 
                                     PRUint32 aIndex, 
                                     PRUint32* aReturn)
 {
   // No doing this if the sheet is not complete!
   PRBool complete;
   GetComplete(complete);
   if (!complete) {
@@ -1994,17 +1994,17 @@ nsCSSStyleSheet::DeleteRule(PRUint32 aIn
         mDocument->StyleRuleRemoved(this, rule);
       }
     }
   }
 
   return result;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::DeleteRuleFromGroup(nsICSSGroupRule* aGroup, PRUint32 aIndex)
 {
   NS_ENSURE_ARG_POINTER(aGroup);
   NS_ASSERTION(mInner->mComplete, "No deleting from an incomplete sheet!");
   nsresult result;
   nsCOMPtr<nsICSSRule> rule;
   result = aGroup->GetStyleRuleAt(aIndex, *getter_AddRefs(rule));
   NS_ENSURE_SUCCESS(result, result);
@@ -2030,17 +2030,17 @@ nsCSSStyleSheet::DeleteRuleFromGroup(nsI
 
   if (mDocument) {
     mDocument->StyleRuleRemoved(this, rule);
   }
 
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::InsertRuleIntoGroup(const nsAString & aRule,
                                      nsICSSGroupRule* aGroup,
                                      PRUint32 aIndex,
                                      PRUint32* _retval)
 {
   nsresult result;
   NS_ASSERTION(mInner->mComplete, "No inserting into an incomplete sheet!");
   // check that the group actually belongs to this sheet!
@@ -2118,17 +2118,17 @@ nsCSSStyleSheet::InsertRuleIntoGroup(con
   if (loader) {
     loader->RecycleParser(css);
   }
 
   *_retval = aIndex;
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 nsCSSStyleSheet::ReplaceRuleInGroup(nsICSSGroupRule* aGroup,
                                       nsICSSRule* aOld, nsICSSRule* aNew)
 {
   nsresult result;
   NS_PRECONDITION(mInner->mComplete, "No replacing in an incomplete sheet!");
 #ifdef DEBUG
   {
     nsCOMPtr<nsIStyleSheet> groupSheet;
@@ -2171,17 +2171,17 @@ nsCSSStyleSheet::StyleSheetLoaded(nsICSS
     nsCOMPtr<nsIStyleRule> styleRule(do_QueryInterface(ownerRule));
     
     mDocument->StyleRuleAdded(this, styleRule);
   }
 
   return NS_OK;
 }
 
-NS_IMETHODIMP_(nsIURI*)
+nsIURI*
 nsCSSStyleSheet::GetOriginalURI() const
 {
   return mInner->mOriginalSheetURI;
 }
 
 nsresult
 NS_NewCSSStyleSheet(nsICSSStyleSheet** aInstancePtrResult)
 {
diff --git a/layout/style/nsCSSStyleSheet.h b/layout/style/nsCSSStyleSheet.h
--- a/layout/style/nsCSSStyleSheet.h
+++ b/layout/style/nsCSSStyleSheet.h
@@ -130,52 +130,78 @@ public:
   NS_IMETHOD GetComplete(PRBool& aComplete) const;
   NS_IMETHOD SetComplete();
   NS_IMETHOD GetParentSheet(nsIStyleSheet*& aParent) const;  // may be null
   NS_IMETHOD GetOwningDocument(nsIDocument*& aDocument) const;  // may be null
   NS_IMETHOD SetOwningDocument(nsIDocument* aDocument);
 #ifdef DEBUG
   virtual void List(FILE* out = stdout, PRInt32 aIndent = 0) const;
 #endif
-  
-  // nsICSSStyleSheet interface
-  NS_IMETHOD AppendStyleSheet(nsICSSStyleSheet* aSheet);
-  NS_IMETHOD InsertStyleSheetAt(nsICSSStyleSheet* aSheet, PRInt32 aIndex);
-  NS_IMETHOD PrependStyleRule(nsICSSRule* aRule);
-  NS_IMETHOD AppendStyleRule(nsICSSRule* aRule);
-  NS_IMETHOD ReplaceStyleRule(nsICSSRule* aOld, nsICSSRule* aNew);
-  NS_IMETHOD StyleRuleCount(PRInt32& aCount) const;
-  NS_IMETHOD GetStyleRuleAt(PRInt32 aIndex, nsICSSRule*& aRule) const;
-  NS_IMETHOD DeleteRuleFromGroup(nsICSSGroupRule* aGroup, PRUint32 aIndex);
-  NS_IMETHOD InsertRuleIntoGroup(const nsAString& aRule, nsICSSGroupRule* aGroup, PRUint32 aIndex, PRUint32* _retval);
-  NS_IMETHOD ReplaceRuleInGroup(nsICSSGroupRule* aGroup, nsICSSRule* aOld, nsICSSRule* aNew);
-  NS_IMETHOD StyleSheetCount(PRInt32& aCount) const;
-  NS_IMETHOD GetStyleSheetAt(PRInt32 aIndex, nsICSSStyleSheet*& aSheet) const;
-  NS_IMETHOD SetURIs(nsIURI* aSheetURI, nsIURI* aOriginalSheetURI,
-                     nsIURI* aBaseURI);
-  virtual NS_HIDDEN_(void) SetPrincipal(nsIPrincipal* aPrincipal);
-  virtual NS_HIDDEN_(nsIPrincipal*) Principal() const;
-  NS_IMETHOD SetTitle(const nsAString& aTitle);
-  NS_IMETHOD SetMedia(nsMediaList* aMedia);
-  NS_IMETHOD SetOwningNode(nsIDOMNode* aOwningNode);
-  NS_IMETHOD SetOwnerRule(nsICSSImportRule* aOwnerRule);
-  NS_IMETHOD GetOwnerRule(nsICSSImportRule** aOwnerRule);
+
+  NS_HIDDEN_(nsresult) AppendStyleSheet(nsICSSStyleSheet* aSheet);
+  NS_HIDDEN_(nsresult) InsertStyleSheetAt(nsICSSStyleSheet* aSheet,
+                                          PRInt32 aIndex);
+  // XXX do these belong here or are they generic?
+  NS_HIDDEN_(nsresult) PrependStyleRule(nsICSSRule* aRule);
+  NS_HIDDEN_(nsresult) AppendStyleRule(nsICSSRule* aRule);
+  NS_HIDDEN_(nsresult) ReplaceStyleRule(nsICSSRule* aOld, nsICSSRule* aNew);
+  NS_HIDDEN_(nsresult) StyleRuleCount(PRInt32& aCount) const;
+  NS_HIDDEN_(nsresult) GetStyleRuleAt(PRInt32 aIndex,
+                                      nsICSSRule*& aRule) const;
+  NS_HIDDEN_(nsresult) DeleteRuleFromGroup(nsICSSGroupRule* aGroup,
+                                           PRUint32 aIndex);
+  NS_HIDDEN_(nsresult) InsertRuleIntoGroup(const nsAString& aRule,
+                                           nsICSSGroupRule* aGroup,
+                                           PRUint32 aIndex,
+                                           PRUint32* _retval);
+  NS_HIDDEN_(nsresult) ReplaceRuleInGroup(nsICSSGroupRule* aGroup,
+                                          nsICSSRule* aOld, nsICSSRule* aNew);
+  NS_HIDDEN_(nsresult) StyleSheetCount(PRInt32& aCount) const;
+  NS_HIDDEN_(nsresult) GetStyleSheetAt(PRInt32 aIndex,
+                                       nsICSSStyleSheet*& aSheet) const;
+  /**
+   * SetURIs must be called on all sheets before parsing into them.
+   * SetURIs may only be called while the sheet is 1) incomplete and 2)
+   * has no rules in it
+   */
+  NS_HIDDEN_(nsresult) SetURIs(nsIURI* aSheetURI, nsIURI* aOriginalSheetURI,
+                               nsIURI* aBaseURI);
+  /**
+   * SetPrincipal should be called on all sheets before parsing into them.
+   * This can only be called once with a non-null principal.  Calling this with
+   * a null pointer is allowed and is treated as a no-op.
+   */
+  NS_HIDDEN_(void) SetPrincipal(nsIPrincipal* aPrincipal);
+  // Principal() never returns a null pointer.
+  NS_HIDDEN_(nsIPrincipal*) Principal() const;
+  NS_HIDDEN_(nsresult) SetTitle(const nsAString& aTitle);
+  NS_HIDDEN_(nsresult) SetMedia(nsMediaList* aMedia);
+  NS_HIDDEN_(nsresult) SetOwningNode(nsIDOMNode* aOwningNode);
+  NS_HIDDEN_(nsresult) SetOwnerRule(nsICSSImportRule* aOwnerRule);
+  NS_HIDDEN_(nsresult) GetOwnerRule(nsICSSImportRule** aOwnerRule);
+  // get namespace map for sheet
   virtual NS_HIDDEN_(nsXMLNameSpaceMap*) GetNameSpaceMap() const;
-  NS_IMETHOD Clone(nsICSSStyleSheet* aCloneParent,
-                   nsICSSImportRule* aCloneOwnerRule,
-                   nsIDocument* aCloneDocument,
-                   nsIDOMNode* aCloneOwningNode,
-                   nsICSSStyleSheet** aClone) const;
-  NS_IMETHOD IsModified(PRBool* aSheetModified) const;
-  NS_IMETHOD SetModified(PRBool aModified);
-  NS_IMETHOD AddRuleProcessor(nsCSSRuleProcessor* aProcessor);
-  NS_IMETHOD DropRuleProcessor(nsCSSRuleProcessor* aProcessor);
-  NS_IMETHOD InsertRuleInternal(const nsAString& aRule,
-                                PRUint32 aIndex, PRUint32* aReturn);
-  NS_IMETHOD_(nsIURI*) GetOriginalURI() const;
+  NS_HIDDEN_(nsresult) Clone(nsICSSStyleSheet* aCloneParent,
+                             nsICSSImportRule* aCloneOwnerRule,
+                             nsIDocument* aCloneDocument,
+                             nsIDOMNode* aCloneOwningNode,
+                             nsICSSStyleSheet** aClone) const;
+  // returns the mDirty status of the sheet
+  NS_HIDDEN_(nsresult) IsModified(PRBool* aSheetModified) const;
+  NS_HIDDEN_(nsresult) SetModified(PRBool aModified);
+  NS_HIDDEN_(nsresult) AddRuleProcessor(nsCSSRuleProcessor* aProcessor);
+  NS_HIDDEN_(nsresult) DropRuleProcessor(nsCSSRuleProcessor* aProcessor);
+  /**
+   * Like the DOM insertRule() method, but doesn't do any security checks
+   */
+  NS_HIDDEN_(nsresult) InsertRuleInternal(const nsAString& aRule,
+                                          PRUint32 aIndex, PRUint32* aReturn);
+  /* Get the URI this sheet was originally loaded from, if any.  Can
+     return null */
+  NS_HIDDEN_(nsIURI*) GetOriginalURI() const;
 
   // nsICSSLoaderObserver interface
   NS_IMETHOD StyleSheetLoaded(nsICSSStyleSheet* aSheet, PRBool aWasAlternate,
                               nsresult aStatus);
   
   nsresult EnsureUniqueInner();
 
   PRBool UseForPresentation(nsPresContext* aPresContext,
diff --git a/layout/style/nsICSSStyleSheet.h b/layout/style/nsICSSStyleSheet.h
--- a/layout/style/nsICSSStyleSheet.h
+++ b/layout/style/nsICSSStyleSheet.h
@@ -56,84 +56,16 @@ class nsIPrincipal;
 // ba09b3a4-4a29-495d-987b-cfbb58c5c6ec
 #define NS_ICSS_STYLE_SHEET_IID     \
 { 0xba09b3a4, 0x4a29, 0x495d, \
  { 0x98, 0x7b, 0xcf, 0xbb, 0x58, 0xc5, 0xc6, 0xec } }
 
 class nsICSSStyleSheet : public nsIStyleSheet {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICSS_STYLE_SHEET_IID)
-
-  NS_IMETHOD  AppendStyleSheet(nsICSSStyleSheet* aSheet) = 0;
-  NS_IMETHOD  InsertStyleSheetAt(nsICSSStyleSheet* aSheet, PRInt32 aIndex) = 0;
-
-  // XXX do these belong here or are they generic?
-  NS_IMETHOD  PrependStyleRule(nsICSSRule* aRule) = 0;
-  NS_IMETHOD  AppendStyleRule(nsICSSRule* aRule) = 0;
-  NS_IMETHOD  ReplaceStyleRule(nsICSSRule* aOld, nsICSSRule* aNew) = 0;
-
-  NS_IMETHOD  StyleRuleCount(PRInt32& aCount) const = 0;
-  NS_IMETHOD  GetStyleRuleAt(PRInt32 aIndex, nsICSSRule*& aRule) const = 0;
-
-  NS_IMETHOD  DeleteRuleFromGroup(nsICSSGroupRule* aGroup, PRUint32 aIndex) = 0;
-  NS_IMETHOD  InsertRuleIntoGroup(const nsAString & aRule, nsICSSGroupRule* aGroup, PRUint32 aIndex, PRUint32* _retval) = 0;
-  NS_IMETHOD  ReplaceRuleInGroup(nsICSSGroupRule* aGroup, nsICSSRule* aOld, nsICSSRule* aNew) = 0;
-
-  NS_IMETHOD  StyleSheetCount(PRInt32& aCount) const = 0;
-  NS_IMETHOD  GetStyleSheetAt(PRInt32 aIndex, nsICSSStyleSheet*& aSheet) const = 0;
-
-  /**
-   * SetURIs must be called on all sheets before parsing into them.
-   * SetURIs may only be called while the sheet is 1) incomplete and 2)
-   * has no rules in it
-   */
-  NS_IMETHOD  SetURIs(nsIURI* aSheetURI, nsIURI* aOriginalSheetURI,
-                      nsIURI* aBaseURI) = 0;
-
-  /**
-   * SetPrincipal should be called on all sheets before parsing into them.
-   * This can only be called once with a non-null principal.  Calling this with
-   * a null pointer is allowed and is treated as a no-op.
-   */
-  virtual NS_HIDDEN_(void) SetPrincipal(nsIPrincipal* aPrincipal) = 0;
-
-  // Principal() never returns a null pointer.
-  virtual NS_HIDDEN_(nsIPrincipal*) Principal() const = 0;
-  
-  NS_IMETHOD  SetTitle(const nsAString& aTitle) = 0;
-  NS_IMETHOD  SetMedia(nsMediaList* aMedia) = 0;
-  NS_IMETHOD  SetOwningNode(nsIDOMNode* aOwningNode) = 0;
-
-  NS_IMETHOD  SetOwnerRule(nsICSSImportRule* aOwnerRule) = 0;
-  NS_IMETHOD  GetOwnerRule(nsICSSImportRule** aOwnerRule) = 0;
-  
-  // get namespace map for sheet
-  virtual NS_HIDDEN_(nsXMLNameSpaceMap*) GetNameSpaceMap() const = 0;
-
-  NS_IMETHOD  Clone(nsICSSStyleSheet* aCloneParent,
-                    nsICSSImportRule* aCloneOwnerRule,
-                    nsIDocument* aCloneDocument,
-                    nsIDOMNode* aCloneOwningNode,
-                    nsICSSStyleSheet** aClone) const = 0;
-
-  NS_IMETHOD  IsModified(PRBool* aModified) const = 0; // returns the mDirty status of the sheet
-  NS_IMETHOD  SetModified(PRBool aModified) = 0;
-
-  NS_IMETHOD  AddRuleProcessor(nsCSSRuleProcessor* aProcessor) = 0;
-  NS_IMETHOD  DropRuleProcessor(nsCSSRuleProcessor* aProcessor) = 0;
-
-  /**
-   * Like the DOM insertRule() method, but doesn't do any security checks
-   */
-  NS_IMETHOD InsertRuleInternal(const nsAString& aRule,
-                                PRUint32 aIndex, PRUint32* aReturn) = 0;
-
-  /* Get the URI this sheet was originally loaded from, if any.  Can
-     return null */
-  NS_IMETHOD_(nsIURI*) GetOriginalURI() const = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsICSSStyleSheet, NS_ICSS_STYLE_SHEET_IID)
 
 nsresult
 NS_NewCSSStyleSheet(nsICSSStyleSheet** aInstancePtrResult);
 
 #endif /* nsICSSStyleSheet_h___ */
