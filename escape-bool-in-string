From: L. David Baron <dbaron@dbaron.org>

Pass whether we're in a string to ParseAndAppendEscape.  (Bug 384672, patch 1)

diff --git a/layout/style/nsCSSScanner.cpp b/layout/style/nsCSSScanner.cpp
--- a/layout/style/nsCSSScanner.cpp
+++ b/layout/style/nsCSSScanner.cpp
@@ -966,17 +966,17 @@ nsCSSScanner::NextURL(nsCSSToken& aToken
   Pushback(ch);
 
   // start of a non-quoted url (which may be empty)
   PRBool ok = PR_TRUE;
   for (;;) {
     ch = Read();
     if (ch < 0) break;
     if (ch == CSS_ESCAPE) {
-      ParseAndAppendEscape(ident);
+      ParseAndAppendEscape(ident, PR_FALSE);
     } else if (IsWhitespace(ch)) {
       // Whitespace is allowed at the end of the URL
       EatWhiteSpace();
       // Consume the close paren if we have it; if not we're an invalid URL.
       ok = LookAheadOrEOF(')');
       break;
     } else if (ch == '"' || ch == '\'' || ch == '(' || ch < PRUnichar(' ')) {
       // This is an invalid URL spec
@@ -998,17 +998,17 @@ nsCSSScanner::NextURL(nsCSSToken& aToken
   if (ok) {
     aToken.mType = eCSSToken_URL;
   }
   return PR_TRUE;
 }
 
 
 void
-nsCSSScanner::ParseAndAppendEscape(nsString& aOutput)
+nsCSSScanner::ParseAndAppendEscape(nsString& aOutput, PRBool aInString)
 {
   PRInt32 ch = Peek();
   if (ch < 0) {
     aOutput.Append(CSS_ESCAPE);
     return;
   }
   if (IsHexDigit(ch)) {
     PRInt32 rv = 0;
@@ -1071,17 +1071,17 @@ nsCSSScanner::ParseAndAppendEscape(nsStr
  * will be aIdent with all of the identifier characters appended
  * until the first non-identifier character is seen. The termination
  * character is unread for the future re-reading.
  */
 PRBool
 nsCSSScanner::GatherIdent(PRInt32 aChar, nsString& aIdent)
 {
   if (aChar == CSS_ESCAPE) {
-    ParseAndAppendEscape(aIdent);
+    ParseAndAppendEscape(aIdent, PR_FALSE);
   }
   else if (0 < aChar) {
     aIdent.Append(aChar);
   }
   for (;;) {
     // If nothing in pushback, first try to get as much as possible in one go
     if (!mPushbackCount && EnsureData()) {
       // See how much we can consume and append in one go
@@ -1098,17 +1098,17 @@ nsCSSScanner::GatherIdent(PRInt32 aChar,
         aIdent.Append(&mReadPointer[mOffset], n - mOffset);
         mOffset = n;
       }
     }
 
     aChar = Read();
     if (aChar < 0) break;
     if (aChar == CSS_ESCAPE) {
-      ParseAndAppendEscape(aIdent);
+      ParseAndAppendEscape(aIdent, PR_FALSE);
     } else if (IsIdent(aChar)) {
       aIdent.Append(PRUnichar(aChar));
     } else {
       Pushback(aChar);
       break;
     }
   }
   return PR_TRUE;
@@ -1362,17 +1362,17 @@ nsCSSScanner::ParseString(PRInt32 aStop,
     if (ch == '\n') {
       aToken.mType = eCSSToken_Bad_String;
 #ifdef CSS_REPORT_PARSE_ERRORS
       ReportUnexpectedToken(aToken, "SEUnterminatedString");
 #endif
       break;
     }
     if (ch == CSS_ESCAPE) {
-      ParseAndAppendEscape(aToken.mIdent);
+      ParseAndAppendEscape(aToken.mIdent, PR_TRUE);
     } else {
       aToken.mIdent.Append(ch);
     }
   }
   return PR_TRUE;
 }
 
 // UNICODE-RANGE tokens match the regular expression
diff --git a/layout/style/nsCSSScanner.h b/layout/style/nsCSSScanner.h
--- a/layout/style/nsCSSScanner.h
+++ b/layout/style/nsCSSScanner.h
@@ -210,17 +210,17 @@ class nsCSSScanner {
 protected:
   PRBool EnsureData();
   PRInt32 Read();
   PRInt32 Peek();
   PRBool LookAhead(PRUnichar aChar);
   PRBool LookAheadOrEOF(PRUnichar aChar); // expect either aChar or EOF
   void EatWhiteSpace();
   
-  void ParseAndAppendEscape(nsString& aOutput);
+  void ParseAndAppendEscape(nsString& aOutput, PRBool aInString);
   PRBool ParseIdent(PRInt32 aChar, nsCSSToken& aResult);
   PRBool ParseAtKeyword(PRInt32 aChar, nsCSSToken& aResult);
   PRBool ParseNumber(PRInt32 aChar, nsCSSToken& aResult);
   PRBool ParseRef(PRInt32 aChar, nsCSSToken& aResult);
   PRBool ParseString(PRInt32 aChar, nsCSSToken& aResult);
   PRBool ParseURange(PRInt32 aChar, nsCSSToken& aResult);
   PRBool SkipCComment();
 
