From: L. David Baron <dbaron@dbaron.org>

Track which frame we're doing shrink-wrap on.  (FIXME:  We should instead use this approach to track the current container and container width -- since otherwise this is insufficient since we won't be able to get the container width when we decide we want to use inflation during shrink-wrapping.)  (TODO: set to null on containers)

TODO: audit all callers of nsIFrame::GetMinWidth and nsIFrame::GetPrefWidth.

diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -2258,16 +2258,24 @@ nsLayoutUtils::IntrinsicForContainer(nsR
 
 #ifdef DEBUG_INTRINSIC_WIDTH
   nsFrame::IndentBy(stdout, gNoiseIndent);
   static_cast<nsFrame*>(aFrame)->ListTag(stdout);
   printf(" %s intrinsic width for container:\n",
          aType == MIN_WIDTH ? "min" : "pref");
 #endif
 
+  nsPresContext *presContext = aFrame->PresContext();
+  AutoRestore<nsIFrame*> ar(presContext->mCurrentInflationContainer);
+  if (nsLayoutUtils::IsContainerForFontSizeInflation(aFrame)) {
+    // If we're a container for font size inflation, then shrink
+    // wrapping inside of us should not apply font size inflation.
+    presContext->mCurrentInflationContainer = nsnull;
+  }
+
   nsIFrame::IntrinsicWidthOffsetData offsets =
     aFrame->IntrinsicWidthOffsets(aRenderingContext);
 
   const nsStylePosition *stylePos = aFrame->GetStylePosition();
   PRUint8 boxSizing = stylePos->mBoxSizing;
   const nsStyleCoord &styleWidth = stylePos->mWidth;
   const nsStyleCoord &styleMinWidth = stylePos->mMinWidth;
   const nsStyleCoord &styleMaxWidth = stylePos->mMaxWidth;
@@ -2859,27 +2867,33 @@ nsLayoutUtils::ComputeAutoSizeWithIntrin
 
   return nsSize(width, height);
 }
 
 /* static */ nscoord
 nsLayoutUtils::MinWidthFromInline(nsIFrame* aFrame,
                                   nsRenderingContext* aRenderingContext)
 {
+  NS_ASSERTION(!nsLayoutUtils::IsContainerForFontSizeInflation(aFrame),
+               "should not be container for font size inflation");
+
   nsIFrame::InlineMinWidthData data;
   DISPLAY_MIN_WIDTH(aFrame, data.prevLines);
   aFrame->AddInlineMinWidth(aRenderingContext, &data);
   data.ForceBreak(aRenderingContext);
   return data.prevLines;
 }
 
 /* static */ nscoord
 nsLayoutUtils::PrefWidthFromInline(nsIFrame* aFrame,
                                    nsRenderingContext* aRenderingContext)
 {
+  NS_ASSERTION(!nsLayoutUtils::IsContainerForFontSizeInflation(aFrame),
+               "should not be container for font size inflation");
+
   nsIFrame::InlinePrefWidthData data;
   DISPLAY_PREF_WIDTH(aFrame, data.prevLines);
   aFrame->AddInlinePrefWidth(aRenderingContext, &data);
   data.ForceBreak(aRenderingContext);
   return data.prevLines;
 }
 
 static nscolor
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -3914,16 +3914,24 @@ nsFrame::ComputeAutoSize(nsRenderingCont
   }
   return result;
 }
 
 nscoord
 nsFrame::ShrinkWidthToFit(nsRenderingContext *aRenderingContext,
                           nscoord aWidthInCB)
 {
+  nsPresContext *presContext = PresContext();
+  AutoRestore<nsIFrame*> ar(presContext->mCurrentInflationContainer);
+  if (nsLayoutUtils::IsContainerForFontSizeInflation(this)) {
+    // If we're a container for font size inflation, then shrink
+    // wrapping inside of us should not apply font size inflation.
+    presContext->mCurrentInflationContainer = nsnull;
+  }
+
   nscoord result;
   nscoord minWidth = GetMinWidth(aRenderingContext);
   if (minWidth > aWidthInCB) {
     result = minWidth;
   } else {
     nscoord prefWidth = GetPrefWidth(aRenderingContext);
     if (prefWidth > aWidthInCB) {
       result = aWidthInCB;
