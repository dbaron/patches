Keep old rule trees around until they are no longer referenced.  (Bug 475128)  r+sr=bzbarsky

diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -277,16 +277,17 @@ public:
   {
     if (mShell)
       return mShell->AllocateFrame(aSize);
     return nsnull;
   }
 
   void FreeToShell(size_t aSize, void* aFreeChunk)
   {
+    NS_ASSERTION(mShell, "freeing after shutdown");
     if (mShell)
       mShell->FreeFrame(aSize, aFreeChunk);
   }
 
   /**
    * Get the font metrics for a given font.
    *
    * If aUseUserFontSet is false, don't build or use the user font set.
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -5363,17 +5363,17 @@ SweepRuleNodeChildren(PLDHashTable *tabl
 
 PRBool
 nsRuleNode::Sweep()
 {
   // If we're not marked, then we have to delete ourself.
   // However, we never allow the root node to GC itself, because nsStyleSet
   // wants to hold onto the root node and not worry about re-creating a
   // rule walker if the root node is deleted.
-  if (!(mDependentBits & NS_RULE_NODE_GC_MARK) && !IsRoot()) {
+  if (!(mDependentBits & NS_RULE_NODE_GC_MARK) && !IsCurrentRoot()) {
     Destroy();
     return PR_TRUE;
   }
 
   // Clear our mark, for the next time around.
   mDependentBits &= ~NS_RULE_NODE_GC_MARK;
 
   // Call sweep on the children, since some may not be marked, and
diff --git a/layout/style/nsRuleNode.h b/layout/style/nsRuleNode.h
--- a/layout/style/nsRuleNode.h
+++ b/layout/style/nsRuleNode.h
@@ -699,32 +699,39 @@ private:
 
 public:
   static NS_HIDDEN_(nsRuleNode*) CreateRootNode(nsPresContext* aPresContext);
 
   NS_HIDDEN_(nsRuleNode*) Transition(nsIStyleRule* aRule, PRUint8 aLevel,
                                      PRPackedBool aIsImportantRule);
   nsRuleNode* GetParent() const { return mParent; }
   PRBool IsRoot() const { return mParent == nsnull; }
+  // Are we the root of the current rule tree as opposed to the root of
+  // an old (no-longer-used) one?
+  PRBool IsCurrentRoot() const {
+    return IsRoot() && StyleSet()->GetRuleTree() == this;
+  }
 
   // These PRUint8s are really nsStyleSet::sheetType values.
   PRUint8 GetLevel() const { 
     NS_ASSERTION(!IsRoot(), "can't call on root");
     return (mDependentBits & NS_RULE_NODE_LEVEL_MASK) >>
              NS_RULE_NODE_LEVEL_SHIFT;
   }
   PRBool IsImportantRule() const {
     NS_ASSERTION(!IsRoot(), "can't call on root");
     return (mDependentBits & NS_RULE_NODE_IS_IMPORTANT) != 0;
   }
 
   // NOTE:  Does not |AddRef|.
   nsIStyleRule* GetRule() const { return mRule; }
   // NOTE: Does not |AddRef|.
+  // Should be renamed to |PresContext|.
   nsPresContext* GetPresContext() const { return mPresContext; }
+  nsStyleSet* StyleSet() const { return mPresContext->StyleSet(); }
 
   NS_HIDDEN_(const void*) GetStyleData(nsStyleStructID aSID, 
                                        nsStyleContext* aContext,
                                        PRBool aComputeData);
 
   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)                      \
     NS_HIDDEN_(const nsStyle##name_*)                                         \
       GetStyle##name_(nsStyleContext* aContext,                               \
diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -81,17 +81,17 @@ nsStyleContext::nsStyleContext(nsStyleCo
     mParent->AddRef();
     mParent->AddChild(this);
 #ifdef DEBUG
     nsRuleNode *r1 = mParent->GetRuleNode(), *r2 = aRuleNode;
     while (r1->GetParent())
       r1 = r1->GetParent();
     while (r2->GetParent())
       r2 = r2->GetParent();
-    NS_ABORT_IF_FALSE(r1 == r2, "must be in the same rule tree as parent");
+    NS_ASSERTION(r1 == r2, "must be in the same rule tree as parent");
 #endif
   }
 
   ApplyStyleFixups(aPresContext);
 
   #define eStyleStruct_LastItem (nsStyleStructID_Length - 1)
   NS_ASSERTION(NS_STYLE_INHERIT_MASK & NS_STYLE_INHERIT_BIT(LastItem),
                "NS_STYLE_INHERIT_MASK must be bigger, and other bits shifted");
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -81,19 +81,19 @@ static const nsStyleSet::sheetType gCSSS
   nsStyleSet::eOverrideSheet
 };
 
 nsStyleSet::nsStyleSet()
   : mRuleTree(nsnull),
     mRuleWalker(nsnull),
     mDestroyedCount(0),
     mBatching(0),
-    mOldRuleTree(nsnull),
     mInShutdown(PR_FALSE),
     mAuthorStyleDisabled(PR_FALSE),
+    mInReconstruct(PR_FALSE),
     mDirty(0)
 {
 }
 
 nsresult
 nsStyleSet::Init(nsPresContext *aPresContext)
 {
   mFirstLineRule = new nsEmptyStyleRule;
@@ -121,70 +121,75 @@ nsStyleSet::Init(nsPresContext *aPresCon
   }
 
   return NS_OK;
 }
 
 nsresult
 nsStyleSet::BeginReconstruct()
 {
-  NS_ASSERTION(!mOldRuleTree, "Unmatched begin/end?");
+  NS_ASSERTION(!mInReconstruct, "Unmatched begin/end?");
   NS_ASSERTION(mRuleTree, "Reconstructing before first construction?");
 
   // Create a new rule tree root
   nsRuleNode* newTree =
     nsRuleNode::CreateRootNode(mRuleTree->GetPresContext());
   if (!newTree)
     return NS_ERROR_OUT_OF_MEMORY;
   nsRuleWalker* ruleWalker = new nsRuleWalker(newTree);
   if (!ruleWalker) {
     newTree->Destroy();
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   // Save the old rule tree so we can destroy it later
-  mOldRuleTree = mRuleTree;
+  if (!mOldRuleTrees.AppendElement(mRuleTree)) {
+    delete ruleWalker;
+    newTree->Destroy();
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
   // Delete mRuleWalker because it holds a reference to the rule tree root
   delete mRuleWalker;
-  // We don't need to clear out mRoots; NotifyStyleContextDestroyed
-  // will, and they're useful in EndReconstruct if they don't get
-  // completely cleared out.
 
+  // We need to keep mRoots so that the rule tree GC will only free the
+  // rule trees that really aren't referenced anymore (which should be
+  // all of them, if there are no bugs in reresolution code).
+
+  mInReconstruct = PR_TRUE;
   mRuleTree = newTree;
   mRuleWalker = ruleWalker;
 
   return NS_OK;
 }
 
 void
 nsStyleSet::EndReconstruct()
 {
+  NS_ASSERTION(mInReconstruct, "Unmatched begin/end?");
+  mInReconstruct = PR_FALSE;
 #ifdef DEBUG
   for (PRInt32 i = mRoots.Length() - 1; i >= 0; --i) {
     nsRuleNode *n = mRoots[i]->GetRuleNode();
     while (n->GetParent()) {
       n = n->GetParent();
     }
     // Since nsStyleContext's mParent and mRuleNode are immutable, and
     // style contexts own their parents, and nsStyleContext asserts in
     // its constructor that the style context and its parent are in the
     // same rule tree, we don't need to check any of the children of
     // mRoots; we only need to check the rule nodes of mRoots
     // themselves.
 
-    NS_ABORT_IF_FALSE(n == mRuleTree, "style context has old rule node");
+    NS_ASSERTION(n == mRuleTree, "style context has old rule node");
   }
 #endif
-  NS_ASSERTION(mOldRuleTree, "Unmatched begin/end?");
-  // Reset the destroyed count; it's no longer valid
-  mDestroyedCount = 0;
-  // Destroy the old rule tree (all the associated style contexts should have
-  // been destroyed by the caller beforehand)
-  mOldRuleTree->Destroy();
-  mOldRuleTree = nsnull;
+  // This *should* destroy the only element of mOldRuleTrees, but in
+  // case of some bugs (which would trigger the above assertions), it
+  // won't.
+  GCRuleTrees();
 }
 
 void
 nsStyleSet::SetQuirkStyleSheet(nsIStyleSheet* aQuirkStyleSheet)
 {
   NS_ASSERTION(aQuirkStyleSheet, "Must have quirk sheet if this is called");
   NS_ASSERTION(!mQuirkStyleSheet, "Multiple calls to SetQuirkStyleSheet?");
   NS_ASSERTION(mSheets[eAgentSheet].IndexOf(aQuirkStyleSheet) != -1,
@@ -870,16 +875,25 @@ void
 nsStyleSet::Shutdown(nsPresContext* aPresContext)
 {
   delete mRuleWalker;
   mRuleWalker = nsnull;
 
   mRuleTree->Destroy();
   mRuleTree = nsnull;
 
+  // We can have old rule trees either because:
+  //   (1) we failed the assertions in EndReconstruct, or
+  //   (2) we're shutting down within a reconstruct (see bug 462392)
+  for (PRUint32 i = mOldRuleTrees.Length(); i > 0; ) {
+    --i;
+    mOldRuleTrees[i]->Destroy();
+  }
+  mOldRuleTrees.Clear();
+
   mDefaultStyleData.Destroy(0, aPresContext);
 }
 
 static const PRInt32 kGCInterval = 1000;
 
 void
 nsStyleSet::NotifyStyleContextDestroyed(nsPresContext* aPresContext,
                                         nsStyleContext* aStyleContext)
@@ -890,37 +904,53 @@ nsStyleSet::NotifyStyleContextDestroyed(
   NS_ASSERTION(mRuleWalker->AtRoot(), "Rule walker should be at root");
 
   // Remove style contexts from mRoots even if mOldRuleTree is non-null.  This
   // could be a style context from the new ruletree!
   if (!aStyleContext->GetParent()) {
     mRoots.RemoveElement(aStyleContext);
   }
 
-  if (mOldRuleTree)
+  if (mInReconstruct)
     return;
 
   if (++mDestroyedCount == kGCInterval) {
-    mDestroyedCount = 0;
+    GCRuleTrees();
+  }
+}
 
-    // Mark the style context tree by marking all roots, which will mark
-    // all descendants.  This will reach style contexts in the
-    // undisplayed map and "additional style contexts" since they are
-    // descendants of the root.
-    for (PRInt32 i = mRoots.Length() - 1; i >= 0; --i) {
-      mRoots[i]->Mark();
+void
+nsStyleSet::GCRuleTrees()
+{
+  mDestroyedCount = 0;
+
+  // Mark the style context tree by marking all style contexts which
+  // have no parent, which will mark all descendants.  This will reach
+  // style contexts in the undisplayed map and "additional style
+  // contexts" since they are descendants of the roots.
+  for (PRInt32 i = mRoots.Length() - 1; i >= 0; --i) {
+    mRoots[i]->Mark();
+  }
+
+  // Sweep the rule tree.
+#ifdef DEBUG
+  PRBool deleted =
+#endif
+    mRuleTree->Sweep();
+  NS_ASSERTION(!deleted, "Root node must not be gc'd");
+
+  // Sweep the old rule trees.
+  for (PRUint32 i = mOldRuleTrees.Length(); i > 0; ) {
+    --i;
+    if (mOldRuleTrees[i]->Sweep()) {
+      // It was deleted, as it should be.
+      mOldRuleTrees.RemoveElementAt(i);
+    } else {
+      NS_NOTREACHED("old rule tree still referenced");
     }
-
-    // Sweep the rule tree.
-#ifdef DEBUG
-    PRBool deleted =
-#endif
-      mRuleTree->Sweep();
-
-    NS_ASSERTION(!deleted, "Root node must not be gc'd");
   }
 }
 
 already_AddRefed<nsStyleContext>
 nsStyleSet::ReParentStyleContext(nsPresContext* aPresContext,
                                  nsStyleContext* aStyleContext, 
                                  nsStyleContext* aNewParentContext)
 {
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -81,16 +81,18 @@ class nsStyleSet
   // the nsStyleSet if Init() fails.
 
   nsresult Init(nsPresContext *aPresContext);
 
   // For getting the cached default data in case we hit out-of-memory.
   // To be used only by nsRuleNode.
   nsCachedStyleData* DefaultStyleData() { return &mDefaultStyleData; }
 
+  nsRuleNode* GetRuleTree() { return mRuleTree; }
+
   // enable / disable the Quirk style sheet
   void EnableQuirkStyleSheet(PRBool aEnable);
 
   // get a style context for a non-pseudo frame.
   already_AddRefed<nsStyleContext>
   ResolveStyleFor(nsIContent* aContent, nsStyleContext* aParentContext);
 
   // get a style context from some rules
@@ -241,16 +243,19 @@ class nsStyleSet
  private:
   // Not to be implemented
   nsStyleSet(const nsStyleSet& aCopy);
   nsStyleSet& operator=(const nsStyleSet& aCopy);
 
   // Returns false on out-of-memory.
   PRBool BuildDefaultStyleData(nsPresContext* aPresContext);
 
+  // Run mark-and-sweep GC on mRuleTree and mOldRuleTrees, based on mRoots.
+  void GCRuleTrees();
+
   // Update the rule processor list after a change to the style sheet list.
   nsresult GatherRuleProcessors(sheetType aType);
 
   void AddImportantRules(nsRuleNode* aCurrLevelNode,
                          nsRuleNode* aLastPrevLevelNode);
 
   // Move mRuleWalker forward by the appropriate rule if we need to add
   // a rule due to property restrictions on pseudo-elements.
@@ -312,18 +317,21 @@ class nsStyleSet
   nsTArray<nsStyleContext*> mRoots; // style contexts with no parent
 
   // Empty style rules to force things that restrict which properties
   // apply into different branches of the rule tree.
   nsRefPtr<nsEmptyStyleRule> mFirstLineRule, mFirstLetterRule;
 
   PRUint16 mBatching;
 
-  nsRuleNode* mOldRuleTree; // Old rule tree; used during tree reconstruction
-                            // (See BeginReconstruct and EndReconstruct)
+  // Old rule trees, which should only be non-empty between
+  // BeginReconstruct and EndReconstruct, but in case of bugs that cause
+  // style contexts to exist too long, may last longer.
+  nsTArray<nsRuleNode*> mOldRuleTrees;
 
   unsigned mInShutdown : 1;
   unsigned mAuthorStyleDisabled: 1;
+  unsigned mInReconstruct : 1;
   unsigned mDirty : 7;  // one dirty bit is used per sheet type
 
 };
 
 #endif
