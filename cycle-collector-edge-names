Add knowledge of edge names to cycle collector, ifdef DEBUG_CC.  b=420514

diff --git a/content/base/public/nsIContent.h b/content/base/public/nsIContent.h
--- a/content/base/public/nsIContent.h
+++ b/content/base/public/nsIContent.h
@@ -843,6 +843,7 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsIContent
     nsISupports *preservedWrapper = nsnull;                      \
     if (tmp->GetOwnerDoc())                                      \
       preservedWrapper = tmp->GetOwnerDoc()->GetReference(tmp);  \
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[preserved wrapper]");\
     cb.NoteXPCOMChild(preservedWrapper);                         \
   }
 
diff --git a/content/base/src/nsContentUtils.cpp b/content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp
+++ b/content/base/src/nsContentUtils.cpp
@@ -3230,6 +3230,7 @@ nsContentUtils::TraverseListenerManager(
                (PL_DHashTableOperate(&sEventListenerManagersHash, aNode,
                                         PL_DHASH_LOOKUP));
   if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via hash] mListenerManager");
     cb.NoteXPCOMChild(entry->mListenerManager);
   }
 }
diff --git a/content/base/src/nsDocument.cpp b/content/base/src/nsDocument.cpp
--- a/content/base/src/nsDocument.cpp
+++ b/content/base/src/nsDocument.cpp
@@ -960,7 +960,9 @@ SubDocTraverser(PLDHashTable *table, PLD
   nsCycleCollectionTraversalCallback *cb = 
     static_cast<nsCycleCollectionTraversalCallback*>(arg);
 
+  NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mSubDocuments entry->mKey");
   cb->NoteXPCOMChild(entry->mKey);
+  NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mSubDocuments entry->mSubDocument");
   cb->NoteXPCOMChild(entry->mSubDocument);
 
   return PL_DHASH_NEXT;
@@ -972,10 +974,14 @@ RadioGroupsTraverser(const nsAString& aK
   nsCycleCollectionTraversalCallback *cb = 
     static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
 
+  NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
+                                   "mRadioGroups entry->mSelectedRadioButton");
   cb->NoteXPCOMChild(aData->mSelectedRadioButton);
 
   PRUint32 i, count = aData->mRadioButtons.Count();
   for (i = 0; i < count; ++i) {
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
+                                       "mRadioGroups entry->mRadioButtons[i]");
     cb->NoteXPCOMChild(aData->mRadioButtons[i]);
   }
 
@@ -988,6 +994,7 @@ BoxObjectTraverser(const void* key, nsPI
   nsCycleCollectionTraversalCallback *cb = 
     static_cast<nsCycleCollectionTraversalCallback*>(userArg);
  
+  NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mBoxObjectTable entry");
   cb->NoteXPCOMChild(boxObject);
 
   return PL_DHASH_NEXT;
@@ -1008,6 +1015,7 @@ LinkMapTraverser(nsUint32ToContentHashEn
 {
   LinkMapTraversalVisitor visitor;
   visitor.mCb = static_cast<nsCycleCollectionTraversalCallback*>(userArg);
+  NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*visitor.mCb, "mLinkMap entry");
   aEntry->VisitContent(&visitor);
   return PL_DHASH_NEXT;
 }
@@ -1019,6 +1027,7 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(
 
   // Traverse the mChildren nsAttrAndChildArray.
   for (PRInt32 indx = PRInt32(tmp->mChildren.ChildCount()); indx > 0; --indx) {
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mChildren[i]");
     cb.NoteXPCOMChild(tmp->mChildren.ChildAt(indx - 1));
   }
 
@@ -1063,6 +1072,7 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mVisitednessChangedURIs)
 
   // Traverse any associated preserved wrapper.
+  NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[preserved wrapper]");
   cb.NoteXPCOMChild(tmp->GetReference(tmp));
 
   if (tmp->mSubDocuments && tmp->mSubDocuments->ops) {
diff --git a/content/base/src/nsGenericElement.cpp b/content/base/src/nsGenericElement.cpp
--- a/content/base/src/nsGenericElement.cpp
+++ b/content/base/src/nsGenericElement.cpp
@@ -3495,8 +3495,10 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(
   {
     PRUint32 i;
     PRUint32 kids = tmp->mAttrsAndChildren.ChildCount();
-    for (i = 0; i < kids; i++)
+    for (i = 0; i < kids; i++) {
+      NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mAttrsAndChildren[i]");
       cb.NoteXPCOMChild(tmp->mAttrsAndChildren.GetSafeChildAt(i));
+    }
   }
 
   // Traverse any DOM slots of interest.
diff --git a/content/base/src/nsNodeUtils.cpp b/content/base/src/nsNodeUtils.cpp
--- a/content/base/src/nsNodeUtils.cpp
+++ b/content/base/src/nsNodeUtils.cpp
@@ -390,6 +390,7 @@ NoteUserData(void *aObject, nsIAtom *aKe
 {
   nsCycleCollectionTraversalCallback* cb =
     static_cast<nsCycleCollectionTraversalCallback*>(aData);
+  NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "[user data (or handler)]");
   cb->NoteXPCOMChild(static_cast<nsISupports*>(aXPCOMChild));
 }
 
diff --git a/content/xbl/src/nsBindingManager.cpp b/content/xbl/src/nsBindingManager.cpp
--- a/content/xbl/src/nsBindingManager.cpp
+++ b/content/xbl/src/nsBindingManager.cpp
@@ -1501,28 +1501,38 @@ nsBindingManager::Traverse(nsIContent *a
 
   nsXBLBinding *binding = GetBinding(aContent);
   if (binding) {
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mBindingTable key");
     cb.NoteXPCOMChild(aContent);
-    NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_PTR(binding, nsXBLBinding)
+    NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_PTR(binding, nsXBLBinding,
+                                  "[via binding manager] mBindingTable value")
   }
   nsISupports *value;
   if (mContentListTable.ops &&
       (value = LookupObject(mContentListTable, aContent))) {
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mContentListTable key");
     cb.NoteXPCOMChild(aContent);
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mContentListTable value");
     cb.NoteXPCOMChild(value);
   }
   if (mAnonymousNodesTable.ops &&
       (value = LookupObject(mAnonymousNodesTable, aContent))) {
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mAnonymousNodesTable key");
     cb.NoteXPCOMChild(aContent);
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mAnonymousNodesTable value");
     cb.NoteXPCOMChild(value);
   }
   if (mInsertionParentTable.ops &&
       (value = LookupObject(mInsertionParentTable, aContent))) {
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mInsertionParentTable key");
     cb.NoteXPCOMChild(aContent);
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mInsertionParentTable value");
     cb.NoteXPCOMChild(value);
   }
   if (mWrapperTable.ops &&
       (value = LookupObject(mWrapperTable, aContent))) {
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mWrapperTable key");
     cb.NoteXPCOMChild(aContent);
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mWrapperTable value");
     cb.NoteXPCOMChild(value);
   }
 }
diff --git a/content/xbl/src/nsXBLBinding.cpp b/content/xbl/src/nsXBLBinding.cpp
--- a/content/xbl/src/nsXBLBinding.cpp
+++ b/content/xbl/src/nsXBLBinding.cpp
@@ -294,9 +294,11 @@ TraverseKey(nsISupports* aKey, nsInserti
   nsCycleCollectionTraversalCallback &cb = 
     *static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
 
+  NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mInsertionPointTable key");
   cb.NoteXPCOMChild(aKey);
   if (aData) {
-    NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY(*aData, nsXBLInsertionPoint)
+    NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY(*aData, nsXBLInsertionPoint,
+                                               "mInsertionPointTable value")
   }
   return PL_DHASH_NEXT;
 }
diff --git a/content/xbl/src/nsXBLPrototypeBinding.cpp b/content/xbl/src/nsXBLPrototypeBinding.cpp
--- a/content/xbl/src/nsXBLPrototypeBinding.cpp
+++ b/content/xbl/src/nsXBLPrototypeBinding.cpp
@@ -338,7 +338,8 @@ TraverseInsertionPoint(nsHashKey* aKey, 
   nsXBLInsertionPointEntry* entry =
     static_cast<nsXBLInsertionPointEntry*>(aData);
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_PTR(entry,
-                                               nsXBLInsertionPointEntry)
+                                               nsXBLInsertionPointEntry,
+                                               "[insertion point table] value")
   return kHashEnumerateNext;
 }
 
diff --git a/content/xul/content/src/nsXULElement.cpp b/content/xul/content/src/nsXULElement.cpp
--- a/content/xul/content/src/nsXULElement.cpp
+++ b/content/xul/content/src/nsXULElement.cpp
@@ -2416,7 +2416,8 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE
         PRUint32 i;
         for (i = 0; i < elem->mNumChildren; ++i) {
             NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_PTR(elem->mChildren[i],
-                                                         nsXULPrototypeNode)
+                                                         nsXULPrototypeNode,
+                                                         "mChildren[i]")
         }
     }
     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
diff --git a/js/src/xpconnect/src/nsXPConnect.cpp b/js/src/xpconnect/src/nsXPConnect.cpp
--- a/js/src/xpconnect/src/nsXPConnect.cpp
+++ b/js/src/xpconnect/src/nsXPConnect.cpp
@@ -727,6 +727,23 @@ NoteJSChild(JSTracer *trc, void *thing, 
     if(ADD_TO_CC(kind))
     {
         TraversalTracer *tracer = static_cast<TraversalTracer*>(trc);
+#if defined(DEBUG) && defined(DEBUG_CC)
+        // based on DumpNotify in jsapi.c
+        if (tracer->debugPrinter) {
+            char buffer[200];
+            tracer->debugPrinter(trc, buffer, sizeof(buffer));
+            tracer->cb.NoteNextEdgeName(buffer);
+        } else if (tracer->debugPrintIndex != (size_t)-1) {
+            char buffer[200];
+            JS_snprintf(buffer, sizeof(buffer), "%s[%lu]",
+                        static_cast<const char *>(tracer->debugPrintArg),
+                        tracer->debugPrintIndex);
+            tracer->cb.NoteNextEdgeName(buffer);
+        } else {
+            tracer->cb.NoteNextEdgeName(
+              static_cast<const char*>(tracer->debugPrintArg));
+        }
+#endif
         tracer->cb.NoteScriptChild(nsIProgrammingLanguage::JAVASCRIPT, thing);
     }
     else if(kind != JSTRACE_DOUBLE && kind != JSTRACE_STRING)
@@ -1001,6 +1018,7 @@ public:
 #ifdef DEBUG_CC
         cb.DescribeNode(RefCounted, refCount, sizeof(JSContext),
                         "JSContext");
+        cb.NoteNextEdgeName("[global object]");
 #else
         cb.DescribeNode(RefCounted, refCount);
 #endif
diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -143,9 +143,11 @@
 #include "nsServiceManagerUtils.h"
 #include "nsThreadUtils.h"
 #include "nsTPtrArray.h"
+#include "nsVoidArray.h" // for nsCStringArray
 #include "prinrval.h"
 
 #include <stdio.h>
+#include <string.h>
 #ifdef WIN32
 #include <io.h>
 #include <process.h>
@@ -432,6 +434,7 @@ public:
 
 struct ReversedEdge {
     PtrInfo *mTarget;
+    nsCString *mEdgeName;
     ReversedEdge *mNext;
 };
 
@@ -467,6 +470,9 @@ struct PtrInfo
     // expected to be garbage are black).
     ReversedEdge* mReversedEdges; // linked list
     PtrInfo* mShortestPathToExpectedGarbage;
+    nsCString* mShortestPathToExpectedGarbageEdgeName;
+
+    nsCStringArray mEdgeNames;
 #endif
 
     PtrInfo(void *aPointer, nsCycleCollectionParticipant *aParticipant
@@ -485,13 +491,23 @@ struct PtrInfo
           mLangID(aLangID),
           mSCCIndex(0),
           mReversedEdges(nsnull),
-          mShortestPathToExpectedGarbage(nsnull)
+          mShortestPathToExpectedGarbage(nsnull),
+          mShortestPathToExpectedGarbageEdgeName(nsnull)
 #endif
     {
     }
 
-    // Allow uninitialized values in large arrays.
-    PtrInfo() {}
+#ifdef DEBUG_CC
+    void Destroy() {
+        PL_strfree(mName);
+        mEdgeNames.~nsCStringArray();
+    }
+#endif
+
+    // Allow NodePool::Block's constructor to compile.
+    PtrInfo() {
+        NS_NOTREACHED("should never be called");
+    }
 };
 
 /**
@@ -504,10 +520,14 @@ private:
     enum { BlockSize = 32 * 1024 }; // could be int template parameter
 
     struct Block {
+        // We create and destroy Block using NS_Alloc/NS_Free rather
+        // than new and delete to avoid calling its constructor and
+        // destructor.
+        Block() { NS_NOTREACHED("should never be called"); }
+        ~Block() { NS_NOTREACHED("should never be called"); }
+
         Block* mNext;
         PtrInfo mEntries[BlockSize];
-
-        Block() : mNext(nsnull) {}
     };
 
 public:
@@ -528,14 +548,14 @@ public:
         {
             Enumerator queue(*this);
             while (!queue.IsDone()) {
-                PL_strfree(queue.GetNext()->mName);
+                queue.GetNext()->Destroy();
             }
         }
 #endif
         Block *b = mBlocks;
         while (b) {
             Block *n = b->mNext;
-            delete b;
+            NS_Free(b);
             b = n;
         }
 
@@ -561,10 +581,12 @@ public:
         {
             if (mNext == mBlockEnd) {
                 Block *block;
-                if (!(*mNextBlock = block = new Block()))
+                if (!(*mNextBlock = block =
+                        static_cast<Block*>(NS_Alloc(sizeof(Block)))))
                     return nsnull;
                 mNext = block->mEntries;
                 mBlockEnd = block->mEntries + BlockSize;
+                block->mNext = nsnull;
                 mNextBlock = &block->mNext;
             }
             return new (mNext++) PtrInfo(aPointer, aParticipant
@@ -1194,6 +1216,9 @@ private:
     PLDHashTable mPtrToNodeMap;
     PtrInfo *mCurrPi;
     nsCycleCollectionLanguageRuntime **mRuntimes; // weak, from nsCycleCollector
+#ifdef DEBUG_CC
+    nsCString mNextEdgeName;
+#endif
 
 public:
     GCGraphBuilder(GCGraph &aGraph,
@@ -1231,6 +1256,9 @@ private:
     NS_IMETHOD_(void) NoteNativeChild(void *child,
                                      nsCycleCollectionParticipant *participant);
     NS_IMETHOD_(void) NoteScriptChild(PRUint32 langID, void *child);
+#ifdef DEBUG_CC
+    NS_IMETHOD_(void) NoteNextEdgeName(const char* name);
+#endif
 };
 
 GCGraphBuilder::GCGraphBuilder(GCGraph &aGraph,
@@ -1360,6 +1388,10 @@ NS_IMETHODIMP_(void)
 NS_IMETHODIMP_(void)
 GCGraphBuilder::NoteXPCOMChild(nsISupports *child) 
 {
+#ifdef DEBUG_CC
+    nsCString edgeName(mNextEdgeName);
+    mNextEdgeName.Truncate();
+#endif
     if (!child || !(child = canonicalize(child)))
         return; 
 
@@ -1375,6 +1407,9 @@ GCGraphBuilder::NoteXPCOMChild(nsISuppor
         if (!childPi)
             return;
         mEdgeBuilder.Add(childPi);
+#ifdef DEBUG_CC
+        mCurrPi->mEdgeNames.AppendCString(edgeName);
+#endif
         ++childPi->mInternalRefs;
     }
 }
@@ -1383,6 +1418,10 @@ GCGraphBuilder::NoteNativeChild(void *ch
 GCGraphBuilder::NoteNativeChild(void *child,
                                 nsCycleCollectionParticipant *participant)
 {
+#ifdef DEBUG_CC
+    nsCString edgeName(mNextEdgeName);
+    mNextEdgeName.Truncate();
+#endif
     if (!child)
         return;
 
@@ -1392,12 +1431,19 @@ GCGraphBuilder::NoteNativeChild(void *ch
     if (!childPi)
         return;
     mEdgeBuilder.Add(childPi);
+#ifdef DEBUG_CC
+    mCurrPi->mEdgeNames.AppendCString(edgeName);
+#endif
     ++childPi->mInternalRefs;
 }
 
 NS_IMETHODIMP_(void)
 GCGraphBuilder::NoteScriptChild(PRUint32 langID, void *child) 
 {
+#ifdef DEBUG_CC
+    nsCString edgeName(mNextEdgeName);
+    mNextEdgeName.Truncate();
+#endif
     if (!child)
         return;
 
@@ -1414,8 +1460,19 @@ GCGraphBuilder::NoteScriptChild(PRUint32
     if (!childPi)
         return;
     mEdgeBuilder.Add(childPi);
+#ifdef DEBUG_CC
+    mCurrPi->mEdgeNames.AppendCString(edgeName);
+#endif
     ++childPi->mInternalRefs;
 }
+
+#ifdef DEBUG_CC
+NS_IMETHODIMP_(void)
+GCGraphBuilder::NoteNextEdgeName(const char* name)
+{
+    mNextEdgeName = name;
+}
+#endif
 
 static PRBool
 AddPurpleRoot(GCGraphBuilder &builder, nsISupports *root)
@@ -2022,6 +2079,7 @@ public:
     NS_IMETHOD_(void) NoteScriptChild(PRUint32 langID, void *child) {}
     NS_IMETHOD_(void) NoteNativeChild(void *child,
                                      nsCycleCollectionParticipant *participant) {}
+    NS_IMETHOD_(void) NoteNextEdgeName(const char* name) {}
 };
 
 char *Suppressor::sSuppressionList = nsnull;
@@ -2545,8 +2603,11 @@ nsCycleCollector::ExplainLiveExpectedGar
                     if (e->mTarget->mSCCIndex == INDEX_UNREACHED) {
                         e->mTarget->mSCCIndex = INDEX_REACHED;
                         PtrInfo *target = e->mTarget;
-                        if (!target->mShortestPathToExpectedGarbage)
+                        if (!target->mShortestPathToExpectedGarbage) {
                             target->mShortestPathToExpectedGarbage = pi;
+                            target->mShortestPathToExpectedGarbageEdgeName =
+                                e->mEdgeName;
+                        }
                         queue.Push(target);
                     }
                 }
@@ -2572,8 +2633,16 @@ nsCycleCollector::ExplainLiveExpectedGar
                            "reached from it by the path:\n");
                     for (PtrInfo *path = pi, *prev = nsnull; prev != path;
                          prev = path,
-                         path = path->mShortestPathToExpectedGarbage)
+                         path = path->mShortestPathToExpectedGarbage) {
+                        if (prev) {
+                            nsCString *edgeName = prev
+                                ->mShortestPathToExpectedGarbageEdgeName;
+                            printf("        via %s\n",
+                                   edgeName->IsEmpty() ? "<unknown edge>"
+                                                       : edgeName->get());
+                        }
                         printf("    %s %p\n", path->mName, path->mPointer);
+                    }
 
                     if (pi->mRefCount == PR_UINT32_MAX) {
                         printf("  The known references to it were from:\n");
@@ -2584,8 +2653,12 @@ nsCycleCollector::ExplainLiveExpectedGar
                     }
                     for (ReversedEdge *e = pi->mReversedEdges;
                          e; e = e->mNext) {
-                        printf("    %s %p\n",
+                        printf("    %s %p",
                                e->mTarget->mName, e->mTarget->mPointer);
+                        if (!e->mEdgeName->IsEmpty()) {
+                            printf(" via %s", e->mEdgeName->get());
+                        }
+                        printf("\n");
                     }
                     mRuntimes[pi->mLangID]->PrintAllReferencesTo(pi->mPointer);
                 }
@@ -2734,12 +2807,15 @@ nsCycleCollector::CreateReversedEdges()
     NodePool::Enumerator buildQueue(mGraph.mNodes);
     while (!buildQueue.IsDone()) {
         PtrInfo *pi = buildQueue.GetNext();
+        PRInt32 i = 0;
         for (EdgePool::Iterator e = pi->mFirstChild, e_end = pi->mLastChild;
              e != e_end; ++e) {
             current->mTarget = pi;
+            current->mEdgeName = pi->mEdgeNames.CStringAt(i);
             current->mNext = (*e)->mReversedEdges;
             (*e)->mReversedEdges = current;
             ++current;
+            ++i;
         }
     }
     NS_ASSERTION(current - mGraph.mReversedEdges == ptrdiff_t(edgeCount),
diff --git a/xpcom/glue/nsCycleCollectionParticipant.h b/xpcom/glue/nsCycleCollectionParticipant.h
--- a/xpcom/glue/nsCycleCollectionParticipant.h
+++ b/xpcom/glue/nsCycleCollectionParticipant.h
@@ -113,6 +113,11 @@ public:
     NS_IMETHOD_(void) NoteXPCOMChild(nsISupports *child) = 0;
     NS_IMETHOD_(void) NoteNativeChild(void *child,
                                       nsCycleCollectionParticipant *helper) = 0;
+#ifdef DEBUG_CC
+    // Give a name to the edge associated with the next call to
+    // NoteScriptChild, NoteXPCOMChild, or NoteNativeChild.
+    NS_IMETHOD_(void) NoteNextEdgeName(const char* name) = 0;
+#endif
 };
 
 class NS_NO_VTABLE nsCycleCollectionParticipant
@@ -357,39 +362,64 @@ public:
     _class *tmp = static_cast<_class*>(p);                                     \
     NS_IMPL_CYCLE_COLLECTION_DESCRIBE(_class)
 
+#ifdef DEBUG_CC
+  #define NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(_cb, _name)                       \
+    PR_BEGIN_MACRO (_cb).NoteNextEdgeName(_name); PR_END_MACRO
+#else
+  #define NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(_cb, _name)                       \
+    PR_BEGIN_MACRO PR_END_MACRO
+#endif
+
 #define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(_field)                       \
-    cb.NoteXPCOMChild(tmp->_field);
+  PR_BEGIN_MACRO                                                               \
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, #_field);                           \
+    cb.NoteXPCOMChild(tmp->_field);                                            \
+  PR_END_MACRO;
 
 #define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(_field)                     \
-    cb.NoteXPCOMChild(tmp->_field.get());
+  PR_BEGIN_MACRO                                                               \
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, #_field);                           \
+    cb.NoteXPCOMChild(tmp->_field.get());                                      \
+  PR_END_MACRO;
 
 #define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(_field, _base)    \
-    cb.NoteXPCOMChild(NS_ISUPPORTS_CAST(_base*, tmp->_field));
+  PR_BEGIN_MACRO                                                               \
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, #_field);                           \
+    cb.NoteXPCOMChild(NS_ISUPPORTS_CAST(_base*, tmp->_field));                 \
+  PR_END_MACRO;
 
 #define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(_field)                   \
     {                                                                          \
       PRInt32 i;                                                               \
-      for (i = 0; i < tmp->_field.Count(); ++i)                                \
+      for (i = 0; i < tmp->_field.Count(); ++i) {                              \
+        NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, #_field "[i]");                 \
         cb.NoteXPCOMChild(tmp->_field[i]);                                     \
+      }                                                                        \
     }
 
-#define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_PTR(_ptr, _ptr_class)         \
-  cb.NoteNativeChild(_ptr, &NS_CYCLE_COLLECTION_NAME(_ptr_class));
+#define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_PTR(_ptr, _ptr_class, _name)  \
+  PR_BEGIN_MACRO                                                               \
+    NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, _name);                             \
+    cb.NoteNativeChild(_ptr, &NS_CYCLE_COLLECTION_NAME(_ptr_class));           \
+  PR_END_MACRO;
 
 #define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(_field, _field_class)  \
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_PTR(tmp->_field, _field_class)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_PTR(tmp->_field, _field_class,      \
+                                               #_field)
 
-#define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY(_array, _element_class)     \
+#define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY(_array, _element_class, _name) \
     {                                                                          \
       PRUint32 i, length = (_array).Length();                                  \
       for (i = 0; i < length; ++i)                                             \
         NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_PTR((_array)[i],              \
-                                                     _element_class);          \
+                                                     _element_class,           \
+                                                     _name "[i]");             \
     }
 
 #define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY_MEMBER(_field,              \
                                                           _element_class)      \
-    NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY(tmp->_field, _element_class)
+    NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY(tmp->_field, _element_class,    \
+                                               #_field)
 
 #define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS                       \
     TraverseScriptObjects(tmp, cb);
