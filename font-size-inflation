From: L. David Baron <dbaron@dbaron.org>

Implement computation of font size inflation.  (Bug 627842)

diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -4363,8 +4363,138 @@ NS_IMETHODIMP
 nsReflowFrameRunnable::Run()
 {
   if (mWeakFrame.IsAlive()) {
     mWeakFrame->PresContext()->PresShell()->
       FrameNeedsReflow(mWeakFrame, mIntrinsicDirty, mBitToAdd);
   }
   return NS_OK;
 }
+
+static nscoord
+MinimumFontSizeFor(nscoord aContainerWidth)
+{
+  // FIXME: Control with prefs.  (Which of sizes or ratios will need
+  // less adjustment across devices?  A ratio would work just like the
+  // '15' below; with a size preference we'd compute the 15 below by
+  // dividing screen size by the minimum font size.)
+  return aContainerWidth / 15;
+}
+
+// NOTE: line heights should be inflated by the same ratio as the font
+// size of the same text; the aStyleFontSize parameter here should
+// always be a font size, and never a line height.
+static float
+FontSizeInflationFor(nscoord aContainerContentWidth, nscoord aStyleFontSize)
+{
+  if (aStyleFontSize <= 0) {
+    // Never scale zero font size.
+    return 1.0;
+  }
+
+  nscoord min = MinimumFontSizeFor(aContainerContentWidth);
+  if (min <= 0) {
+    // No need to scale.
+    return 1.0;
+  }
+
+  // Scale everything from 0-1.5 times min to instead fit in the range
+  // 1-1.5 times min, so that we still show some distinction rather than
+  // just enforcing a minimum.
+  // FIXME: Fiddle with this algorithm; maybe have prefs to control it?
+  float ratio = float(aStyleFontSize) / float(min);
+  if (ratio >= 1.5f) {
+    // If we're already at 1.5 or more times the minimum, don't scale.
+    return 1.0;
+  }
+
+  // To scale 0-1.5 times min to instead be 1-1.5 times min, we want
+  // to the desired multiple of min to be 1 + (ratio/3) (where ratio
+  // is our input's multiple of min).  The scaling needed to produce
+  // that is that divided by |ratio|, or:
+  return (1.0f / ratio) + (1.0f / 3.0f);
+}
+
+static inline bool
+IsContainerForFontSizeInflation(nsIFrame *aFrame)
+{
+  // For now, basically anything other than inline and text frames.
+  // FIXME (maybe): This may be wrong, since we probably want many cases
+  // of nested blocks to apply the same scaling to both even if they
+  // have different widths -- though for many other cases of nested
+  // blocks this is what we want.
+  return !aFrame->IsFrameOfType(nsIFrame::eLineParticipant);
+}
+
+static bool
+ShouldInflateFontsForContainer(nsIFrame *aFrame)
+{
+  // FIXME: We only want to inflate fonts for text that is in a place
+  // with room to expand.  The question is what the best heuristic for
+  // that is...
+
+  // If any ancestor has a constrained height, we should not expand.
+  return true;
+}
+
+float
+nsLayoutUtils::FontSizeInflationFor(const nsHTMLReflowState *aReflowState)
+{
+#ifdef DEBUG
+  {
+    const nsHTMLReflowState *rs = aReflowState;
+    nsIFrame *f = aReflowState->frame;
+    for (; rs; rs = rs->parentReflowState, f = f->GetParent()) {
+      NS_ABORT_IF_FALSE(rs->frame == f,
+                        "reflow state parentage must match frame parentage");
+    }
+  }
+#endif
+
+  for (const nsHTMLReflowState *rs = aReflowState; rs;
+       rs = rs->parentReflowState) {
+    if (IsContainerForFontSizeInflation(rs->frame)) {
+      if (!ShouldInflateFontsForContainer(rs->frame)) {
+        return 1.0;
+      }
+
+      NS_ABORT_IF_FALSE(rs->ComputedWidth() != NS_INTRINSICSIZE,
+                        "must have a computed width");
+      return ::FontSizeInflationFor(rs->ComputedWidth(),
+                 aReflowState->frame->GetStyleFont()->mFont.size);
+    }
+  }
+
+  NS_ABORT_IF_FALSE(false, "reflow roots should always be container");
+
+  return 1.0;
+}
+
+float
+nsLayoutUtils::FontSizeInflationFor(nsIFrame *aFrame)
+{
+#ifdef DEBUG
+  // Check that neither this frame nor any of its ancestors are
+  // currently being reflowed.
+  for (nsIFrame *f = aFrame; f; f = f->GetParent()) {
+    NS_ABORT_IF_FALSE(!(f->GetStateBits() & NS_FRAME_IN_REFLOW),
+                      "must call nsHTMLReflowState* version during reflow");
+  }
+  // It's ok if frames are dirty, or even if they've never been
+  // reflowed, since they will be eventually and then we'll get the
+  // right size.
+#endif
+
+  for (nsIFrame *f = aFrame; f; f = f->GetParent()) {
+    if (IsContainerForFontSizeInflation(f)) {
+      if (!ShouldInflateFontsForContainer(f)) {
+        return 1.0;
+      }
+
+      return ::FontSizeInflationFor(f->GetContentRect().width,
+                                    aFrame->GetStyleFont()->mFont.size);
+    }
+  }
+
+  NS_ABORT_IF_FALSE(false, "root should always be container");
+
+  return 1.0;
+}
diff --git a/layout/base/nsLayoutUtils.h b/layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h
+++ b/layout/base/nsLayoutUtils.h
@@ -1425,16 +1425,24 @@ public:
                                       PRBool aFollowContinuations,
                                       nsFontFaceList* aFontFaceList);
 
   /**
    * Checks if CSS 3D transforms are currently enabled.
    */
   static PRBool Are3DTransformsEnabled();
 
+  /**
+   * Return the font size inflation *ratio* for a given frame; pass a
+   * reflow state if the frame or any of its ancestors are currently
+   * being reflowed and a frame otherwise.
+   */
+  static float FontSizeInflationFor(const nsHTMLReflowState *aReflowState);
+  static float FontSizeInflationFor(nsIFrame *aFrame);
+
   static void Shutdown();
 
 #ifdef DEBUG
   /**
    * Assert that there are no duplicate continuations of the same frame
    * within aFrameList.  Optimize the tests by assuming that all frames
    * in aFrameList have parent aContainer.
    */
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -1056,16 +1056,18 @@ nsBlockFrame::Reflow(nsPresContext*     
   nsOverflowAreas fcBounds;
   nsReflowStatus fcStatus = NS_FRAME_COMPLETE;
   rv = ReflowPushedFloats(state, fcBounds, fcStatus);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // If we're not dirty (which means we'll mark everything dirty later)
   // and our width has changed, mark the lines dirty that we need to
   // mark dirty for a resize reflow.
+  // FIXME: If font size inflation is enabled, we just need to mark
+  // everything dirty.
   if (reflowState->mFlags.mHResize)
     PrepareResizeReflow(state);
 
   mState &= ~NS_FRAME_FIRST_REFLOW;
 
   // Now reflow...
   rv = ReflowDirtyLines(state);
   NS_ASSERTION(NS_SUCCEEDED(rv), "reflow dirty lines failed");
diff --git a/layout/generic/nsLineLayout.h b/layout/generic/nsLineLayout.h
--- a/layout/generic/nsLineLayout.h
+++ b/layout/generic/nsLineLayout.h
@@ -363,16 +363,19 @@ public:
   }
 
   /**
    * This can't be null. It usually returns a block frame but may return
    * some other kind of frame when inline frames are reflowed in a non-block
    * context (e.g. MathML or floating first-letter).
    */
   nsIFrame* GetLineContainerFrame() const { return mBlockReflowState->frame; }
+  const nsHTMLReflowState* GetLineContainerRS() const {
+    return mBlockReflowState;
+  }
   const nsLineList::iterator* GetLine() const {
     return GetFlag(LL_GOTLINEBOX) ? &mLineBox : nsnull;
   }
   nsLineList::iterator* GetLine() {
     return GetFlag(LL_GOTLINEBOX) ? &mLineBox : nsnull;
   }
   
   /**
diff --git a/layout/generic/nsTextFrameThebes.cpp b/layout/generic/nsTextFrameThebes.cpp
--- a/layout/generic/nsTextFrameThebes.cpp
+++ b/layout/generic/nsTextFrameThebes.cpp
@@ -7090,17 +7090,22 @@ nsTextFrame::ReflowText(nsLineLayout& aL
 
   NS_ASSERTION(gfxSkipCharsIterator(iter).ConvertOriginalToSkipped(offset + length)
                     <= mTextRun->GetLength(),
                "Text run does not map enough text for our reflow");
 
   /////////////////////////////////////////////////////////////////////
   // See how much text should belong to this text frame, and measure it
   /////////////////////////////////////////////////////////////////////
-  
+  float fontSizeInflation =
+    nsLayoutUtils::FontSizeInflationFor(aLineLayout.GetLineContainerRS());
+  // REVIEW: He're we're assuming that drawing text with a different
+  // font size scales it up by exactly that scale, which is bogus.
+  //FIXME AutoScaleTextRun autoscale(mTextRun, fontSizeInflation);
+
   iter.SetOriginalOffset(offset);
   nscoord xOffsetForTabs = (mTextRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_TAB) ?
     (aLineLayout.GetCurrentFrameXDistanceFromBlock() -
        lineContainer->GetUsedBorderAndPadding().left)
     : -1;
   PropertyProvider provider(mTextRun, textStyle, frag, this, iter, length,
       lineContainer, xOffsetForTabs);
 
@@ -7533,16 +7538,19 @@ nsTextFrame::RecomputeOverflow()
 {
   nsRect bounds(nsPoint(0, 0), GetSize());
   nsOverflowAreas result(bounds, bounds);
 
   gfxSkipCharsIterator iter = EnsureTextRun();
   if (!mTextRun)
     return result;
 
+  // FIXME: inflation (and everywhere else we construct a
+  // PropertyProvider!)
+  // FIXME: also scale the word spacing and letter spacing!
   PropertyProvider provider(this, iter);
   provider.InitializeForDisplay(PR_TRUE);
 
   gfxTextRun::Metrics textMetrics =
     mTextRun->MeasureText(provider.GetStart().GetSkippedOffset(),
                           ComputeTransformedLength(provider),
                           gfxFont::LOOSE_INK_EXTENTS, nsnull,
                           &provider);
