Make nsPseudoClassList capable of storing integers or integer pairs.  b=75375

diff --git a/layout/style/nsCSSStyleRule.cpp b/layout/style/nsCSSStyleRule.cpp
--- a/layout/style/nsCSSStyleRule.cpp
+++ b/layout/style/nsCSSStyleRule.cpp
@@ -157,20 +157,80 @@ nsAtomList::~nsAtomList(void)
   NS_IF_DEEP_DELETE(nsAtomList, mNext);
 }
 
+static PRBool
+PseudoClassHasStringArg(nsIAtom* aAtom)
+{
+}
+
+static PRBool
+PseudoClassHasIntegerArg(nsIAtom* aAtom)
+{
+}
+
+static PRBool
+PseudoClassHasIntPairArg(nsIAtom* aAtom)
+{
+}
+
+nsPseudoClassList::nsPseudoClassList(nsIAtom* aAtom)
+  : mAtom(aAtom),
+    mNext(nsnull)
+{
+  NS_ASSERTION(!PseudoClassHasStringArg(aAtom) &&
+               !PseudoClassHasIntegerArg(aAtom) &&
+               !PseudoClassHasIntPairArg(aAtom),
+               "unexpected pseudo-class");
+  MOZ_COUNT_CTOR(nsPseudoClassList);
+  u.mMemory = nsnull;
+}
+
 nsPseudoClassList::nsPseudoClassList(nsIAtom* aAtom, const PRUnichar* aString)
   : mAtom(aAtom),
-    mString(nsnull),
     mNext(nsnull)
 {
+  NS_ASSERTION(PseudoClassHasStringArg(aAtom), "unexpected pseudo-class");
+  NS_ASSERTION(aString, "string expected");
   MOZ_COUNT_CTOR(nsPseudoClassList);
-  if (aString)
-    mString = NS_strdup(aString);
+  u.mString = NS_strdup(aString);
+}
+
+nsPseudoClassList::nsPseudoClassList(nsIAtom* aAtom, const PRInt32 aInteger)
+  : mAtom(aAtom),
+    mNext(nsnull)
+{
+  NS_ASSERTION(PseudoClassHasIntegerArg(aAtom), "unexpected pseudo-class");
+  MOZ_COUNT_CTOR(nsPseudoClassList);
+  u.mNumbers =
+    static_cast<PRInt32*>(nsMemory::Clone(&aInteger, sizeof(PRInt32)));
+}
+
+nsPseudoClassList::nsPseudoClassList(nsIAtom* aAtom, const PRInt32* aIntPair)
+  : mAtom(aAtom),
+    mNext(nsnull)
+{
+  NS_ASSERTION(PseudoClassHasIntPairArg(aAtom), "unexpected pseudo-class");
+  NS_ASSERTION(aIntPair, "integer pair expected");
+  MOZ_COUNT_CTOR(nsPseudoClassList);
+  u.mNumbers =
+    static_cast<PRInt32*>(nsMemory::Clone(aIntPair, sizeof(PRInt32) * 2));
 }
 
 nsPseudoClassList*
 nsPseudoClassList::Clone(PRBool aDeep) const
 {
-  nsPseudoClassList *result = new nsPseudoClassList(mAtom, mString);
+  nsPseudoClassList *result = new nsPseudoClassList(mAtom);
+  if (u.mMemory) {
+    if (PseudoClassHasStringArg(mAtom)) {
+      result->u.mString = NS_strdup(u.mString);
+    } else if (PseudoClassHasIntegerArg(mAtom)) {
+      result->u.mNumbers = static_cast<PRInt32*>(
+        nsMemory::Clone(u.mNumbers, sizeof(PRInt32)));
+    } else {
+      NS_ASSERTION(PseudoClassHasIntPairArg(mAtom), "unexpected pseudo-class");
+      result->u.mNumbers = static_cast<PRInt32*>(
+        nsMemory::Clone(u.mNumbers, sizeof(PRInt32) * 2));
+    }
+  }
 
   if (aDeep)
     NS_IF_DEEP_CLONE(nsPseudoClassList, mNext, (PR_FALSE));
@@ -181,8 +241,8 @@ nsPseudoClassList::~nsPseudoClassList(vo
 nsPseudoClassList::~nsPseudoClassList(void)
 {
   MOZ_COUNT_DTOR(nsPseudoClassList);
-  if (mString)
-    NS_Free(mString);
+  if (u.mMemory)
+    NS_Free(u.mMemory);
   NS_IF_DEEP_DELETE(nsPseudoClassList, mNext);
 }
 
@@ -346,16 +406,36 @@ void nsCSSSelector::AddClass(const nsStr
   }
 }
 
+void nsCSSSelector::AddPseudoClass(nsIAtom* aPseudoClass)
+{
+  AddPseudoClassInternal(new nsPseudoClassList(aPseudoClass));
+}
+
 void nsCSSSelector::AddPseudoClass(nsIAtom* aPseudoClass,
                                    const PRUnichar* aString)
 {
-  if (nsnull != aPseudoClass) {
-    nsPseudoClassList** list = &mPseudoClassList;
-    while (nsnull != *list) {
-      list = &((*list)->mNext);
-    }
-    *list = new nsPseudoClassList(aPseudoClass, aString);
+  AddPseudoClassInternal(new nsPseudoClassList(aPseudoClass, aString));
+}
+
+void nsCSSSelector::AddPseudoClass(nsIAtom* aPseudoClass,
+                                   const PRInt32 aInteger)
+{
+  AddPseudoClassInternal(new nsPseudoClassList(aPseudoClass, aInteger));
+}
+
+void nsCSSSelector::AddPseudoClass(nsIAtom* aPseudoClass,
+                                   const PRInt32* aIntPair)
+{
+  AddPseudoClassInternal(new nsPseudoClassList(aPseudoClass, aIntPair));
+}
+
+void nsCSSSelector::AddPseudoClassInternal(nsPseudoClassList *aPseudoClass)
+{
+  nsPseudoClassList** list = &mPseudoClassList;
+  while (nsnull != *list) {
+    list = &((*list)->mNext);
   }
+  *list = aPseudoClass;
 }
 
 void nsCSSSelector::AddAttribute(PRInt32 aNameSpace, const nsString& aAttr)
@@ -627,9 +707,23 @@ void nsCSSSelector::ToStringInternal(nsA
     while (list != nsnull) {
       list->mAtom->ToString(temp);
       aString.Append(temp);
-      if (nsnull != list->mString) {
+      if (list->u.mMemory) {
         aString.Append(PRUnichar('('));
-        aString.Append(list->mString);
+        if (PseudoClassHasStringArg(mAtom)) {
+          aString.Append(list->u.mString);
+        } else if (PseudoClassHasIntegerArg(mAtom)) {
+          nsString temp;
+          temp.AppendInt(result->u.mNumbers[0]);
+          aString.Append(temp);
+        } else {
+          NS_ASSERTION(PseudoClassHasIntPairArg(mAtom),
+                       "unexpected pseudo-class");
+          nsString temp;
+          temp.AppendInt(result->u.mNumbers[0]);
+          temp.Append(PRUnichar(','));
+          temp.AppendInt(result->u.mNumbers[1]);
+          aString.Append(temp);
+        }
         aString.Append(PRUnichar(')'));
       }
       list = list->mNext;
diff --git a/layout/style/nsICSSStyleRule.h b/layout/style/nsICSSStyleRule.h
--- a/layout/style/nsICSSStyleRule.h
+++ b/layout/style/nsICSSStyleRule.h
@@ -77,14 +77,22 @@ private:
 
 struct nsPseudoClassList {
 public:
-  nsPseudoClassList(nsIAtom* aAtom, const PRUnichar *aString = nsnull);
+  nsPseudoClassList(nsIAtom* aAtom);
+  nsPseudoClassList(nsIAtom* aAtom, const PRUnichar *aString);
+  nsPseudoClassList(nsIAtom* aAtom, const PRUint32 aInteger);
+  nsPseudoClassList(nsIAtom* aAtom, const PRUint32 *aIntPair);
   ~nsPseudoClassList(void);
 
   /** Do a deep clone.  Should be used only on the first in the linked list. */
   nsPseudoClassList* Clone() const { return Clone(PR_TRUE); }
 
   nsCOMPtr<nsIAtom> mAtom;
-  PRUnichar*        mString;
+  union {
+    void*           mMemory; // all pointer types use NS_Alloc/NS_Free
+    // Which of the following is used depend on mAtom.
+    PRUnichar*      mString;
+    PRInt32*        mNumbers;
+  } u;
   nsPseudoClassList* mNext;
 private: 
   nsPseudoClassList* Clone(PRBool aDeep) const;
@@ -141,7 +149,10 @@ public:
   void SetTag(const nsString& aTag);
   void AddID(const nsString& aID);
   void AddClass(const nsString& aClass);
-  void AddPseudoClass(nsIAtom* aPseudoClass, const PRUnichar* aString = nsnull);
+  void AddPseudoClass(nsIAtom* aPseudoClass);
+  void AddPseudoClass(nsIAtom* aPseudoClass, const PRUnichar* aString);
+  void AddPseudoClass(nsIAtom* aPseudoClass, const PRInt32 aInteger);
+  void AddPseudoClass(nsIAtom* aPseudoClass, const PRInt32* aIntPair);
   void AddAttribute(PRInt32 aNameSpace, const nsString& aAttr);
   void AddAttribute(PRInt32 aNameSpace, const nsString& aAttr, PRUint8 aFunc, 
                     const nsString& aValue, PRBool aCaseSensitive);
@@ -153,6 +164,7 @@ public:
                 PRBool aAppend = PR_FALSE) const;
 
 private:
+  void AddPseudoClassInternal(nsPseudoClassList *aPseudoClass);
   nsCSSSelector* Clone(PRBool aDeepNext, PRBool aDeepNegations) const;
 
   void AppendNegationToString(nsAString& aString);
