Make nsPseudoClassList capable of storing integer pairs for :nth-*().  b=75375  r+sr=bzbarsky

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -2555,19 +2555,17 @@ CSSParserImpl::ParsePseudoSelector(PRInt
   // If it's a function token, it better be on our "ok" list, and if the name
   // is that of a function pseudo it better be a function token
   if ((eCSSToken_Function == mToken.mType) !=
       (
 #ifdef MOZ_XUL
        isTree ||
 #endif
        nsCSSPseudoClasses::notPseudo == pseudo ||
-       nsCSSPseudoClasses::lang == pseudo ||
-       nsCSSPseudoClasses::mozEmptyExceptChildrenWithLocalname == pseudo ||
-       nsCSSPseudoClasses::mozSystemMetric == pseudo)) {
+       nsCSSPseudoClasses::HasStringArg(pseudo))) {
     // There are no other function pseudos
     REPORT_UNEXPECTED_TOKEN(PEPseudoSelNonFunc);
     UngetToken();
     return eSelectorParsingStatus_Error;
   }
   
   // If it starts with "::", it better be a pseudo-element
   if (parsingPseudoElement &&
@@ -2588,19 +2586,17 @@ CSSParserImpl::ParsePseudoSelector(PRInt
     nsSelectorParsingStatus parsingStatus =
       ParseNegatedSimpleSelector(aDataMask, aSelector, aErrorCode);
     if (eSelectorParsingStatus_Continue != parsingStatus) {
       return parsingStatus;
     }
   }    
   else if (!parsingPseudoElement && isPseudoClass) {
     aDataMask |= SEL_MASK_PCLASS;
-    if (nsCSSPseudoClasses::lang == pseudo ||
-        nsCSSPseudoClasses::mozEmptyExceptChildrenWithLocalname == pseudo ||
-        nsCSSPseudoClasses::mozSystemMetric == pseudo) {
+    if (nsCSSPseudoClasses::HasStringArg(pseudo)) {
       nsSelectorParsingStatus parsingStatus =
         ParsePseudoClassWithIdentArg(aSelector, pseudo, aErrorCode);
       if (eSelectorParsingStatus_Continue != parsingStatus) {
         return parsingStatus;
       }
     }
     // XXX are there more pseudo classes which accept arguments ?
     else {
diff --git a/layout/style/nsCSSPseudoClasses.cpp b/layout/style/nsCSSPseudoClasses.cpp
--- a/layout/style/nsCSSPseudoClasses.cpp
+++ b/layout/style/nsCSSPseudoClasses.cpp
@@ -63,8 +63,21 @@ void nsCSSPseudoClasses::AddRefAtoms()
 }
 
 PRBool nsCSSPseudoClasses::IsPseudoClass(nsIAtom *aAtom)
 {
   return nsAtomListUtils::IsMember(aAtom,CSSPseudoClasses_info,
                                    NS_ARRAY_LENGTH(CSSPseudoClasses_info));
 }
 
+PRBool
+nsCSSPseudoClasses::HasStringArg(nsIAtom* aAtom)
+{
+  return aAtom == nsCSSPseudoClasses::lang ||
+         aAtom == nsCSSPseudoClasses::mozEmptyExceptChildrenWithLocalname ||
+         aAtom == nsCSSPseudoClasses::mozSystemMetric;
+}
+
+PRBool
+nsCSSPseudoClasses::HasNthPairArg(nsIAtom* aAtom)
+{
+  return PR_FALSE;
+}
diff --git a/layout/style/nsCSSPseudoClasses.h b/layout/style/nsCSSPseudoClasses.h
--- a/layout/style/nsCSSPseudoClasses.h
+++ b/layout/style/nsCSSPseudoClasses.h
@@ -48,15 +48,17 @@ class nsICSSPseudoClass : public nsIAtom
 class nsICSSPseudoClass : public nsIAtom {};
 
 class nsCSSPseudoClasses {
 public:
 
   static void AddRefAtoms();
 
   static PRBool IsPseudoClass(nsIAtom *aAtom);
+  static PRBool HasStringArg(nsIAtom* aAtom);
+  static PRBool HasNthPairArg(nsIAtom* aAtom);
 
 #define CSS_PSEUDO_CLASS(_name, _value) static nsICSSPseudoClass* _name;
 #include "nsCSSPseudoClassList.h"
 #undef CSS_PSEUDO_CLASS
 };
 
 #endif /* nsCSSPseudoClasses_h___ */
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1156,38 +1156,38 @@ static PRBool SelectorMatches(RuleProces
       do {
         child = element->GetChildAt(++index);
         // stop at first non-comment (and non-whitespace for
         // :-moz-only-whitespace) node        
       } while (child && !IsSignificantChild(child, PR_TRUE, isWhitespaceSignificant));
       result = (child == nsnull);
     }
     else if (nsCSSPseudoClasses::mozEmptyExceptChildrenWithLocalname == pseudoClass->mAtom) {
-      NS_ASSERTION(pseudoClass->mString, "Must have string!");
+      NS_ASSERTION(pseudoClass->u.mString, "Must have string!");
       nsIContent *child = nsnull;
       nsIContent *element = data.mContent;
       PRInt32 index = -1;
 
       if (setNodeFlags)
         element->SetFlags(NODE_HAS_SLOW_SELECTOR);
 
       do {
         child = element->GetChildAt(++index);
       } while (child &&
                (!IsSignificantChild(child, PR_TRUE, PR_FALSE) ||
                 (child->GetNameSpaceID() == element->GetNameSpaceID() &&
-                 child->Tag()->Equals(nsDependentString(pseudoClass->mString)))));
+                 child->Tag()->Equals(nsDependentString(pseudoClass->u.mString)))));
       result = (child == nsnull);
     }
     else if (nsCSSPseudoClasses::mozSystemMetric == pseudoClass->mAtom) {
       if (!sSystemMetrics && !InitSystemMetrics()) {
         return PR_FALSE;
       }
-      NS_ASSERTION(pseudoClass->mString, "Must have string!");
-      nsCOMPtr<nsIAtom> metric = do_GetAtom(pseudoClass->mString);
+      NS_ASSERTION(pseudoClass->u.mString, "Must have string!");
+      nsCOMPtr<nsIAtom> metric = do_GetAtom(pseudoClass->u.mString);
       result = sSystemMetrics->IndexOf(metric) !=
                sSystemMetrics->NoIndex;
     }
     else if (nsCSSPseudoClasses::mozHasHandlerRef == pseudoClass->mAtom) {
       nsIContent *child = nsnull;
       nsIContent *element = data.mContent;
       PRInt32 index = -1;
 
@@ -1210,40 +1210,40 @@ static PRBool SelectorMatches(RuleProces
     }
     else if (nsCSSPseudoClasses::mozBoundElement == pseudoClass->mAtom) {
       // XXXldb How do we know where the selector came from?  And what
       // if there are multiple bindings, and we should be matching the
       // outer one?
       result = (data.mScopedRoot && data.mScopedRoot == data.mContent);
     }
     else if (nsCSSPseudoClasses::lang == pseudoClass->mAtom) {
-      NS_ASSERTION(nsnull != pseudoClass->mString, "null lang parameter");
+      NS_ASSERTION(nsnull != pseudoClass->u.mString, "null lang parameter");
       result = PR_FALSE;
-      if (pseudoClass->mString && *pseudoClass->mString) {
+      if (pseudoClass->u.mString && *pseudoClass->u.mString) {
         // We have to determine the language of the current element.  Since
         // this is currently no property and since the language is inherited
         // from the parent we have to be prepared to look at all parent
         // nodes.  The language itself is encoded in the LANG attribute.
         const nsString* lang = data.GetLang();
         if (lang && !lang->IsEmpty()) { // null check for out-of-memory
           result = nsStyleUtil::DashMatchCompare(*lang,
-                                    nsDependentString(pseudoClass->mString), 
+                                    nsDependentString(pseudoClass->u.mString), 
                                     nsCaseInsensitiveStringComparator());
         }
         else if (data.mContent) {
           nsIDocument* doc = data.mContent->GetDocument();
           if (doc) {
             // Try to get the language from the HTTP header or if this
             // is missing as well from the preferences.
             // The content language can be a comma-separated list of
             // language codes.
             nsAutoString language;
             doc->GetContentLanguage(language);
 
-            nsDependentString langString(pseudoClass->mString);
+            nsDependentString langString(pseudoClass->u.mString);
             language.StripWhitespace();
             PRInt32 begin = 0;
             PRInt32 len = language.Length();
             while (begin < len) {
               PRInt32 end = language.FindChar(PRUnichar(','), begin);
               if (end == kNotFound) {
                 end = len;
               }
diff --git a/layout/style/nsCSSStyleRule.cpp b/layout/style/nsCSSStyleRule.cpp
--- a/layout/style/nsCSSStyleRule.cpp
+++ b/layout/style/nsCSSStyleRule.cpp
@@ -17,16 +17,17 @@
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   David Hyatt <hyatt@netscape.com>
  *   Daniel Glazman <glazman@netscape.com>
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -68,16 +69,17 @@
 #include "nsINameSpaceManager.h"
 #include "nsXMLNameSpaceMap.h"
 #include "nsILookAndFeel.h"
 #include "nsRuleNode.h"
 #include "nsUnicharUtils.h"
 #include "nsCSSPseudoElements.h"
 #include "nsIPrincipal.h"
 #include "nsComponentManagerUtils.h"
+#include "nsCSSPseudoClasses.h"
 
 #include "nsContentUtils.h"
 #include "nsContentErrors.h"
 #include "mozAutoDocUpdate.h"
 
 #define NS_IF_CLONE(member_)                                                  \
   PR_BEGIN_MACRO                                                              \
     if (member_) {                                                            \
@@ -153,42 +155,75 @@ nsAtomList::Clone(PRBool aDeep) const
 }
 
 nsAtomList::~nsAtomList(void)
 {
   MOZ_COUNT_DTOR(nsAtomList);
   NS_IF_DEEP_DELETE(nsAtomList, mNext);
 }
 
+nsPseudoClassList::nsPseudoClassList(nsIAtom* aAtom)
+  : mAtom(aAtom),
+    mNext(nsnull)
+{
+  NS_ASSERTION(!nsCSSPseudoClasses::HasStringArg(aAtom) &&
+               !nsCSSPseudoClasses::HasNthPairArg(aAtom),
+               "unexpected pseudo-class");
+  MOZ_COUNT_CTOR(nsPseudoClassList);
+  u.mMemory = nsnull;
+}
+
 nsPseudoClassList::nsPseudoClassList(nsIAtom* aAtom, const PRUnichar* aString)
   : mAtom(aAtom),
-    mString(nsnull),
     mNext(nsnull)
 {
+  NS_ASSERTION(nsCSSPseudoClasses::HasStringArg(aAtom),
+               "unexpected pseudo-class");
+  NS_ASSERTION(aString, "string expected");
   MOZ_COUNT_CTOR(nsPseudoClassList);
-  if (aString)
-    mString = NS_strdup(aString);
+  u.mString = NS_strdup(aString);
+}
+
+nsPseudoClassList::nsPseudoClassList(nsIAtom* aAtom, const PRInt32* aIntPair)
+  : mAtom(aAtom),
+    mNext(nsnull)
+{
+  NS_ASSERTION(nsCSSPseudoClasses::HasNthPairArg(aAtom),
+               "unexpected pseudo-class");
+  NS_ASSERTION(aIntPair, "integer pair expected");
+  MOZ_COUNT_CTOR(nsPseudoClassList);
+  u.mNumbers =
+    static_cast<PRInt32*>(nsMemory::Clone(aIntPair, sizeof(PRInt32) * 2));
 }
 
 nsPseudoClassList*
 nsPseudoClassList::Clone(PRBool aDeep) const
 {
-  nsPseudoClassList *result = new nsPseudoClassList(mAtom, mString);
+  nsPseudoClassList *result;
+  if (!u.mMemory) {
+    result = new nsPseudoClassList(mAtom);
+  } else if (nsCSSPseudoClasses::HasStringArg(mAtom)) {
+    result = new nsPseudoClassList(mAtom, u.mString);
+  } else {
+    NS_ASSERTION(nsCSSPseudoClasses::HasNthPairArg(mAtom),
+                 "unexpected pseudo-class");
+    result = new nsPseudoClassList(mAtom, u.mNumbers);
+  }
 
   if (aDeep)
     NS_IF_DEEP_CLONE(nsPseudoClassList, mNext, (PR_FALSE));
 
   return result;
 }
 
 nsPseudoClassList::~nsPseudoClassList(void)
 {
   MOZ_COUNT_DTOR(nsPseudoClassList);
-  if (mString)
-    NS_Free(mString);
+  if (u.mMemory)
+    NS_Free(u.mMemory);
   NS_IF_DEEP_DELETE(nsPseudoClassList, mNext);
 }
 
 nsAttrSelector::nsAttrSelector(PRInt32 aNameSpace, const nsString& aAttr)
   : mNameSpace(aNameSpace),
     mAttr(nsnull),
     mFunction(NS_ATTR_FUNC_SET),
     mCaseSensitive(1),
@@ -342,26 +377,40 @@ void nsCSSSelector::AddClass(const nsStr
     nsAtomList** list = &mClassList;
     while (nsnull != *list) {
       list = &((*list)->mNext);
     }
     *list = new nsAtomList(aClass);
   }
 }
 
+void nsCSSSelector::AddPseudoClass(nsIAtom* aPseudoClass)
+{
+  AddPseudoClassInternal(new nsPseudoClassList(aPseudoClass));
+}
+
 void nsCSSSelector::AddPseudoClass(nsIAtom* aPseudoClass,
                                    const PRUnichar* aString)
 {
-  if (nsnull != aPseudoClass) {
-    nsPseudoClassList** list = &mPseudoClassList;
-    while (nsnull != *list) {
-      list = &((*list)->mNext);
-    }
-    *list = new nsPseudoClassList(aPseudoClass, aString);
+  AddPseudoClassInternal(new nsPseudoClassList(aPseudoClass, aString));
+}
+
+void nsCSSSelector::AddPseudoClass(nsIAtom* aPseudoClass,
+                                   const PRInt32* aIntPair)
+{
+  AddPseudoClassInternal(new nsPseudoClassList(aPseudoClass, aIntPair));
+}
+
+void nsCSSSelector::AddPseudoClassInternal(nsPseudoClassList *aPseudoClass)
+{
+  nsPseudoClassList** list = &mPseudoClassList;
+  while (nsnull != *list) {
+    list = &((*list)->mNext);
   }
+  *list = aPseudoClass;
 }
 
 void nsCSSSelector::AddAttribute(PRInt32 aNameSpace, const nsString& aAttr)
 {
   if (!aAttr.IsEmpty()) {
     nsAttrSelector** list = &mAttrList;
     while (nsnull != *list) {
       list = &((*list)->mNext);
@@ -623,19 +672,41 @@ void nsCSSSelector::ToStringInternal(nsA
   }
 
   // Append each pseudo-class in the linked list
   if (mPseudoClassList) {
     nsPseudoClassList* list = mPseudoClassList;
     while (list != nsnull) {
       list->mAtom->ToString(temp);
       aString.Append(temp);
-      if (nsnull != list->mString) {
+      if (list->u.mMemory) {
         aString.Append(PRUnichar('('));
-        aString.Append(list->mString);
+        if (nsCSSPseudoClasses::HasStringArg(list->mAtom)) {
+          aString.Append(list->u.mString);
+        } else {
+          NS_ASSERTION(nsCSSPseudoClasses::HasNthPairArg(list->mAtom),
+                       "unexpected pseudo-class");
+          PRInt32 a = list->u.mNumbers[0],
+                  b = list->u.mNumbers[1];
+          temp.Truncate();
+          if (a != 0) {
+            if (a == -1) {
+              temp.Append(PRUnichar('-'));
+            } else if (a != 1) {
+              temp.AppendInt(a);
+            }
+            temp.Append(PRUnichar('n'));
+          }
+          if (b != 0 || a == 0) {
+            if (b >= 0 && a != 0) // check a != 0 for whether we printed above
+              temp.Append(PRUnichar('+'));
+            temp.AppendInt(b);
+          }
+          aString.Append(temp);
+        }
         aString.Append(PRUnichar(')'));
       }
       list = list->mNext;
     }
   }
 
   if (!aIsNegated) {
     for (nsCSSSelector* negation = mNegations; negation;
diff --git a/layout/style/nsICSSStyleRule.h b/layout/style/nsICSSStyleRule.h
--- a/layout/style/nsICSSStyleRule.h
+++ b/layout/style/nsICSSStyleRule.h
@@ -16,16 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Daniel Glazman <glazman@netscape.com>
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -72,24 +73,37 @@ private:
 
   // These are not supported and are not implemented! 
   nsAtomList(const nsAtomList& aCopy);
   nsAtomList& operator=(const nsAtomList& aCopy); 
 };
 
 struct nsPseudoClassList {
 public:
-  nsPseudoClassList(nsIAtom* aAtom, const PRUnichar *aString = nsnull);
+  nsPseudoClassList(nsIAtom* aAtom);
+  nsPseudoClassList(nsIAtom* aAtom, const PRUnichar *aString);
+  nsPseudoClassList(nsIAtom* aAtom, const PRInt32 *aIntPair);
   ~nsPseudoClassList(void);
 
   /** Do a deep clone.  Should be used only on the first in the linked list. */
   nsPseudoClassList* Clone() const { return Clone(PR_TRUE); }
 
   nsCOMPtr<nsIAtom> mAtom;
-  PRUnichar*        mString;
+  union {
+    // For a given value of mAtom, we have either:
+    //   a. no value, which means mMemory is always null
+    //      (if neither of the conditions for (b) or (c) is true)
+    //   b. a string value, which means mString/mMemory is non-null
+    //      (if nsCSSPseudoClasses::HasStringArg(mAtom))
+    //   c. an integer pair value, which means mNumbers/mMemory is non-null
+    //      (if nsCSSPseudoClasses::HasNthPairArg(mAtom))
+    void*           mMemory; // both pointer types use NS_Alloc/NS_Free
+    PRUnichar*      mString;
+    PRInt32*        mNumbers;
+  } u;
   nsPseudoClassList* mNext;
 private: 
   nsPseudoClassList* Clone(PRBool aDeep) const;
 
   // These are not supported and are not implemented! 
   nsPseudoClassList(const nsPseudoClassList& aCopy);
   nsPseudoClassList& operator=(const nsPseudoClassList& aCopy); 
 };
@@ -136,28 +150,31 @@ public:
   /** Do a deep clone.  Should be used only on the first in the linked list. */
   nsCSSSelector* Clone() const { return Clone(PR_TRUE, PR_TRUE); }
 
   void Reset(void);
   void SetNameSpace(PRInt32 aNameSpace);
   void SetTag(const nsString& aTag);
   void AddID(const nsString& aID);
   void AddClass(const nsString& aClass);
-  void AddPseudoClass(nsIAtom* aPseudoClass, const PRUnichar* aString = nsnull);
+  void AddPseudoClass(nsIAtom* aPseudoClass);
+  void AddPseudoClass(nsIAtom* aPseudoClass, const PRUnichar* aString);
+  void AddPseudoClass(nsIAtom* aPseudoClass, const PRInt32* aIntPair);
   void AddAttribute(PRInt32 aNameSpace, const nsString& aAttr);
   void AddAttribute(PRInt32 aNameSpace, const nsString& aAttr, PRUint8 aFunc, 
                     const nsString& aValue, PRBool aCaseSensitive);
   void SetOperator(PRUnichar aOperator);
 
   PRInt32 CalcWeight(void) const;
 
   void ToString(nsAString& aString, nsICSSStyleSheet* aSheet,
                 PRBool aAppend = PR_FALSE) const;
 
 private:
+  void AddPseudoClassInternal(nsPseudoClassList *aPseudoClass);
   nsCSSSelector* Clone(PRBool aDeepNext, PRBool aDeepNegations) const;
 
   void AppendNegationToString(nsAString& aString);
   void ToStringInternal(nsAString& aString, nsICSSStyleSheet* aSheet,
                         PRBool aIsPseudoElem,
                         PRBool aIsNegated) const;
 
 public:
