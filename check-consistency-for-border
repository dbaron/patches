Check consistency before returning 'border' shorthand.  (Bug 376075)

diff --git a/layout/style/nsCSSDeclaration.cpp b/layout/style/nsCSSDeclaration.cpp
--- a/layout/style/nsCSSDeclaration.cpp
+++ b/layout/style/nsCSSDeclaration.cpp
@@ -663,18 +663,17 @@ nsCSSDeclaration::GetValue(nsCSSProperty
     case eCSSProperty__moz_outline_radius: {
       const nsCSSProperty* subprops =
         nsCSSProps::SubpropertyEntryFor(aProperty);
       NS_ASSERTION(nsCSSProps::kTypeTable[subprops[0]] == eCSSType_ValuePair &&
                    nsCSSProps::kTypeTable[subprops[1]] == eCSSType_ValuePair &&
                    nsCSSProps::kTypeTable[subprops[2]] == eCSSType_ValuePair &&
                    nsCSSProps::kTypeTable[subprops[3]] == eCSSType_ValuePair,
                    "type mismatch");
-      nsCSSCompressedDataBlock *data = GetValueIsImportant(aProperty)
-                                     ? mImportantData : mData;
+      nsCSSCompressedDataBlock *data = importantCount ? mImportantData : mData;
       const nsCSSValuePair* vals[4] = {
         static_cast<const nsCSSValuePair*>(data->StorageFor(subprops[0])),
         static_cast<const nsCSSValuePair*>(data->StorageFor(subprops[1])),
         static_cast<const nsCSSValuePair*>(data->StorageFor(subprops[2])),
         static_cast<const nsCSSValuePair*>(data->StorageFor(subprops[3]))
       };
 
       AppendCSSValueToString(aProperty, vals[0]->mXValue, aValue);
@@ -697,19 +696,46 @@ nsCSSDeclaration::GetValue(nsCSSProperty
         AppendCSSValueToString(aProperty, vals[1]->mYValue, aValue);
         aValue.Append(PRUnichar(' '));
         AppendCSSValueToString(aProperty, vals[2]->mYValue, aValue);
         aValue.Append(PRUnichar(' '));
         AppendCSSValueToString(aProperty, vals[3]->mYValue, aValue);
       }
       break;
     }
-    case eCSSProperty_border:
-      // XXX More consistency checking needed before falling through.
+    case eCSSProperty_border: {
+      nsCSSCompressedDataBlock *data =
+        importantCount ? mImportantData : mData;
+      const nsCSSProperty* subproptables[3] = {
+        nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_color),
+        nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_style),
+        nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_width)
+      };
+      PRBool match = PR_TRUE;
+      for (const nsCSSProperty** subprops = subproptables,
+               **subprops_end = subproptables + NS_ARRAY_LENGTH(subproptables);
+           subprops < subprops_end; ++subprops) {
+        // Check only the first four subprops in each table, since the
+        // others are extras for dimensional box properties.
+        const nsCSSValue *firstSide =
+          static_cast<const nsCSSValue*>(data->StorageFor((*subprops)[0]));
+        for (PRInt32 side = 1; side < 4; ++side) {
+          const nsCSSValue *otherSide =
+            static_cast<const nsCSSValue*>(data->StorageFor((*subprops)[side]));
+          if (*firstSide != *otherSide)
+            match = PR_FALSE;
+        }
+      }
+      if (!match) {
+        // We can't express what we have in the border shorthand
+        break;
+      }
+      // tweak aProperty and fall through
       aProperty = eCSSProperty_border_top;
+    }
     case eCSSProperty_border_top:
     case eCSSProperty_border_right:
     case eCSSProperty_border_bottom:
     case eCSSProperty_border_left:
     case eCSSProperty_border_start:
     case eCSSProperty_border_end:
     case eCSSProperty__moz_column_rule:
     case eCSSProperty_outline: {
