From: L. David Baron <dbaron@dbaron.org>

Remove now-unneeded parameters to COMPUTE_START_{INHERITED,RESET}.  (Bug 636039)

diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -2401,20 +2401,18 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
  * Begin an nsRuleNode::Compute*Data function for an inherited struct.
  *
  * @param type_ The nsStyle* type this function computes.
  * @param ctorargs_ The arguments used for the default nsStyle* constructor.
  * @param data_ Variable (declared here) holding the result of this
  *              function.
  * @param parentdata_ Variable (declared here) holding the parent style
  *                    context's data for this struct.
- * @param rdtype_ The nsCSS* struct type used to compute this struct's data.
- * @param rdata_ Variable (declared here) holding the nsCSS* used here.
  */
-#define COMPUTE_START_INHERITED(type_, ctorargs_, data_, parentdata_, rdtype_, rdata_) \
+#define COMPUTE_START_INHERITED(type_, ctorargs_, data_, parentdata_)         \
   NS_ASSERTION(aRuleDetail != eRuleFullInherited,                             \
                "should not have bothered calling Compute*Data");              \
                                                                               \
   nsStyleContext* parentContext = aContext->GetParent();                      \
                                                                               \
   nsStyle##type_* data_ = nsnull;                                             \
   const nsStyle##type_* parentdata_ = nsnull;                                 \
   PRBool canStoreInRuleTree = aCanStoreInRuleTree;                            \
@@ -2454,20 +2452,18 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
  * Begin an nsRuleNode::Compute*Data function for a reset struct.
  *
  * @param type_ The nsStyle* type this function computes.
  * @param ctorargs_ The arguments used for the default nsStyle* constructor.
  * @param data_ Variable (declared here) holding the result of this
  *              function.
  * @param parentdata_ Variable (declared here) holding the parent style
  *                    context's data for this struct.
- * @param rdtype_ The nsCSS* struct type used to compute this struct's data.
- * @param rdata_ Variable (declared here) holding the nsCSS* used here.
  */
-#define COMPUTE_START_RESET(type_, ctorargs_, data_, parentdata_, rdtype_, rdata_) \
+#define COMPUTE_START_RESET(type_, ctorargs_, data_, parentdata_)             \
   NS_ASSERTION(aRuleDetail != eRuleFullInherited,                             \
                "should not have bothered calling Compute*Data");              \
                                                                               \
   nsStyleContext* parentContext = aContext->GetParent();                      \
   /* Reset structs don't inherit from first-line */                           \
   /* See similar code in WalkRuleTree */                                      \
   while (parentContext &&                                                     \
          parentContext->GetPseudo() == nsCSSPseudoElements::firstLine) {      \
@@ -3205,18 +3201,17 @@ static PRBool ExtractGeneric(const nsStr
 const void*
 nsRuleNode::ComputeFontData(void* aStartStruct,
                             const nsRuleDataStruct& aData,
                             nsStyleContext* aContext,
                             nsRuleNode* aHighestNode,
                             const RuleDetail aRuleDetail,
                             const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_INHERITED(Font, (mPresContext), font, parentFont,
-                          Font, fontData)
+  COMPUTE_START_INHERITED(Font, (mPresContext), font, parentFont)
 
   // NOTE:  The |aRuleDetail| passed in is a little bit conservative due
   // to the -moz-system-font property.  We really don't need to consider
   // it here in determining whether to cache in the rule tree.  However,
   // we do need to consider it in WalkRuleTree when deciding whether to
   // walk further up the tree.  So this means that when the font struct
   // is fully specified using *longhand* properties (excluding
   // -moz-system-font), we won't cache in the rule tree even though we
@@ -3392,17 +3387,17 @@ nsRuleNode::GetShadowData(const nsCSSVal
 const void*
 nsRuleNode::ComputeTextData(void* aStartStruct,
                             const nsRuleDataStruct& aData,
                             nsStyleContext* aContext,
                             nsRuleNode* aHighestNode,
                             const RuleDetail aRuleDetail,
                             const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_INHERITED(Text, (), text, parentText, Text, textData)
+  COMPUTE_START_INHERITED(Text, (), text, parentText)
 
   // tab-size: integer, inherit
   SetDiscrete(textData.mTabSize, text->mTabSize, canStoreInRuleTree,
               SETDSC_INTEGER, parentText->mTabSize,
               NS_STYLE_TABSIZE_INITIAL, 0, 0, 0, 0);
 
   // letter-spacing: normal, length, inherit
   SetCoord(textData.mLetterSpacing, text->mLetterSpacing, parentText->mLetterSpacing,
@@ -3529,17 +3524,17 @@ nsRuleNode::ComputeTextData(void* aStart
 const void*
 nsRuleNode::ComputeTextResetData(void* aStartStruct,
                                  const nsRuleDataStruct& aData,
                                  nsStyleContext* aContext,
                                  nsRuleNode* aHighestNode,
                                  const RuleDetail aRuleDetail,
                                  const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_RESET(TextReset, (), text, parentText, Text, textData)
+  COMPUTE_START_RESET(TextReset, (), text, parentText)
 
   // vertical-align: enum, length, percent, calc, inherit
   if (!SetCoord(textData.mVerticalAlign, text->mVerticalAlign,
                 parentText->mVerticalAlign,
                 SETCOORD_LPH | SETCOORD_ENUMERATED | SETCOORD_STORE_CALC,
                 aContext, mPresContext, canStoreInRuleTree)) {
     if (eCSSUnit_Initial == textData.mVerticalAlign.GetUnit()) {
       text->mVerticalAlign.SetIntValue(NS_STYLE_VERTICAL_ALIGN_BASELINE,
@@ -3579,18 +3574,17 @@ nsRuleNode::ComputeTextResetData(void* a
 const void*
 nsRuleNode::ComputeUserInterfaceData(void* aStartStruct,
                                      const nsRuleDataStruct& aData,
                                      nsStyleContext* aContext,
                                      nsRuleNode* aHighestNode,
                                      const RuleDetail aRuleDetail,
                                      const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_INHERITED(UserInterface, (), ui, parentUI,
-                          UserInterface, uiData)
+  COMPUTE_START_INHERITED(UserInterface, (), ui, parentUI)
 
   // cursor: enum, url, inherit
   nsCSSUnit cursorUnit = uiData.mCursor.GetUnit();
   if (cursorUnit != eCSSUnit_Null) {
     delete [] ui->mCursorArray;
     ui->mCursorArray = nsnull;
     ui->mCursorArrayLength = 0;
 
@@ -3668,17 +3662,17 @@ nsRuleNode::ComputeUserInterfaceData(voi
 const void*
 nsRuleNode::ComputeUIResetData(void* aStartStruct,
                                const nsRuleDataStruct& aData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_RESET(UIReset, (), ui, parentUI, UserInterface, uiData)
+  COMPUTE_START_RESET(UIReset, (), ui, parentUI)
 
   // user-select: enum, inherit, initial
   SetDiscrete(uiData.mUserSelect, ui->mUserSelect, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentUI->mUserSelect,
               NS_STYLE_USER_SELECT_AUTO, 0, 0, 0, 0);
 
   // ime-mode: enum, inherit, initial
   SetDiscrete(uiData.mIMEMode, ui->mIMEMode, canStoreInRuleTree,
@@ -3754,18 +3748,17 @@ struct TransitionPropData {
 const void*
 nsRuleNode::ComputeDisplayData(void* aStartStruct,
                                const nsRuleDataStruct& aData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_RESET(Display, (), display, parentDisplay,
-                      Display, displayData)
+  COMPUTE_START_RESET(Display, (), display, parentDisplay)
 
   // Each property's index in this array must match its index in the
   // const array |transitionPropInfo| above.
   TransitionPropData transitionPropData[4];
   TransitionPropData& delay = transitionPropData[0];
   TransitionPropData& duration = transitionPropData[1];
   TransitionPropData& property = transitionPropData[2];
   TransitionPropData& timingFunction = transitionPropData[3];
@@ -4296,18 +4289,17 @@ const void*
 nsRuleNode::ComputeVisibilityData(void* aStartStruct,
                                   const nsRuleDataStruct& aData,
                                   nsStyleContext* aContext,
                                   nsRuleNode* aHighestNode,
                                   const RuleDetail aRuleDetail,
                                   const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Visibility, (mPresContext),
-                          visibility, parentVisibility,
-                          Display, displayData)
+                          visibility, parentVisibility)
 
   // direction: enum, inherit, initial
   SetDiscrete(displayData.mDirection, visibility->mDirection,
               canStoreInRuleTree,
               SETDSC_ENUMERATED, parentVisibility->mDirection,
               (GET_BIDI_OPTION_DIRECTION(mPresContext->GetBidi())
                == IBMBIDI_TEXTDIRECTION_RTL)
               ? NS_STYLE_DIRECTION_RTL : NS_STYLE_DIRECTION_LTR,
@@ -4353,18 +4345,17 @@ nsRuleNode::ComputeVisibilityData(void* 
 const void*
 nsRuleNode::ComputeColorData(void* aStartStruct,
                              const nsRuleDataStruct& aData,
                              nsStyleContext* aContext,
                              nsRuleNode* aHighestNode,
                              const RuleDetail aRuleDetail,
                              const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_INHERITED(Color, (mPresContext), color, parentColor,
-                          Color, colorData)
+  COMPUTE_START_INHERITED(Color, (mPresContext), color, parentColor)
 
   // color: color, string, inherit
   // Special case for currentColor.  According to CSS3, setting color to 'currentColor'
   // should behave as if it is inherited
   if (colorData.mColor.GetUnit() == eCSSUnit_EnumColor &&
       colorData.mColor.GetIntValue() == NS_COLOR_CURRENTCOLOR) {
     color->mColor = parentColor->mColor;
     canStoreInRuleTree = PR_FALSE;
@@ -4744,17 +4735,17 @@ FillBackgroundList(nsAutoTArray< nsStyle
 const void*
 nsRuleNode::ComputeBackgroundData(void* aStartStruct,
                                   const nsRuleDataStruct& aData,
                                   nsStyleContext* aContext,
                                   nsRuleNode* aHighestNode,
                                   const RuleDetail aRuleDetail,
                                   const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_RESET(Background, (), bg, parentBG, Color, colorData)
+  COMPUTE_START_RESET(Background, (), bg, parentBG)
 
   // background-color: color, string, inherit
   if (eCSSUnit_Initial == colorData.mBackColor.GetUnit()) {
     bg->mBackgroundColor = NS_RGBA(0, 0, 0, 0);
   } else if (!SetColor(colorData.mBackColor, parentBG->mBackgroundColor,
                        mPresContext, aContext, bg->mBackgroundColor,
                        canStoreInRuleTree)) {
     NS_ASSERTION(eCSSUnit_Null == colorData.mBackColor.GetUnit(),
@@ -4855,17 +4846,17 @@ nsRuleNode::ComputeBackgroundData(void* 
 const void*
 nsRuleNode::ComputeMarginData(void* aStartStruct,
                               const nsRuleDataStruct& aData,
                               nsStyleContext* aContext,
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
                               const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_RESET(Margin, (), margin, parentMargin, Margin, marginData)
+  COMPUTE_START_RESET(Margin, (), margin, parentMargin)
 
   // margin: length, percent, auto, inherit
   nsStyleCoord  coord;
   nsCSSRect ourMargin(marginData.mMargin);
   AdjustLogicalBoxProp(aContext,
                        marginData.mMarginLeftLTRSource,
                        marginData.mMarginLeftRTLSource,
                        marginData.mMarginStart, marginData.mMarginEnd,
@@ -4892,18 +4883,17 @@ nsRuleNode::ComputeMarginData(void* aSta
 const void*
 nsRuleNode::ComputeBorderData(void* aStartStruct,
                               const nsRuleDataStruct& aData,
                               nsStyleContext* aContext,
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
                               const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_RESET(Border, (mPresContext), border, parentBorder,
-                      Margin, marginData)
+  COMPUTE_START_RESET(Border, (mPresContext), border, parentBorder)
 
   // box-shadow: none, list, inherit, initial
   switch (marginData.mBoxShadow.GetUnit()) {
   case eCSSUnit_Null:
     break;
 
   case eCSSUnit_Initial:
   case eCSSUnit_None:
@@ -5231,17 +5221,17 @@ nsRuleNode::ComputeBorderData(void* aSta
 const void*
 nsRuleNode::ComputePaddingData(void* aStartStruct,
                                const nsRuleDataStruct& aData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_RESET(Padding, (), padding, parentPadding, Margin, marginData)
+  COMPUTE_START_RESET(Padding, (), padding, parentPadding)
 
   // padding: length, percent, inherit
   nsStyleCoord  coord;
   nsCSSRect ourPadding(marginData.mPadding);
   AdjustLogicalBoxProp(aContext,
                        marginData.mPaddingLeftLTRSource,
                        marginData.mPaddingLeftRTLSource,
                        marginData.mPaddingStart, marginData.mPaddingEnd,
@@ -5268,18 +5258,17 @@ nsRuleNode::ComputePaddingData(void* aSt
 const void*
 nsRuleNode::ComputeOutlineData(void* aStartStruct,
                                const nsRuleDataStruct& aData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_RESET(Outline, (mPresContext), outline, parentOutline,
-                      Margin, marginData)
+  COMPUTE_START_RESET(Outline, (mPresContext), outline, parentOutline)
 
   // outline-width: length, enum, inherit
   if (eCSSUnit_Initial == marginData.mOutlineWidth.GetUnit()) {
     outline->mOutlineWidth =
       nsStyleCoord(NS_STYLE_BORDER_WIDTH_MEDIUM, eStyleUnit_Enumerated);
   }
   else {
     SetCoord(marginData.mOutlineWidth, outline->mOutlineWidth,
@@ -5376,17 +5365,17 @@ nsRuleNode::ComputeOutlineData(void* aSt
 const void*
 nsRuleNode::ComputeListData(void* aStartStruct,
                             const nsRuleDataStruct& aData,
                             nsStyleContext* aContext,
                             nsRuleNode* aHighestNode,
                             const RuleDetail aRuleDetail,
                             const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_INHERITED(List, (), list, parentList, List, listData)
+  COMPUTE_START_INHERITED(List, (), list, parentList)
 
   // list-style-type: enum, inherit, initial
   SetDiscrete(listData.mType, list->mListStyleType, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentList->mListStyleType,
               NS_STYLE_LIST_STYLE_DISC, 0, 0, 0, 0);
 
   // list-style-image: url, none, inherit
   if (eCSSUnit_Image == listData.mImage.GetUnit()) {
@@ -5466,17 +5455,17 @@ nsRuleNode::ComputeListData(void* aStart
 const void*
 nsRuleNode::ComputePositionData(void* aStartStruct,
                                 const nsRuleDataStruct& aData,
                                 nsStyleContext* aContext,
                                 nsRuleNode* aHighestNode,
                                 const RuleDetail aRuleDetail,
                                 const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_RESET(Position, (), pos, parentPos, Position, posData)
+  COMPUTE_START_RESET(Position, (), pos, parentPos)
 
   // box offsets: length, percent, calc, auto, inherit
   nsStyleCoord  coord;
   NS_FOR_CSS_SIDES(side) {
     nsStyleCoord parentCoord = parentPos->mOffset.Get(side);
     if (SetCoord(posData.mOffset.*(nsCSSRect::sides[side]),
                  coord, parentCoord,
                  SETCOORD_LPAH | SETCOORD_INITIAL_AUTO | SETCOORD_STORE_CALC,
@@ -5527,17 +5516,17 @@ nsRuleNode::ComputePositionData(void* aS
 const void*
 nsRuleNode::ComputeTableData(void* aStartStruct,
                              const nsRuleDataStruct& aData,
                              nsStyleContext* aContext,
                              nsRuleNode* aHighestNode,
                              const RuleDetail aRuleDetail,
                              const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_RESET(Table, (), table, parentTable, Table, tableData)
+  COMPUTE_START_RESET(Table, (), table, parentTable)
 
   // table-layout: enum, inherit, initial
   SetDiscrete(tableData.mLayout, table->mLayoutStrategy, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentTable->mLayoutStrategy,
               NS_STYLE_TABLE_LAYOUT_AUTO, 0, 0, 0, 0);
 
   // cols: enum, int (not a real CSS prop)
   if (eCSSUnit_Enumerated == tableData.mCols.GetUnit() ||
@@ -5555,18 +5544,17 @@ nsRuleNode::ComputeTableData(void* aStar
 const void*
 nsRuleNode::ComputeTableBorderData(void* aStartStruct,
                                    const nsRuleDataStruct& aData,
                                    nsStyleContext* aContext,
                                    nsRuleNode* aHighestNode,
                                    const RuleDetail aRuleDetail,
                                    const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_INHERITED(TableBorder, (mPresContext), table, parentTable,
-                          Table, tableData)
+  COMPUTE_START_INHERITED(TableBorder, (mPresContext), table, parentTable)
 
   // border-collapse: enum, inherit, initial
   SetDiscrete(tableData.mBorderCollapse, table->mBorderCollapse,
               canStoreInRuleTree,
               SETDSC_ENUMERATED, parentTable->mBorderCollapse,
               NS_STYLE_BORDER_SEPARATE, 0, 0, 0, 0);
 
   if (tableData.mBorderSpacing.GetUnit() != eCSSUnit_Null) {
@@ -5613,18 +5601,17 @@ nsRuleNode::ComputeContentData(void* aSt
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
   PRUint32 count;
   nsAutoString buffer;
 
-  COMPUTE_START_RESET(Content, (), content, parentContent,
-                      Content, contentData)
+  COMPUTE_START_RESET(Content, (), content, parentContent)
 
   // content: [string, url, counter, attr, enum]+, normal, none, inherit
   switch (contentData.mContent.GetUnit()) {
   case eCSSUnit_Null:
     break;
 
   case eCSSUnit_Normal:
   case eCSSUnit_None:
@@ -5843,18 +5830,17 @@ nsRuleNode::ComputeContentData(void* aSt
 const void*
 nsRuleNode::ComputeQuotesData(void* aStartStruct,
                               const nsRuleDataStruct& aData,
                               nsStyleContext* aContext,
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
                               const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_INHERITED(Quotes, (), quotes, parentQuotes,
-                          Content, contentData)
+  COMPUTE_START_INHERITED(Quotes, (), quotes, parentQuotes)
 
   // quotes: inherit, initial, none, [string string]+
   switch (contentData.mQuotes.GetUnit()) {
   case eCSSUnit_Null:
     break;
   case eCSSUnit_Inherit:
     canStoreInRuleTree = PR_FALSE;
     quotes->CopyFrom(*parentQuotes);
@@ -5897,17 +5883,17 @@ nsRuleNode::ComputeQuotesData(void* aSta
 const void*
 nsRuleNode::ComputeXULData(void* aStartStruct,
                            const nsRuleDataStruct& aData,
                            nsStyleContext* aContext,
                            nsRuleNode* aHighestNode,
                            const RuleDetail aRuleDetail,
                            const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_RESET(XUL, (), xul, parentXUL, XUL, xulData)
+  COMPUTE_START_RESET(XUL, (), xul, parentXUL)
 
   // box-align: enum, inherit, initial
   SetDiscrete(xulData.mBoxAlign, xul->mBoxAlign, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentXUL->mBoxAlign,
               NS_STYLE_BOX_ALIGN_STRETCH, 0, 0, 0, 0);
 
   // box-direction: enum, inherit, initial
   SetDiscrete(xulData.mBoxDirection, xul->mBoxDirection, canStoreInRuleTree,
@@ -5949,17 +5935,17 @@ nsRuleNode::ComputeXULData(void* aStartS
 const void*
 nsRuleNode::ComputeColumnData(void* aStartStruct,
                               const nsRuleDataStruct& aData,
                               nsStyleContext* aContext,
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
                               const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_RESET(Column, (mPresContext), column, parent, Column, columnData)
+  COMPUTE_START_RESET(Column, (mPresContext), column, parent)
 
   // column-width: length, auto, inherit
   SetCoord(columnData.mColumnWidth,
            column->mColumnWidth, parent->mColumnWidth,
            SETCOORD_LAH | SETCOORD_INITIAL_AUTO |
            SETCOORD_CALC_LENGTH_ONLY | SETCOORD_CALC_CLAMP_NONNEGATIVE,
            aContext, mPresContext, canStoreInRuleTree);
 
@@ -6104,17 +6090,17 @@ SetSVGPaint(const nsCSSValue& aValue, co
 const void*
 nsRuleNode::ComputeSVGData(void* aStartStruct,
                            const nsRuleDataStruct& aData,
                            nsStyleContext* aContext,
                            nsRuleNode* aHighestNode,
                            const RuleDetail aRuleDetail,
                            const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_INHERITED(SVG, (), svg, parentSVG, SVG, SVGData)
+  COMPUTE_START_INHERITED(SVG, (), svg, parentSVG)
 
   // clip-rule: enum, inherit, initial
   SetDiscrete(SVGData.mClipRule, svg->mClipRule, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentSVG->mClipRule,
               NS_STYLE_FILL_RULE_NONZERO, 0, 0, 0, 0);
 
   // color-interpolation: enum, inherit, initial
   SetDiscrete(SVGData.mColorInterpolation,
@@ -6302,17 +6288,17 @@ nsRuleNode::ComputeSVGData(void* aStartS
 const void*
 nsRuleNode::ComputeSVGResetData(void* aStartStruct,
                                 const nsRuleDataStruct& aData,
                                 nsStyleContext* aContext,
                                 nsRuleNode* aHighestNode,
                                 const RuleDetail aRuleDetail,
                                 const PRBool aCanStoreInRuleTree)
 {
-  COMPUTE_START_RESET(SVGReset, (), svgReset, parentSVGReset, SVG, SVGData)
+  COMPUTE_START_RESET(SVGReset, (), svgReset, parentSVGReset)
 
   // stop-color:
   if (eCSSUnit_Initial == SVGData.mStopColor.GetUnit()) {
     svgReset->mStopColor = NS_RGB(0, 0, 0);
   } else {
     SetColor(SVGData.mStopColor, parentSVGReset->mStopColor,
              mPresContext, aContext, svgReset->mStopColor, canStoreInRuleTree);
   }
