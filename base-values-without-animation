From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch 3 - Use style without animation for base values for CSS animations (refixes bug 686656 in the new architecture).

This is needed to make the tests for bug 686656 in test_animations.html
pass.

Note that once the rest of bug 960465 happens this will start producing
slightly different results in edge cases, since we will only be skipping
animation styles for the element itself and not for ancestors.  However,
both old and new behaviors are incorrect, since per spec we should be
updating the base values dynamically.

FIXME: File a bug on this.

diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -423,16 +423,18 @@ nsAnimationManager::BuildAnimations(nsSt
                                     AnimationPlayerPtrArray& aPlayers)
 {
   MOZ_ASSERT(aPlayers.IsEmpty(), "expect empty array");
 
   ResolvedStyleCache resolvedStyles;
 
   const nsStyleDisplay *disp = aStyleContext->StyleDisplay();
 
+  nsRefPtr<nsStyleContext> styleWithoutAnimation;
+
   for (size_t animIdx = 0, animEnd = disp->mAnimationNameCount;
        animIdx != animEnd; ++animIdx) {
     const StyleAnimation& src = disp->mAnimations[animIdx];
 
     // CSS Animations whose animation-name does not match a @keyframes rule do
     // not generate animation events. This includes when the animation-name is
     // "none" which is represented by an empty name in the StyleAnimation.
     // Since such animations neither affect style nor dispatch events, we do
@@ -575,35 +577,45 @@ nsAnimationManager::BuildAnimations(nsSt
             BuildSegment(propData.mSegments, prop, src,
                          fromKeyframe->mKey, fromContext,
                          fromKeyframe->mRule->Declaration(),
                          toKeyframe.mKey, toContext);
         } else {
           if (toKeyframe.mKey != 0.0f) {
             // There's no data for this property at 0%, so use the
             // cascaded value above us.
+            if (!styleWithoutAnimation) {
+              styleWithoutAnimation = mPresContext->StyleSet()->
+                ResolveStyleWithoutAnimation(aTarget, aStyleContext,
+                                             eRestyle_ChangeAnimationPhase);
+            }
             interpolated = interpolated &&
               BuildSegment(propData.mSegments, prop, src,
-                           0.0f, aStyleContext, nullptr,
+                           0.0f, styleWithoutAnimation, nullptr,
                            toKeyframe.mKey, toContext);
           }
         }
 
         fromContext = toContext;
         fromKeyframe = &toKeyframe;
       }
 
       if (fromKeyframe->mKey != 1.0f) {
         // There's no data for this property at 100%, so use the
         // cascaded value above us.
+        if (!styleWithoutAnimation) {
+          styleWithoutAnimation = mPresContext->StyleSet()->
+            ResolveStyleWithoutAnimation(aTarget, aStyleContext,
+                                         eRestyle_ChangeAnimationPhase);
+        }
         interpolated = interpolated &&
           BuildSegment(propData.mSegments, prop, src,
                        fromKeyframe->mKey, fromContext,
                        fromKeyframe->mRule->Declaration(),
-                       1.0f, aStyleContext);
+                       1.0f, styleWithoutAnimation);
       }
 
       // If we failed to build any segments due to inability to
       // interpolate, remove the property from the animation.  (It's not
       // clear if this is the right thing to do -- we could run some of
       // the segments, but it's really not clear whether we should skip
       // values (which?) or skip segments, so best to skip the whole
       // thing for now.)
