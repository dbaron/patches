From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Use style without animation for base values for CSS animations (refixes bug 686656 in the new architecture).

This is needed to make the tests for bug 686656 in test_animations.html
pass.

Note that once bug 960465 happens this will start producing slightly
different results in edge cases, since we will only be skipping
animation styles for the element itself and not for ancestors.  However,
both old and new behaviors are incorrect, since per spec we should be
updating the base values dynamically.

diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -109,25 +109,33 @@ public:
 
   // Whether rule matching should skip styles associated with animation
   bool SkipAnimationRules() const {
     MOZ_ASSERT(mSkipAnimationRules || !mPostAnimationRestyles,
                "inconsistent state");
     return mSkipAnimationRules;
   }
 
+  void SetSkipAnimationRules(bool aSkipAnimationRules) {
+    mSkipAnimationRules = aSkipAnimationRules;
+  }
+
   // Whether rule matching should post animation restyles when it skips
   // styles associated with animation.  Only true when
   // SkipAnimationRules() is also true.
   bool PostAnimationRestyles() const {
     MOZ_ASSERT(mSkipAnimationRules || !mPostAnimationRestyles,
                "inconsistent state");
     return mPostAnimationRestyles;
   }
 
+  void SetPostAnimationRestyles(bool aPostAnimationRestyles) {
+    mPostAnimationRestyles = aPostAnimationRestyles;
+  }
+
   // Whether we're currently in the animation phase of restyle
   // processing (to be eliminated in bug 960465)
   bool IsProcessingAnimationStyleChange() const {
     return mIsProcessingAnimationStyleChange;
   }
 
   /**
    * Reparent the style contexts of this frame subtree.  The parent frame of
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -398,29 +398,57 @@ ResolvedStyleCache::Get(nsPresContext *a
     nsRefPtr<nsStyleContext> resultStrong = aPresContext->StyleSet()->
       ResolveStyleByAddingRules(aParentStyleContext, rules);
     mCache.Put(aKeyframe, resultStrong);
     result = resultStrong;
   }
   return result;
 }
 
+already_AddRefed<nsStyleContext>
+nsAnimationManager::StyleWithoutAnimation(dom::Element* aTarget,
+                                          nsStyleContext* aStyleContext)
+{
+  RestyleManager* restyleManager = mPresContext->RestyleManager();
+  // FIXME: Right now oldSkipAnimationRules will always be true, but bug
+  // 960465 will change it to always being false.  Once that happens, we
+  // can remove it.
+  bool oldSkipAnimationRules = restyleManager->SkipAnimationRules();
+  restyleManager->SetSkipAnimationRules(true);
+  // FIXME: Right now oldPostAnimationRestyles will always be true, but
+  // bug 960465 will change it to always being false, and also make the
+  // entire variable unnecessary.  Once that happens, we can remove it.
+  bool oldPostAnimationRestyles = restyleManager->PostAnimationRestyles();
+  restyleManager->SetPostAnimationRestyles(false);
+
+  nsRefPtr<nsStyleContext> result = mPresContext->StyleSet()->
+    ResolveStyleWithReplacement(aTarget, aStyleContext->GetParent(),
+                                aStyleContext, eRestyle_ChangeAnimationPhase);
+
+  restyleManager->SetPostAnimationRestyles(oldPostAnimationRestyles);
+  restyleManager->SetSkipAnimationRules(oldSkipAnimationRules);
+
+  return result.forget();
+}
+
 void
 nsAnimationManager::BuildAnimations(nsStyleContext* aStyleContext,
                                     dom::Element* aTarget,
                                     dom::AnimationTimeline* aTimeline,
                                     AnimationPlayerPtrArray& aPlayers)
 {
   NS_ABORT_IF_FALSE(aPlayers.IsEmpty(), "expect empty array");
 
   ResolvedStyleCache resolvedStyles;
 
   const nsStyleDisplay *disp = aStyleContext->StyleDisplay();
   Nullable<TimeDuration> now = aTimeline->GetCurrentTime();
 
+  nsRefPtr<nsStyleContext> styleWithoutAnimation;
+
   for (size_t animIdx = 0, animEnd = disp->mAnimationNameCount;
        animIdx != animEnd; ++animIdx) {
     const StyleAnimation& src = disp->mAnimations[animIdx];
 
     // CSS Animations whose animation-name does not match a @keyframes rule do
     // not generate animation events. This includes when the animation-name is
     // "none" which is represented by an empty name in the StyleAnimation.
     // Since such animations neither affect style nor dispatch events, we do
@@ -559,35 +587,43 @@ nsAnimationManager::BuildAnimations(nsSt
             BuildSegment(propData.mSegments, prop, src,
                          fromKeyframe->mKey, fromContext,
                          fromKeyframe->mRule->Declaration(),
                          toKeyframe.mKey, toContext);
         } else {
           if (toKeyframe.mKey != 0.0f) {
             // There's no data for this property at 0%, so use the
             // cascaded value above us.
+            if (!styleWithoutAnimation) {
+              styleWithoutAnimation =
+                StyleWithoutAnimation(aTarget, aStyleContext);
+            }
             interpolated = interpolated &&
               BuildSegment(propData.mSegments, prop, src,
-                           0.0f, aStyleContext, nullptr,
+                           0.0f, styleWithoutAnimation, nullptr,
                            toKeyframe.mKey, toContext);
           }
         }
 
         fromContext = toContext;
         fromKeyframe = &toKeyframe;
       }
 
       if (fromKeyframe->mKey != 1.0f) {
         // There's no data for this property at 100%, so use the
         // cascaded value above us.
+        if (!styleWithoutAnimation) {
+          styleWithoutAnimation =
+            StyleWithoutAnimation(aTarget, aStyleContext);
+        }
         interpolated = interpolated &&
           BuildSegment(propData.mSegments, prop, src,
                        fromKeyframe->mKey, fromContext,
                        fromKeyframe->mRule->Declaration(),
-                       1.0f, aStyleContext);
+                       1.0f, styleWithoutAnimation);
       }
 
       // If we failed to build any segments due to inability to
       // interpolate, remove the property from the animation.  (It's not
       // clear if this is the right thing to do -- we could run some of
       // the segments, but it's really not clear whether we should skip
       // values (which?) or skip segments, so best to skip the whole
       // thing for now.)
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -227,16 +227,19 @@ private:
                        mozilla::AnimationPlayerPtrArray& aAnimations);
   bool BuildSegment(InfallibleTArray<mozilla::AnimationPropertySegment>&
                       aSegments,
                     nsCSSProperty aProperty,
                     const mozilla::StyleAnimation& aAnimation,
                     float aFromKey, nsStyleContext* aFromContext,
                     mozilla::css::Declaration* aFromDeclaration,
                     float aToKey, nsStyleContext* aToContext);
+  already_AddRefed<nsStyleContext>
+    StyleWithoutAnimation(mozilla::dom::Element* aTarget,
+                          nsStyleContext* aStyleContext);
 
   // The guts of DispatchEvents
   void DoDispatchEvents();
 
   mozilla::EventArray mPendingEvents;
 };
 
 #endif /* !defined(nsAnimationManager_h_) */
