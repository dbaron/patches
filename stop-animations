From: L. David Baron <dbaron@dbaron.org>

Bug 651506 - Stop animations in the same cases we stop animated images.

diff --git a/dom/animation/AnimationPlayer.h b/dom/animation/AnimationPlayer.h
--- a/dom/animation/AnimationPlayer.h
+++ b/dom/animation/AnimationPlayer.h
@@ -28,16 +28,17 @@ namespace dom {
 class AnimationPlayer MOZ_FINAL : public nsWrapperCache
 {
 protected:
   virtual ~AnimationPlayer() { }
 
 public:
   explicit AnimationPlayer(AnimationTimeline* aTimeline)
     : mPlayState(NS_STYLE_ANIMATION_PLAY_STATE_RUNNING)
+    , mForcedPause(false)
     , mIsRunningOnCompositor(false)
     , mTimeline(aTimeline)
   {
     SetIsDOMBinding();
   }
 
   NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(AnimationPlayer)
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(AnimationPlayer)
@@ -55,17 +56,18 @@ public:
   void SetSource(Animation* aSource);
   void Tick();
 
   const nsString& Name() const {
     return mSource ? mSource->Name() : EmptyString();
   }
 
   bool IsPaused() const {
-    return mPlayState == NS_STYLE_ANIMATION_PLAY_STATE_PAUSED;
+    return mPlayState == NS_STYLE_ANIMATION_PLAY_STATE_PAUSED ||
+           mForcedPause;
   }
 
   bool IsRunning() const;
   bool IsCurrent() const;
 
   // Return the duration since the start time of the player, taking into
   // account the pause state.  May be negative.
   // Returns a null value if the timeline associated with this object has a
@@ -86,16 +88,17 @@ public:
     }
     return result;
   }
 
   // The beginning of the delay period.
   TimeStamp mStartTime;
   TimeStamp mPauseStart;
   uint8_t mPlayState;
+  bool mForcedPause;
   bool mIsRunningOnCompositor;
 
   nsRefPtr<AnimationTimeline> mTimeline;
   nsRefPtr<Animation> mSource;
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1406,16 +1406,22 @@ nsPresContext::SetImageAnimationModeInte
       Element *rootElement = doc->GetRootElement();
       if (rootElement) {
         SetImgAnimations(rootElement, aMode);
       }
       SetSMILAnimations(doc, aMode, mImageAnimationMode);
     }
   }
 
+  // FIXME: Handle kLoopOnceAnimMode, and also changes back to
+  // animating.
+  if (mAnimationManager && aMode == imgIContainer::kDontAnimMode) {
+    mAnimationManager->StopAllAnimations();
+  }
+
   mImageAnimationMode = aMode;
 }
 
 void
 nsPresContext::SetImageAnimationModeExternal(uint16_t aMode)
 {
   SetImageAnimationModeInternal(aMode);
 }
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -785,8 +785,53 @@ nsAnimationManager::DoDispatchEvents()
     AnimationEventInfo &info = events[i];
     EventDispatcher::Dispatch(info.mElement, mPresContext, &info.mEvent);
 
     if (!mPresContext) {
       break;
     }
   }
 }
+
+void
+nsAnimationManager::StopAllAnimations()
+{
+  for (PRCList *l = PR_LIST_HEAD(&mElementCollections); l != &mElementCollections;
+       l = PR_NEXT_LINK(l)) {
+    AnimationPlayerCollection* collection =
+      static_cast<AnimationPlayerCollection*>(l);
+    bool needsRestyle = false;
+    for (uint32_t playerIdx = 0, playerEnd = collection->mPlayers.Length();
+         playerIdx != playerEnd; ++playerIdx) {
+      AnimationPlayer* player = collection->mPlayers[playerIdx];
+      Animation* anim = player->GetSource();
+      if (player->IsPaused()) {
+        continue;
+      }
+      TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
+      if (anim->Timing().mIterationCount == NS_IEEEPositiveInfinity()) {
+        // Pause animations with an 'infinite'
+        // animation-iteration-count.  (Should we consider forcing them
+        // to the beginning or end of an iteration?)
+        player->mForcedPause = true;
+        player->mPauseStart = now;
+        if (collection->mStyleRuleRefreshTime.IsNull() ||
+            collection->mStyleRuleRefreshTime != now) {
+          needsRestyle = true;
+        }
+      } else {
+        // Push animations that complete, but have not completed yet, to
+        // their completed state by adjusting their start time.
+        TimeDuration durationToEnd = TimeDuration::FromSeconds(
+            anim->Timing().mIterationDuration.ToSeconds() *
+            anim->Timing().mIterationCount) +
+          anim->Timing().mDelay;
+        if (now < player->mStartTime + durationToEnd) {
+          player->mStartTime = now - durationToEnd;
+          needsRestyle = true;
+        }
+      }
+    }
+    if (needsRestyle) {
+      collection->PostRestyleForAnimation(mPresContext);
+    }
+  }
+}
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -127,16 +127,29 @@ public:
     }
   }
 
   mozilla::AnimationPlayerCollection*
   GetAnimationPlayers(mozilla::dom::Element *aElement,
                       nsCSSPseudoElements::Type aPseudoType,
                       bool aCreateIfNeeded);
 
+  /**
+   * A hook for user interface (such as the stop button or escape key)
+   * that stops animations.
+   *
+   * This goes through all currently running animations, and:
+   *  + for those with a non-'infinite' animation-iteration-count,
+   *    advances them to their end time by moving their start time
+   *    backwards, and
+   *  + for those with an 'infinite' animation-iteration-count,
+   *    pauses them.
+   */
+  void StopAllAnimations();
+
 protected:
   virtual void ElementCollectionRemoved() MOZ_OVERRIDE
   {
     CheckNeedsRefresh();
   }
   virtual void
   AddElementCollection(mozilla::AnimationPlayerCollection* aData) MOZ_OVERRIDE;
 
