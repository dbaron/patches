From: L. David Baron <dbaron@dbaron.org>

Bug 651506 - Stop animations in the same cases we stop animated images.

diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1407,16 +1407,24 @@ nsPresContext::SetImageAnimationModeInte
       Element *rootElement = doc->GetRootElement();
       if (rootElement) {
         SetImgAnimations(rootElement, aMode);
       }
       SetSMILAnimations(doc, aMode, mImageAnimationMode);
     }
   }
 
+#ifdef MOZ_CSS_ANIMATIONS
+  // FIXME: Handle kLoopOnceAnimMode, and also changes back to
+  // animating.
+  if (mAnimationManager && aMode == imgIContainer::kDontAnimMode) {
+    mAnimationManager->StopAllAnimations();
+  }
+#endif
+
   mImageAnimationMode = aMode;
 }
 
 void
 nsPresContext::SetImageAnimationModeExternal(uint16_t aMode)
 {
   SetImageAnimationModeInternal(aMode);
 }
diff --git a/layout/style/AnimationCommon.h b/layout/style/AnimationCommon.h
--- a/layout/style/AnimationCommon.h
+++ b/layout/style/AnimationCommon.h
@@ -246,17 +246,18 @@ struct ComputedTiming
  */
 class ElementAnimation : public nsWrapperCache
 {
 protected:
   virtual ~ElementAnimation() { }
 
 public:
   explicit ElementAnimation(dom::AnimationTimeline* aTimeline)
-    : mIsRunningOnCompositor(false)
+    : mForcedPause(false)
+    , mIsRunningOnCompositor(false)
     , mIsFinishedTransition(false)
     , mLastNotification(LAST_NOTIFICATION_NONE)
     , mTimeline(aTimeline)
   {
     SetIsDOMBinding();
   }
 
   NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(ElementAnimation)
@@ -274,17 +275,18 @@ public:
   // AnimationEffect (as per the Web Animations API) we should remove these
   // virtual methods.
   virtual ElementPropertyTransition* AsTransition() { return nullptr; }
   virtual const ElementPropertyTransition* AsTransition() const {
     return nullptr;
   }
 
   bool IsPaused() const {
-    return mPlayState == NS_STYLE_ANIMATION_PLAY_STATE_PAUSED;
+    return mPlayState == NS_STYLE_ANIMATION_PLAY_STATE_PAUSED ||
+           mForcedPause;
   }
 
   // After transitions finish they need to be retained for one throttle-able
   // cycle (for reasons see explanation in nsTransitionManager.cpp). In the
   // meantime, however, they should be ignored.
   bool IsFinishedTransition() const {
     return mIsFinishedTransition;
   }
@@ -351,16 +353,17 @@ public:
   static mozilla::TimeDuration ActiveDuration(const AnimationTiming& aTiming);
 
   nsString mName;
   AnimationTiming mTiming;
   // The beginning of the delay period.
   mozilla::TimeStamp mStartTime;
   mozilla::TimeStamp mPauseStart;
   uint8_t mPlayState;
+  bool mForcedPause;
   bool mIsRunningOnCompositor;
   // A flag to mark transitions that have finished and are due to
   // be removed on the next throttle-able cycle.
   bool mIsFinishedTransition;
 
   enum {
     LAST_NOTIFICATION_NONE = uint64_t(-1),
     LAST_NOTIFICATION_END = uint64_t(-2)
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -770,8 +770,51 @@ nsAnimationManager::DoDispatchEvents()
     AnimationEventInfo &info = events[i];
     EventDispatcher::Dispatch(info.mElement, mPresContext, &info.mEvent);
 
     if (!mPresContext) {
       break;
     }
   }
 }
+
+void
+nsAnimationManager::StopAllAnimations()
+{
+  for (PRCList *l = PR_LIST_HEAD(&mElementCollections); l != &mElementCollections;
+       l = PR_NEXT_LINK(l)) {
+    ElementAnimationCollection *collection = static_cast<ElementAnimationCollection*>(l);
+    bool needsRestyle = false;
+    for (uint32_t animIdx = 0, animEnd = collection->mAnimations.Length();
+         animIdx != animEnd; ++animIdx) {
+      ElementAnimation* anim = collection->mAnimations[animIdx];
+      if (anim->IsPaused()) {
+        continue;
+      }
+      TimeStamp now = mPresContext->RefreshDriver()->MostRecentRefresh();
+      if (anim->mTiming.mIterationCount == NS_IEEEPositiveInfinity()) {
+        // Pause animations with an 'infinite'
+        // animation-iteration-count.  (Should we consider forcing them
+        // to the beginning or end of an iteration?)
+        anim->mForcedPause = true;
+        anim->mPauseStart = now;
+        if (collection->mStyleRuleRefreshTime.IsNull() ||
+            collection->mStyleRuleRefreshTime != now) {
+          needsRestyle = true;
+        }
+      } else {
+        // Push animations that complete, but have not completed yet, to
+        // their completed state by adjusting their start time.
+        TimeDuration durationToEnd = TimeDuration::FromSeconds(
+            anim->mTiming.mIterationDuration.ToSeconds() *
+            anim->mTiming.mIterationCount) +
+          anim->mTiming.mDelay;
+        if (now < anim->mStartTime + durationToEnd) {
+          anim->mStartTime = now - durationToEnd;
+          needsRestyle = true;
+        }
+      }
+    }
+    if (needsRestyle) {
+      collection->PostRestyleForAnimation(mPresContext);
+    }
+  }
+}
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -140,16 +140,29 @@ protected:
   virtual void
   AddElementCollection(mozilla::ElementAnimationCollection* aData) MOZ_OVERRIDE;
 
   /**
    * Check to see if we should stop or start observing the refresh driver
    */
   void CheckNeedsRefresh();
 
+  /**
+   * A hook for user interface (such as the stop button or escape key)
+   * that stops animations.
+   *
+   * This goes through all currently running animations, and:
+   *  + for those with a non-'infinite' animation-iteration-count,
+   *    advances them to their end time by moving their start time
+   *    backwards, and
+   *  + for those with an 'infinite' animation-iteration-count,
+   *    pauses them.
+   */
+  void StopAllAnimations();
+
 private:
   void BuildAnimations(nsStyleContext* aStyleContext,
                        mozilla::dom::AnimationTimeline* aTimeline,
                        mozilla::ElementAnimationPtrArray& aAnimations);
   bool BuildSegment(InfallibleTArray<mozilla::AnimationPropertySegment>&
                       aSegments,
                     nsCSSProperty aProperty,
                     const mozilla::StyleAnimation& aAnimation,
