From: L. David Baron <dbaron@dbaron.org>

Bug 847287 patch 6 - Dynamically update cascade results when animations start or stop filling.

diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -201,32 +201,62 @@ CSSAnimationPlayer::PseudoTypeAsString(n
 }
 
 void
 nsAnimationManager::UpdateStyleAndEvents(AnimationPlayerCollection*
                                            aCollection,
                                          TimeStamp aRefreshTime,
                                          EnsureStyleRuleFlags aFlags)
 {
+  // Update cascade results before updating the style rule, since the
+  // cascade results can influence the style rule.
+  MaybeUpdateCascadeResults(aCollection);
+
   aCollection->EnsureStyleRuleFor(aRefreshTime, aFlags);
   QueueEvents(aCollection, mPendingEvents);
 }
 
 void
 nsAnimationManager::QueueEvents(AnimationPlayerCollection* aCollection,
                                 EventArray& aEventsToDispatch)
 {
   for (size_t playerIdx = aCollection->mPlayers.Length(); playerIdx-- != 0; ) {
     CSSAnimationPlayer* player =
       aCollection->mPlayers[playerIdx]->AsCSSAnimationPlayer();
     MOZ_ASSERT(player, "Expected a collection of CSS Animation players");
     player->QueueEvents(aEventsToDispatch);
   }
 }
 
+void
+nsAnimationManager::MaybeUpdateCascadeResults(AnimationPlayerCollection* aCollection)
+{
+  for (size_t playerIdx = aCollection->mPlayers.Length(); playerIdx-- != 0; ) {
+    CSSAnimationPlayer* player =
+      aCollection->mPlayers[playerIdx]->AsCSSAnimationPlayer();
+    const Animation* anim = player->GetSource();
+
+    bool filling = anim &&
+                   anim->GetComputedTiming().mTimeFraction !=
+                     ComputedTiming::kNullTimeFraction;
+    if (filling != player->mFillingForCascadeResults) {
+      mozilla::dom::Element* element = aCollection->GetElementToRestyle();
+      if (!element) {
+        return;
+      }
+      nsIFrame* frame = element->GetPrimaryFrame();
+      if (!frame) {
+        return;
+      }
+      UpdateCascadeResults(frame->StyleContext(), aCollection);
+      return;
+    }
+  }
+}
+
 /* virtual */ size_t
 nsAnimationManager::SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const
 {
   return CommonAnimationManager::SizeOfExcludingThis(aMallocSizeOf);
 
   // Measurement of the following members may be added later if DMD finds it is
   // worthwhile:
   // - mPendingEvents
@@ -766,18 +796,25 @@ nsAnimationManager::UpdateCascadeResults
    * override earlier ones, so we add properties to the set of
    * overridden properties as we encounter them, if the animation is
    * currently filling.
    */
 
   bool changed = false;
   for (size_t playerIdx = aElementAnimations->mPlayers.Length();
        playerIdx-- != 0; ) {
-    AnimationPlayer* player = aElementAnimations->mPlayers[playerIdx];
+    CSSAnimationPlayer* player =
+      aElementAnimations->mPlayers[playerIdx]->AsCSSAnimationPlayer();
     Animation* anim = player->GetSource();
+
+    player->mFillingForCascadeResults =
+      anim &&
+      anim->GetComputedTiming().mTimeFraction !=
+        ComputedTiming::kNullTimeFraction;
+
     if (!anim) {
       continue;
     }
 
     for (size_t propIdx = 0, propEnd = anim->Properties().Length();
          propIdx != propEnd; ++propIdx) {
       AnimationProperty& prop = anim->Properties()[propIdx];
       // We only bother setting mWinsInCascade for properties that we
@@ -786,24 +823,20 @@ nsAnimationManager::UpdateCascadeResults
                                    CSS_PROPERTY_CAN_ANIMATE_ON_COMPOSITOR)) {
         bool newWinsInCascade =
           !propertiesOverridden.HasProperty(prop.mProperty);
         if (newWinsInCascade != prop.mWinsInCascade) {
           changed = true;
         }
         prop.mWinsInCascade = newWinsInCascade;
 
-        if (prop.mWinsInCascade) {
-          ComputedTiming computedTiming = anim->GetComputedTiming();
-          if (computedTiming.mTimeFraction !=
-              ComputedTiming::kNullTimeFraction) {
-            // This animation is filling right now, so it overrides
-            // earlier animations.
-            propertiesOverridden.AddProperty(prop.mProperty);
-          }
+        if (prop.mWinsInCascade && player->mFillingForCascadeResults) {
+          // This animation is filling right now, so it overrides
+          // earlier animations.
+          propertiesOverridden.AddProperty(prop.mProperty);
         }
       }
     }
   }
 
   if (changed) {
     aElementAnimations->
       UpdateAnimationGeneration(aElementAnimations->mManager->PresContext());
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -75,16 +75,23 @@ public:
 
   void PlayFromStyle();
   void PauseFromStyle();
 
   bool IsStylePaused() const { return mIsStylePaused; }
 
   void QueueEvents(EventArray& aEventsToDispatch);
 
+  // Is this animation currently filling for the purposes of computing
+  // mWinsInCascade.  (In general, this can be computed from the timing
+  // function.  This boolean remembers the state as of the last time we
+  // called UpdateCascadeResults so we know if it changes and we need to
+  // call UpdateCascadeResults again.)
+  bool mFillingForCascadeResults;
+
 protected:
   virtual ~CSSAnimationPlayer() { }
   virtual css::CommonAnimationManager* GetAnimationManager() const MOZ_OVERRIDE;
 
   static nsString PseudoTypeAsString(nsCSSPseudoElements::Type aPseudoType);
 
   // When combining animation-play-state with play() / pause() the following
   // behavior applies:
@@ -163,18 +170,16 @@ public:
   {
     return mozilla::css::CommonAnimationManager::GetAnimationsForCompositor(
       aContent, nsGkAtoms::animationsProperty, aProperty);
   }
 
   void UpdateStyleAndEvents(mozilla::AnimationPlayerCollection* aEA,
                             mozilla::TimeStamp aRefreshTime,
                             mozilla::EnsureStyleRuleFlags aFlags);
-  void QueueEvents(mozilla::AnimationPlayerCollection* aEA,
-                   mozilla::EventArray &aEventsToDispatch);
 
   // nsIStyleRuleProcessor (parts)
   virtual size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf)
     const MOZ_MUST_OVERRIDE MOZ_OVERRIDE;
   virtual size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf)
     const MOZ_MUST_OVERRIDE MOZ_OVERRIDE;
 
   // nsARefreshObserver
@@ -232,16 +237,21 @@ private:
   bool BuildSegment(InfallibleTArray<mozilla::AnimationPropertySegment>&
                       aSegments,
                     nsCSSProperty aProperty,
                     const mozilla::StyleAnimation& aAnimation,
                     float aFromKey, nsStyleContext* aFromContext,
                     mozilla::css::Declaration* aFromDeclaration,
                     float aToKey, nsStyleContext* aToContext);
 
+  void QueueEvents(mozilla::AnimationPlayerCollection* aEA,
+                   mozilla::EventArray &aEventsToDispatch);
+  void MaybeUpdateCascadeResults(mozilla::AnimationPlayerCollection*
+                                   aCollection);
+
   static void UpdateCascadeResults(nsStyleContext* aStyleContext,
                                    mozilla::AnimationPlayerCollection*
                                      aElementAnimations);
 
   // The guts of DispatchEvents
   void DoDispatchEvents();
 
   mozilla::EventArray mPendingEvents;
diff --git a/layout/style/test/test_animations_omta.html b/layout/style/test/test_animations_omta.html
--- a/layout/style/test/test_animations_omta.html
+++ b/layout/style/test/test_animations_omta.html
@@ -2126,19 +2126,16 @@ addAsyncAnimTest(function *() {
   omta_is("opacity", 1, RunningOn.Compositor,
           "anim3 overriding anim2 at start (0s)");
   advance_clock(400);
   yield waitForPaintsFlushed();
   omta_is("opacity", 0.2, RunningOn.Compositor,
           "anim3 overriding anim2 at 400ms");
   advance_clock(200);
   yield waitForPaintsFlushed();
-  // FIXME: Half of this test fails, which means that omta_todo_is fails
-  // just as much as omta_is.  (The value is wrong on both compositor and
-  // main threads.)
   omta_is("opacity", 0.6, RunningOn.Compositor,
           "anim2 at 600ms");
   done_div();
 
   // One animation overriding another, and then not, but without a
   // restyle when the overriding one ends.
   new_div("animation: anim2 1s steps(8, end)");
   yield waitForPaintsFlushed();
@@ -2153,25 +2150,21 @@ addAsyncAnimTest(function *() {
   omta_is("opacity", 0, RunningOn.Compositor,
           "anim3 overriding anim2 at 300ms");
   advance_clock(475);
   yield waitForPaintsFlushed();
   omta_is("opacity", 0.75, RunningOn.Compositor,
           "anim3 the same as anim2 at 775ms");
   advance_clock(50);
   yield waitForPaintsFlushed();
-  // FIXME: Half of this test fails, which means that omta_todo_is fails
-  // just as much as omta_is.  (The value is wrong on both compositor and
-  // main threads.)
-  omta_is("opacity", 0.75, RunningOn.Compositor,
+  // FIXME: What's wrong here?  The computed style is correct but the OMTA
+  // style is wrong.
+  omta_todo_is("opacity", 0.75, RunningOn.Compositor,
           "anim2 at 825ms");
   advance_clock(75);
   yield waitForPaintsFlushed();
-  // FIXME: Half of this test fails, which means that omta_todo_is fails
-  // just as much as omta_is.  (The value is wrong on both compositor and
-  // main threads.)
   omta_is("opacity", 0.875, RunningOn.Compositor,
           "anim2 at 900ms");
   done_div();
 });
 
 </script>
 </html>
