From: L. David Baron <dbaron@dbaron.org>

Bug 847287 patch 6 - Dynamically update cascade results when animations start or stop filling.

diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -203,30 +203,55 @@ CSSAnimationPlayer::PseudoTypeAsString(n
 void
 nsAnimationManager::UpdateStyleAndEvents(AnimationPlayerCollection*
                                            aCollection,
                                          TimeStamp aRefreshTime,
                                          EnsureStyleRuleFlags aFlags)
 {
   aCollection->EnsureStyleRuleFor(aRefreshTime, aFlags);
   QueueEvents(aCollection, mPendingEvents);
+  MaybeUpdateCascadeResults(aCollection);
 }
 
 void
 nsAnimationManager::QueueEvents(AnimationPlayerCollection* aCollection,
                                 EventArray& aEventsToDispatch)
 {
   for (size_t playerIdx = aCollection->mPlayers.Length(); playerIdx-- != 0; ) {
     CSSAnimationPlayer* player =
       aCollection->mPlayers[playerIdx]->AsCSSAnimationPlayer();
     MOZ_ASSERT(player, "Expected a collection of CSS Animation players");
     player->QueueEvents(aEventsToDispatch);
   }
 }
 
+void
+nsAnimationManager::MaybeUpdateCascadeResults(AnimationPlayerCollection* aCollection)
+{
+  for (size_t playerIdx = aCollection->mPlayers.Length(); playerIdx-- != 0; ) {
+    CSSAnimationPlayer* player =
+      aCollection->mPlayers[playerIdx]->AsCSSAnimationPlayer();
+
+    bool filling = anim->GetComputedTiming().mTimeFraction !=
+                   ComputedTiming::kNullTimeFraction;
+    if (filling != player->mFillingForCascadeResults) {
+      mozilla::dom::Element* element = aCollection->GetElementToRestyle();
+      if (!element) {
+        return;
+      }
+      nsIFrame* frame = element->GetPrimaryFrame();
+      if (!frame) {
+        return;
+      }
+      UpdateCascadeResults(frame->StyleContext(), aCollection);
+      return;
+    }
+  }
+}
+
 /* virtual */ size_t
 nsAnimationManager::SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const
 {
   return CommonAnimationManager::SizeOfExcludingThis(aMallocSizeOf);
 
   // Measurement of the following members may be added later if DMD finds it is
   // worthwhile:
   // - mPendingEvents
@@ -760,39 +785,40 @@ nsAnimationManager::UpdateCascadeResults
    * AnimationPlayerCollection::EnsureStyleRuleFor.  Later animations
    * override earlier ones, so we add properties to the set of
    * overridden properties as we encounter them, if the animation is
    * currently filling.
    */
 
   for (size_t playerIdx = aElementAnimations->mPlayers.Length();
        playerIdx-- != 0; ) {
-    AnimationPlayer* player = aElementAnimations->mPlayers[playerIdx];
+    CSSAnimationPlayer* player =
+      aElementAnimations->mPlayers[playerIdx]->AsCSSAnimationPlayer();
     Animation* anim = player->GetSource();
     if (!anim) {
       continue;
     }
 
+    player->mFillingForCascadeResults =
+      anim->GetComputedTiming().mTimeFraction !=
+      ComputedTiming::kNullTimeFraction;
+
     for (size_t propIdx = 0, propEnd = anim->Properties().Length();
          propIdx != propEnd; ++propIdx) {
       AnimationProperty& prop = anim->Properties()[propIdx];
       // We only bother setting mWinsInCascade for properties that we
       // can animate on the compositor.
       if (nsCSSProps::PropHasFlags(prop.mProperty,
                                    CSS_PROPERTY_CAN_ANIMATE_ON_COMPOSITOR)) {
         prop.mWinsInCascade = !propertiesOverridden.HasProperty(prop.mProperty);
 
-        if (prop.mWinsInCascade) {
-          ComputedTiming computedTiming = anim->GetComputedTiming();
-          if (computedTiming.mTimeFraction !=
-              ComputedTiming::kNullTimeFraction) {
-            // This animation is filling right now, so it overrides
-            // earlier animations.
-            propertiesOverridden.AddProperty(prop.mProperty);
-          }
+        if (prop.mWinsInCascade && player->mFillingForCascadeResults) {
+          // This animation is filling right now, so it overrides
+          // earlier animations.
+          propertiesOverridden.AddProperty(prop.mProperty);
         }
       }
     }
   }
 }
 
 /* virtual */ void
 nsAnimationManager::WillRefresh(mozilla::TimeStamp aTime)
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -75,16 +75,23 @@ public:
 
   void PlayFromStyle();
   void PauseFromStyle();
 
   bool IsStylePaused() const { return mIsStylePaused; }
 
   void QueueEvents(EventArray& aEventsToDispatch);
 
+  // Is this animation currently filling for the purposes of computing
+  // mWinsInCascade.  (In general, this can be computed from the timing
+  // function.  This boolean remembers the state as of the last time we
+  // called UpdateCascadeResults so we know if it changes and we need to
+  // call UpdateCascadeResults again.)
+  bool mFillingForCascadeResults;
+
 protected:
   virtual ~CSSAnimationPlayer() { }
   virtual css::CommonAnimationManager* GetAnimationManager() const MOZ_OVERRIDE;
 
   static nsString PseudoTypeAsString(nsCSSPseudoElements::Type aPseudoType);
 
   // When combining animation-play-state with play() / pause() the following
   // behavior applies:
@@ -163,18 +170,16 @@ public:
   {
     return mozilla::css::CommonAnimationManager::GetAnimationsForCompositor(
       aContent, nsGkAtoms::animationsProperty, aProperty);
   }
 
   void UpdateStyleAndEvents(mozilla::AnimationPlayerCollection* aEA,
                             mozilla::TimeStamp aRefreshTime,
                             mozilla::EnsureStyleRuleFlags aFlags);
-  void QueueEvents(mozilla::AnimationPlayerCollection* aEA,
-                   mozilla::EventArray &aEventsToDispatch);
 
   // nsIStyleRuleProcessor (parts)
   virtual size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf)
     const MOZ_MUST_OVERRIDE MOZ_OVERRIDE;
   virtual size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf)
     const MOZ_MUST_OVERRIDE MOZ_OVERRIDE;
 
   // nsARefreshObserver
@@ -232,16 +237,20 @@ private:
   bool BuildSegment(InfallibleTArray<mozilla::AnimationPropertySegment>&
                       aSegments,
                     nsCSSProperty aProperty,
                     const mozilla::StyleAnimation& aAnimation,
                     float aFromKey, nsStyleContext* aFromContext,
                     mozilla::css::Declaration* aFromDeclaration,
                     float aToKey, nsStyleContext* aToContext);
 
+  void QueueEvents(mozilla::AnimationPlayerCollection* aEA,
+                   mozilla::EventArray &aEventsToDispatch);
+  void MaybeUpdateCascadeResults(AnimationPlayerCollection* aCollection);
+
   static void UpdateCascadeResults(nsStyleContext* aStyleContext,
                                    mozilla::AnimationPlayerCollection*
                                      aElementAnimations);
 
   // The guts of DispatchEvents
   void DoDispatchEvents();
 
   mozilla::EventArray mPendingEvents;
