From: L. David Baron <dbaron@dbaron.org>

Bug 847287 patch 7 - Dynamically update cascade results when animations start or stop filling.

This is an additional part of the main work in this bug; it keeps
mWinsInCascade updated in cases where we need to update it.

diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -788,16 +788,23 @@ AnimationPlayerCollection::EnsureStyleRu
 
   if (aFlags == EnsureStyleRule_IsThrottled) {
     return;
   }
 
   // mStyleRule may be null and valid, if we have no style to apply.
   if (mStyleRuleRefreshTime.IsNull() ||
       mStyleRuleRefreshTime != aRefreshTime) {
+    if (mManager->IsAnimationManager()) {
+      // Update cascade results before updating the style rule, since the
+      // cascade results can influence the style rule.
+      static_cast<nsAnimationManager*>(mManager)->
+        MaybeUpdateCascadeResults(this);
+    }
+
     mStyleRuleRefreshTime = aRefreshTime;
     mStyleRule = nullptr;
     // We'll set mNeedsRefreshes to true below in all cases where we need them.
     mNeedsRefreshes = false;
 
     // If multiple animations specify behavior for the same property the
     // animation which occurs last in the value of animation-name wins.
     // As a result, we iterate from last animation to first and, if a
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -217,16 +217,40 @@ nsAnimationManager::QueueEvents(Animatio
   for (size_t playerIdx = aCollection->mPlayers.Length(); playerIdx-- != 0; ) {
     CSSAnimationPlayer* player =
       aCollection->mPlayers[playerIdx]->AsCSSAnimationPlayer();
     MOZ_ASSERT(player, "Expected a collection of CSS Animation players");
     player->QueueEvents(aEventsToDispatch);
   }
 }
 
+void
+nsAnimationManager::MaybeUpdateCascadeResults(AnimationPlayerCollection* aCollection)
+{
+  for (size_t playerIdx = aCollection->mPlayers.Length(); playerIdx-- != 0; ) {
+    CSSAnimationPlayer* player =
+      aCollection->mPlayers[playerIdx]->AsCSSAnimationPlayer();
+    const Animation* anim = player->GetSource();
+
+    bool filling = anim &&
+                   anim->GetComputedTiming().mTimeFraction !=
+                     ComputedTiming::kNullTimeFraction;
+    if (filling != player->mFillingForCascadeResults) {
+      mozilla::dom::Element* element = aCollection->GetElementToRestyle();
+      if (element) {
+        nsIFrame* frame = element->GetPrimaryFrame();
+        if (frame) {
+          UpdateCascadeResults(frame->StyleContext(), aCollection);
+        }
+      }
+      return;
+    }
+  }
+}
+
 /* virtual */ size_t
 nsAnimationManager::SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const
 {
   return CommonAnimationManager::SizeOfExcludingThis(aMallocSizeOf);
 
   // Measurement of the following members may be added later if DMD finds it is
   // worthwhile:
   // - mPendingEvents
@@ -769,18 +793,25 @@ nsAnimationManager::UpdateCascadeResults
    * override earlier ones, so we add properties to the set of
    * overridden properties as we encounter them, if the animation is
    * currently filling.
    */
 
   bool changed = false;
   for (size_t playerIdx = aElementAnimations->mPlayers.Length();
        playerIdx-- != 0; ) {
-    AnimationPlayer* player = aElementAnimations->mPlayers[playerIdx];
+    CSSAnimationPlayer* player =
+      aElementAnimations->mPlayers[playerIdx]->AsCSSAnimationPlayer();
     Animation* anim = player->GetSource();
+
+    player->mFillingForCascadeResults =
+      anim &&
+      anim->GetComputedTiming().mTimeFraction !=
+        ComputedTiming::kNullTimeFraction;
+
     if (!anim) {
       continue;
     }
 
     for (size_t propIdx = 0, propEnd = anim->Properties().Length();
          propIdx != propEnd; ++propIdx) {
       AnimationProperty& prop = anim->Properties()[propIdx];
       // We only bother setting mWinsInCascade for properties that we
@@ -789,24 +820,20 @@ nsAnimationManager::UpdateCascadeResults
                                    CSS_PROPERTY_CAN_ANIMATE_ON_COMPOSITOR)) {
         bool newWinsInCascade =
           !propertiesOverridden.HasProperty(prop.mProperty);
         if (newWinsInCascade != prop.mWinsInCascade) {
           changed = true;
         }
         prop.mWinsInCascade = newWinsInCascade;
 
-        if (prop.mWinsInCascade) {
-          ComputedTiming computedTiming = anim->GetComputedTiming();
-          if (computedTiming.mTimeFraction !=
-              ComputedTiming::kNullTimeFraction) {
-            // This animation is filling right now, so it overrides
-            // earlier animations.
-            propertiesOverridden.AddProperty(prop.mProperty);
-          }
+        if (prop.mWinsInCascade && player->mFillingForCascadeResults) {
+          // This animation is filling right now, so it overrides
+          // earlier animations.
+          propertiesOverridden.AddProperty(prop.mProperty);
         }
       }
     }
   }
 
   if (changed) {
     nsPresContext* presContext = aElementAnimations->mManager->PresContext();
     presContext->RestyleManager()->IncrementAnimationGeneration();
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -75,16 +75,23 @@ public:
 
   void PlayFromStyle();
   void PauseFromStyle();
 
   bool IsStylePaused() const { return mIsStylePaused; }
 
   void QueueEvents(EventArray& aEventsToDispatch);
 
+  // Is this animation currently filling for the purposes of computing
+  // mWinsInCascade.  (In general, this can be computed from the timing
+  // function.  This boolean remembers the state as of the last time we
+  // called UpdateCascadeResults so we know if it changes and we need to
+  // call UpdateCascadeResults again.)
+  bool mFillingForCascadeResults;
+
 protected:
   virtual ~CSSAnimationPlayer() { }
   virtual css::CommonAnimationManager* GetAnimationManager() const override;
 
   static nsString PseudoTypeAsString(nsCSSPseudoElements::Type aPseudoType);
 
   // When combining animation-play-state with play() / pause() the following
   // behavior applies:
@@ -166,16 +173,19 @@ public:
   }
 
   void UpdateStyleAndEvents(mozilla::AnimationPlayerCollection* aEA,
                             mozilla::TimeStamp aRefreshTime,
                             mozilla::EnsureStyleRuleFlags aFlags);
   void QueueEvents(mozilla::AnimationPlayerCollection* aEA,
                    mozilla::EventArray &aEventsToDispatch);
 
+  void MaybeUpdateCascadeResults(mozilla::AnimationPlayerCollection*
+                                   aCollection);
+
   // nsIStyleRuleProcessor (parts)
   virtual size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf)
     const MOZ_MUST_OVERRIDE override;
   virtual size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf)
     const MOZ_MUST_OVERRIDE override;
 
   // nsARefreshObserver
   virtual void WillRefresh(mozilla::TimeStamp aTime) override;
diff --git a/layout/style/test/test_animations_omta.html b/layout/style/test/test_animations_omta.html
--- a/layout/style/test/test_animations_omta.html
+++ b/layout/style/test/test_animations_omta.html
@@ -2190,19 +2190,16 @@ addAsyncAnimTest(function *() {
   advance_clock(400);
   omta_is("opacity", 0.2, RunningOn.Compositor,
           "anim3 overriding anim2 at 400ms");
   advance_clock(200);
   // Wait for paints because we're resending animations to the
   // compositor via an UpdateOpacityLayer hint, which does the resending
   // via painting.
   yield waitForPaints();
-  // FIXME: Half of this test fails, which means that omta_todo_is fails
-  // just as much as omta_is.  (The value is wrong on both compositor and
-  // main threads.)
   omta_is("opacity", 0.6, RunningOn.Compositor,
           "anim2 at 600ms");
   done_div();
 
   // One animation overriding another, and then not, but without a
   // restyle when the overriding one ends.
   new_div("animation: anim2 1s steps(8, end)");
   yield waitForPaintsFlushed();
@@ -2218,25 +2215,19 @@ addAsyncAnimTest(function *() {
   advance_clock(475);
   omta_is("opacity", 0.75, RunningOn.Compositor,
           "anim3 the same as anim2 at 775ms");
   advance_clock(50);
   // Wait for paints because we're resending animations to the
   // compositor via an UpdateOpacityLayer hint, which does the resending
   // via painting.
   yield waitForPaints();
-  // FIXME: Half of this test fails, which means that omta_todo_is fails
-  // just as much as omta_is.  (The value is wrong on both compositor and
-  // main threads.)
   omta_is("opacity", 0.75, RunningOn.Compositor,
           "anim2 at 825ms");
   advance_clock(75);
-  // FIXME: Half of this test fails, which means that omta_todo_is fails
-  // just as much as omta_is.  (The value is wrong on both compositor and
-  // main threads.)
   omta_is("opacity", 0.875, RunningOn.Compositor,
           "anim2 at 900ms");
   done_div();
 
   // Exactly the same as the previous test, except with an extra
   // waitForPaintsFlushed(), since that extra one exposes other bugs.
   new_div("animation: anim2 1s steps(8, end)");
   yield waitForPaintsFlushed();
@@ -2254,24 +2245,18 @@ addAsyncAnimTest(function *() {
           "anim3 the same as anim2 at 775ms");
   // Extra waitForPaintsFlushed to expose bugs.
   yield waitForPaintsFlushed();
   advance_clock(50);
   // Wait for paints because we're resending animations to the
   // compositor via an UpdateOpacityLayer hint, which does the resending
   // via painting.
   yield waitForPaints();
-  // FIXME: Half of this test fails, which means that omta_todo_is fails
-  // just as much as omta_is.  (The value is wrong on both compositor and
-  // main threads.)
   omta_is("opacity", 0.75, RunningOn.Compositor,
           "anim2 at 825ms");
   advance_clock(75);
-  // FIXME: Half of this test fails, which means that omta_todo_is fails
-  // just as much as omta_is.  (The value is wrong on both compositor and
-  // main threads.)
   omta_is("opacity", 0.875, RunningOn.Compositor,
           "anim2 at 900ms");
   done_div();
 });
 
 </script>
 </html>
