Make cycle collector work with refcounted non-XPCOM objects.  b=368774

diff -r a3c13f50f124 content/xbl/src/nsBindingManager.cpp
--- a/content/xbl/src/nsBindingManager.cpp	Thu Mar 01 18:00:51 2007 -0800
+++ b/content/xbl/src/nsBindingManager.cpp	Fri Mar 02 14:52:15 2007 -0800
@@ -85,12 +85,14 @@
 // = nsAnonymousContentList 
 // ==================================================================
 
-class nsAnonymousContentList : public nsGenericDOMNodeList
+class nsAnonymousContentList : public nsIDOMNodeList
 {
 public:
   nsAnonymousContentList(nsInsertionPointList* aElements);
   virtual ~nsAnonymousContentList();
 
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+  NS_DECL_CYCLE_COLLECTION_CLASS(nsAnonymousContentList)
   // nsIDOMNodeList interface
   NS_DECL_NSIDOMNODELIST
 
@@ -117,6 +119,29 @@ nsAnonymousContentList::~nsAnonymousCont
   MOZ_COUNT_DTOR(nsAnonymousContentList);
   delete mElements;
 }
+
+NS_IMPL_CYCLE_COLLECTION_CLASS(nsAnonymousContentList)
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(nsAnonymousContentList)
+NS_IMPL_CYCLE_COLLECTING_RELEASE(nsAnonymousContentList)
+
+NS_INTERFACE_MAP_BEGIN(nsAnonymousContentList)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMNodeList)
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(NodeList)
+  NS_INTERFACE_MAP_ENTRY_CYCLE_COLLECTION(nsAnonymousContentList)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsAnonymousContentList)
+NS_IMPL_CYCLE_COLLECTION_UNLINK_END
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsAnonymousContentList)
+  {
+    PRInt32 i, count = tmp->mElements->Length();
+    for (i = 0; i < count; ++i) {
+      NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_POINTER(mElements->ElementAt(i), nsXBLInsertionPoint);
+    }
+  }
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMETHODIMP
 nsAnonymousContentList::GetLength(PRUint32* aLength)
@@ -1341,8 +1366,7 @@ nsBindingManager::Traverse(nsIContent *a
 {
   nsXBLBinding *binding = GetBinding(aContent);
   if (binding) {
-    // XXX nsXBLBinding isn't nsISupports but it is refcounted, so we can't
-    //     traverse it.
+    cb.NoteNativeChild(binding, NS_CYCLE_COLLECTION_NATIVE_CLASS_HELPER(nsXBLBinding));
     cb.NoteXPCOMChild(aContent);
   }
   nsISupports *value;
diff -r a3c13f50f124 content/xbl/src/nsXBLBinding.cpp
--- a/content/xbl/src/nsXBLBinding.cpp	Thu Mar 01 18:00:51 2007 -0800
+++ b/content/xbl/src/nsXBLBinding.cpp	Fri Mar 02 14:52:15 2007 -0800
@@ -173,6 +173,34 @@ nsXBLBinding::~nsXBLBinding(void)
   NS_RELEASE(info);
 }
 
+PR_STATIC_CALLBACK(PLDHashOperator)
+TraverseKey(nsISupports* aKey, nsInsertionPointList* aData, void* aClosure)
+{
+  nsCycleCollectionTraversalCallback *cb = 
+    NS_STATIC_CAST(nsCycleCollectionTraversalCallback*, aClosure);
+
+  if (aKey)
+    cb->NoteXPCOMChild(aKey);
+  if (aData) {
+    PRInt32 i, count = aData->Length();
+    for (i = 0; i < count; ++i) {
+      cb->NoteNativeChild(aData->ElementAt(i), NS_CYCLE_COLLECTION_NATIVE_CLASS_HELPER(nsXBLInsertionPoint));
+    }
+  }
+  return PL_DHASH_NEXT;
+}
+
+NS_IMPL_CYCLE_COLLECTION_NATIVE_CLASS(nsXBLBinding)
+NS_IMPL_CYCLE_COLLECTION_UNLINK_NATIVE_BEGIN(nsXBLBinding)
+NS_IMPL_CYCLE_COLLECTION_UNLINK_END
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(nsXBLBinding)
+  cb.NoteXPCOMChild(tmp->mPrototypeBinding->XBLDocumentInfo());
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mContent)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_POINTER(mNextBinding, nsXBLBinding)
+  if (tmp->mInsertionPointTable)
+    tmp->mInsertionPointTable->EnumerateRead(TraverseKey, &cb);
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
+
 void
 nsXBLBinding::SetBaseBinding(nsXBLBinding* aBinding)
 {
diff -r a3c13f50f124 content/xbl/src/nsXBLBinding.h
--- a/content/xbl/src/nsXBLBinding.h	Thu Mar 01 18:00:51 2007 -0800
+++ b/content/xbl/src/nsXBLBinding.h	Fri Mar 02 14:52:15 2007 -0800
@@ -45,6 +45,7 @@
 #include "nsIStyleRuleProcessor.h"
 #include "nsClassHashtable.h"
 #include "nsTArray.h"
+#include "nsCycleCollectionParticipant.h"
 
 class nsXBLPrototypeBinding;
 class nsIContent;
@@ -94,6 +95,8 @@ public:
     }
     return mRefCnt;
   }
+
+  NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(nsXBLBinding)
 
   nsXBLPrototypeBinding* PrototypeBinding() { return mPrototypeBinding; }
   nsIContent* GetAnonymousContent() { return mContent.get(); }
diff -r a3c13f50f124 content/xbl/src/nsXBLInsertionPoint.cpp
--- a/content/xbl/src/nsXBLInsertionPoint.cpp	Thu Mar 01 18:00:51 2007 -0800
+++ b/content/xbl/src/nsXBLInsertionPoint.cpp	Fri Mar 02 14:52:16 2007 -0800
@@ -64,6 +64,15 @@ nsXBLInsertionPoint::Release()
   return mRefCnt;
 }
 
+NS_IMPL_CYCLE_COLLECTION_NATIVE_CLASS(nsXBLInsertionPoint)
+NS_IMPL_CYCLE_COLLECTION_UNLINK_NATIVE_BEGIN(nsXBLInsertionPoint)
+NS_IMPL_CYCLE_COLLECTION_UNLINK_END
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(nsXBLInsertionPoint)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mElements)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDefaultContentTemplate)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDefaultContent)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
+
 already_AddRefed<nsIContent>
 nsXBLInsertionPoint::GetInsertionParent()
 {
diff -r a3c13f50f124 content/xbl/src/nsXBLInsertionPoint.h
--- a/content/xbl/src/nsXBLInsertionPoint.h	Thu Mar 01 18:00:51 2007 -0800
+++ b/content/xbl/src/nsXBLInsertionPoint.h	Fri Mar 02 14:52:16 2007 -0800
@@ -42,6 +42,7 @@
 #include "nsCOMArray.h"
 #include "nsIContent.h"
 #include "nsCOMPtr.h"
+#include "nsCycleCollectionParticipant.h"
 
 class nsXBLInsertionPoint
 {
@@ -58,6 +59,8 @@ public:
   }
 
   nsrefcnt Release();
+
+  NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(nsXBLInsertionPoint)
 
   already_AddRefed<nsIContent> GetInsertionParent();
   PRInt32 GetInsertionIndex() { return mIndex; }
diff -r a3c13f50f124 content/xbl/src/nsXBLPrototypeBinding.cpp
--- a/content/xbl/src/nsXBLPrototypeBinding.cpp	Thu Mar 01 18:00:51 2007 -0800
+++ b/content/xbl/src/nsXBLPrototypeBinding.cpp	Fri Mar 02 14:52:16 2007 -0800
@@ -147,7 +147,9 @@ public:
       mDefaultContent->UnbindFromTree();
     }      
   }
-  
+
+  NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(nsXBLInsertionPointEntry)
+
   nsIContent* GetInsertionParent() { return mInsertionParent; }
   PRUint32 GetInsertionIndex() { return mInsertionIndex; }
   void SetInsertionIndex(PRUint32 aIndex) { mInsertionIndex = aIndex; }
@@ -188,12 +190,11 @@ protected:
   nsCOMPtr<nsIContent> mInsertionParent;
   nsCOMPtr<nsIContent> mDefaultContent;
   PRUint32 mInsertionIndex;
-  nsrefcnt mRefCnt;
+  nsAutoRefCnt mRefCnt;
 
   nsXBLInsertionPointEntry(nsIContent* aParent)
     : mInsertionParent(aParent),
-      mInsertionIndex(0),
-      mRefCnt(0) { }
+      mInsertionIndex(0) { }
 
 private:
   // Hide so that only Create() and Destroy() can be used to
@@ -201,6 +202,14 @@ private:
   static void* operator new(size_t) CPP_THROW_NEW { return 0; }
   static void operator delete(void*, size_t) {}
 };
+
+NS_IMPL_CYCLE_COLLECTION_NATIVE_CLASS(nsXBLInsertionPointEntry)
+NS_IMPL_CYCLE_COLLECTION_UNLINK_NATIVE_BEGIN(nsXBLInsertionPointEntry)
+NS_IMPL_CYCLE_COLLECTION_UNLINK_END
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(nsXBLInsertionPointEntry)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mInsertionParent)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDefaultContent)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 // =============================================================================
 
@@ -279,11 +288,24 @@ nsXBLPrototypeBinding::Init(const nsACSt
   return NS_OK;
 }
 
+static PRIntn PR_CALLBACK
+TraverseInsertionPoint(nsHashKey* aKey, void* aData, void* aClosure)
+{
+  nsCycleCollectionTraversalCallback *cb = 
+    NS_STATIC_CAST(nsCycleCollectionTraversalCallback*, aClosure);
+  nsXBLInsertionPointEntry* entry =
+    NS_STATIC_CAST(nsXBLInsertionPointEntry*, aData);
+  cb->NoteNativeChild(entry,
+                      NS_CYCLE_COLLECTION_NATIVE_CLASS_HELPER(nsXBLInsertionPointEntry));
+  return kHashEnumerateNext;
+}
+
 void
 nsXBLPrototypeBinding::Traverse(nsCycleCollectionTraversalCallback &cb) const
 {
   cb.NoteXPCOMChild(mBinding);
-  // XXX mInsertionPointTable!
+  if (mInsertionPointTable)
+    mInsertionPointTable->Enumerate(TraverseInsertionPoint, &cb);
   if (mResources && mResources->mLoader)
     cb.NoteXPCOMChild(mResources->mLoader);
 }
diff -r a3c13f50f124 content/xul/content/src/nsXULElement.h
--- a/content/xul/content/src/nsXULElement.h	Thu Mar 01 18:00:51 2007 -0800
+++ b/content/xul/content/src/nsXULElement.h	Fri Mar 02 14:52:16 2007 -0800
@@ -228,6 +228,10 @@ public:
     }
     virtual void ReleaseSubtree() { Release(); }
 
+    virtual void Traverse(nsCycleCollectionTraversalCallback &cb)
+    {
+    }
+
 protected:
     nsXULPrototypeNode(Type aType)
         : mType(aType), mRefCnt(1) {}
@@ -282,6 +286,20 @@ public:
                                  const nsCOMArray<nsINodeInfo> *aNodeInfos);
 
     nsresult SetAttrAt(PRUint32 aPos, const nsAString& aValue, nsIURI* aDocumentURI);
+
+    virtual void Traverse(nsCycleCollectionTraversalCallback &cb)
+    {
+        PRUint32 i;
+        for (i = 0; i < mNumAttributes; ++i) {
+            void *eventHandler = mAttributes[i].mEventHandler;
+            if (eventHandler) {
+                cb.NoteScriptChild(mScriptTypeID, eventHandler);
+            }
+        }
+        for (i = 0; i < mNumChildren; ++i) {
+            mChildren[i]->Traverse(cb);
+        }
+    }
 
     PRUint32                 mNumChildren;
     nsXULPrototypeNode**     mChildren;           // [OWNER]
@@ -345,6 +363,11 @@ public:
                      nsIURI* aURI, PRUint32 aLineNo,
                      nsIDocument* aDocument,
                      nsIScriptGlobalObjectOwner* aGlobalOwner);
+
+    virtual void Traverse(nsCycleCollectionTraversalCallback &cb)
+    {
+        mScriptObject.traverse(cb);
+    }
 
     nsCOMPtr<nsIURI>         mSrcURI;
     PRUint32                 mLineNo;
diff -r a3c13f50f124 content/xul/document/src/nsXULPrototypeDocument.cpp
--- a/content/xul/document/src/nsXULPrototypeDocument.cpp	Thu Mar 01 18:00:51 2007 -0800
+++ b/content/xul/document/src/nsXULPrototypeDocument.cpp	Fri Mar 02 14:52:16 2007 -0800
@@ -196,7 +196,9 @@ NS_IMPL_CYCLE_COLLECTION_CLASS(nsXULProt
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsXULPrototypeDocument)
 NS_IMPL_CYCLE_COLLECTION_UNLINK_0(nsXULPrototypeDocument)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsXULPrototypeDocument)
-  // XXX Can't traverse tmp->mRoot, non-XPCOM refcounted object
+  if (tmp->mRoot) {
+    tmp->mRoot->Traverse(cb);
+  }
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mGlobalObject)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
diff -r a3c13f50f124 js/src/xpconnect/src/nsXPConnect.cpp
--- a/js/src/xpconnect/src/nsXPConnect.cpp	Thu Mar 01 18:00:51 2007 -0800
+++ b/js/src/xpconnect/src/nsXPConnect.cpp	Fri Mar 02 14:52:46 2007 -0800
@@ -578,7 +578,8 @@ nsXPConnect::Unroot(const nsDeque &nodes
 }
 
 nsresult 
-nsXPConnect::Traverse(void *p, nsCycleCollectionTraversalCallback &cb)
+nsXPConnect::Traverse(void *p, void *helper,
+                      nsCycleCollectionTraversalCallback &cb)
 {
     XPCCallContext cx(NATIVE_CALLER);
 
diff -r a3c13f50f124 js/src/xpconnect/src/xpcprivate.h
--- a/js/src/xpconnect/src/xpcprivate.h	Thu Mar 01 18:00:51 2007 -0800
+++ b/js/src/xpconnect/src/xpcprivate.h	Fri Mar 02 14:52:46 2007 -0800
@@ -479,7 +479,8 @@ public:
     nsresult Root(const nsDeque &nodes);
     nsresult Unlink(const nsDeque &nodes);
     nsresult Unroot(const nsDeque &nodes);
-    nsresult Traverse(void *p, nsCycleCollectionTraversalCallback &cb);
+    nsresult Traverse(void *p, void *helper,
+                      nsCycleCollectionTraversalCallback &cb);
     nsresult FinishCycleCollection();
     JSObjectRefcounts* GetJSObjectRefcounts() {return mObjRefcounts;}
 #ifndef XPCONNECT_STANDALONE
diff -r a3c13f50f124 js/src/xpconnect/src/xpcwrappedjs.cpp
--- a/js/src/xpconnect/src/xpcwrappedjs.cpp	Thu Mar 01 18:00:51 2007 -0800
+++ b/js/src/xpconnect/src/xpcwrappedjs.cpp	Fri Mar 02 14:52:47 2007 -0800
@@ -49,7 +49,7 @@ NS_IMPL_CYCLE_COLLECTION_CLASS(nsXPCWrap
 
 NS_IMETHODIMP
 NS_CYCLE_COLLECTION_CLASSNAME(nsXPCWrappedJS)::Traverse
-   (nsISupports *s, nsCycleCollectionTraversalCallback &cb)
+   (void *s, nsCycleCollectionTraversalCallback &cb)
 {
     // REVIEW ME PLEASE: this is a very odd area and it's easy to get
     // it wrong. I'm not sure I got it right.
@@ -68,7 +68,8 @@ NS_CYCLE_COLLECTION_CLASSNAME(nsXPCWrapp
     {
         // Put the nsCOMPtr in a local scope, to avoid messing up the refcount
         // below.
-        nsCOMPtr<nsIXPConnectWrappedJS> owner = do_QueryInterface(s, &rv);
+        nsCOMPtr<nsIXPConnectWrappedJS> owner =
+          do_QueryInterface(NS_STATIC_CAST(nsISupports*, s), &rv);
         if (NS_FAILED(rv))
             return rv;
 
@@ -118,7 +119,7 @@ NS_CYCLE_COLLECTION_CLASSNAME(nsXPCWrapp
 }
 
 NS_IMETHODIMP
-NS_CYCLE_COLLECTION_CLASSNAME(nsXPCWrappedJS)::Unlink(nsISupports *s)
+NS_CYCLE_COLLECTION_CLASSNAME(nsXPCWrappedJS)::Unlink(void *s)
 {
     // NB: We might unlink our outgoing references in the future; for
     // now we do nothing. This is a harmless conservative behavior; it
diff -r a3c13f50f124 js/src/xpconnect/src/xpcwrappednative.cpp
--- a/js/src/xpconnect/src/xpcwrappednative.cpp	Thu Mar 01 18:00:51 2007 -0800
+++ b/js/src/xpconnect/src/xpcwrappednative.cpp	Fri Mar 02 14:52:47 2007 -0800
@@ -50,7 +50,7 @@ NS_IMPL_CYCLE_COLLECTION_CLASS(XPCWrappe
 NS_IMPL_CYCLE_COLLECTION_CLASS(XPCWrappedNative)
 
 NS_IMETHODIMP
-NS_CYCLE_COLLECTION_CLASSNAME(XPCWrappedNative)::Traverse(nsISupports *s,
+NS_CYCLE_COLLECTION_CLASSNAME(XPCWrappedNative)::Traverse(void *s,
                                                           nsCycleCollectionTraversalCallback &cb)
 {
     XPCWrappedNative *tmp = NS_STATIC_CAST(XPCWrappedNative*, s);
@@ -118,7 +118,7 @@ NS_CYCLE_COLLECTION_CLASSNAME(XPCWrapped
 }
 
 NS_IMETHODIMP
-NS_CYCLE_COLLECTION_CLASSNAME(XPCWrappedNative)::Unlink(nsISupports *s)
+NS_CYCLE_COLLECTION_CLASSNAME(XPCWrappedNative)::Unlink(void *s)
 {
     // NB: We might unlink our outgoing references in the future; for
     // now we do nothing. This is a harmless conservative behavior; it
diff -r a3c13f50f124 xpcom/base/nsCycleCollectionParticipant.h
--- a/xpcom/base/nsCycleCollectionParticipant.h	Thu Mar 01 18:00:51 2007 -0800
+++ b/xpcom/base/nsCycleCollectionParticipant.h	Fri Mar 02 15:01:03 2007 -0800
@@ -78,6 +78,12 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsCycleCol
 #undef  IMETHOD_VISIBILITY
 #define IMETHOD_VISIBILITY NS_VISIBILITY_DEFAULT
 
+struct nsCycleCollectionHelper
+{
+    PRUint32 mLang;
+    void *mParticipantHelper;
+};
+
 struct nsCycleCollectionTraversalCallback
 {
     // You must call DescribeNode() with an accurate refcount,
@@ -88,6 +94,8 @@ struct nsCycleCollectionTraversalCallbac
                               const char *objname) = 0;
     virtual void NoteScriptChild(PRUint32 langID, void *child) = 0;
     virtual void NoteXPCOMChild(nsISupports *child) = 0;
+    virtual void NoteNativeChild(void *child,
+                                 nsCycleCollectionHelper *helper) = 0;
 };
 
 class NS_COM nsCycleCollectionParticipant
@@ -97,8 +105,8 @@ public:
     NS_DECLARE_STATIC_IID_ACCESSOR(NS_CYCLECOLLECTIONPARTICIPANT_IID)
     NS_DECL_ISUPPORTS
 
-    NS_IMETHOD Unlink(nsISupports *p) = 0;
-    NS_IMETHOD Traverse(nsISupports *p, 
+    NS_IMETHOD Unlink(void *p) = 0;
+    NS_IMETHOD Traverse(void *p, 
                         nsCycleCollectionTraversalCallback &cb) = 0;
 
 #ifdef DEBUG
@@ -153,16 +161,24 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsCycleCol
 
 #define NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(_class)                          \
   NS_IMETHODIMP                                                                \
-  NS_CYCLE_COLLECTION_CLASSNAME(_class)::Unlink(nsISupports *s)                \
-  {                                                                            \
+  NS_CYCLE_COLLECTION_CLASSNAME(_class)::Unlink(void *p)                       \
+  {                                                                            \
+    nsISupports *s = NS_STATIC_CAST(nsISupports*, p);                          \
     NS_ASSERTION(CheckForRightISupports(s),                                    \
                  "not the nsISupports pointer we expect");                     \
     _class *tmp = Downcast(s);
 
+#define NS_IMPL_CYCLE_COLLECTION_UNLINK_NATIVE_BEGIN(_class)                   \
+  NS_IMETHODIMP                                                                \
+  NS_CYCLE_COLLECTION_CLASSNAME(_class)::Unlink(void *s)                       \
+  {                                                                            \
+    _class *tmp = NS_STATIC_CAST(_class*, s);                                  \
+
 #define NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(_class, _base_class)   \
   NS_IMETHODIMP                                                                \
-  NS_CYCLE_COLLECTION_CLASSNAME(_class)::Unlink(nsISupports *s)                \
-  {                                                                            \
+  NS_CYCLE_COLLECTION_CLASSNAME(_class)::Unlink(void *p)                       \
+  {                                                                            \
+    nsISupports *s = NS_STATIC_CAST(nsISupports*, p);                          \
     NS_ASSERTION(CheckForRightISupports(s),                                    \
                  "not the nsISupports pointer we expect");                     \
     _class *tmp = NS_STATIC_CAST(_class*, Downcast(s));                        \
@@ -180,8 +196,9 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsCycleCol
 
 #define NS_IMPL_CYCLE_COLLECTION_UNLINK_0(_class)                              \
   NS_IMETHODIMP                                                                \
-  NS_CYCLE_COLLECTION_CLASSNAME(_class)::Unlink(nsISupports *s)                \
-  {                                                                            \
+  NS_CYCLE_COLLECTION_CLASSNAME(_class)::Unlink(void *p)                       \
+  {                                                                            \
+    nsISupports *s = NS_STATIC_CAST(nsISupports*, p);                          \
     NS_ASSERTION(CheckForRightISupports(s),                                    \
                  "not the nsISupports pointer we expect");                     \
     return NS_OK;                                                              \
@@ -198,9 +215,10 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsCycleCol
 #define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(_class)                        \
   NS_IMETHODIMP                                                                \
   NS_CYCLE_COLLECTION_CLASSNAME(_class)::Traverse                              \
-                         (nsISupports *s,                                      \
+                         (void *p,                                             \
                           nsCycleCollectionTraversalCallback &cb)              \
   {                                                                            \
+    nsISupports *s = NS_STATIC_CAST(nsISupports*, p);                          \
     NS_ASSERTION(CheckForRightISupports(s),                                    \
                  "not the nsISupports pointer we expect");                     \
     _class *tmp = Downcast(s);                                                 \
@@ -209,13 +227,23 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsCycleCol
 #define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(_class, _base_class) \
   NS_IMETHODIMP                                                                \
   NS_CYCLE_COLLECTION_CLASSNAME(_class)::Traverse                              \
-                         (nsISupports *s,                                      \
+                         (void *p,                                             \
                           nsCycleCollectionTraversalCallback &cb)              \
   {                                                                            \
+    nsISupports *s = NS_STATIC_CAST(nsISupports*, p);                          \
     NS_ASSERTION(CheckForRightISupports(s),                                    \
                  "not the nsISupports pointer we expect");                     \
     _class *tmp = NS_STATIC_CAST(_class*, Downcast(s));                        \
     NS_CYCLE_COLLECTION_CLASSNAME(_base_class)::Traverse(s, cb);
+
+#define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(_class)                 \
+  NS_IMETHODIMP                                                                \
+  NS_CYCLE_COLLECTION_CLASSNAME(_class)::Traverse                              \
+                         (void *s,                                             \
+                          nsCycleCollectionTraversalCallback &cb)              \
+  {                                                                            \
+    _class *tmp = NS_STATIC_CAST(_class*, s);                                  \
+    NS_IMPL_CYCLE_COLLECTION_DESCRIBE(_class)
 
 #define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(_field)                       \
     if (tmp->_field) { cb.NoteXPCOMChild(tmp->_field); }
@@ -236,6 +264,15 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsCycleCol
        if (tmp->_field[i])                                                     \
          cb.NoteXPCOMChild(tmp->_field[i]);                                    \
     }
+#define NS_CYCLE_COLLECTION_NATIVE_NAME(_class) \
+  _class::NS_CYCLE_COLLECTION_NAME(_class)
+#define NS_CYCLE_COLLECTION_NATIVE_CLASS_HELPER(_class) \
+  &NS_CYCLE_COLLECTION_NATIVE_NAME(_class)
+
+#define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_POINTER(_field, _field_class) \
+  {                                                                            \
+    if (tmp->_field) cb.NoteNativeChild(tmp->_field, NS_CYCLE_COLLECTION_NATIVE_CLASS_HELPER(_field_class));       \
+  }
 
 #define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END                                  \
     return NS_OK;                                                              \
@@ -244,14 +281,24 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsCycleCol
 ///////////////////////////////////////////////////////////////////////////////
 // Helpers for implementing a concrete nsCycleCollectionParticipant 
 ///////////////////////////////////////////////////////////////////////////////
+
+#define NS_DECL_SIMPLE_CYCLE_COLLECTION_CLASS(_class)                          \
+class NS_CYCLE_COLLECTION_INNERCLASS                                           \
+ : public nsCycleCollectionParticipant                                         \
+{                                                                              \
+public:                                                                        \
+  NS_IMETHOD Unlink(void *n);                                                  \
+  NS_IMETHOD Traverse(void *n,                                                 \
+                      nsCycleCollectionTraversalCallback &cb);                 \
+};                                                           
 
 #define NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(_class, _base)                \
 class NS_CYCLE_COLLECTION_INNERCLASS                                           \
  : public nsCycleCollectionParticipant                                         \
 {                                                                              \
 public:                                                                        \
-  NS_IMETHOD Unlink(nsISupports *n);                                           \
-  NS_IMETHOD Traverse(nsISupports *n,                                          \
+  NS_IMETHOD Unlink(void *n);                                                  \
+  NS_IMETHOD Traverse(void *n,                                                 \
                       nsCycleCollectionTraversalCallback &cb);                 \
   static _class* Downcast(nsISupports* s)                                      \
   {                                                                            \
@@ -272,7 +319,7 @@ class NS_CYCLE_COLLECTION_INNERCLASS    
  : public NS_CYCLE_COLLECTION_CLASSNAME(_base_class)                           \
 {                                                                              \
 public:                                                                        \
-  NS_IMETHOD Traverse(nsISupports *n,                                          \
+  NS_IMETHOD Traverse(void *n,                                                 \
                       nsCycleCollectionTraversalCallback &cb);                 \
   static _class* Downcast(nsISupports* s)                                      \
   {                                                                            \
@@ -285,6 +332,21 @@ public:                                 
   static NS_CYCLE_COLLECTION_CLASSNAME(_class)                                 \
     NS_CYCLE_COLLECTION_NAME(_class);
 
+#define NATIVE_LANG (nsIProgrammingLanguage::MAX + 1)
+
+#define NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(_class)                          \
+  NS_DECL_SIMPLE_CYCLE_COLLECTION_CLASS(_class)                                \
+  static nsCycleCollectionHelper NS_CYCLE_COLLECTION_NAME(_class);
+
+#define NS_CYCLE_COLLECTION_HELPER_NAME(_class) \
+  _class##_cycleCollectorGlobalHelper
+#define NS_IMPL_CYCLE_COLLECTION_NATIVE_CLASS(_class)                          \
+  static NS_CYCLE_COLLECTION_CLASSNAME(_class)                                 \
+    NS_CYCLE_COLLECTION_HELPER_NAME(_class);                                   \
+  nsCycleCollectionHelper                                                      \
+    NS_CYCLE_COLLECTION_NATIVE_NAME(_class) =                                  \
+      {NATIVE_LANG,&NS_CYCLE_COLLECTION_HELPER_NAME(_class)};
+
 #define NS_IMPL_CYCLE_COLLECTION_0(_class)                                     \
  NS_IMPL_CYCLE_COLLECTION_CLASS(_class)                                        \
  NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(_class)                                 \
diff -r a3c13f50f124 xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp	Thu Mar 01 18:00:51 2007 -0800
+++ b/xpcom/base/nsCycleCollector.cpp	Fri Mar 02 15:03:19 2007 -0800
@@ -152,6 +152,7 @@ struct nsCycleCollectorParams
     PRBool mReportStats;
     PRBool mHookMalloc;
     PRBool mDrawGraphs;
+    PRBool mAlwaysDraw;
     PRBool mFaultIsFatal;
     PRBool mLogPointers;
     
@@ -162,6 +163,7 @@ struct nsCycleCollectorParams
         mReportStats   (PR_GetEnv("XPCOM_CC_REPORT_STATS") != NULL),
         mHookMalloc    (PR_GetEnv("XPCOM_CC_HOOK_MALLOC") != NULL),
         mDrawGraphs    (PR_GetEnv("XPCOM_CC_DRAW_GRAPHS") != NULL),
+        mAlwaysDraw    (PR_GetEnv("XPCOM_CC_ALWAYS_DRAW") != NULL),
         mFaultIsFatal  (PR_GetEnv("XPCOM_CC_FAULT_IS_FATAL") != NULL),
         mLogPointers   (PR_GetEnv("XPCOM_CC_LOG_POINTERS") != NULL),
 
@@ -263,7 +265,7 @@ struct PtrInfo
 struct PtrInfo
 {
     NodeColor mColor;
-    PRUint32 mLang;
+    nsCycleCollectionHelper *mHelper;
     size_t mInternalRefs;
     size_t mRefCount;
     size_t mBytes;
@@ -271,7 +273,7 @@ struct PtrInfo
 
     PtrInfo() 
         : mColor(black),
-          mLang(nsIProgrammingLanguage::CPLUSPLUS),
+          mHelper(nsnull),
           mInternalRefs(0), 
           mRefCount(0),
           mBytes(0), 
@@ -280,7 +282,7 @@ struct PtrInfo
     
     PtrInfo(PRUint32 gen, NodeColor col) 
         : mColor(col),
-          mLang(nsIProgrammingLanguage::CPLUSPLUS),
+          mHelper(nsnull),
           mInternalRefs(0), 
           mRefCount(0),
           mBytes(0), 
@@ -460,7 +462,8 @@ struct nsCycleCollector
     PRBool mScanInProgress;
 
     GCTable mGraph;
-    nsCycleCollectionLanguageRuntime *mRuntimes[nsIProgrammingLanguage::MAX+1];
+    nsCycleCollectionLanguageRuntime *mRuntimes[NATIVE_LANG+1];
+    nsCycleCollectionHelper mHelpers[NATIVE_LANG+1];
 
     // The set of buffers |mBufs| serves a variety of purposes; mostly
     // involving the transfer of pointers from a hashtable iterator
@@ -469,7 +472,7 @@ struct nsCycleCollector
     // set-of-all-pointers); in other contexts, one buffer is used
     // per-language (as a set-of-pointers-in-language-N).
 
-    nsDeque *mBufs[nsIProgrammingLanguage::MAX+1];
+    nsDeque *mBufs[NATIVE_LANG+1];
     
     nsCycleCollectorParams mParams;
     nsCycleCollectorStats mStats;    
@@ -510,15 +513,18 @@ protected:
 protected:
     GCTable &mGraph;
     nsCycleCollectionLanguageRuntime **mRuntimes;
+    nsCycleCollectionHelper *mHelpers;
 
 public:
     
     GraphWalker(GCTable & tab,
-                nsCycleCollectionLanguageRuntime **runtimes) : 
+                nsCycleCollectionLanguageRuntime **runtimes,
+                nsCycleCollectionHelper *helpers) : 
         mQueue(nsnull),
         mCurrPtr(nsnull),
         mGraph(tab),
-        mRuntimes(runtimes)
+        mRuntimes(runtimes),
+        mHelpers(helpers)
     {}
 
     virtual ~GraphWalker() 
@@ -530,6 +536,8 @@ public:
     void DescribeNode(size_t refCount, size_t objSz, const char *objName);
     void NoteXPCOMChild(nsISupports *child);
     void NoteScriptChild(PRUint32 langID, void *child);
+    void NoteNativeChild(void *child,
+                         nsCycleCollectionHelper *helper);
 
     // Provided by concrete walker subtypes.
     virtual PRBool ShouldVisitNode(void *p, PtrInfo const & pi) = 0;
@@ -563,6 +571,8 @@ struct safetyCallback :
     void DescribeNode(size_t refCount, size_t objSz, const char *objName) {}
     void NoteXPCOMChild(nsISupports *child) {}
     void NoteScriptChild(PRUint32 langID, void *child) {}
+    void NoteNativeChild(void *child,
+                         nsCycleCollectionHelper *helper) {}
 };
 
 static safetyCallback sSafetyCallback;
@@ -619,7 +629,7 @@ GraphWalker::DescribeNode(size_t refCoun
     mCurrPi.mName = objName;
     this->VisitNode(mCurrPtr, mCurrPi, refCount);
     sCollector.mStats.mVisitedNode++;
-    if (mCurrPi.mLang == nsIProgrammingLanguage::JAVASCRIPT)
+    if (mCurrPi.mHelper->mLang == nsIProgrammingLanguage::JAVASCRIPT)
         sCollector.mStats.mVisitedJSNode++;
 }
 
@@ -645,11 +655,29 @@ GraphWalker::NoteXPCOMChild(nsISupports 
     if (nsCycleCollector_isScanSafe(child) && 
         !nsCycleCollector_shouldSuppress(child)) {
         PtrInfo childPi;
+        childPi.mHelper = &mHelpers[nsIProgrammingLanguage::CPLUSPLUS];
         EnsurePtrInfo(mGraph, child, childPi);
         this->NoteChild(child, childPi);
-        mRuntimes[nsIProgrammingLanguage::CPLUSPLUS]->Traverse(child, sSafetyCallback);
+        NS_ASSERTION(!childPi.mHelper->mParticipantHelper,
+                     "Need to pass the helper to Traverse!");
+        mRuntimes[nsIProgrammingLanguage::CPLUSPLUS]->Traverse(child, nsnull, sSafetyCallback);
         mQueue.Push(child);
     }
+}
+
+
+void
+GraphWalker::NoteNativeChild(void *child, nsCycleCollectionHelper *helper)
+{
+    if (!child)
+        Fault("null native pointer returned"); 
+   
+    PtrInfo childPi;
+    childPi.mHelper = helper;
+    EnsurePtrInfo(mGraph, child, childPi);
+    this->NoteChild(child, childPi);
+    mRuntimes[NATIVE_LANG]->Traverse(child, childPi.mHelper->mParticipantHelper, sSafetyCallback);
+    mQueue.Push(child);
 }
 
 
@@ -663,10 +691,12 @@ GraphWalker::NoteScriptChild(PRUint32 la
         Fault("traversing pointer for unregistered language", child);
 
     PtrInfo childPi;
-    childPi.mLang = langID;
+    childPi.mHelper = &mHelpers[langID];
     EnsurePtrInfo(mGraph, child, childPi);
     this->NoteChild(child, childPi);
-    mRuntimes[langID]->Traverse(child, sSafetyCallback);
+    NS_ASSERTION(!childPi.mHelper->mParticipantHelper,
+                 "Need to pass the helper to Traverse!");
+    mRuntimes[langID]->Traverse(child, nsnull, sSafetyCallback);
     mQueue.Push(child);
 }
 
@@ -687,19 +717,19 @@ GraphWalker::Walk(void *s0)
             continue;
         }
 
-        if (mCurrPi.mLang >nsIProgrammingLanguage::MAX ) {
+        if (mCurrPi.mHelper->mLang > NATIVE_LANG) {
             Fault("unknown language during walk");
             continue;
         }
 
-        if (!mRuntimes[mCurrPi.mLang]) {
+        if (!mRuntimes[mCurrPi.mHelper->mLang]) {
             Fault("script pointer for unregistered language");
             continue;
         }
         
         if (this->ShouldVisitNode(mCurrPtr, mCurrPi)) {
 
-            rv = mRuntimes[mCurrPi.mLang]->Traverse(mCurrPtr, *this);
+            rv = mRuntimes[mCurrPi.mHelper->mLang]->Traverse(mCurrPtr, mCurrPi.mHelper->mParticipantHelper, *this);
             if (NS_FAILED(rv)) {
                 Fault("script pointer traversal failed", mCurrPtr);
             }
@@ -717,8 +747,9 @@ struct MarkGreyWalker : public GraphWalk
 struct MarkGreyWalker : public GraphWalker
 {
     MarkGreyWalker(GCTable &tab,
-                   nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes) 
+                   nsCycleCollectionLanguageRuntime **runtimes,
+                   nsCycleCollectionHelper *helpers)
+        : GraphWalker(tab, runtimes, helpers) 
     {}
 
     PRBool ShouldVisitNode(void *p, PtrInfo const & pi)  
@@ -754,10 +785,11 @@ nsCycleCollector::MarkRoots()
     int i;
     for (i = 0; i < mBufs[0]->GetSize(); ++i) {
         PtrInfo pi;
+        pi.mHelper = &mHelpers[nsIProgrammingLanguage::CPLUSPLUS];
         nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0]->ObjectAt(i));
         s = canonicalize(s);
         EnsurePtrInfo(mGraph, s, pi);
-        MarkGreyWalker(mGraph, mRuntimes).Walk(s);
+        MarkGreyWalker(mGraph, mRuntimes, mHelpers).Walk(s);
     }
 }
 
@@ -770,8 +802,9 @@ struct ScanBlackWalker : public GraphWal
 struct ScanBlackWalker : public GraphWalker
 {
     ScanBlackWalker(GCTable &tab,
-                   nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes) 
+                   nsCycleCollectionLanguageRuntime **runtimes,
+                   nsCycleCollectionHelper *helpers)
+        : GraphWalker(tab, runtimes, helpers) 
     {}
 
     PRBool ShouldVisitNode(void *p, PtrInfo const & pi) 
@@ -793,8 +826,9 @@ struct scanWalker : public GraphWalker
 struct scanWalker : public GraphWalker
 {
     scanWalker(GCTable &tab,
-               nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes) 
+               nsCycleCollectionLanguageRuntime **runtimes,
+               nsCycleCollectionHelper *helpers)
+        : GraphWalker(tab, runtimes, helpers) 
     {}
 
     PRBool ShouldVisitNode(void *p, PtrInfo const & pi) 
@@ -814,7 +848,7 @@ struct scanWalker : public GraphWalker
             pi.mColor = white;
             sCollector.mStats.mSetColorWhite++;
         } else {
-            ScanBlackWalker(mGraph, mRuntimes).Walk(p);
+            ScanBlackWalker(mGraph, mRuntimes, mHelpers).Walk(p);
             pi.mColor = black;
             sCollector.mStats.mSetColorBlack++;
         }
@@ -843,7 +877,7 @@ nsCycleCollector::ScanRoots()
     for (i = 0; i < mBufs[0]->GetSize(); ++i) {
         nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0]->ObjectAt(i));
         s = canonicalize(s);
-        scanWalker(mGraph, mRuntimes).Walk(s); 
+        scanWalker(mGraph, mRuntimes, mHelpers).Walk(s);
     }
 
     // Sanity check: scan should have colored all grey nodes black or
@@ -867,10 +901,10 @@ FindWhiteCallback(const void*  ptr,
     if (pinfo.mColor == white) {
         nsISupports *s = NS_STATIC_CAST(nsISupports *, 
                                         NS_CONST_CAST(void*, ptr));
-        if (pinfo.mLang  > nsIProgrammingLanguage::MAX)
+        if (pinfo.mHelper->mLang > NATIVE_LANG)
             Fault("White node has bad language ID", s);
         else
-            collector->mBufs[pinfo.mLang]->Push(s);
+            collector->mBufs[pinfo.mHelper->mLang]->Push(s);
     }
     return PL_DHASH_NEXT;
 }
@@ -896,7 +930,7 @@ nsCycleCollector::CollectWhite()
     PRUint32 i;
     nsresult rv;
 
-    for (i = 0; i < nsIProgrammingLanguage::MAX+1; ++i)
+    for (i = 0; i < NATIVE_LANG + 1; ++i)
         mBufs[i]->Empty();
 
 #ifndef __MINGW32__
@@ -908,7 +942,7 @@ nsCycleCollector::CollectWhite()
 
     mGraph.Enumerate(FindWhiteCallback, this);
 
-    for (i = 0; i < nsIProgrammingLanguage::MAX+1; ++i) {
+    for (i = 0; i < NATIVE_LANG + 1; ++i) {
         if (mRuntimes[i] &&
             mBufs[i]->GetSize() > 0) {
             rv = mRuntimes[i]->Root(*mBufs[i]);
@@ -917,7 +951,7 @@ nsCycleCollector::CollectWhite()
         }
     }
 
-    for (i = 0; i < nsIProgrammingLanguage::MAX+1; ++i) {
+    for (i = 0; i < NATIVE_LANG + 1; ++i) {
         if (mRuntimes[i] &&
             mBufs[i]->GetSize() > 0) {
             rv = mRuntimes[i]->Unlink(*mBufs[i]);
@@ -930,7 +964,7 @@ nsCycleCollector::CollectWhite()
         }
     }
 
-    for (i = 0; i < nsIProgrammingLanguage::MAX+1; ++i) {
+    for (i = 0; i < NATIVE_LANG + 1; ++i) {
         if (mRuntimes[i] &&
             mBufs[i]->GetSize() > 0) {
             rv = mRuntimes[i]->Unroot(*mBufs[i]);
@@ -939,7 +973,7 @@ nsCycleCollector::CollectWhite()
         }
     }
 
-    for (i = 0; i < nsIProgrammingLanguage::MAX+1; ++i)
+    for (i = 0; i < NATIVE_LANG + 1; ++i)
         mBufs[i]->Empty();
 
 #ifndef __MINGW32__
@@ -965,7 +999,8 @@ struct nsCycleCollectionXPCOMRuntime :
         return NS_OK;
     }
 
-    nsresult Traverse(void *p, nsCycleCollectionTraversalCallback &cb) 
+    nsresult Traverse(void *p, void *helper,
+                      nsCycleCollectionTraversalCallback &cb) 
     {
         nsresult rv;
 
@@ -1044,6 +1079,50 @@ struct nsCycleCollectionXPCOMRuntime :
     }
 };
 
+struct nsCycleCollectionNativeRuntime : 
+    public nsCycleCollectionLanguageRuntime 
+{
+    nsresult BeginCycleCollection() 
+    {
+        return NS_OK;
+    }
+
+    nsresult Traverse(void *p, void *helper,
+                      nsCycleCollectionTraversalCallback &cb) 
+    {
+        nsCycleCollectionParticipant *cp =
+            NS_STATIC_CAST(nsCycleCollectionParticipant*, helper);
+        nsresult rv = cp->Traverse(p, cb);
+        if (NS_FAILED(rv)) {
+            Fault("Native pointer traversal failed", p);
+            return NS_ERROR_FAILURE;
+        }
+        return NS_OK;
+    }
+
+    nsresult Root(const nsDeque &nodes)
+    {
+        NS_ERROR("Can't root!");
+        return NS_OK;
+    }
+
+    nsresult Unlink(const nsDeque &nodes)
+    {
+        // XXX Currently do nothing.
+        return NS_OK;
+    }
+
+    nsresult Unroot(const nsDeque &nodes)
+    {
+        NS_ERROR("Can't unroot!");
+        return NS_OK;
+    }
+
+    nsresult FinishCycleCollection() 
+    {
+        return NS_OK;
+    }
+};
 
 ////////////////////////////////////////////////////////////////////////
 // Extra book-keeping functions.
@@ -1086,8 +1165,9 @@ struct graphVizWalker : public GraphWalk
     FILE *mStream;
 
     graphVizWalker(GCTable &tab,
-                   nsCycleCollectionLanguageRuntime **runtimes)
-        : GraphWalker(tab, runtimes), 
+                   nsCycleCollectionLanguageRuntime **runtimes,
+                   nsCycleCollectionHelper *helpers)
+        : GraphWalker(tab, runtimes, helpers), 
           mParent(nsnull), 
           mStream(nsnull)        
     {
@@ -1313,7 +1393,7 @@ static void InitMemHook(void)
 }
 #endif // __MINGW32__
 
-#elif 0 // defined(XP_MACOSX)
+#elif defined(XP_MACOSX)
 
 #include <malloc/malloc.h>
 
@@ -1363,13 +1443,17 @@ nsCycleCollector::nsCycleCollector() :
 {
     mGraph.Init();
 
-    for (PRUint32 i = 0; i <= nsIProgrammingLanguage::MAX; ++i) {
+    for (PRUint32 i = 0; i < NATIVE_LANG + 1; ++i) {
         mRuntimes[i] = nsnull;
+        mHelpers[i].mLang = i;
+        mHelpers[i].mParticipantHelper = nsnull;
         mBufs[i] = new nsDeque(nsnull);
     }
 
     mRuntimes[nsIProgrammingLanguage::CPLUSPLUS] 
         = new nsCycleCollectionXPCOMRuntime();
+    mRuntimes[NATIVE_LANG] 
+        = new nsCycleCollectionNativeRuntime();
 
     sCollectorConstructed = 1;
 }
@@ -1381,7 +1465,7 @@ nsCycleCollector::~nsCycleCollector()
 
     mGraph.Clear();    
 
-    for (PRUint32 i = 0; i < nsIProgrammingLanguage::MAX+1; ++i) {
+    for (PRUint32 i = 0; i < NATIVE_LANG + 1; ++i) {
         delete mBufs[i];
         mBufs[i] = NULL;
     }
@@ -1389,7 +1473,7 @@ nsCycleCollector::~nsCycleCollector()
     delete mRuntimes[nsIProgrammingLanguage::CPLUSPLUS];
     mRuntimes[nsIProgrammingLanguage::CPLUSPLUS] = NULL;
 
-    for (PRUint32 i = 0; i < nsIProgrammingLanguage::MAX+1; ++i) {
+    for (PRUint32 i = 0; i < NATIVE_LANG + 1; ++i) {
         mRuntimes[i] = NULL;
     }
 }
@@ -1439,7 +1523,7 @@ nsCycleCollector::MaybeDrawGraphs()
         while (mBufs[0]->GetSize() > 0)
             roots.Push(mBufs[0]->Pop());
 
-        for (i = 0; i < nsIProgrammingLanguage::MAX+1; ++i)
+        for (i = 0; i < NATIVE_LANG + 1; ++i)
             mBufs[i]->Empty();
 
         mGraph.Enumerate(FindWhiteCallback, this);
@@ -1447,15 +1531,15 @@ nsCycleCollector::MaybeDrawGraphs()
         // We draw graphs only if there were any white nodes.
         PRBool anyWhites = PR_FALSE;
 
-        for (i = 0; i < nsIProgrammingLanguage::MAX+1; ++i) {
+        for (i = 0; i < NATIVE_LANG + 1; ++i) {
             if (mBufs[i]->GetSize() > 0) {
                 anyWhites = PR_TRUE;
                 break;
             }
         }
 
-        if (anyWhites) {
-            graphVizWalker gw(mGraph, mRuntimes);
+        if (anyWhites || mParams.mAlwaysDraw) {
+            graphVizWalker gw(mGraph, mRuntimes, mHelpers);
             while (roots.GetSize() > 0) {
                 nsISupports *s = NS_STATIC_CAST(nsISupports *, roots.Pop());
                 s = canonicalize(s);
@@ -1463,7 +1547,7 @@ nsCycleCollector::MaybeDrawGraphs()
             }
         }
 
-        for (i = 0; i < nsIProgrammingLanguage::MAX+1; ++i)
+        for (i = 0; i < NATIVE_LANG + 1; ++i)
             mBufs[i]->Empty();
     }
 }
@@ -1507,6 +1591,7 @@ public:
 
     void NoteXPCOMChild(nsISupports *child) {}
     void NoteScriptChild(PRUint32 langID, void *child) {}
+    void NoteNativeChild(void *child, nsCycleCollectionHelper *desc) {}
 };
 
 char *Suppressor::sSuppressionList = nsnull;
@@ -1623,7 +1708,7 @@ nsCycleCollector::Collect()
     // GC calls -- so it's essential that we actually execute this
     // step!
     
-    for (PRUint32 i = 0; i <= nsIProgrammingLanguage::MAX; ++i) {
+    for (PRUint32 i = 0; i <= NATIVE_LANG; ++i) {
         if (mRuntimes[i])
             mRuntimes[i]->BeginCycleCollection();
     }
@@ -1674,7 +1759,7 @@ nsCycleCollector::Collect()
         }
     }
 
-    for (PRUint32 i = 0; i <= nsIProgrammingLanguage::MAX; ++i) {
+    for (PRUint32 i = 0; i < NATIVE_LANG + 1; ++i) {
         if (mRuntimes[i])
             mRuntimes[i]->FinishCycleCollection();
     }    
diff -r a3c13f50f124 xpcom/base/nsCycleCollector.h
--- a/xpcom/base/nsCycleCollector.h	Thu Mar 01 18:00:51 2007 -0800
+++ b/xpcom/base/nsCycleCollector.h	Fri Mar 02 14:52:47 2007 -0800
@@ -49,7 +49,8 @@ struct nsCycleCollectionLanguageRuntime
 {
     virtual nsresult BeginCycleCollection() = 0;
 
-    virtual nsresult Traverse(void *p, nsCycleCollectionTraversalCallback &cb) = 0;
+    virtual nsresult Traverse(void *p, void *helper,
+                              nsCycleCollectionTraversalCallback &cb) = 0;
 
     virtual nsresult Root(const nsDeque &nodes) = 0;
     virtual nsresult Unlink(const nsDeque &nodes) = 0;
diff -r a3c13f50f124 xpcom/glue/nsISupportsImpl.h
--- a/xpcom/glue/nsISupportsImpl.h	Thu Mar 01 18:00:51 2007 -0800
+++ b/xpcom/glue/nsISupportsImpl.h	Fri Mar 02 14:52:47 2007 -0800
@@ -358,7 +358,7 @@ NS_IMETHODIMP_(nsrefcnt) _class::Release
 {                                                                             \
   NS_PRECONDITION(0 != mRefCnt, "dup release");                               \
   NS_ASSERT_OWNINGTHREAD(_class);                                             \
-  mRefCnt.decr(NS_STATIC_CAST(_basetype *, this));		              \
+  mRefCnt.decr(NS_STATIC_CAST(_basetype *, this));		                        \
   NS_LOG_RELEASE(this, mRefCnt, #_class);                                     \
   if (mRefCnt == 0) {                                                         \
     mRefCnt.stabilizeForDeletion(NS_STATIC_CAST(_basetype *, this));          \
