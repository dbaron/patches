From: L. David Baron <dbaron@dbaron.org>

Ensure that 'load' and 'script' tests do layout and painting before we go on to the next test.  (Bug 624279)

(It's tempting to remove both the direct call to RecordResult() (and
instead always go through WaitForTestEnd) and the setupPrintMode() call
not inside WaitForTestEnd, but that's probably more than I should tackle
right now.)

diff --git a/layout/generic/crashtests/crashtests.list b/layout/generic/crashtests/crashtests.list
--- a/layout/generic/crashtests/crashtests.list
+++ b/layout/generic/crashtests/crashtests.list
@@ -340,14 +340,14 @@ load 586806-2.html
 load 586806-3.html
 load 586973-1.html
 load 589002-1.html
 load 590404.html
 load 591141.html
 asserts(0-1) load 592118.html
 load 594808-1.html
 asserts(4) load 595435-1.xhtml # bug 610331
-!= 595740-1.html about:blank # != rather than load to work around bug 624279
+load 595740-1.html
 load 603490-1.html
 load 603510-1.html
 load 604314-1.html
 load 604843.html
 load 605340.html
diff --git a/layout/tools/reftest/reftest.js b/layout/tools/reftest/reftest.js
--- a/layout/tools/reftest/reftest.js
+++ b/layout/tools/reftest/reftest.js
@@ -961,17 +961,17 @@ const STATE_WAITING_TO_FIRE_INVALIDATE_E
 // When reftest-wait has been removed from the root element, we can move to the
 // next state.
 const STATE_WAITING_FOR_REFTEST_WAIT_REMOVAL = 1;
 // When all MozAfterPaint events and all explicit paint waits are flushed, we're
 // done and can move to the COMPLETED state.
 const STATE_WAITING_TO_FINISH = 2;
 const STATE_COMPLETED = 3;
 
-function WaitForTestEnd(contentRootElement) {
+function WaitForTestEnd(contentRootElement, inPrintMode) {
     var stopAfterPaintReceived = false;
     var state = STATE_WAITING_TO_FIRE_INVALIDATE_EVENT;
 
     function FlushRendering() {
         var anyPendingPaintsGeneratedInDescendants = false;
 
         function flushWindow(win) {
             var utils = win.QueryInterface(CI.nsIInterfaceRequestor)
@@ -1071,19 +1071,21 @@ function WaitForTestEnd(contentRootEleme
                     LogInfo("MakeProgress: waiting for MozAfterPaint");
                 }
                 return;
             }
 
             state = STATE_WAITING_FOR_REFTEST_WAIT_REMOVAL;
             var hasReftestWait = shouldWaitForReftestWaitRemoval(contentRootElement);            
             // Notify the test document that now is a good time to test some invalidation
-            var notification = document.createEvent("Events");
-            notification.initEvent("MozReftestInvalidate", true, false);
-            contentRootElement.dispatchEvent(notification);
+            if (contentRootElement) {
+                var notification = document.createEvent("Events");
+                notification.initEvent("MozReftestInvalidate", true, false);
+                contentRootElement.dispatchEvent(notification);
+            }
             if (hasReftestWait && !shouldWaitForReftestWaitRemoval(contentRootElement)) {
                 // MozReftestInvalidate handler removed reftest-wait.
                 // We expect something to have been invalidated...
                 FlushRendering();
                 if (!shouldWaitForPendingPaints() && !shouldWaitForExplicitPaintWaiters()) {
                     LogWarning("MozInvalidateEvent didn't invalidate");
                 }
             }
@@ -1095,20 +1097,19 @@ function WaitForTestEnd(contentRootEleme
         case STATE_WAITING_FOR_REFTEST_WAIT_REMOVAL:
             LogInfo("MakeProgress: STATE_WAITING_FOR_REFTEST_WAIT_REMOVAL");
             if (shouldWaitForReftestWaitRemoval(contentRootElement)) {
                 gFailureReason = "timed out waiting for reftest-wait to be removed";
                 LogInfo("MakeProgress: waiting for reftest-wait to be removed");
                 return;
             }
             state = STATE_WAITING_TO_FINISH;
-            if (doPrintMode(contentRootElement)) {
+            if (!inPrintMode && doPrintMode(contentRootElement)) {
                 LogInfo("MakeProgress: setting up print mode");
                 setupPrintMode();
-                didPrintMode = true;
             }
             // Try next state
             MakeProgress();
             return;
 
         case STATE_WAITING_TO_FINISH:
             LogInfo("MakeProgress: STATE_WAITING_TO_FINISH");
             if (shouldWaitForExplicitPaintWaiters() || shouldWaitForPendingPaints()) {
@@ -1173,35 +1174,39 @@ function OnDocumentLoad(event)
     setupZoom(contentRootElement);
     var inPrintMode = false;
 
     function AfterOnLoadScripts() {
         // Take a snapshot now. We need to do this before we check whether
         // we should wait, since this might trigger dispatching of
         // MozPaintWait events and make shouldWaitForExplicitPaintWaiters() true
         // below.
-        InitCurrentCanvasWithSnapshot();
+        var painted = InitCurrentCanvasWithSnapshot();
 
         if (shouldWaitForExplicitPaintWaiters() ||
-            (!inPrintMode && doPrintMode(contentRootElement))) {
+            (!inPrintMode && doPrintMode(contentRootElement)) ||
+            // If we didn't force a paint above, in
+            // InitCurrentCanvasWithSnapshot, so we should wait for a
+            // paint before we consider them done.
+            !painted) {
             LogInfo("AfterOnLoadScripts belatedly entering WaitForTestEnd");
             // Go into reftest-wait mode belatedly.
-            WaitForTestEnd(contentRootElement);
+            WaitForTestEnd(contentRootElement, inPrintMode);
         } else {
             RecordResult();
         }
     }
 
     if (shouldWaitForReftestWaitRemoval(contentRootElement) ||
         shouldWaitForExplicitPaintWaiters()) {
         // Go into reftest-wait mode immediately after painting has been
         // unsuppressed, after the onload event has finished dispatching.
         gFailureReason = "timed out waiting for test to complete (trying to get into WaitForTestEnd)";
         LogInfo("OnDocumentLoad triggering WaitForTestEnd");
-        setTimeout(WaitForTestEnd, 0, contentRootElement);
+        setTimeout(WaitForTestEnd, 0, contentRootElement, inPrintMode);
     } else {
         if (doPrintMode(contentRootElement)) {
             LogInfo("OnDocumentLoad setting up print mode");
             setupPrintMode();
             inPrintMode = true;
         }
 
         // Since we can't use a bubbling-phase load listener from chrome,
@@ -1270,25 +1275,26 @@ function DoDrawWindow(ctx, x, y, w, h)
     ctx.drawWindow(window, x, y, w, h, "rgb(255,255,255)",
                    gDrawWindowFlags);
 }
 
 function InitCurrentCanvasWithSnapshot()
 {
     if (gURLs[0].type == TYPE_LOAD || gURLs[0].type == TYPE_SCRIPT) {
         // We don't want to snapshot this kind of test
-        return;
+        return false;
     }
 
     if (!gCurrentCanvas) {
         gCurrentCanvas = AllocateCanvas();
     }
 
     var ctx = gCurrentCanvas.getContext("2d");
     DoDrawWindow(ctx, 0, 0, gCurrentCanvas.width, gCurrentCanvas.height);
+    return true;
 }
 
 function roundTo(x, fraction)
 {
     return Math.round(x/fraction)*fraction;
 }
 
 function UpdateCurrentCanvasForEvent(event)
