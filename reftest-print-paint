From: L. David Baron <dbaron@dbaron.org>

Ensure that 'load' tests do layout and painting before we go on to the next test.  (Bug 624279)

(It's tempting to remove both the direct call to RecordResult() (and
instead always go through WaitForTestEnd) and the setupPrintMode() call
not inside WaitForTestEnd, but that's probably more than I should tackle
right now.)

diff --git a/layout/tools/reftest/reftest.js b/layout/tools/reftest/reftest.js
--- a/layout/tools/reftest/reftest.js
+++ b/layout/tools/reftest/reftest.js
@@ -961,17 +961,17 @@ const STATE_WAITING_TO_FIRE_INVALIDATE_E
 // When reftest-wait has been removed from the root element, we can move to the
 // next state.
 const STATE_WAITING_FOR_REFTEST_WAIT_REMOVAL = 1;
 // When all MozAfterPaint events and all explicit paint waits are flushed, we're
 // done and can move to the COMPLETED state.
 const STATE_WAITING_TO_FINISH = 2;
 const STATE_COMPLETED = 3;
 
-function WaitForTestEnd(contentRootElement) {
+function WaitForTestEnd(contentRootElement, inPrintMode) {
     var stopAfterPaintReceived = false;
     var state = STATE_WAITING_TO_FIRE_INVALIDATE_EVENT;
 
     function FlushRendering() {
         var anyPendingPaintsGeneratedInDescendants = false;
 
         function flushWindow(win) {
             var utils = win.QueryInterface(CI.nsIInterfaceRequestor)
@@ -1095,20 +1095,19 @@ function WaitForTestEnd(contentRootEleme
         case STATE_WAITING_FOR_REFTEST_WAIT_REMOVAL:
             LogInfo("MakeProgress: STATE_WAITING_FOR_REFTEST_WAIT_REMOVAL");
             if (shouldWaitForReftestWaitRemoval(contentRootElement)) {
                 gFailureReason = "timed out waiting for reftest-wait to be removed";
                 LogInfo("MakeProgress: waiting for reftest-wait to be removed");
                 return;
             }
             state = STATE_WAITING_TO_FINISH;
-            if (doPrintMode(contentRootElement)) {
+            if (!inPrintMode && doPrintMode(contentRootElement)) {
                 LogInfo("MakeProgress: setting up print mode");
                 setupPrintMode();
-                didPrintMode = true;
             }
             // Try next state
             MakeProgress();
             return;
 
         case STATE_WAITING_TO_FINISH:
             LogInfo("MakeProgress: STATE_WAITING_TO_FINISH");
             if (shouldWaitForExplicitPaintWaiters() || shouldWaitForPendingPaints()) {
@@ -1173,35 +1172,39 @@ function OnDocumentLoad(event)
     setupZoom(contentRootElement);
     var inPrintMode = false;
 
     function AfterOnLoadScripts() {
         // Take a snapshot now. We need to do this before we check whether
         // we should wait, since this might trigger dispatching of
         // MozPaintWait events and make shouldWaitForExplicitPaintWaiters() true
         // below.
-        InitCurrentCanvasWithSnapshot();
+        var painted = InitCurrentCanvasWithSnapshot();
 
         if (shouldWaitForExplicitPaintWaiters() ||
-            (!inPrintMode && doPrintMode(contentRootElement))) {
+            (!inPrintMode && doPrintMode(contentRootElement)) ||
+            // If we didn't force a paint above, in
+            // InitCurrentCanvasWithSnapshot, so we should wait for a
+            // paint before we consider them done.
+            !painted) {
             LogInfo("AfterOnLoadScripts belatedly entering WaitForTestEnd");
             // Go into reftest-wait mode belatedly.
-            WaitForTestEnd(contentRootElement);
+            WaitForTestEnd(contentRootElement, inPrintMode);
         } else {
             RecordResult();
         }
     }
 
     if (shouldWaitForReftestWaitRemoval(contentRootElement) ||
         shouldWaitForExplicitPaintWaiters()) {
         // Go into reftest-wait mode immediately after painting has been
         // unsuppressed, after the onload event has finished dispatching.
         gFailureReason = "timed out waiting for test to complete (trying to get into WaitForTestEnd)";
         LogInfo("OnDocumentLoad triggering WaitForTestEnd");
-        setTimeout(WaitForTestEnd, 0, contentRootElement);
+        setTimeout(WaitForTestEnd, 0, contentRootElement, inPrintMode);
     } else {
         if (doPrintMode(contentRootElement)) {
             LogInfo("OnDocumentLoad setting up print mode");
             setupPrintMode();
             inPrintMode = true;
         }
 
         // Since we can't use a bubbling-phase load listener from chrome,
@@ -1270,25 +1273,26 @@ function DoDrawWindow(ctx, x, y, w, h)
     ctx.drawWindow(window, x, y, w, h, "rgb(255,255,255)",
                    gDrawWindowFlags);
 }
 
 function InitCurrentCanvasWithSnapshot()
 {
     if (gURLs[0].type == TYPE_LOAD || gURLs[0].type == TYPE_SCRIPT) {
         // We don't want to snapshot this kind of test
-        return;
+        return false;
     }
 
     if (!gCurrentCanvas) {
         gCurrentCanvas = AllocateCanvas();
     }
 
     var ctx = gCurrentCanvas.getContext("2d");
     DoDrawWindow(ctx, 0, 0, gCurrentCanvas.width, gCurrentCanvas.height);
+    return true;
 }
 
 function roundTo(x, fraction)
 {
     return Math.round(x/fraction)*fraction;
 }
 
 function UpdateCurrentCanvasForEvent(event)
