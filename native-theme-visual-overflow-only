From: L. David Baron <dbaron@dbaron.org>

Only apply overflow area reported by native theme to the visual overflow, and not to the scrollable overflow.  (Bug 669284)

diff --git a/gfx/src/nsITheme.h b/gfx/src/nsITheme.h
--- a/gfx/src/nsITheme.h
+++ b/gfx/src/nsITheme.h
@@ -125,16 +125,22 @@ public:
 
   /**
    * On entry, *aResult is positioned at 0,0 and sized to the new size
    * of aFrame (aFrame->GetSize() may be stale and should not be used).
    * This method can return PR_FALSE to indicate that no special
    * overflow area is required by the native widget. Otherwise it will
    * fill in aResult with the desired overflow area, in appunits, relative
    * to the frame origin, and return PR_TRUE.
+   *
+   * This overflow area is used to determine what area needs to be
+   * repainted when the widget changes.  However, it does not affect the
+   * widget's size or what area is reachable by scrollbars.  (In other
+   * words, in layout terms, it affects visual overflow but not
+   * scrollable overflow.)
    */
   virtual PRBool GetWidgetOverflow(nsDeviceContext* aContext,
                                    nsIFrame* aFrame,
                                    PRUint8 aWidgetType,
                                    /*INOUT*/ nsRect* aOverflowRect)
   { return PR_FALSE; }
 
   /**
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -6265,20 +6265,18 @@ nsIFrame::FinishAndStoreOverflow(nsOverf
   // Note that NS_STYLE_OVERFLOW_CLIP doesn't clip the frame background,
   // so we add theme background overflow here so it's not clipped.
   if (!IsBoxWrapped() && IsThemed(disp)) {
     nsRect r(bounds);
     nsPresContext *presContext = PresContext();
     if (presContext->GetTheme()->
           GetWidgetOverflow(presContext->DeviceContext(), this,
                             disp->mAppearance, &r)) {
-      NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
-        nsRect& o = aOverflowAreas.Overflow(otype);
-        o.UnionRectEdges(o, r);
-      }
+      nsRect& vo = aOverflowAreas.VisualOverflow();
+      vo.UnionRectEdges(vo, r);
     }
   }
 
   // Nothing in here should affect scrollable overflow.
   PRBool hasOutlineOrEffects;
   aOverflowAreas.VisualOverflow() =
     ComputeOutlineAndEffectsRect(this, &hasOutlineOrEffects,
                                  aOverflowAreas.VisualOverflow(), aNewSize,
