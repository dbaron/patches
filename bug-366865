Subtract allocated parts before repeating division used for allocation to avoid rounding error of total.  b=366865

diff -r d8221286f0ba layout/tables/BasicTableLayoutStrategy.cpp
--- a/layout/tables/BasicTableLayoutStrategy.cpp	Fri Feb 02 20:06:10 2007 -0800
+++ b/layout/tables/BasicTableLayoutStrategy.cpp	Fri Feb 02 20:51:07 2007 -0800
@@ -337,8 +337,8 @@ BasicTableLayoutStrategy::ComputeColumnI
 
             // Before looping over the spanned columns to distribute
             // this cell's width over the columns it spans, we first
-            // compute that loop's invariants, which include totals over
-            // the spanned columns and ratios derived from those totals.
+            // compute totals over the spanned columns so we know how to
+            // allocate the space.
 
             // Accumulate information about the spanned columns, and
             // subtract the already-used space from |info|.
@@ -381,17 +381,6 @@ BasicTableLayoutStrategy::ComputeColumnI
             if (info.prefPercent < 0.0f)
                 info.prefPercent = 0.0f;
 
-            // Compute the ratios used to distribute this cell's width
-            // appropriately among the spanned columns.
-            float pctRatio = 0.0f;
-            if (nonPctCount && info.prefPercent > 0.0f) {
-                if (totalSNonPctPref > 0) {
-                    pctRatio = info.prefPercent / float(totalSNonPctPref);
-                } else {
-                    pctRatio = info.prefPercent / float(nonPctCount);
-                }
-            }
-
             // The min-width of this cell that fits inside the
             // pref-width of the spanned columns gets distributed
             // according to different ratios.
@@ -399,6 +388,10 @@ BasicTableLayoutStrategy::ComputeColumnI
                 PR_MIN(info.minCoord, totalSPref - totalSMin);
             NS_ASSERTION(minWithinPref >= 0, "neither value can be negative");
             info.minCoord -= minWithinPref;
+
+            // Loop invariants
+            const PRBool spanHasNonPctPref = totalSNonPctPref > 0;
+            const PRBool spanHasPref = totalSPref > 0;
 
             // ... and actually do the distribution of the widths of
             // this cell exceeding the totals already in the spanned
@@ -416,11 +409,20 @@ BasicTableLayoutStrategy::ComputeColumnI
                 // the existing pref widths)
                 if (scolFrame->GetPrefPercent() == 0.0f) {
                     float spp;
-                    if (totalSNonPctPref > 0) {
-                        spp = pctRatio * scolFrame->GetPrefCoord();
+                    if (spanHasNonPctPref) {
+                        nscoord scolPref = scolFrame->GetPrefCoord();
+                        if (scolPref == 0) {
+                            // We might have already subtracted all of
+                            // totalSNonPctPref.
+                            spp = 0.0f;
+                        } else {
+                            spp = info.prefPercent *
+                                  float(scolFrame->GetPrefCoord()) /
+                                  float(totalSNonPctPref);
+                        }
                     } else {
                         // distribute equally when all pref widths are 0
-                        spp = pctRatio;
+                        spp = info.prefPercent / float(nonPctCount);
                     }
                     scolFrame->AddSpanPrefPercent(spp);
                 }
@@ -437,9 +439,15 @@ BasicTableLayoutStrategy::ComputeColumnI
                 // the rest of the min width, and the pref width (in
                 // proportion to the existing pref widths)
                 float coordRatio; // for both min and pref
-                if (totalSPref > 0) {
-                    coordRatio = float(scolFrame->GetPrefCoord()) /
-                                 float(totalSPref);
+                if (spanHasPref) {
+                    if (scolFrame->GetPrefCoord() == 0) {
+                        // We might have already subtracted all of
+                        // totalSPref.
+                        coordRatio = 0.0f;
+                    } else {
+                        coordRatio = float(scolFrame->GetPrefCoord()) /
+                                     float(totalSPref);
+                    }
                 } else {
                     // distribute equally when all pref widths are 0
                     coordRatio = 1.0f / float(colSpan);
@@ -447,12 +455,35 @@ BasicTableLayoutStrategy::ComputeColumnI
 
                 // combine the two min-width distributions, and record
                 // min and pref
-                scolFrame->AddSpanMinCoord(NSToCoordRound(
-                               float(info.minCoord) * coordRatio +
-                               float(minWithinPref) * minRatio));
-                scolFrame->AddSpanPrefCoord(NSToCoordRound(
-                               float(info.prefCoord) * coordRatio));
-            }
+                nscoord allocatedMinWithinPref =
+                    NSToCoordRound(float(minWithinPref) * minRatio);
+                nscoord allocatedMinOutsidePref =
+                    NSToCoordRound(float(info.minCoord) * coordRatio);
+                scolFrame->AddSpanMinCoord(allocatedMinWithinPref +
+                                           allocatedMinOutsidePref);
+                nscoord allocatedPref =
+                    NSToCoordRound(float(info.prefCoord) * coordRatio)
+                scolFrame->AddSpanPrefCoord(allocatedPref);
+
+                // To avoid accumulating rounding error from division,
+                // subtract everything to do with the column we've
+                // passed from the totals.
+                minWithinPref -= allocatedMinWithinPref;
+                info.minCoord -= allocatedMinOutsidePref;
+                info.prefCoord -= allocatedPref;
+                totalSPref -= scolFrame->GetPrefCoord();
+                totalSMin -= scolFrame->GetMinCoord();
+                if (scolFrame->GetPrefPercent() == 0.0f) {
+                    totalSNonPctPref -= scolFrame->GetPrefCoord();
+                    --nonPctCount;
+                }
+            }
+
+            NS_ASSERTION(totalSPref == 0 && totalSMin == 0 &&
+                         totalSNonPctPref == 0 && nonPctCount == 0 &&
+                         info.minCoord == 0 && minWithinPref == 0 &&
+                         info.prefCoord == 0 && info.prefPercent == 0.0f,
+                         "didn't subtract all that we added");
         } while ((item = item->next));
 
         // Combine the results of the span analysis into the main results,
@@ -748,46 +779,51 @@ BasicTableLayoutStrategy::ComputeColumnW
     };
 
     Loop2Type l2t;
-    float c; // the constant (over columns) for each case's math
+    // These are constants (over columns) for each case's math.  We use
+    // a pair of nscoords rather than a float so that we can subtract
+    // each column's allocation so we avoid accumulating rounding error.
+    nscoord space, // the amount of extra width to allocate
+            basis; // the sum of the statistic over columns to divide it
     if (width < guess_pref) {
         NS_ASSERTION(width >= guess_min, "bad width");
         if (width < guess_min_pct) {
             l2t = FLEX_PCT_SMALL;
-            c = float(width - guess_min) /
-                float(guess_min_pct - guess_min);
+            space = width - guess_min;
+            basis = guess_min_pct - guess_min;
         } else if (width < guess_min_spec) {
             l2t = FLEX_FIXED_SMALL;
-            c = float(width - guess_min_pct) /
-                float(guess_min_spec - guess_min_pct);
+            space = width - guess_min_pct;
+            basis = guess_min_spec - guess_min_pct;
         } else {
             l2t = FLEX_FLEX_SMALL;
-            c = float(width - guess_min_spec) /
-                float(guess_pref - guess_min_spec);
+            space = width - guess_min_spec;
+            basis = guess_pref - guess_min_spec;
         }
     } else {
+        space = width - guess_pref;
         if (total_flex_pref > 0) {
             l2t = FLEX_FLEX_LARGE;
-            c = float(width - guess_pref) / float(total_flex_pref);
+            basis = total_flex_pref;
         } else if (total_fixed_pref > 0) {
             l2t = FLEX_FIXED_LARGE;
-            c = float(width - guess_pref) / float(total_fixed_pref);
+            basis = total_fixed_pref;
         } else if (total_pct > 0.0f) {
             l2t = FLEX_PCT_LARGE;
-            c = float(width - guess_pref) / float(total_pct);
+            basis = total_pct;
         } else {
             l2t = FLEX_ALL_LARGE;
-            c = 1.0f / float(colCount);
+            basis = colCount;
         }
     }
 
 #ifdef DEBUG_dbaron_off
     printf("ComputeColumnWidths: %d columns in width %d,\n"
            "  guesses=[%d,%d,%d,%d], totals=[%d,%d,%f],\n"
-           "  l2t=%d, c=%f\n",
+           "  l2t=%d, space=%d, basis=%d\n",
            colCount, width,
            guess_min, guess_min_pct, guess_min_spec, guess_pref,
            total_flex_pref, total_fixed_pref, total_pct,
-           l2t, c);
+           l2t, space, basis);
 #endif
 
     for (col = 0; col < colCount; ++col) {
@@ -808,6 +844,7 @@ BasicTableLayoutStrategy::ComputeColumnW
             col_width = colFrame->GetPrefCoord();
         }
 
+        float c = float(space) / float(basis);
         switch (l2t) {
             case FLEX_PCT_SMALL:
                 col_width = colFrame->GetMinCoord();
@@ -865,7 +902,7 @@ BasicTableLayoutStrategy::ComputeColumnW
                 col_width += NSToCoordRound(pct * c);
                 break;
             case FLEX_ALL_LARGE:
-                col_width += NSToCoordRound(float(width - guess_pref) * c);
+                col_width += NSToCoordRound(c);
                 break;
         }
 
