From: Sudheer Kumar Peddireddy <skumar@sta.samsung.com>

Increase the initial sizes of hash tables that are guaranteed to grow.  b=432633  r=dbaron

diff --git a/dom/src/base/nsScriptNameSpaceManager.cpp b/dom/src/base/nsScriptNameSpaceManager.cpp
--- a/dom/src/base/nsScriptNameSpaceManager.cpp
+++ b/dom/src/base/nsScriptNameSpaceManager.cpp
@@ -444,33 +444,36 @@ nsScriptNameSpaceManager::RegisterInterf
   }
 
   s->mType = nsGlobalNameStruct::eTypeInterface;
   s->mIID = *aIfIID;
 
   return NS_OK;
 }
 
+#define GLOBALNAME_HASHTABLE_INITIAL_SIZE	1024
+
 nsresult
 nsScriptNameSpaceManager::Init()
 {
   static PLDHashTableOps hash_table_ops =
   {
     PL_DHashAllocTable,
     PL_DHashFreeTable,
     GlobalNameHashHashKey,
     GlobalNameHashMatchEntry,
     PL_DHashMoveEntryStub,
     GlobalNameHashClearEntry,
     PL_DHashFinalizeStub,
     GlobalNameHashInitEntry
   };
 
   mIsInitialized = PL_DHashTableInit(&mGlobalNames, &hash_table_ops, nsnull,
-                                     sizeof(GlobalNameMapEntry), 128);
+                                     sizeof(GlobalNameMapEntry), 
+                                     GLOBALNAME_HASHTABLE_INITIAL_SIZE);
   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_OUT_OF_MEMORY);
 
   nsresult rv = NS_OK;
 
   rv = FillHashWithDOMInterfaces();
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsICategoryManager> cm =
diff --git a/modules/libpref/src/prefapi.cpp b/modules/libpref/src/prefapi.cpp
--- a/modules/libpref/src/prefapi.cpp
+++ b/modules/libpref/src/prefapi.cpp
@@ -187,22 +187,24 @@ struct CallbackNode {
 
 /* -- Prototypes */
 static nsresult pref_DoCallback(const char* changed_pref);
 
 
 static nsresult pref_HashPref(const char *key, PrefValue value, PrefType type, PRBool defaultPref);
 static inline PrefHashEntry* pref_HashTableLookup(const void *key);
 
+#define PREF_HASHTABLE_INITIAL_SIZE	2048
 
 nsresult PREF_Init()
 {
     if (!gHashTable.ops) {
         if (!PL_DHashTableInit(&gHashTable, &pref_HashTableOps, nsnull,
-                               sizeof(PrefHashEntry), 1024)) {
+                               sizeof(PrefHashEntry),
+                               PREF_HASHTABLE_INITIAL_SIZE)) {
             gHashTable.ops = nsnull;
             return NS_ERROR_OUT_OF_MEMORY;
         }
 
         PL_INIT_ARENA_POOL(&gPrefNameArena, "PrefNameArena",
                            PREFNAME_ARENA_SIZE);
     }
     return NS_OK;
diff --git a/xpcom/components/nsComponentManager.cpp b/xpcom/components/nsComponentManager.cpp
--- a/xpcom/components/nsComponentManager.cpp
+++ b/xpcom/components/nsComponentManager.cpp
@@ -594,16 +594,19 @@ nsComponentManagerImpl::nsComponentManag
     mShuttingDown(NS_SHUTDOWN_NEVERHAPPENED),
     mLoaderData(4),
     mRegistryDirty(PR_FALSE)
 {
     mFactories.ops = nsnull;
     mContractIDs.ops = nsnull;
 }
 
+#define CONTRACTID_HASHTABLE_INITIAL_SIZE	2048
+#define AUTOREGENTRY_HASHTABLE_INITIAL_SIZE	256
+
 nsresult nsComponentManagerImpl::Init(nsStaticModuleInfo const *aStaticModules,
                                       PRUint32 aStaticModuleCount)
 {
     PR_ASSERT(mShuttingDown != NS_SHUTDOWN_INPROGRESS);
     if (mShuttingDown == NS_SHUTDOWN_INPROGRESS)
         return NS_ERROR_FAILURE;
 
     mShuttingDown = NS_SHUTDOWN_NEVERHAPPENED;
@@ -629,31 +632,31 @@ nsresult nsComponentManagerImpl::Init(ns
         PL_DHashTableSetAlphaBounds(&mFactories,
                                     0.875,
                                     PL_DHASH_MIN_ALPHA(&mFactories, 2));
     }
 
     if (!mContractIDs.ops) {
         if (!PL_DHashTableInit(&mContractIDs, &contractID_DHashTableOps,
                                0, sizeof(nsContractIDTableEntry),
-                               1024)) {
+                               CONTRACTID_HASHTABLE_INITIAL_SIZE)) {
             mContractIDs.ops = nsnull;
             return NS_ERROR_OUT_OF_MEMORY;
         }
 
         // Minimum alpha uses k=1 because nsContractIDTableEntry saves one
         // word compared to what a chained hash table requires.
 #if 0
         PL_DHashTableSetAlphaBounds(&mContractIDs,
                                     0.875,
                                     PL_DHASH_MIN_ALPHA(&mContractIDs, 1));
 #endif
     }
 
-    if (!mAutoRegEntries.Init(32))
+    if (!mAutoRegEntries.Init(AUTOREGENTRY_HASHTABLE_INITIAL_SIZE))
         return NS_ERROR_OUT_OF_MEMORY;
 
     if (mMon == nsnull) {
         mMon = nsAutoMonitor::NewMonitor("nsComponentManagerImpl");
         if (mMon == nsnull)
             return NS_ERROR_OUT_OF_MEMORY;
     }
 
diff --git a/xpcom/ds/nsAtomTable.cpp b/xpcom/ds/nsAtomTable.cpp
--- a/xpcom/ds/nsAtomTable.cpp
+++ b/xpcom/ds/nsAtomTable.cpp
@@ -625,39 +625,41 @@ WrapStaticAtom(const nsStaticAtom* aAtom
   PL_ARENA_ALLOCATE(mem, gStaticAtomArena, sizeof(nsStaticAtomWrapper));
 
   nsStaticAtomWrapper* wrapper =
     new (mem) nsStaticAtomWrapper(aAtom, aLength);
 
   return wrapper;
 }
 
+#define ATOM_HASHTABLE_INITIAL_SIZE  4096
+
 static inline AtomTableEntry*
 GetAtomHashEntry(const char* aString, PRUint32 aLength)
 {
   NS_ASSERTION(NS_IsMainThread(), "wrong thread");
   if (!gAtomTable.ops &&
       !PL_DHashTableInit(&gAtomTable, &AtomTableOps, 0,
-                         sizeof(AtomTableEntry), 2048)) {
+                         sizeof(AtomTableEntry), ATOM_HASHTABLE_INITIAL_SIZE)) {
     gAtomTable.ops = nsnull;
     return nsnull;
   }
 
   AtomTableEntry key(aString, aLength);
   return static_cast<AtomTableEntry*>
                     (PL_DHashTableOperate(&gAtomTable, &key, PL_DHASH_ADD));
 }
 
 static inline AtomTableEntry*
 GetAtomHashEntry(const PRUnichar* aString, PRUint32 aLength)
 {
   NS_ASSERTION(NS_IsMainThread(), "wrong thread");
   if (!gAtomTable.ops &&
       !PL_DHashTableInit(&gAtomTable, &AtomTableOps, 0,
-                         sizeof(AtomTableEntry), 2048)) {
+                         sizeof(AtomTableEntry), ATOM_HASHTABLE_INITIAL_SIZE)) {
     gAtomTable.ops = nsnull;
     return nsnull;
   }
 
   AtomTableEntry key(aString, aLength);
   return static_cast<AtomTableEntry*>
                     (PL_DHashTableOperate(&gAtomTable, &key, PL_DHASH_ADD));
 }
diff --git a/xpcom/reflect/xptinfo/src/xptiWorkingSet.cpp b/xpcom/reflect/xptinfo/src/xptiWorkingSet.cpp
--- a/xpcom/reflect/xptinfo/src/xptiWorkingSet.cpp
+++ b/xpcom/reflect/xptinfo/src/xptiWorkingSet.cpp
@@ -39,17 +39,17 @@
 
 /* Implementation of xptiWorkingSet. */
 
 #include "xptiprivate.h"
 #include "nsString.h"
 
 #define XPTI_STRING_ARENA_BLOCK_SIZE    (1024 * 1)
 #define XPTI_STRUCT_ARENA_BLOCK_SIZE    (1024 * 1)
-#define XPTI_HASHTABLE_SIZE             128
+#define XPTI_HASHTABLE_SIZE             2048
 
 /***************************************************************************/
 
 PR_STATIC_CALLBACK(PLDHashNumber)
 IIDHash(PLDHashTable *table, const void *key)
 {
     return (PLDHashNumber) ((const nsIID*)key)->m0;        
 }
