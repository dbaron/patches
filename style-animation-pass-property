From: L. David Baron <dbaron@dbaron.org>

Pass property to nsStyleAnimation interpolation functions.  (Bug 528234)  r=dholbert

diff --git a/content/smil/nsSMILCSSValueType.cpp b/content/smil/nsSMILCSSValueType.cpp
--- a/content/smil/nsSMILCSSValueType.cpp
+++ b/content/smil/nsSMILCSSValueType.cpp
@@ -208,17 +208,17 @@ nsSMILCSSValueType::Add(nsSMILValue& aDe
     }      
   }
 
   // Special case: some properties are explicitly non-additive
   if (destWrapper->mPropID == eCSSProperty_font_size_adjust ||
       destWrapper->mPropID == eCSSProperty_stroke_dasharray) {
     return NS_ERROR_FAILURE;
   }
-  return nsStyleAnimation::Add(destWrapper->mCSSValue,
+  return nsStyleAnimation::Add(destWrapper->mPropID, destWrapper->mCSSValue,
                                *realValueToAdd, aCount) ?
     NS_OK : NS_ERROR_FAILURE;
 }
 
 nsresult
 nsSMILCSSValueType::ComputeDistance(const nsSMILValue& aFrom,
                                     const nsSMILValue& aTo,
                                     double& aDistance) const
@@ -244,17 +244,18 @@ nsSMILCSSValueType::ComputeDistance(cons
     }
   } else {
     fromCSSValue = &fromWrapper->mCSSValue;
   }
   NS_ABORT_IF_FALSE(toWrapper->mPropID != eCSSProperty_UNKNOWN &&
                     !toWrapper->mCSSValue.IsNull() && toWrapper->mPresContext,
                     "ComputeDistance endpoint should be a parsed value");
 
-  return nsStyleAnimation::ComputeDistance(*fromCSSValue, toWrapper->mCSSValue,
+  return nsStyleAnimation::ComputeDistance(toWrapper->mPropID,
+                                           *fromCSSValue, toWrapper->mCSSValue,
                                            aDistance) ?
     NS_OK : NS_ERROR_FAILURE;
 }
 
 nsresult
 nsSMILCSSValueType::Interpolate(const nsSMILValue& aStartVal,
                                 const nsSMILValue& aEndVal,
                                 double aUnitDistance,
@@ -287,17 +288,18 @@ nsSMILCSSValueType::Interpolate(const ns
     }
   } else {
     startCSSValue = &startWrapper->mCSSValue;
   }
   NS_ABORT_IF_FALSE(endWrapper->mPropID != eCSSProperty_UNKNOWN &&
                     !endWrapper->mCSSValue.IsNull() && endWrapper->mPresContext,
                     "Interpolate endpoint should be a parsed value");
 
-  if (nsStyleAnimation::Interpolate(*startCSSValue,
+  if (nsStyleAnimation::Interpolate(endWrapper->mPropID,
+                                    *startCSSValue,
                                     endWrapper->mCSSValue,
                                     aUnitDistance,
                                     resultWrapper->mCSSValue)) {
     resultWrapper->mPropID = endWrapper->mPropID;
     resultWrapper->mPresContext = endWrapper->mPresContext;
     return NS_OK;
   }
   return NS_ERROR_FAILURE;
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -112,17 +112,18 @@ lcm(PRUint32 a, PRUint32 b)
   // Divide first to reduce overflow risk.
   return (a / gcd(a, b)) * b;
 }
 
 // CLASS METHODS
 // -------------
 
 PRBool
-nsStyleAnimation::ComputeDistance(const Value& aStartValue,
+nsStyleAnimation::ComputeDistance(nsCSSProperty aProperty,
+                                  const Value& aStartValue,
                                   const Value& aEndValue,
                                   double& aDistance)
 {
   Unit commonUnit = GetCommonUnit(aStartValue.GetUnit(), aEndValue.GetUnit());
 
   PRBool success = PR_TRUE;
   switch (commonUnit) {
     case eUnit_Null:
@@ -268,18 +269,20 @@ nsStyleAnimation::ComputeDistance(const 
     case eUnit_Dasharray: {
       // NOTE: This produces results on substantially different scales
       // for length values and percentage values, which might even be
       // mixed in the same property value.  This means the result isn't
       // particularly useful for paced animation.
 
       // Call AddWeighted to make us lists of the same length.
       Value normValue1, normValue2;
-      if (!AddWeighted(1.0, aStartValue, 0.0, aEndValue, normValue1) ||
-          !AddWeighted(0.0, aStartValue, 1.0, aEndValue, normValue2)) {
+      if (!AddWeighted(aProperty, 1.0, aStartValue, 0.0, aEndValue,
+                       normValue1) ||
+          !AddWeighted(aProperty, 0.0, aStartValue, 1.0, aEndValue,
+                       normValue2)) {
         success = PR_FALSE;
         break;
       }
 
       double squareDistance = 0.0;
       const nsCSSValueList *list1 = normValue1.GetCSSValueListValue();
       const nsCSSValueList *list2 = normValue2.GetCSSValueListValue();
 
@@ -310,18 +313,20 @@ nsStyleAnimation::ComputeDistance(const 
       }
 
       aDistance = sqrt(squareDistance);
       break;
     }
     case eUnit_Shadow: {
       // Call AddWeighted to make us lists of the same length.
       Value normValue1, normValue2;
-      if (!AddWeighted(1.0, aStartValue, 0.0, aEndValue, normValue1) ||
-          !AddWeighted(0.0, aStartValue, 1.0, aEndValue, normValue2)) {
+      if (!AddWeighted(aProperty, 1.0, aStartValue, 0.0, aEndValue,
+                       normValue1) ||
+          !AddWeighted(aProperty, 0.0, aStartValue, 1.0, aEndValue,
+                       normValue2)) {
         success = PR_FALSE;
         break;
       }
 
       const nsCSSValueList *shadow1 = normValue1.GetCSSValueListValue();
       const nsCSSValueList *shadow2 = normValue2.GetCSSValueListValue();
 
       double squareDistance = 0.0f;
@@ -356,17 +361,18 @@ nsStyleAnimation::ComputeDistance(const 
             (color1.GetColorValue(), nsStyleAnimation::Value::ColorConstructor);
           nsStyleAnimation::Value color2Value
             (color2.GetColorValue(), nsStyleAnimation::Value::ColorConstructor);
           double colorDistance;
 
         #ifdef DEBUG
           PRBool ok =
         #endif
-            nsStyleAnimation::ComputeDistance(color1Value, color2Value,
+            nsStyleAnimation::ComputeDistance(eCSSProperty_color,
+                                              color1Value, color2Value,
                                               colorDistance);
           NS_ABORT_IF_FALSE(ok, "should not fail");
           squareDistance += colorDistance * colorDistance;
         }
 
         shadow1 = shadow1->mNext;
         shadow2 = shadow2->mNext;
         NS_ABORT_IF_FALSE(!shadow1 == !shadow2, "lists should be same length");
@@ -443,18 +449,18 @@ AddShadowItems(double aCoeff1, const nsC
     nsStyleAnimation::Value color1Value
       (color1.GetColorValue(), nsStyleAnimation::Value::ColorConstructor);
     nsStyleAnimation::Value color2Value
       (color2.GetColorValue(), nsStyleAnimation::Value::ColorConstructor);
     nsStyleAnimation::Value resultColorValue;
   #ifdef DEBUG
     PRBool ok =
   #endif
-      nsStyleAnimation::AddWeighted(aCoeff1, color1Value, aCoeff2, color2Value,
-                                    resultColorValue);
+      nsStyleAnimation::AddWeighted(eCSSProperty_color, aCoeff1, color1Value,
+                                    aCoeff2, color2Value, resultColorValue);
     NS_ABORT_IF_FALSE(ok, "should not fail");
     resultArray->Item(4).SetColorValue(resultColorValue.GetColorValue());
   }
 
   NS_ABORT_IF_FALSE(inset1 == inset2, "should match");
   resultArray->Item(5) = inset1;
 
   nsCSSValueList *resultItem = new nsCSSValueList;
@@ -463,17 +469,18 @@ AddShadowItems(double aCoeff1, const nsC
   }
   resultItem->mValue.SetArrayValue(resultArray, eCSSUnit_Array);
   *aResultTail = resultItem;
   aResultTail = &resultItem->mNext;
   return PR_TRUE;
 }
 
 PRBool
-nsStyleAnimation::AddWeighted(double aCoeff1, const Value& aValue1,
+nsStyleAnimation::AddWeighted(nsCSSProperty aProperty,
+                              double aCoeff1, const Value& aValue1,
                               double aCoeff2, const Value& aValue2,
                               Value& aResultValue)
 {
   Unit commonUnit = GetCommonUnit(aValue1.GetUnit(), aValue2.GetUnit());
   // Maybe need a followup method to convert the inputs into the common
   // unit-type, if they don't already match it. (Or would it make sense to do
   // that in GetCommonUnit? in which case maybe ConvertToCommonUnit would be
   // better.)
diff --git a/layout/style/nsStyleAnimation.h b/layout/style/nsStyleAnimation.h
--- a/layout/style/nsStyleAnimation.h
+++ b/layout/style/nsStyleAnimation.h
@@ -72,19 +72,19 @@ public:
    * Note that if |aCount| is 0, then |aDest| will be unchanged.  Also, if
    * this method fails, then |aDest| will be unchanged.
    *
    * @param aDest       The value to add to.
    * @param aValueToAdd The value to add.
    * @param aCount      The number of times to add aValueToAdd.
    * @return PR_TRUE on success, PR_FALSE on failure.
    */
-  static PRBool Add(Value& aDest, const Value& aValueToAdd,
-                    PRUint32 aCount) {
-    return AddWeighted(1.0, aDest, aCount, aValueToAdd, aDest);
+  static PRBool Add(nsCSSProperty aProperty, Value& aDest,
+                    const Value& aValueToAdd, PRUint32 aCount) {
+    return AddWeighted(aProperty, 1.0, aDest, aCount, aValueToAdd, aDest);
   }
 
   /**
    * Calculates a measure of 'distance' between two values.
    *
    * This measure of Distance is guaranteed to be proportional to
    * portions passed to Interpolate, Add, or AddWeighted.  However, for
    * some types of Value it may not produce sensible results for paced
@@ -95,17 +95,18 @@ public:
    *
    * @param aStartValue The start of the interval for which the distance
    *                    should be calculated.
    * @param aEndValue   The end of the interval for which the distance
    *                    should be calculated.
    * @param aDistance   The result of the calculation.
    * @return PR_TRUE on success, PR_FALSE on failure.
    */
-  static PRBool ComputeDistance(const Value& aStartValue,
+  static PRBool ComputeDistance(nsCSSProperty aProperty,
+                                const Value& aStartValue,
                                 const Value& aEndValue,
                                 double& aDistance);
 
   /**
    * Calculates an interpolated value that is the specified |aPortion| between
    * the two given values.
    *
    * This really just does the following calculation:
@@ -115,40 +116,42 @@ public:
    *                    interpolation.
    * @param aEndValue   The value defining the end of the interval of
    *                    interpolation.
    * @param aPortion    A number in the range [0.0, 1.0] defining the
    *                    distance of the interpolated value in the interval.
    * @param [out] aResultValue The resulting interpolated value.
    * @return PR_TRUE on success, PR_FALSE on failure.
    */
-  static PRBool Interpolate(const Value& aStartValue,
+  static PRBool Interpolate(nsCSSProperty aProperty,
+                            const Value& aStartValue,
                             const Value& aEndValue,
                             double aPortion,
                             Value& aResultValue) {
     NS_ABORT_IF_FALSE(0.0 <= aPortion && aPortion <= 1.0, "out of range");
-    return AddWeighted(1.0 - aPortion, aStartValue, aPortion, aEndValue,
-                       aResultValue);
+    return AddWeighted(aProperty, 1.0 - aPortion, aStartValue,
+                       aPortion, aEndValue, aResultValue);
   }
 
   /**
    * Does the calculation:
    *   aResultValue = aCoeff1 * aValue1 + aCoeff2 * aValue2
    *
    * @param [out] aResultValue The resulting interpolated value.  May be
    *                           the same as aValue1 or aValue2.
    * @return PR_TRUE on success, PR_FALSE on failure.
    *
    * NOTE: Current callers always pass aCoeff1 and aCoeff2 >= 0.  They
    * are currently permitted to be negative; however, if, as we add
    * support more value types types, we find that this causes
    * difficulty, we might change this to restrict them to being
    * positive.
    */
-  static PRBool AddWeighted(double aCoeff1, const Value& aValue1,
+  static PRBool AddWeighted(nsCSSProperty aProperty,
+                            double aCoeff1, const Value& aValue1,
                             double aCoeff2, const Value& aValue2,
                             Value& aResultValue);
 
   // Type-conversion methods
   // -----------------------
   /**
    * Creates a computed value for the given specified value
    * (property ID + string).  A style context is needed in case the
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -240,17 +240,18 @@ ElementTransitionsStyleRule::MapRuleInfo
           timePortion = 1.0; // we might be behind on flushing
       }
 
       double valuePortion =
         pt.mTimingFunction.GetSplineValue(timePortion);
 #ifdef DEBUG
       PRBool ok =
 #endif
-        nsStyleAnimation::Interpolate(pt.mStartValue, pt.mEndValue,
+        nsStyleAnimation::Interpolate(pt.mProperty,
+                                      pt.mStartValue, pt.mEndValue,
                                       valuePortion, pt.mCurrentValue);
       NS_ABORT_IF_FALSE(ok, "could not interpolate values");
 
       void *prop =
         nsCSSExpandedDataBlock::RuleDataPropertyAt(aRuleData, pt.mProperty);
 #ifdef DEBUG
       ok =
 #endif
@@ -568,18 +569,18 @@ nsTransitionManager::ConsiderStartingTra
     nsStyleAnimation::ExtractComputedValue(aProperty, aOldStyleContext,
                                            pt.mStartValue) &&
     nsStyleAnimation::ExtractComputedValue(aProperty, aNewStyleContext,
                                            pt.mEndValue) &&
     pt.mStartValue != pt.mEndValue &&
     // Check that we can interpolate between these values
     // (If this is ever a performance problem, we could add a
     // CanInterpolate method, but it seems fine for now.)
-    nsStyleAnimation::Interpolate(pt.mStartValue, pt.mEndValue, 0.5,
-                                  dummyValue);
+    nsStyleAnimation::Interpolate(aProperty, pt.mStartValue, pt.mEndValue,
+                                  0.5, dummyValue);
 
   PRUint32 currentIndex = nsTArray<ElementPropertyTransition>::NoIndex;
   if (aElementTransitions) {
     nsTArray<ElementPropertyTransition> &pts =
       aElementTransitions->mPropertyTransitions;
     for (PRUint32 i = 0, i_end = pts.Length(); i < i_end; ++i) {
       if (pts[i].mProperty == aProperty) {
         currentIndex = i;
@@ -629,22 +630,22 @@ nsTransitionManager::ConsiderStartingTra
       // WalkTransitionRule already called RestyleForAnimation.
       return;
     }
 
     double fullDistance, remainingDistance;
 #ifdef DEBUG
     PRBool ok =
 #endif
-      nsStyleAnimation::ComputeDistance(pt.mStartValue, pt.mEndValue,
-                                        fullDistance);
+      nsStyleAnimation::ComputeDistance(aProperty, pt.mStartValue,
+                                        pt.mEndValue, fullDistance);
     NS_ABORT_IF_FALSE(ok, "could not compute distance");
     NS_ABORT_IF_FALSE(fullDistance >= 0.0, "distance must be positive");
 
-    if (nsStyleAnimation::ComputeDistance(endVal, pt.mEndValue,
+    if (nsStyleAnimation::ComputeDistance(aProperty, endVal, pt.mEndValue,
                                           remainingDistance)) {
       NS_ABORT_IF_FALSE(remainingDistance >= 0.0, "distance must be positive");
       durationFraction = fullDistance / remainingDistance;
       if (durationFraction > 1.0) {
         durationFraction = 1.0;
       }
     }
   }
