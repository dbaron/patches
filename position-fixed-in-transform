Handle some additional codepaths for position: fixed elements inside elements with -moz-transform.  (Bug 455171)

diff --git a/content/events/src/nsEventStateManager.cpp b/content/events/src/nsEventStateManager.cpp
--- a/content/events/src/nsEventStateManager.cpp
+++ b/content/events/src/nsEventStateManager.cpp
@@ -2510,17 +2510,18 @@ nsEventStateManager::DoScrollZoom(nsIFra
 }
 
 static nsIFrame*
 GetParentFrameToScroll(nsPresContext* aPresContext, nsIFrame* aFrame)
 {
   if (!aPresContext || !aFrame)
     return nsnull;
 
-  if (aFrame->GetStyleDisplay()->mPosition == NS_STYLE_POSITION_FIXED)
+  if (aFrame->GetStyleDisplay()->mPosition == NS_STYLE_POSITION_FIXED &&
+      nsLayoutUtils::IsReallyFixedPos(aFrame))
     return aPresContext->GetPresShell()->GetRootScrollFrame();
 
   return aFrame->GetParent();
 }
 
 static nsIScrollableView*
 GetScrollableViewForFrame(nsPresContext* aPresContext, nsIFrame* aFrame)
 {
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -1777,17 +1777,21 @@ GetChildListNameFor(nsIFrame*       aChi
   // See if the frame is moved out of the flow
   else if (aChildFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
     // Look at the style information to tell
     const nsStyleDisplay* disp = aChildFrame->GetStyleDisplay();
     
     if (NS_STYLE_POSITION_ABSOLUTE == disp->mPosition) {
       listName = nsGkAtoms::absoluteList;
     } else if (NS_STYLE_POSITION_FIXED == disp->mPosition) {
-      listName = nsGkAtoms::fixedList;
+      if (nsLayoutUtils::IsReallyFixedPos(aChildFrame)) {
+        listName = nsGkAtoms::fixedList;
+      } else {
+        listName = nsGkAtoms::absoluteList;
+      }
 #ifdef MOZ_XUL
     } else if (NS_STYLE_DISPLAY_POPUP == disp->mDisplay) {
       // Out-of-flows that are DISPLAY_POPUP must be kids of the root popup set
 #ifdef DEBUG
       nsIFrame* parent = aChildFrame->GetParent();
       NS_ASSERTION(parent && parent->GetType() == nsGkAtoms::popupSetFrame,
                    "Unexpected parent");
 #endif // DEBUG
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -3024,16 +3024,28 @@ nsLayoutUtils::GetDeviceContextForScreen
     nsCOMPtr<nsIDocShellTreeItem> parentItem;
     curItem->GetParent(getter_AddRefs(parentItem));
     docShell = do_QueryInterface(parentItem);
   }
 
   return nsnull;
 }
 
+/* static */ PRBool
+nsLayoutUtils::IsReallyFixedPos(nsIFrame* aFrame)
+{
+  NS_PRECONDITION(aFrame->GetParent,
+                  "IsReallyFixedPos called on frame not in tree");
+  NS_PRECONDITION(aFrame->GetStyleDisplay()->mPosition ==
+                    NS_STYLE_POSITION_FIXED,
+                  "IsReallyFixedPos called on non-'position:fixed' frame");
+
+  return aFrame->GetParent()->GetType() == nsLayoutAtoms::viewportFrame;
+}
+
 nsSetAttrRunnable::nsSetAttrRunnable(nsIContent* aContent, nsIAtom* aAttrName,
                                      const nsAString& aValue)
   : mContent(aContent),
     mAttrName(aAttrName),
     mValue(aValue)
 {
   NS_ASSERTION(aContent && aAttrName, "Missing stuff, prepare to crash");
 }
diff --git a/layout/base/nsLayoutUtils.h b/layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h
+++ b/layout/base/nsLayoutUtils.h
@@ -914,16 +914,24 @@ public:
    * Get a device context that can be used to get up-to-date device
    * dimensions for the given docshell.  For some reason, this is more
    * complicated than it ought to be in multi-monitor situations.
    */
   static nsIDeviceContext*
   GetDeviceContextForScreenInfo(nsIDocShell* aDocShell);
 
   /**
+   * Some frames with 'position: fixed' (nsStylePosition::mDisplay ==
+   * NS_STYLE_POSITION_FIXED) are not really fixed positioned, since
+   * they're inside an element with -moz-transform.  This function says
+   * whether such an element is a real fixed-pos element.
+   */
+  static PRBool IsReallyFixedPos(nsIFrame* aFrame);
+
+  /**
    * Indicates if the nsIFrame::GetUsedXXX assertions in nsFrame.cpp should
    * disabled.
    */
   static PRBool sDisableGetUsedXAssertions;
 };
 
 class nsAutoDisableGetUsedXAssertions
 {
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -885,16 +885,18 @@ static PRBool AreAllEarlierInFlowFramesE
   }
   *aFound = PR_FALSE;
   return PR_TRUE;
 }
 
 // Calculate the hypothetical box that the element would have if it were in
 // the flow. The values returned are relative to the padding edge of the
 // absolute containing block
+// aContainingBlock is the placeholder's containing block (XXX rename it?)
+// cbrs->frame is the actual containing block
 void
 nsHTMLReflowState::CalculateHypotheticalBox(nsPresContext*    aPresContext,
                                             nsIFrame*         aPlaceholderFrame,
                                             nsIFrame*         aContainingBlock,
                                             nscoord           aBlockLeftContentEdge,
                                             nscoord           aBlockContentWidth,
                                             const nsHTMLReflowState* cbrs,
                                             nsHypotheticalBox& aHypotheticalBox)
@@ -1081,18 +1083,21 @@ nsHTMLReflowState::CalculateHypothetical
 
   }
 
   // The current coordinate space is that of the nearest block to the placeholder.
   // Convert to the coordinate space of the absolute containing block
   // One weird thing here is that for fixed-positioned elements we want to do
   // the conversion incorrectly; specifically we want to ignore any scrolling
   // that may have happened;
+  // XXXldb Why don't we also want to ignore scrolling for the absolute case?
   nsPoint cbOffset;
-  if (mStyleDisplay->mPosition == NS_STYLE_POSITION_FIXED) {
+  if (mStyleDisplay->mPosition == NS_STYLE_POSITION_FIXED &&
+      // Exclude cases inside -moz-transform where fixed is like absolute.
+      nsLayoutUtils::IsReallyFixedPos(frame)) {
     // In this case, cbrs->frame will always be an ancestor of
     // aContainingBlock, so can just walk our way up the frame tree.
     // Make sure to not add positions of frames whose parent is a
     // scrollFrame, since we're doing fixed positioning, which assumes
     // everything is scrolled to (0,0).
     cbOffset.MoveTo(0, 0);
     do {
       NS_ASSERTION(aContainingBlock,
