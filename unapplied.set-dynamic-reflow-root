From: L. David Baron <dbaron@dbaron.org>

Bug 1159042 patch 3 - Add NS_FRAME_DYNAMIC_REFLOW_ROOT on frames that we can dynamically make reflow roots.

diff --git a/layout/generic/ReflowInput.cpp b/layout/generic/ReflowInput.cpp
--- a/layout/generic/ReflowInput.cpp
+++ b/layout/generic/ReflowInput.cpp
@@ -421,16 +421,17 @@ ReflowInput::Init(nsPresContext*     aPr
   LogicalSize cbSize(mWritingMode, -1, -1);
   if (aContainingBlockSize) {
     cbSize = *aContainingBlockSize;
   }
 
   InitConstraints(aPresContext, cbSize, aBorder, aPadding, type);
 
   InitResizeFlags(aPresContext, type);
+  InitDynamicReflowRoot();
 
   nsIFrame *parent = mFrame->GetParent();
   if (parent &&
       (parent->GetStateBits() & NS_FRAME_IN_CONSTRAINED_BSIZE) &&
       !(parent->IsScrollFrame() &&
         parent->StyleDisplay()->mOverflowY != NS_STYLE_OVERFLOW_HIDDEN)) {
     mFrame->AddStateBits(NS_FRAME_IN_CONSTRAINED_BSIZE);
   } else if (type == LayoutFrameType::SVGForeignObject) {
@@ -817,16 +818,97 @@ ReflowInput::InitResizeFlags(nsPresConte
   }
   if (mFrame->GetStateBits() & NS_FRAME_IS_DIRTY) {
     // If we're reflowing everything, then we'll find out if we need
     // to re-set this.
     mFrame->RemoveStateBits(NS_FRAME_CONTAINS_RELATIVE_BSIZE);
   }
 }
 
+static inline bool
+IsIntrinsicKeyword(const nsStyleCoord& aCoord)
+{
+  if (aCoord.GetUnit() != eStyleUnit_Enumerated) {
+    return false;
+  }
+
+  // All of the keywords except for 'fill' depend on intrinsic sizes.
+  return aCoord.GetIntValue() != NS_STYLE_WIDTH_AVAILABLE;
+}
+
+void
+ReflowInput::InitDynamicReflowRoot()
+{
+  auto display = mStyleDisplay->mDisplay;
+  if (mFrame->IsFrameOfType(nsIFrame::eLineParticipant) ||
+      nsStyleDisplay::IsRubyDisplayType(display) ||
+      mFrameType == NS_CSS_FRAME_TYPE_INTERNAL_TABLE ||
+      display == NS_STYLE_DISPLAY_TABLE ||
+      display == NS_STYLE_DISPLAY_TABLE_CAPTION ||
+      display == NS_STYLE_DISPLAY_INLINE_TABLE ||
+      (mFrame->GetParent() && mFrame->GetParent()->IsXULBoxFrame())) {
+    // We have a display type where 'width' and 'height' don't actually
+    // set the width or height.
+    NS_ASSERTION(!(mFrame->GetStateBits() & NS_FRAME_DYNAMIC_REFLOW_ROOT),
+                 "should not have dynamic reflow root bit");
+    return;
+  }
+
+  bool canBeDynamicReflowRoot = true;
+
+  // We can't do this if we don't have fixed width and height.
+  // FIXME: For display:block, we should probably optimize inline-size
+  // being auto.
+  // FIXME: Other flex and grid cases?
+  const nsStyleCoord& width = mStylePosition->mWidth;
+  const nsStyleCoord& height = mStylePosition->mHeight;
+  if (!width.IsCoordPercentCalcUnit() ||
+      width.HasPercent() ||
+      !height.IsCoordPercentCalcUnit() ||
+      height.HasPercent() ||
+      IsIntrinsicKeyword(mStylePosition->mMinWidth) ||
+      IsIntrinsicKeyword(mStylePosition->mMaxWidth) ||
+      IsIntrinsicKeyword(mStylePosition->mMinHeight) ||
+      IsIntrinsicKeyword(mStylePosition->mMaxHeight) ||
+      ((mStylePosition->mMinWidth.GetUnit() == eStyleUnit_Auto ||
+        mStylePosition->mMinHeight.GetUnit() == eStyleUnit_Auto) &&
+       mFrame->IsFlexItem())) {
+    canBeDynamicReflowRoot = false;
+  }
+
+  if (!mFrame->IsFixedPosContainingBlock()) {
+    // We can't treat this frame as a reflow root, since dynamic changes
+    // to absolutely-positioned frames inside of it require that we
+    // reflow the placeholder before we reflow the absolutely positioned
+    // frame.
+    // FIXME:  Alternatively, we could sort the reflow roots in
+    // PresShell::ProcessReflowCommands by depth in the tree, from
+    // deepest to least deep.  However, for performance (FIXME) we
+    // should really be sorting them in the opposite order!
+    canBeDynamicReflowRoot = false;
+  } else {
+    MOZ_ASSERT(mFrame->IsAbsPosContainingBlock(),
+               "we need the frame to be both an abs-pos and fixed-pos cb");
+  }
+
+  // If we participate in a container's block reflow context, or margins
+  // can collapse through us, we can't be a dynamic reflow root.
+  if (canBeDynamicReflowRoot &&
+      mFrame->IsFrameOfType(nsIFrame::eBlockFrame) &&
+      (~mFrame->GetStateBits() & (NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT))) {
+    canBeDynamicReflowRoot = false;
+  }
+
+  if (canBeDynamicReflowRoot) {
+    mFrame->AddStateBits(NS_FRAME_DYNAMIC_REFLOW_ROOT);
+  } else {
+    mFrame->RemoveStateBits(NS_FRAME_DYNAMIC_REFLOW_ROOT);
+  }
+}
+
 nscoord
 ReflowInput::GetContainingBlockContentISize(WritingMode aWritingMode) const
 {
   if (!mCBReflowInput) {
     return 0;
   }
   return mCBReflowInput->GetWritingMode().IsOrthogonalTo(aWritingMode)
     ? mCBReflowInput->ComputedBSize()
diff --git a/layout/generic/ReflowInput.h b/layout/generic/ReflowInput.h
--- a/layout/generic/ReflowInput.h
+++ b/layout/generic/ReflowInput.h
@@ -972,16 +972,17 @@ public:
                                        void* aValue);
 #endif
 
 protected:
   void InitFrameType(LayoutFrameType aFrameType);
   void InitCBReflowInput();
   void InitResizeFlags(nsPresContext* aPresContext,
                        mozilla::LayoutFrameType aFrameType);
+  void InitDynamicReflowRoot();
 
   void InitConstraints(nsPresContext* aPresContext,
                        const mozilla::LogicalSize& aContainingBlockSize,
                        const nsMargin* aBorder,
                        const nsMargin* aPadding,
                        mozilla::LayoutFrameType aFrameType);
 
   // Returns the nearest containing block or block frame (whether or not
diff --git a/layout/generic/nsFrameStateBits.h b/layout/generic/nsFrameStateBits.h
--- a/layout/generic/nsFrameStateBits.h
+++ b/layout/generic/nsFrameStateBits.h
@@ -282,16 +282,20 @@ FRAME_STATE_BIT(Generic, 57, NS_FRAME_SI
 // base frame) to indicate that the SSTY font feature should be used.
 FRAME_STATE_BIT(Generic, 58, NS_FRAME_MATHML_SCRIPT_DESCENDANT)
 
 // This state bit is set on frames within token MathML elements if the
 // token represents an <mi> tag whose inner HTML consists of a single
 // non-whitespace character to allow special rendering behaviour.
 FRAME_STATE_BIT(Generic, 59, NS_FRAME_IS_IN_SINGLE_CHAR_MI)
 
+// If this bit is set, then reflow may be dispatched from the current
+// frame instead of the root frame.
+FRAME_STATE_BIT(Generic, XX, NS_FRAME_DYNAMIC_REFLOW_ROOT)
+
 // NOTE: Bits 20-31 and 60-63 of the frame state are reserved for specific
 // frame classes.
 
 
 // == Frame state bits that apply to box frames ===============================
 
 FRAME_STATE_GROUP(Box, nsBoxFrame)
 
