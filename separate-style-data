From: L. David Baron <dbaron@dbaron.org>

Add mechanism for separate style data for visited style.  (Bug 147777)

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -7637,16 +7637,23 @@ nsCSSFrameConstructor::DoContentStateCha
 
     nsReStyleHint rshint = 
       styleSet->HasStateDependentStyle(presContext, aContent, aStateMask);
       
     if ((aStateMask & NS_EVENT_STATE_HOVER) && rshint != 0) {
       ++mHoverGeneration;
     }
 
+    if (aStateMask & NS_EVENT_STATE_VISITED) {
+      // Exposing information to the page about whether the link is
+      // visited or not isn't really something we can worry about here.
+      // FIXME: We could probably do this a bit better.
+      NS_UpdateHint(hint, NS_STYLE_HINT_VISUAL);
+    }
+
     PostRestyleEvent(aContent, rshint, hint);
   }
 }
 
 void
 nsCSSFrameConstructor::AttributeWillChange(nsIContent* aContent,
                                            PRInt32 aNameSpaceID,
                                            nsIAtom* aAttribute,
diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -458,22 +458,78 @@ nsStyleContext::CalcStyleDifference(nsSt
 
   // The following structs cause (as their maximal difference) a
   // re-render to occur.  VISUAL Structs: Color, Background
   DO_STRUCT_DIFFERENCE(Color);
   DO_STRUCT_DIFFERENCE(Background);
 
 #undef DO_STRUCT_DIFFERENCE
 
+  nsStyleContext *thisVis = StyleIfVisited(),
+                *otherVis = aOther->StyleIfVisited();
+  if (thisVis) {
+    if (otherVis) {
+      PRBool change = PR_FALSE;
+
+      // NB: Calling Peek on |this|, not |thisVis|.
+      if (PeekStyleColor()) {
+        if (thisVis->GetStyleColor()->mColor !=
+            otherVis->GetStyleColor()->mColor) {
+          change = PR_TRUE;
+        }
+      }
+
+      // NB: Calling Peek on |this|, not |thisVis|.
+      if (PeekStyleBackground()) {
+        if (thisVis->GetStyleBackground()->mBackgroundColor !=
+            otherVis->GetStyleBackground()->mBackgroundColor) {
+          change = PR_TRUE;
+        }
+      }
+
+      // NB: Calling Peek on |this|, not |thisVis|.
+      if (PeekStyleBorder()) {
+        const nsStyleBorder *thisVisBorder = thisVis->GetStyleBorder();
+        const nsStyleBorder *otherVisBorder = otherVis->GetStyleBorder();
+        NS_FOR_CSS_SIDES(side) {
+          PRBool thisFG, otherFG;
+          nscolor thisColor, otherColor;
+          thisVisBorder->GetBorderColor(side, thisColor, thisFG);
+          otherVisBorder->GetBorderColor(side, otherColor, otherFG);
+          if (thisFG != otherFG || (!thisFG && thisColor != otherColor)) {
+            change = PR_TRUE;
+          }
+        }
+      }
+
+      if (change) {
+        NS_UpdateHint(hint, NS_STYLE_HINT_VISUAL);
+      }
+
+    } else {
+      // Presume a difference.
+      NS_UpdateHint(hint, NS_STYLE_HINT_VISUAL);
+    }
+  } else {
+    if (otherVis) {
+      // Presume a difference.
+      NS_UpdateHint(hint, NS_STYLE_HINT_VISUAL);
+    } else {
+    }
+  }
+
   return hint;
 }
 
 void
 nsStyleContext::Mark()
 {
+  if (mStyleIfVisited)
+    mStyleIfVisited->Mark();
+
   // Mark our rule node.
   mRuleNode->Mark();
 
   // Mark our children (i.e., tell them to mark their rule nodes, etc.).
   if (mChild) {
     nsStyleContext* child = mChild;
     do {
       child->Mark();
diff --git a/layout/style/nsStyleContext.h b/layout/style/nsStyleContext.h
--- a/layout/style/nsStyleContext.h
+++ b/layout/style/nsStyleContext.h
@@ -125,16 +125,45 @@ public:
 
   // Does this style context represent the style for a pseudo-element or
   // inherit data from such a style context?  Whether this returns true
   // is equivalent to whether it or any of its ancestors returns
   // non-null for GetPseudo.
   PRBool HasPseudoElementData() const
     { return !!(mBits & NS_STYLE_HAS_PSEUDO_ELEMENT_DATA); }
 
+  // Is the only link whose visitedness is allowed to influence the
+  // style of the node this style context is for (which is that element
+  // or its nearest ancestor that is a link) visited?
+  PRBool RelevantLinkVisited() const
+    { return !!(mBits & NS_STYLE_RELEVANT_LINK_VISITED); }
+
+  // Return the style context whose style data should be used for the R,
+  // G, and B components of color, background-color, and border-*-color
+  // if RelevantLinkIsVisited().
+  nsStyleContext* StyleIfVisited()
+    { return mStyleIfVisited; }
+
+  // To be called only from nsStyleSet.
+  void SetStyleIfVisited(already_AddRefed<nsStyleContext> aStyleIfVisited)
+  {
+    NS_ASSERTION(!mStyleIfVisited, "should only be set once");
+    mStyleIfVisited = aStyleIfVisited;
+
+    NS_ASSERTION(StyleIfVisited()->GetPseudo() == GetPseudo(),
+                 "pseudo tag mismatch");
+    if (GetParent() && GetParent()->StyleIfVisited()) {
+      NS_ASSERTION(StyleIfVisited()->GetParent() ==
+                     GetParent()->StyleIfVisited(), "parent mismatch");
+    } else {
+      NS_ASSERTION(StyleIfVisited()->GetParent() == GetParent(),
+                   "parent mismatch");
+    }
+  }
+
   // Tell this style context to cache aStruct as the struct for aSID
   NS_HIDDEN_(void) SetStyle(nsStyleStructID aSID, void* aStruct);
 
   // Setters for inherit structs only, since rulenode only sets those eagerly.
   #define STYLE_STRUCT_INHERITED(name_, checkdata_cb_, ctor_args_)          \
     void SetStyle##name_ (nsStyle##name_ * aStruct) {                       \
       NS_ASSERTION(!mCachedInheritedData.m##name_##Data ||                  \
                    (mBits &                                                 \
@@ -238,29 +267,34 @@ protected:
         return cachedData;                                              \
       /* Have the rulenode deal */                                      \
       return mRuleNode->GetStyle##name_(this, aComputeData);            \
     }
   #include "nsStyleStructList.h"
   #undef STYLE_STRUCT_RESET
   #undef STYLE_STRUCT_INHERITED
 
-  nsStyleContext* const mParent;
+  nsStyleContext* const mParent; // STRONG
 
   // Children are kept in two circularly-linked lists.  The list anchor
   // is not part of the list (null for empty), and we point to the first
   // child.
   // mEmptyChild for children whose rule node is the root rule node, and
   // mChild for other children.  The order of children is not
   // meaningful.
   nsStyleContext* mChild;
   nsStyleContext* mEmptyChild;
   nsStyleContext* mPrevSibling;
   nsStyleContext* mNextSibling;
 
+  // Style to be used instead for the R, G, and B components of color,
+  // background-color, and border-*-color if the nearest ancestor link
+  // element is visited (see RelevantLinkVisited()).
+  nsRefPtr<nsStyleContext> mStyleIfVisited;
+
   // If this style context is for a pseudo-element or anonymous box,
   // the relevant atom.
   nsCOMPtr<nsIAtom> mPseudoTag;
 
   // The rule node is the node in the lexicographic tree of rule nodes
   // (the "rule tree") that indicates which style rules are used to
   // compute the style data, and in what cascading order.  The least
   // specific rule matched is the one whose rule node is a child of the
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -79,16 +79,18 @@ class imgIContainer;
 // NS_STYLE_INHERIT_BIT defined in nsStyleStructFwd.h
 #define NS_STYLE_INHERIT_MASK             0x00ffffff
 
 // Additional bits for nsStyleContext's mBits:
 // See nsStyleContext::HasTextDecorations
 #define NS_STYLE_HAS_TEXT_DECORATIONS     0x01000000
 // See nsStyleContext::HasPseudoElementData.
 #define NS_STYLE_HAS_PSEUDO_ELEMENT_DATA  0x02000000
+// See nsStyleContext::RelevantLinkIsVisited
+#define NS_STYLE_RELEVANT_LINK_VISITED    0x04000000
 // See nsStyleContext::GetPseudoEnum
 #define NS_STYLE_CONTEXT_TYPE_MASK        0xf0000000
 #define NS_STYLE_CONTEXT_TYPE_SHIFT       28
 
 // Additional bits for nsRuleNode's mDependentBits:
 #define NS_RULE_NODE_GC_MARK              0x02000000
 #define NS_RULE_NODE_IS_IMPORTANT         0x08000000
 #define NS_RULE_NODE_LEVEL_MASK           0xf0000000
