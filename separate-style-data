From: L. David Baron <dbaron@dbaron.org>

Add mechanism for separate style data for visited style.  (Bug 147777)

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -7638,16 +7638,23 @@ nsCSSFrameConstructor::DoContentStateCha
 
     nsReStyleHint rshint = 
       styleSet->HasStateDependentStyle(presContext, aContent, aStateMask);
       
     if ((aStateMask & NS_EVENT_STATE_HOVER) && rshint != 0) {
       ++mHoverGeneration;
     }
 
+    if (aStateMask & NS_EVENT_STATE_VISITED) {
+      // Exposing information to the page about whether the link is
+      // visited or not isn't really something we can worry about here.
+      // FIXME: We could probably do this a bit better.
+      NS_UpdateHint(hint, NS_STYLE_HINT_VISUAL);
+    }
+
     PostRestyleEvent(aContent, rshint, hint);
   }
 }
 
 void
 nsCSSFrameConstructor::AttributeWillChange(nsIContent* aContent,
                                            PRInt32 aNameSpaceID,
                                            nsIAtom* aAttribute,
diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -466,16 +466,82 @@ nsStyleContext::CalcStyleDifference(nsSt
 
   // The following structs cause (as their maximal difference) a
   // re-render to occur.  VISUAL Structs: Color, Background
   DO_STRUCT_DIFFERENCE(Color);
   DO_STRUCT_DIFFERENCE(Background);
 
 #undef DO_STRUCT_DIFFERENCE
 
+  nsStyleContext *thisVis = StyleIfVisited(),
+                *otherVis = aOther->StyleIfVisited();
+  if (thisVis) {
+    if (otherVis) {
+      PRBool change = PR_FALSE;
+
+      // NB: Calling Peek on |this|, not |thisVis|.
+      if (PeekStyleData(eStyleStruct_Color)) {
+        const nsStyleColor *thisVisColor = static_cast<const nsStyleColor*>
+          (thisVis->PeekStyleData(eStyleStruct_Color));
+        const nsStyleColor *otherVisColor = static_cast<const nsStyleColor*>
+          (otherVis->PeekStyleData(eStyleStruct_Color));
+        if (thisVisColor->mColor != otherVisColor->mColor) {
+          change = PR_TRUE;
+        }
+      }
+
+      // NB: Calling Peek on |this|, not |thisVis|.
+      if (PeekStyleData(eStyleStruct_Background)) {
+        const nsStyleBackground *thisVisBackground =
+          static_cast<const nsStyleBackground*>
+            (thisVis->PeekStyleData(eStyleStruct_Background));
+        const nsStyleBackground *otherVisBackground =
+          static_cast<const nsStyleBackground*>
+            (otherVis->PeekStyleData(eStyleStruct_Background));
+        if (thisVisBackground->mBackgroundColor !=
+            otherVisBackground->mBackgroundColor) {
+          change = PR_TRUE;
+        }
+      }
+
+      // NB: Calling Peek on |this|, not |thisVis|.
+      if (PeekStyleData(eStyleStruct_Border)) {
+        const nsStyleBorder *thisVisBorder =
+          static_cast<const nsStyleBorder*>
+            (thisVis->PeekStyleData(eStyleStruct_Border));
+        const nsStyleBorder *otherVisBorder =
+          static_cast<const nsStyleBorder*>
+            (otherVis->PeekStyleData(eStyleStruct_Border));
+        NS_FOR_CSS_SIDES(side) {
+          PRBool thisFG, otherFG;
+          nscolor thisColor, otherColor;
+          thisVisBorder->GetBorderColor(side, thisColor, thisFG);
+          otherVisBorder->GetBorderColor(side, otherColor, otherFG);
+          if (thisFG != otherFG || (!thisFG && thisColor != otherColor)) {
+            change = PR_TRUE;
+          }
+        }
+      }
+
+      if (change) {
+        NS_UpdateHint(hint, NS_STYLE_HINT_VISUAL);
+      }
+
+    } else {
+      // Presume a difference.
+      NS_UpdateHint(hint, NS_STYLE_HINT_VISUAL);
+    }
+  } else {
+    if (otherVis) {
+      // Presume a difference.
+      NS_UpdateHint(hint, NS_STYLE_HINT_VISUAL);
+    } else {
+    }
+  }
+
   return hint;
 }
 
 void
 nsStyleContext::Mark()
 {
   // Mark our rule node.
   mRuleNode->Mark();
diff --git a/layout/style/nsStyleContext.h b/layout/style/nsStyleContext.h
--- a/layout/style/nsStyleContext.h
+++ b/layout/style/nsStyleContext.h
@@ -125,16 +125,28 @@ public:
 
   // Does this style context represent the style for a pseudo-element or
   // inherit data from such a style context?  Whether this returns true
   // is equivalent to whether it or any of its ancestors returns
   // non-null for GetPseudo.
   PRBool HasPseudoElementData() const
     { return !!(mBits & NS_STYLE_HAS_PSEUDO_ELEMENT_DATA); }
 
+  // Is the only link whose visitedness is allowed to influence the
+  // style of the node this style context is for (which is that element
+  // or its nearest ancestor that is a link) visited?
+  PRBool RelevantLinkVisited() const
+    { return !!(mBits & NS_STYLE_RELEVANT_LINK_VISITED); }
+
+  // Return the style context whose style data should be used for the R,
+  // G, and B components of color, background-color, and border-*-color
+  // if RelevantLinkIsVisited().
+  nsStyleContext* StyleIfVisited()
+    { return mStyleIfVisited; }
+
   NS_HIDDEN_(void) SetStyle(nsStyleStructID aSID, void* aStruct);
 
   nsRuleNode* GetRuleNode() { return mRuleNode; }
   void AddStyleBit(const PRUint32& aBit) { mBits |= aBit; }
 
   /*
    * Mark this style context's rule node (and its ancestors) to prevent
    * it from being garbage collected.
@@ -183,29 +195,34 @@ public:
 #endif
 
 protected:
   NS_HIDDEN_(void) AddChild(nsStyleContext* aChild);
   NS_HIDDEN_(void) RemoveChild(nsStyleContext* aChild);
 
   NS_HIDDEN_(void) ApplyStyleFixups(nsPresContext* aPresContext);
 
-  nsStyleContext* const mParent;
+  nsStyleContext* const mParent; // STRONG
 
   // Children are kept in two circularly-linked lists.  The list anchor
   // is not part of the list (null for empty), and we point to the first
   // child.
   // mEmptyChild for children whose rule node is the root rule node, and
   // mChild for other children.  The order of children is not
   // meaningful.
   nsStyleContext* mChild;
   nsStyleContext* mEmptyChild;
   nsStyleContext* mPrevSibling;
   nsStyleContext* mNextSibling;
 
+  // Style to be used instead for the R, G, and B components of color,
+  // background-color, and border-*-color if the nearest ancestor link
+  // element is visited (see RelevantLinkVisited()).
+  nsRefPtr<nsStyleContext> mStyleIfVisited;
+
   // If this style context is for a pseudo-element or anonymous box,
   // the relevant atom.
   nsCOMPtr<nsIAtom> mPseudoTag;
 
   // The rule node is the node in the lexicographic tree of rule nodes
   // (the "rule tree") that indicates which style rules are used to
   // compute the style data, and in what cascading order.  The least
   // specific rule matched is the one whose rule node is a child of the
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -79,16 +79,18 @@ struct nsCSSValueList;
 // NS_STYLE_INHERIT_BIT defined in nsStyleStructFwd.h
 #define NS_STYLE_INHERIT_MASK             0x00ffffff
 
 // Additional bits for nsStyleContext's mBits:
 // See nsStyleContext::HasTextDecorations
 #define NS_STYLE_HAS_TEXT_DECORATIONS     0x01000000
 // See nsStyleContext::HasPseudoElementData.
 #define NS_STYLE_HAS_PSEUDO_ELEMENT_DATA  0x02000000
+// See nsStyleContext::RelevantLinkIsVisited
+#define NS_STYLE_RELEVANT_LINK_VISITED    0x04000000
 // See nsStyleContext::GetPseudoEnum
 #define NS_STYLE_CONTEXT_TYPE_MASK        0xf0000000
 #define NS_STYLE_CONTEXT_TYPE_SHIFT       28
 
 // Additional bits for nsRuleNode's mDependentBits:
 #define NS_RULE_NODE_GC_MARK              0x02000000
 #define NS_RULE_NODE_IS_IMPORTANT         0x08000000
 #define NS_RULE_NODE_LEVEL_MASK           0xf0000000
