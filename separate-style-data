From: L. David Baron <dbaron@dbaron.org>

Add mechanism for separate style data for visited style.  (Bug 147777)  r=bzbarsky

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -7647,16 +7647,23 @@ nsCSSFrameConstructor::DoContentStateCha
 
     nsRestyleHint rshint = 
       styleSet->HasStateDependentStyle(presContext, aContent, aStateMask);
       
     if ((aStateMask & NS_EVENT_STATE_HOVER) && rshint != 0) {
       ++mHoverGeneration;
     }
 
+    if (aStateMask & NS_EVENT_STATE_VISITED) {
+      // Exposing information to the page about whether the link is
+      // visited or not isn't really something we can worry about here.
+      // FIXME: We could probably do this a bit better.
+      NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
+    }
+
     PostRestyleEvent(aContent, rshint, hint);
   }
 }
 
 void
 nsCSSFrameConstructor::AttributeWillChange(nsIContent* aContent,
                                            PRInt32 aNameSpaceID,
                                            nsIAtom* aAttribute,
diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -458,22 +458,121 @@ nsStyleContext::CalcStyleDifference(nsSt
 
   // The following structs cause (as their maximal difference) a
   // re-render to occur.  VISUAL Structs: Color, Background
   DO_STRUCT_DIFFERENCE(Color);
   DO_STRUCT_DIFFERENCE(Background);
 
 #undef DO_STRUCT_DIFFERENCE
 
+  // Note that we do not check whether this->RelevantLinkVisited() !=
+  // aOther->RelevantLinkVisited(); we don't need to since
+  // nsCSSFrameConstructor::DoContentStateChanged always adds
+  // nsChangeHint_RepaintFrame for NS_EVENT_STATE_VISITED changes (and
+  // needs to, since HasStateDependentStyle probably doesn't work right
+  // for NS_EVENT_STATE_VISITED).  Hopefully this doesn't actually
+  // expose whether links are visited to performance tests since all
+  // link coloring happens asynchronously at a time when it's hard for
+  // the page to measure.
+  // However, we do need to compute the larger of the changes that can
+  // happen depending on whether the link is visited or unvisited, since
+  // doing only the one that's currently appropriate would expose which
+  // links are in history to easy performance measurement.  Therefore,
+  // here, we add nsChangeHint_RepaintFrame hints (the maximum for
+  // things that can depend on :visited) for the properties on which we
+  // call GetVisitedDependentColor.
+  nsStyleContext *thisVis = GetStyleIfVisited(),
+                *otherVis = aOther->GetStyleIfVisited();
+  if (!thisVis != !otherVis) {
+    // One style context has a style-if-visited and the other doesn't.
+    // Presume a difference.
+    NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
+  } else if (thisVis && !NS_IsHintSubset(nsChangeHint_RepaintFrame, hint)) {
+    // Both style contexts have a style-if-visited.
+    PRBool change = PR_FALSE;
+
+    // NB: Calling Peek on |this|, not |thisVis|, since callers may look
+    // at a struct on |this| without looking at the same struct on
+    // |thisVis| (including this function if we skip one of these checks
+    // due to change being true already or due to the old style context
+    // not having a style-if-visited), but not the other way around.
+    if (PeekStyleColor()) {
+      if (thisVis->GetStyleColor()->mColor !=
+          otherVis->GetStyleColor()->mColor) {
+        change = PR_TRUE;
+      }
+    }
+
+    // NB: Calling Peek on |this|, not |thisVis| (see above).
+    if (!change && PeekStyleBackground()) {
+      if (thisVis->GetStyleBackground()->mBackgroundColor !=
+          otherVis->GetStyleBackground()->mBackgroundColor) {
+        change = PR_TRUE;
+      }
+    }
+
+    // NB: Calling Peek on |this|, not |thisVis| (see above).
+    if (!change && PeekStyleBorder()) {
+      const nsStyleBorder *thisVisBorder = thisVis->GetStyleBorder();
+      const nsStyleBorder *otherVisBorder = otherVis->GetStyleBorder();
+      NS_FOR_CSS_SIDES(side) {
+        PRBool thisFG, otherFG;
+        nscolor thisColor, otherColor;
+        thisVisBorder->GetBorderColor(side, thisColor, thisFG);
+        otherVisBorder->GetBorderColor(side, otherColor, otherFG);
+        if (thisFG != otherFG || (!thisFG && thisColor != otherColor)) {
+          change = PR_TRUE;
+          break;
+        }
+      }
+    }
+
+    // NB: Calling Peek on |this|, not |thisVis| (see above).
+    if (!change && PeekStyleOutline()) {
+      if (thisVis->GetStyleOutline()->mOutlineColor !=
+          otherVis->GetStyleOutline()->mOutlineColor) {
+        change = PR_TRUE;
+      }
+    }
+
+    // NB: Calling Peek on |this|, not |thisVis| (see above).
+    if (!change && PeekStyleColumn()) {
+      const nsStyleColumn *thisVisColumn = thisVis->GetStyleColumn();
+      const nsStyleColumn *otherVisColumn = otherVis->GetStyleColumn();
+      if (thisVisColumn->mColumnRuleColor != otherVisColumn->mColumnRuleColor ||
+          thisVisColumn->mColumnRuleColorIsForeground !=
+            otherVisColumn->mColumnRuleColorIsForeground) {
+        change = PR_TRUE;
+      }
+    }
+
+    // NB: Calling Peek on |this|, not |thisVis| (see above).
+    if (!change && PeekStyleSVG()) {
+      const nsStyleSVG *thisVisSVG = thisVis->GetStyleSVG();
+      const nsStyleSVG *otherVisSVG = otherVis->GetStyleSVG();
+      if (thisVisSVG->mFill != otherVisSVG->mFill ||
+          thisVisSVG->mStroke != otherVisSVG->mStroke) {
+        change = PR_TRUE;
+      }
+    }
+
+    if (change) {
+      NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
+    }
+  }
+
   return hint;
 }
 
 void
 nsStyleContext::Mark()
 {
+  if (mStyleIfVisited)
+    mStyleIfVisited->Mark();
+
   // Mark our rule node.
   mRuleNode->Mark();
 
   // Mark our children (i.e., tell them to mark their rule nodes, etc.).
   if (mChild) {
     nsStyleContext* child = mChild;
     do {
       child->Mark();
diff --git a/layout/style/nsStyleContext.h b/layout/style/nsStyleContext.h
--- a/layout/style/nsStyleContext.h
+++ b/layout/style/nsStyleContext.h
@@ -125,16 +125,58 @@ public:
 
   // Does this style context represent the style for a pseudo-element or
   // inherit data from such a style context?  Whether this returns true
   // is equivalent to whether it or any of its ancestors returns
   // non-null for GetPseudo.
   PRBool HasPseudoElementData() const
     { return !!(mBits & NS_STYLE_HAS_PSEUDO_ELEMENT_DATA); }
 
+  // Is the only link whose visitedness is allowed to influence the
+  // style of the node this style context is for (which is that element
+  // or its nearest ancestor that is a link) visited?
+  PRBool RelevantLinkVisited() const
+    { return !!(mBits & NS_STYLE_RELEVANT_LINK_VISITED); }
+
+  // Return the style context whose style data should be used for the R,
+  // G, and B components of color, background-color, and border-*-color
+  // if RelevantLinkIsVisited().
+  //
+  // GetPseudo() and GetPseudoType() on this style context return the
+  // same as on |this|, and its depth in the tree (number of GetParent()
+  // calls until null is returned) is the same as |this|, since its
+  // parent is either |this|'s parent or |this|'s parent's
+  // style-if-visited.
+  //
+  // Structs on this context should never be examined without also
+  // examining the corresponding struct on |this|.  Doing so will likely
+  // both (1) lead to a privacy leak and (2) lead to dynamic change bugs
+  // related to the Peek code in nsStyleContext::CalcStyleDifference.
+  nsStyleContext* GetStyleIfVisited()
+    { return mStyleIfVisited; }
+
+  // To be called only from nsStyleSet.
+  void SetStyleIfVisited(already_AddRefed<nsStyleContext> aStyleIfVisited)
+  {
+    NS_ASSERTION(!mStyleIfVisited, "should only be set once");
+    mStyleIfVisited = aStyleIfVisited;
+
+    NS_ASSERTION(GetStyleIfVisited()->GetPseudo() == GetPseudo(),
+                 "pseudo tag mismatch");
+    if (GetParent() && GetParent()->GetStyleIfVisited()) {
+      NS_ASSERTION(GetStyleIfVisited()->GetParent() ==
+                     GetParent()->GetStyleIfVisited() ||
+                   GetStyleIfVisited()->GetParent() == GetParent(),
+                   "parent mismatch");
+    } else {
+      NS_ASSERTION(GetStyleIfVisited()->GetParent() == GetParent(),
+                   "parent mismatch");
+    }
+  }
+
   // Tell this style context to cache aStruct as the struct for aSID
   NS_HIDDEN_(void) SetStyle(nsStyleStructID aSID, void* aStruct);
 
   // Setters for inherit structs only, since rulenode only sets those eagerly.
   #define STYLE_STRUCT_INHERITED(name_, checkdata_cb_, ctor_args_)          \
     void SetStyle##name_ (nsStyle##name_ * aStruct) {                       \
       NS_ASSERTION(!mCachedInheritedData.m##name_##Data ||                  \
                    (mBits &                                                 \
@@ -238,29 +280,34 @@ protected:
         return cachedData;                                              \
       /* Have the rulenode deal */                                      \
       return mRuleNode->GetStyle##name_(this, aComputeData);            \
     }
   #include "nsStyleStructList.h"
   #undef STYLE_STRUCT_RESET
   #undef STYLE_STRUCT_INHERITED
 
-  nsStyleContext* const mParent;
+  nsStyleContext* const mParent; // STRONG
 
   // Children are kept in two circularly-linked lists.  The list anchor
   // is not part of the list (null for empty), and we point to the first
   // child.
   // mEmptyChild for children whose rule node is the root rule node, and
   // mChild for other children.  The order of children is not
   // meaningful.
   nsStyleContext* mChild;
   nsStyleContext* mEmptyChild;
   nsStyleContext* mPrevSibling;
   nsStyleContext* mNextSibling;
 
+  // Style to be used instead for the R, G, and B components of color,
+  // background-color, and border-*-color if the nearest ancestor link
+  // element is visited (see RelevantLinkVisited()).
+  nsRefPtr<nsStyleContext> mStyleIfVisited;
+
   // If this style context is for a pseudo-element or anonymous box,
   // the relevant atom.
   nsCOMPtr<nsIAtom> mPseudoTag;
 
   // The rule node is the node in the lexicographic tree of rule nodes
   // (the "rule tree") that indicates which style rules are used to
   // compute the style data, and in what cascading order.  The least
   // specific rule matched is the one whose rule node is a child of the
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -79,16 +79,18 @@ class imgIContainer;
 // NS_STYLE_INHERIT_BIT defined in nsStyleStructFwd.h
 #define NS_STYLE_INHERIT_MASK             0x00ffffff
 
 // Additional bits for nsStyleContext's mBits:
 // See nsStyleContext::HasTextDecorations
 #define NS_STYLE_HAS_TEXT_DECORATIONS     0x01000000
 // See nsStyleContext::HasPseudoElementData.
 #define NS_STYLE_HAS_PSEUDO_ELEMENT_DATA  0x02000000
+// See nsStyleContext::RelevantLinkIsVisited
+#define NS_STYLE_RELEVANT_LINK_VISITED    0x04000000
 // See nsStyleContext::GetPseudoEnum
 #define NS_STYLE_CONTEXT_TYPE_MASK        0xf0000000
 #define NS_STYLE_CONTEXT_TYPE_SHIFT       28
 
 // Additional bits for nsRuleNode's mDependentBits:
 #define NS_RULE_NODE_GC_MARK              0x02000000
 #define NS_RULE_NODE_IS_IMPORTANT         0x08000000
 #define NS_RULE_NODE_LEVEL_MASK           0xf0000000
