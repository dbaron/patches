From: Olli Pettay <Olli.Pettay@gmail.com>

WIP from attachment 337333 on bug 433533

diff --git a/content/base/src/nsAttrValue.cpp b/content/base/src/nsAttrValue.cpp
--- a/content/base/src/nsAttrValue.cpp
+++ b/content/base/src/nsAttrValue.cpp
@@ -45,17 +45,17 @@
 #include "nsIAtom.h"
 #include "nsUnicharUtils.h"
 #include "nsICSSStyleRule.h"
 #include "nsCSSDeclaration.h"
 #include "nsIHTMLDocument.h"
 #include "nsIDocument.h"
 #include "nsTPtrArray.h"
 #include "nsContentUtils.h"
-
+#include "nsReadableUtils.h"
 #ifdef MOZ_SVG
 #include "nsISVGValue.h"
 #endif
 
 nsTPtrArray<const nsAttrValue::EnumTable>* nsAttrValue::sEnumTableArray = nsnull;
 
 nsAttrValue::nsAttrValue()
     : mBits(0)
@@ -198,84 +198,101 @@ nsAttrValue::SetTo(const nsAttrValue& aO
     {
       ResetIfSet();
       mBits = aOther.mBits;
       return;      
     }
   }
 
   MiscContainer* otherCont = aOther.GetMiscContainer();
+  if (!EnsureEmptyMiscContainer()) {
+    return;
+  }
+
+  MiscContainer* cont = GetMiscContainer();
   switch (otherCont->mType) {
+    case eInteger:
+    {
+      cont->mInteger = otherCont->mInteger;
+      break;
+    }
+    case eEnum:
+    {
+      cont->mEnumValue = otherCont->mEnumValue;
+      break;
+    }
+    case ePercent:
+    {
+      cont->mPercent = otherCont->mPercent;
+      break;
+    }
     case eColor:
     {
-      if (EnsureEmptyMiscContainer()) {
-        MiscContainer* cont = GetMiscContainer();
-        cont->mColor = otherCont->mColor;
-        cont->mType = eColor;
-      }
+      cont->mColor = otherCont->mColor;
       break;
     }
     case eCSSStyleRule:
     {
-      SetTo(otherCont->mCSSStyleRule);
+      NS_ADDREF(cont->mCSSStyleRule = otherCont->mCSSStyleRule);
       break;
     }
     case eAtomArray:
     {
       if (!EnsureEmptyAtomArray() ||
           !GetAtomArrayValue()->AppendObjects(*otherCont->mAtomArray)) {
         Reset();
+        return;
       }
       break;
     }
 #ifdef MOZ_SVG
     case eSVGValue:
     {
-      SetTo(otherCont->mSVGValue);
+      NS_ADDREF(cont->mSVGValue = otherCont->mSVGValue);
+      break;
     }
 #endif
     default:
     {
       NS_NOTREACHED("unknown type stored in MiscContainer");
       break;
     }
   }
+
+  void* otherPtr =
+    reinterpret_cast<void*>(otherCont->mBits & NS_ATTRVALUE_POINTERVALUE_MASK);
+  if (otherPtr) {
+    if (static_cast<ValueBaseType>(otherCont->mBits & NS_ATTRVALUE_BASETYPE_MASK) ==
+        eStringBase) {
+      static_cast<nsStringBuffer*>(otherPtr)->AddRef();
+    } else {
+      static_cast<nsIAtom*>(otherPtr)->AddRef();
+    }
+    cont->mBits = otherCont->mBits;
+  }
+  // Note, set mType after switch-case, otherwise EnsureEmptyAtomArray doesn't
+  // work correctly.
+  cont->mType = otherCont->mType;
 }
 
 void
 nsAttrValue::SetTo(const nsAString& aValue)
 {
   ResetIfSet();
-  if (!aValue.IsEmpty()) {
-    PRUint32 len = aValue.Length();
-
-    nsStringBuffer* buf = nsStringBuffer::FromString(aValue);
-    if (buf && (buf->StorageSize()/sizeof(PRUnichar) - 1) == len) {
-      buf->AddRef();
-      SetPtrValueAndType(buf, eStringBase);
-      return;
-    }
-
-    buf = nsStringBuffer::Alloc((len + 1) * sizeof(PRUnichar));
-    if (!buf) {
-      return;
-    }
-    PRUnichar *data = static_cast<PRUnichar*>(buf->Data());
-    CopyUnicodeTo(aValue, 0, data, len);
-    data[len] = PRUnichar(0);
-
+  nsStringBuffer* buf = GetStringBuffer(aValue);
+  if (buf) {
     SetPtrValueAndType(buf, eStringBase);
   }
 }
 
 void
-nsAttrValue::SetTo(PRInt16 aInt)
+nsAttrValue::SetTo(PRInt16 aInt, const nsAString& aStringValue)
 {
   ResetIfSet();
-  SetIntValueAndType(aInt, eInteger);
+  SetIntValueAndType(aInt, eInteger, &aStringValue);
 }
 
 void
 nsAttrValue::SetTo(nsICSSStyleRule* aValue)
 {
   if (EnsureEmptyMiscContainer()) {
     MiscContainer* cont = GetMiscContainer();
     NS_ADDREF(cont->mCSSStyleRule = aValue);
@@ -320,131 +337,136 @@ nsAttrValue::ToString(nsAString& aResult
     }
     case eAtom:
     {
       nsIAtom *atom = static_cast<nsIAtom*>(GetPtr());
       atom->ToString(aResult);
 
       break;
     }
-    case eInteger:
-    {
-      nsAutoString intStr;
-      intStr.AppendInt(GetIntInternal());
-      aResult = intStr;
-
-      break;
-    }
     case eColor:
     {
       nscolor v;
       GetColorValue(v);
       NS_RGBToHex(v, aResult);
-
-      break;
-    }
-    case eEnum:
-    {
-      PRInt16 val = GetEnumValue();
-      const EnumTable* table = sEnumTableArray->
-          ElementAt(GetIntInternal() & NS_ATTRVALUE_ENUMTABLEINDEX_MASK);
-      while (table->tag) {
-        if (table->value == val) {
-          aResult.AssignASCII(table->tag);
-
-          return;
-        }
-        table++;
-      }
-
-      NS_NOTREACHED("couldn't find value in EnumTable");
-
-      break;
-    }
-    case ePercent:
-    {
-      nsAutoString intStr;
-      intStr.AppendInt(GetIntInternal());
-      aResult = intStr + NS_LITERAL_STRING("%");
 
       break;
     }
     case eCSSStyleRule:
     {
       aResult.Truncate();
       MiscContainer *container = GetMiscContainer();
       nsCSSDeclaration* decl = container->mCSSStyleRule->GetDeclaration();
       if (decl) {
         decl->ToString(aResult);
       }
 
       break;
     }
-    case eAtomArray:
-    {
-      MiscContainer* cont = GetMiscContainer();
-      PRInt32 count = cont->mAtomArray->Count();
-      if (count) {
-        cont->mAtomArray->ObjectAt(0)->ToString(aResult);
-        nsAutoString tmp;
-        PRInt32 i;
-        for (i = 1; i < count; ++i) {
-          cont->mAtomArray->ObjectAt(i)->ToString(tmp);
-          aResult.Append(NS_LITERAL_STRING(" ") + tmp);
-        }
-      }
-      else {
-        aResult.Truncate();
-      }
-      break;
-    }
 #ifdef MOZ_SVG
     case eSVGValue:
     {
       GetMiscContainer()->mSVGValue->GetValueString(aResult);
       break;
     }
 #endif
-    case eFloatValue:
+    default:
     {
-      nsAutoString str;
-      str.AppendFloat(GetFloatValue());
-      aResult = str;
-
-      break;
+      MiscContainer* cont =
+        (BaseType() == eOtherBase) ? GetMiscContainer() : nsnull;
+      void* ptr = cont
+        ? reinterpret_cast<void*>(cont->mBits & NS_ATTRVALUE_POINTERVALUE_MASK)
+        : nsnull;
+      if (ptr) {
+        if (static_cast<ValueBaseType>(cont->mBits & NS_ATTRVALUE_BASETYPE_MASK) ==
+            eStringBase) {
+          nsStringBuffer* str = static_cast<nsStringBuffer*>(ptr);
+          if (str) {
+            str->ToString(str->StorageSize()/sizeof(PRUnichar) - 1, aResult);
+          }
+        } else {
+          nsIAtom *atom = static_cast<nsIAtom*>(ptr);
+          atom->ToString(aResult);
+        }
+      } else {
+        switch (Type()) {
+          case eInteger:
+          {
+            nsAutoString intStr;
+            intStr.AppendInt(GetIntegerValue());
+            aResult = intStr;
+            break;
+          }
+          case eEnum:
+          {
+            PRInt16 val = GetEnumValue();
+            PRUint32 allEnumBits =
+              cont ? cont->mEnumValue : static_cast<PRUint32>(GetIntInternal());
+            const EnumTable* table = sEnumTableArray->
+              ElementAt(allEnumBits & NS_ATTRVALUE_ENUMTABLEINDEX_MASK);
+            while (table->tag) {
+              if (table->value == val) {
+                aResult.AssignASCII(table->tag);
+                if (allEnumBits & NS_ATTRVALUE_ENUMTABLE_VALUE_NEEDS_TO_UPPER) {
+                  ToUpperCase(aResult);
+                }
+                return;
+              }
+              table++;
+            }
+            NS_NOTREACHED("couldn't find value in EnumTable");
+            break;
+          }
+          case ePercent:
+          {
+            nsAutoString intStr;
+            intStr.AppendInt(cont
+              ? GetMiscContainer()->mPercent
+              : GetIntInternal());
+            aResult = intStr + NS_LITERAL_STRING("%");
+            break;
+          }
+          case eFloatValue:
+          {
+            nsAutoString str;
+            str.AppendFloat(cont->mFloatValue);
+            aResult = str;
+            break;
+          }
+          default:
+          {
+            aResult.Truncate();
+            break;
+          }
+        }
+      }
     }
   }
 }
 
 const nsCheapString
 nsAttrValue::GetStringValue() const
 {
   NS_PRECONDITION(Type() == eString, "wrong type");
 
   return nsCheapString(static_cast<nsStringBuffer*>(GetPtr()));
 }
 
 PRBool
 nsAttrValue::GetColorValue(nscolor& aColor) const
 {
   NS_PRECONDITION(Type() == eColor || Type() == eString, "wrong type");
-  switch (BaseType()) {
+  switch (Type()) {
     case eString:
     {
       return GetPtr() && NS_ColorNameToRGB(GetStringValue(), &aColor);
     }
-    case eOtherBase:
+    case eColor:
     {
       aColor = GetMiscContainer()->mColor;
-      
-      break;
-    }
-    case eIntegerBase:
-    {
-      aColor = static_cast<nscolor>(GetIntInternal());
       
       break;
     }
     default:
     {
       NS_NOTREACHED("unexpected basetype");
       
       break;
@@ -510,16 +532,28 @@ nsAttrValue::HashValue() const
       // any warnings or compile-errors. This is what the implementation of
       // NS_PTR_TO_INT32 does to take care of the same problem.
       return mBits - 0;
     }
   }
 
   MiscContainer* cont = GetMiscContainer();
   switch (cont->mType) {
+    case eInteger:
+    {
+      return cont->mInteger;
+    }
+    case eEnum:
+    {
+      return cont->mEnumValue;
+    }
+    case ePercent:
+    {
+      return cont->mPercent;
+    }
     case eColor:
     {
       return cont->mColor;
     }
     case eCSSStyleRule:
     {
       return NS_PTR_TO_INT32(cont->mCSSStyleRule);
     }
@@ -542,17 +576,17 @@ nsAttrValue::HashValue() const
     {
       NS_NOTREACHED("unknown type stored in MiscContainer");
       return 0;
     }
   }
 }
 
 PRBool
-nsAttrValue::Equals(const nsAttrValue& aOther) const
+nsAttrValue::TypeAndValueEquals(const nsAttrValue& aOther) const
 {
   if (BaseType() != aOther.BaseType()) {
     return PR_FALSE;
   }
 
   switch(BaseType()) {
     case eStringBase:
     {
@@ -570,17 +604,40 @@ nsAttrValue::Equals(const nsAttrValue& a
   }
 
   MiscContainer* thisCont = GetMiscContainer();
   MiscContainer* otherCont = aOther.GetMiscContainer();
   if (thisCont->mType != otherCont->mType) {
     return PR_FALSE;
   }
 
+  PRBool needsStringComparison = PR_FALSE;
+  
   switch (thisCont->mType) {
+    case eInteger:
+    {
+      if (thisCont->mInteger == otherCont->mInteger) {
+        needsStringComparison = PR_TRUE;
+      }
+      break;
+    }
+    case eEnum:
+    {
+      if (thisCont->mEnumValue == otherCont->mEnumValue) {
+        needsStringComparison = PR_TRUE;
+      }
+      break;
+    }
+    case ePercent:
+    {
+      if (thisCont->mPercent == otherCont->mPercent) {
+        needsStringComparison = PR_TRUE;
+      }
+      break;
+    }
     case eColor:
     {
       return thisCont->mColor == otherCont->mColor;
     }
     case eCSSStyleRule:
     {
       return thisCont->mCSSStyleRule == otherCont->mCSSStyleRule;
     }
@@ -596,30 +653,37 @@ nsAttrValue::Equals(const nsAttrValue& a
 
       PRInt32 i;
       for (i = 0; i < count; ++i) {
         if (thisCont->mAtomArray->ObjectAt(i) !=
             otherCont->mAtomArray->ObjectAt(i)) {
           return PR_FALSE;
         }
       }
-      return PR_TRUE;
+      needsStringComparison = PR_TRUE;
+      break;
     }
 #ifdef MOZ_SVG
     case eSVGValue:
     {
       return thisCont->mSVGValue == otherCont->mSVGValue;
     }
 #endif
     default:
     {
       NS_NOTREACHED("unknown type stored in MiscContainer");
       return PR_FALSE;
     }
   }
+  if (needsStringComparison) {
+    nsAutoString otherValue;
+    aOther.ToString(otherValue);
+    return Equals(otherValue, eCaseMatters);
+  }
+  return PR_FALSE;
 }
 
 PRBool
 nsAttrValue::Equals(const nsAString& aValue,
                     nsCaseTreatment aCaseSensitive) const
 {
   switch (BaseType()) {
     case eStringBase:
@@ -736,19 +800,21 @@ nsAttrValue::ParseAtom(const nsAString& 
 }
 
 void
 nsAttrValue::ParseAtomArray(const nsAString& aValue)
 {
   nsAString::const_iterator iter, end;
   aValue.BeginReading(iter);
   aValue.EndReading(end);
-
+  PRBool hasSpace = PR_FALSE;
+  
   // skip initial whitespace
   while (iter != end && nsContentUtils::IsHTMLWhitespace(*iter)) {
+    hasSpace = PR_TRUE;
     ++iter;
   }
 
   if (iter == end) {
     ResetIfSet();
     return;
   }
 
@@ -762,21 +828,23 @@ nsAttrValue::ParseAtomArray(const nsAStr
   nsCOMPtr<nsIAtom> classAtom = do_GetAtom(Substring(start, iter));
   if (!classAtom) {
     Reset();
     return;
   }
 
   // skip whitespace
   while (iter != end && nsContentUtils::IsHTMLWhitespace(*iter)) {
+    hasSpace = PR_TRUE;
     ++iter;
   }
 
-  if (iter == end) {
-    // we only found one classname so don't bother storing a list
+  if (iter == end && !hasSpace) {
+    // we only found one classname and there was no whitespace so
+    // don't bother storing a list
     ResetIfSet();
     nsIAtom* atom = nsnull;
     classAtom.swap(atom);
     SetPtrValueAndType(atom, eAtomBase);
     return;
   }
 
   if (!EnsureEmptyAtomArray()) {
@@ -786,17 +854,17 @@ nsAttrValue::ParseAtomArray(const nsAStr
   nsCOMArray<nsIAtom>* array = GetAtomArrayValue();
   
   if (!array->AppendObject(classAtom)) {
     Reset();
     return;
   }
 
   // parse the rest of the classnames
-  do {
+  while (iter != end) {
     start = iter;
 
     do {
       ++iter;
     } while (iter != end && !nsContentUtils::IsHTMLWhitespace(*iter));
 
     classAtom = do_GetAtom(Substring(start, iter));
 
@@ -804,32 +872,72 @@ nsAttrValue::ParseAtomArray(const nsAStr
       Reset();
       return;
     }
 
     // skip whitespace
     while (iter != end && nsContentUtils::IsHTMLWhitespace(*iter)) {
       ++iter;
     }
-  } while (iter != end);
+  }
 
+  SetMiscAtomOrString(&aValue);
   return;
 }
 
 void
 nsAttrValue::ParseStringOrAtom(const nsAString& aValue)
 {
   PRUint32 len = aValue.Length();
   // Don't bother with atoms if it's an empty string since
   // we can store those efficently anyway.
   if (len && len <= NS_ATTRVALUE_MAX_STRINGLENGTH_ATOM) {
     ParseAtom(aValue);
   }
   else {
     SetTo(aValue);
+  }
+}
+
+void
+nsAttrValue::SetIntValueAndType(PRInt32 aValue, ValueType aType,
+                                const nsAString* aStringValue)
+{
+  if (aStringValue || aValue > NS_ATTRVALUE_INTEGERTYPE_MAXVALUE ||
+      aValue < NS_ATTRVALUE_INTEGERTYPE_MINVALUE) {
+    if (EnsureEmptyMiscContainer()) {
+      MiscContainer* cont = GetMiscContainer();
+      switch (aType) {
+        case eInteger:
+        {
+          cont->mInteger = aValue;
+          break;
+        }
+        case ePercent:
+        {
+          cont->mPercent = aValue;
+          break;
+        }
+        case eEnum:
+        {
+          cont->mEnumValue = aValue;
+          break;
+        }
+        default:
+        {
+          NS_NOTREACHED("unknown integer type");
+          break;
+        }
+      }
+      cont->mType = aType;
+      SetMiscAtomOrString(aStringValue);
+    }
+  } else {
+    NS_ASSERTION(!mBits, "Reset before calling SetIntValueAndType!");
+    mBits = (aValue * NS_ATTRVALUE_INTEGERTYPE_MULTIPLIER) | aType;
   }
 }
 
 PRBool
 nsAttrValue::ParseEnumValue(const nsAString& aValue,
                             const EnumTable* aTable,
                             PRBool aCaseSensitive)
 {
@@ -838,27 +946,34 @@ nsAttrValue::ParseEnumValue(const nsAStr
   while (aTable->tag) {
     if (aCaseSensitive ? aValue.EqualsASCII(aTable->tag) :
                          aValue.LowerCaseEqualsASCII(aTable->tag)) {
 
       // Find index of EnumTable
       PRInt16 index = sEnumTableArray->IndexOf(aTable);
       if (index < 0) {
         index = sEnumTableArray->Length();
-        NS_ASSERTION(index <= NS_ATTRVALUE_ENUMTABLEINDEX_MAXVALUE,
-                     "too many enum tables");
         if (!sEnumTableArray->AppendElement(aTable)) {
           return PR_FALSE;
         }
       }
 
       PRInt32 value = (aTable->value << NS_ATTRVALUE_ENUMTABLEINDEX_BITS) +
                       index;
 
-      SetIntValueAndType(value, eEnum);
+      PRBool equals = aCaseSensitive || aValue.EqualsASCII(aTable->tag);
+      if (!equals) {
+        nsAutoString tag;
+        tag.AssignASCII(aTable->tag);
+        ToUpperCase(tag);
+        if ((equals = tag.Equals(aValue))) {
+          value |= NS_ATTRVALUE_ENUMTABLE_VALUE_NEEDS_TO_UPPER;
+        }
+      }
+      SetIntValueAndType(value, eEnum, equals ? nsnull : &aValue);
       NS_ASSERTION(GetEnumValue() == aTable->value,
                    "failed to store enum properly");
 
       return PR_TRUE;
     }
     aTable++;
   }
 
@@ -867,60 +982,63 @@ nsAttrValue::ParseEnumValue(const nsAStr
 
 PRBool
 nsAttrValue::ParseSpecialIntValue(const nsAString& aString,
                                   PRBool aCanBePercent)
 {
   ResetIfSet();
 
   PRInt32 ec;
+  PRBool strict;
+  PRBool isPercent = PR_FALSE;
   nsAutoString tmp(aString);
-  PRInt32 val = tmp.ToInteger(&ec);
+  PRInt32 originalVal = StringToInteger(aString, &strict, &ec, aCanBePercent, &isPercent);
 
   if (NS_FAILED(ec)) {
     return PR_FALSE;
   }
 
-  val = PR_MAX(val, 0);
-  val = PR_MIN(val, NS_ATTRVALUE_INTEGERTYPE_MAXVALUE);
+  PRInt32 val = PR_MAX(originalVal, 0);
 
   // % (percent)
   // XXX RFindChar means that 5%x will be parsed!
-  if (aCanBePercent && tmp.RFindChar('%') >= 0) {
+  if (aCanBePercent && (isPercent || tmp.RFindChar('%') >= 0)) {
     if (val > 100) {
       val = 100;
     }
-    SetIntValueAndType(val, ePercent);
-    return PR_TRUE;
+    isPercent = PR_TRUE;
   }
 
-  // Straight number is interpreted as integer
-  SetIntValueAndType(val, eInteger);
+  strict = strict && (originalVal == val);
+
+  SetIntValueAndType(val,
+                     isPercent ? ePercent : eInteger,
+                     strict ? nsnull : &aString);
   return PR_TRUE;
 }
 
 PRBool
 nsAttrValue::ParseIntWithBounds(const nsAString& aString,
                                 PRInt32 aMin, PRInt32 aMax)
 {
-  NS_PRECONDITION(aMin < aMax &&
-                  aMin >= NS_ATTRVALUE_INTEGERTYPE_MINVALUE &&
-                  aMax <= NS_ATTRVALUE_INTEGERTYPE_MAXVALUE, "bad boundaries");
+  NS_PRECONDITION(aMin < aMax, "bad boundaries");
 
   ResetIfSet();
 
   PRInt32 ec;
-  PRInt32 val = PromiseFlatString(aString).ToInteger(&ec);
+  PRBool strict;
+  PRInt32 originalVal = StringToInteger(aString, &strict, &ec);
   if (NS_FAILED(ec)) {
     return PR_FALSE;
   }
 
-  val = PR_MAX(val, aMin);
+  PRInt32 val = PR_MAX(originalVal, aMin);
   val = PR_MIN(val, aMax);
-  SetIntValueAndType(val, eInteger);
+  strict = strict && (originalVal == val);
+  SetIntValueAndType(val, eInteger, strict ? nsnull : &aString);
 
   return PR_TRUE;
 }
 
 PRBool
 nsAttrValue::ParseColor(const nsAString& aString, nsIDocument* aDocument)
 {
   nsAutoString colorStr(aString);
@@ -949,23 +1067,17 @@ nsAttrValue::ParseColor(const nsAString&
     }
     colorStr.Cut(0, 1);
     if (!NS_HexToRGB(colorStr, &color)) {
       Reset();
       return PR_FALSE;
     }
   }
 
-  PRInt32 colAsInt = static_cast<PRInt32>(color);
-  PRInt32 tmp = colAsInt * NS_ATTRVALUE_INTEGERTYPE_MULTIPLIER;
-  if (tmp / NS_ATTRVALUE_INTEGERTYPE_MULTIPLIER == colAsInt) {
-    ResetIfSet();
-    SetIntValueAndType(colAsInt, eColor);
-  }
-  else if (EnsureEmptyMiscContainer()) {
+  if (EnsureEmptyMiscContainer()) {
     MiscContainer* cont = GetMiscContainer();
     cont->mColor = color;
     cont->mType = eColor;
   }
 
   return PR_TRUE;
 }
 
@@ -973,25 +1085,68 @@ PRBool nsAttrValue::ParseFloatValue(cons
 {
   ResetIfSet();
 
   PRInt32 ec;
   float val = PromiseFlatString(aString).ToFloat(&ec);
   if (NS_FAILED(ec)) {
     return PR_FALSE;
   }
-  SetFloatValue(val);
+  nsAutoString serializedFloat;
+  serializedFloat.AppendFloat(val);
+  SetFloatValue(val, serializedFloat.Equals(aString) ? nsnull : &aString);
   return PR_TRUE;
+}
+
+void
+nsAttrValue::SetMiscAtomOrString(const nsAString* aValue)
+{
+  NS_ASSERTION(GetMiscContainer(), "Must have MiscContainer!");
+  NS_ASSERTION(!GetMiscContainer()->mBits, "Trying to re-set atom or string!");
+  if (aValue) {
+    PRUint32 len = aValue->Length();
+    if (len) {
+      MiscContainer* cont = GetMiscContainer();
+      if (len <= NS_ATTRVALUE_MAX_STRINGLENGTH_ATOM) {
+        nsIAtom* atom = NS_NewAtom(*aValue);
+        if (atom) {
+          cont->mBits = reinterpret_cast<PtrBits>(atom) | eAtomBase;
+        }
+      } else {
+        nsStringBuffer* buf = GetStringBuffer(*aValue);
+        if (buf) {
+          cont->mBits = reinterpret_cast<PtrBits>(buf) | eStringBase;
+        }
+      }
+    }
+  }
+}
+
+void
+nsAttrValue::ResetMiscAtomOrString()
+{
+  MiscContainer* cont = GetMiscContainer();
+  void* ptr = reinterpret_cast<void*>(cont->mBits & NS_ATTRVALUE_POINTERVALUE_MASK);
+  if (ptr) {
+    if (static_cast<ValueBaseType>(cont->mBits & NS_ATTRVALUE_BASETYPE_MASK) ==
+        eStringBase) {
+      static_cast<nsStringBuffer*>(ptr)->Release();
+    } else {
+      static_cast<nsIAtom*>(ptr)->Release();
+    }
+    cont->mBits = 0;
+  }
 }
 
 PRBool
 nsAttrValue::EnsureEmptyMiscContainer()
 {
   MiscContainer* cont;
   if (BaseType() == eOtherBase) {
+    ResetMiscAtomOrString();
     cont = GetMiscContainer();
     switch (cont->mType) {
       case eCSSStyleRule:
       {
         NS_RELEASE(cont->mCSSStyleRule);
         break;
       }
       case eAtomArray:
@@ -1017,25 +1172,27 @@ nsAttrValue::EnsureEmptyMiscContainer()
 
     cont = new MiscContainer;
     NS_ENSURE_TRUE(cont, PR_FALSE);
 
     SetPtrValueAndType(cont, eOtherBase);
   }
 
   cont->mType = eColor;
+  cont->mBits = 0;
   cont->mColor = 0;
 
   return PR_TRUE;
 }
 
 PRBool
 nsAttrValue::EnsureEmptyAtomArray()
 {
   if (Type() == eAtomArray) {
+    ResetMiscAtomOrString();
     GetAtomArrayValue()->Clear();
     return PR_TRUE;
   }
 
   if (!EnsureEmptyMiscContainer()) {
     // should already be reset
     return PR_FALSE;
   }
@@ -1047,8 +1204,104 @@ nsAttrValue::EnsureEmptyAtomArray()
   }
 
   MiscContainer* cont = GetMiscContainer();
   cont->mAtomArray = array;
   cont->mType = eAtomArray;
 
   return PR_TRUE;
 }
+
+nsStringBuffer*
+nsAttrValue::GetStringBuffer(const nsAString& aValue) const
+{
+  PRUint32 len = aValue.Length();
+  if (!len) {
+    return nsnull;
+  }
+
+  nsStringBuffer* buf = nsStringBuffer::FromString(aValue);
+  if (buf && (buf->StorageSize()/sizeof(PRUnichar) - 1) == len) {
+    buf->AddRef();
+    return buf;
+  }
+
+  buf = nsStringBuffer::Alloc((len + 1) * sizeof(PRUnichar));
+  if (!buf) {
+    return nsnull;
+  }
+  PRUnichar *data = static_cast<PRUnichar*>(buf->Data());
+  CopyUnicodeTo(aValue, 0, data, len);
+  data[len] = PRUnichar(0);
+  return buf;
+}
+
+PRInt32
+nsAttrValue::StringToInteger(const nsAString& aValue, PRBool* aStrict,
+                             PRInt32* aErrorCode,
+                             PRBool aCanBePercent,
+                             PRBool* aIsPercent) const
+{
+  *aStrict = PR_FALSE;
+  *aErrorCode = NS_ERROR_ILLEGAL_VALUE;
+  if (aCanBePercent) {
+    *aIsPercent = PR_FALSE;
+  }
+
+  nsAString::const_iterator iter, end;
+  aValue.BeginReading(iter);
+  aValue.EndReading(end);
+  PRBool negate = PR_FALSE;
+  PRInt32 value = 0;
+  if (iter != end) {
+    if (*iter == PRUnichar('-')) {
+      negate = PR_TRUE;
+      ++iter;
+    }
+    if (iter != end) {
+      if ((*iter >= PRUnichar('1') || (*iter == PRUnichar('0') && !negate)) &&
+          *iter <= PRUnichar('9')) {
+        value = *iter - PRUnichar('0');
+        ++iter;
+        *aStrict = (value != 0 || iter == end ||
+                    (aCanBePercent && *iter == PRUnichar('%')));
+        while (iter != end && *aStrict) {
+          if (*iter >= PRUnichar('0') && *iter <= PRUnichar('9')) {
+            value = (value * 10) + (*iter - PRUnichar('0'));
+            ++iter;
+            if (iter != end && value > ((PR_INT32_MAX / 10) - 9)) {
+              *aStrict = PR_FALSE;
+            }
+          } else if (aCanBePercent && *iter == PRUnichar('%')) {
+            ++iter;
+            if (iter == end) {
+              *aIsPercent = PR_TRUE;
+            } else {
+              *aStrict = PR_FALSE;
+            }
+          } else {
+            *aStrict = PR_FALSE;
+          }
+        }
+        if (*aStrict) {
+          if (negate) {
+            value = -value;
+          }
+          if (!aCanBePercent || !*aIsPercent) {
+            *aErrorCode = NS_OK;
+#ifdef DEBUG
+            nsAutoString stringValue;
+            stringValue.AppendInt(value);
+            if (aCanBePercent && *aIsPercent) {
+              stringValue.AppendLiteral("%");
+            }
+            NS_ASSERTION(stringValue.Equals(aValue), "Wrong conversion!");
+#endif
+            return value;
+          }
+        }
+      }
+    }
+  }
+
+  nsAutoString tmp(aValue);
+  return tmp.ToInteger(aErrorCode);
+}
diff --git a/content/base/src/nsAttrValue.h b/content/base/src/nsAttrValue.h
--- a/content/base/src/nsAttrValue.h
+++ b/content/base/src/nsAttrValue.h
@@ -66,18 +66,19 @@ template<class E> class nsTPtrArray;
 
 #define NS_ATTRVALUE_INTEGERTYPE_BITS 4
 #define NS_ATTRVALUE_INTEGERTYPE_MASK (PtrBits((1 << NS_ATTRVALUE_INTEGERTYPE_BITS) - 1))
 #define NS_ATTRVALUE_INTEGERTYPE_MULTIPLIER (1 << NS_ATTRVALUE_INTEGERTYPE_BITS)
 #define NS_ATTRVALUE_INTEGERTYPE_MAXVALUE ((1 << (31 - NS_ATTRVALUE_INTEGERTYPE_BITS)) - 1)
 #define NS_ATTRVALUE_INTEGERTYPE_MINVALUE (-NS_ATTRVALUE_INTEGERTYPE_MAXVALUE - 1)
 
 #define NS_ATTRVALUE_ENUMTABLEINDEX_BITS (32 - 16 - NS_ATTRVALUE_INTEGERTYPE_BITS)
-#define NS_ATTRVALUE_ENUMTABLEINDEX_MAXVALUE ((1 << NS_ATTRVALUE_ENUMTABLEINDEX_BITS) - 1)
-#define NS_ATTRVALUE_ENUMTABLEINDEX_MASK (PtrBits((1 << NS_ATTRVALUE_ENUMTABLEINDEX_BITS) - 1))
+#define NS_ATTRVALUE_ENUMTABLE_VALUE_NEEDS_TO_UPPER (1 << (NS_ATTRVALUE_ENUMTABLEINDEX_BITS - 1))
+#define NS_ATTRVALUE_ENUMTABLEINDEX_MASK \
+  (PtrBits((((1 << NS_ATTRVALUE_ENUMTABLEINDEX_BITS) - 1) &~ NS_ATTRVALUE_ENUMTABLE_VALUE_NEEDS_TO_UPPER)))
 
 /**
  * A class used to construct a nsString from a nsStringBuffer (we might
  * want to move this to nsString at some point).
  */
 class nsCheapString : public nsString {
 public:
   nsCheapString(nsStringBuffer* aBuf)
@@ -105,33 +106,31 @@ public:
   enum ValueType {
     eString =       0x00, //   00
                           //   01  this value indicates an 'misc' struct
     eAtom =         0x02, //   10
     eInteger =      0x03, // 0011
     eColor =        0x07, // 0111
     eEnum =         0x0B, // 1011  This should eventually die
     ePercent =      0x0F, // 1111
-    // Values below here won't matter, they'll be stored in the 'misc' struct
-    // anyway
     eCSSStyleRule = 0x10,
     eAtomArray =    0x11 
 #ifdef MOZ_SVG
     ,eSVGValue =    0x12
 #endif
     ,eFloatValue  = 0x13
   };
 
   ValueType Type() const;
 
   void Reset();
 
   void SetTo(const nsAttrValue& aOther);
   void SetTo(const nsAString& aValue);
-  void SetTo(PRInt16 aInt);
+  void SetTo(PRInt16 aInt, const nsAString& aStringValue);
   void SetTo(nsICSSStyleRule* aValue);
 #ifdef MOZ_SVG
   void SetTo(nsISVGValue* aValue);
 #endif
 
   void SwapValueWith(nsAttrValue& aOther);
 
   void ToString(nsAString& aResult) const;
@@ -156,17 +155,19 @@ public:
   // Returns the number of atoms we have; 0 if we have none.  It's OK
   // to call this without checking the type first; it handles that.
   PRInt32 GetAtomCount() const;
   // Returns the atom at aIndex (0-based).  Do not call this with
   // aIndex >= GetAtomCount().
   nsIAtom* AtomAt(PRInt32 aIndex) const;
 
   PRUint32 HashValue() const;
-  PRBool Equals(const nsAttrValue& aOther) const;
+  // TypeAndValueEquals compares the type and value of naAttrValue objects,
+  // not the string values.
+  PRBool TypeAndValueEquals(const nsAttrValue& aOther) const;
   PRBool Equals(const nsAString& aValue, nsCaseTreatment aCaseSensitive) const;
   PRBool Equals(nsIAtom* aValue, nsCaseTreatment aCaseSensitive) const;
 
   /**
    * Returns true if this AttrValue is equal to the given atom, or is an
    * array which contains the given atom.
    */
   PRBool Contains(nsIAtom* aValue, nsCaseTreatment aCaseSensitive) const;
@@ -219,30 +220,29 @@ public:
 
   /**
    * Parse a string value into an integer.
    *
    * @param aString the string to parse
    * @return whether the value could be parsed
    */
   PRBool ParseIntValue(const nsAString& aString) {
-    return ParseIntWithBounds(aString, NS_ATTRVALUE_INTEGERTYPE_MINVALUE,
-                              NS_ATTRVALUE_INTEGERTYPE_MAXVALUE);
+    return ParseIntWithBounds(aString, PR_INT32_MIN, PR_INT32_MAX);
   }
 
   /**
    * Parse a string value into an integer with minimum value and maximum value.
    *
    * @param aString the string to parse
    * @param aMin the minimum value (if value is less it will be bumped up)
    * @param aMax the maximum value (if value is greater it will be chopped down)
    * @return whether the value could be parsed
    */
   PRBool ParseIntWithBounds(const nsAString& aString, PRInt32 aMin,
-                            PRInt32 aMax = NS_ATTRVALUE_INTEGERTYPE_MAXVALUE);
+                            PRInt32 aMax = PR_INT32_MAX);
 
   /**
    * Parse a string into a color.
    *
    * @param aString the string to parse
    * @param aDocument the document (to find out whether we're in quirks mode)
    * @return whether the value could be parsed
    */
@@ -263,40 +263,58 @@ private:
     eOtherBase =     0x01,       // 01
     eAtomBase =      eAtom,      // 10
     eIntegerBase =   0x03        // 11
   };
 
   struct MiscContainer
   {
     ValueType mType;
+    // mBits points to either nsIAtom* or nsStringBuffer* and is used when mType
+    // isn't mCSSStyleRule or eSVGValue.
+    // Note eStringBase and eAtomBase is used also to handle the type of mBits.
+    PtrBits mBits;
     union {
+      PRInt32 mInteger;
       nscolor mColor;
+      PRUint32 mEnumValue;
+      PRInt32 mPercent;
       nsICSSStyleRule* mCSSStyleRule;
       nsCOMArray<nsIAtom>* mAtomArray;
 #ifdef MOZ_SVG
       nsISVGValue* mSVGValue;
 #endif
       float mFloatValue;
     };
   };
 
   inline ValueBaseType BaseType() const;
 
   inline void SetPtrValueAndType(void* aValue, ValueBaseType aType);
-  inline void SetIntValueAndType(PRInt32 aValue, ValueType aType);
-  inline void SetFloatValue(float aValue);
+  void SetIntValueAndType(PRInt32 aValue, ValueType aType,
+                          const nsAString* aStringValue);
+  void SetMiscAtomOrString(const nsAString* aValue);
+  void ResetMiscAtomOrString();
+  inline void SetFloatValue(float aValue, const nsAString* aStringValue);
   inline void ResetIfSet();
 
   inline void* GetPtr() const;
   inline MiscContainer* GetMiscContainer() const;
   inline PRInt32 GetIntInternal() const;
 
   PRBool EnsureEmptyMiscContainer();
   PRBool EnsureEmptyAtomArray();
+  nsStringBuffer* GetStringBuffer(const nsAString& aValue) const;
+  // aStrict is set PR_TRUE if stringifying the return value equals with
+  // aValue.
+  PRInt32 StringToInteger(const nsAString& aValue,
+                          PRBool* aStrict,
+                          PRInt32* aErrorCode,
+                          PRBool aCanBePercent = PR_FALSE,
+                          PRBool* aIsPercent = nsnull) const;
 
   static nsTPtrArray<const EnumTable>* sEnumTableArray;
 
   PtrBits mBits;
 };
 
 /**
  * Implementation of inline methods
@@ -308,35 +326,42 @@ nsAttrValue::GetAtomValue() const
   NS_PRECONDITION(Type() == eAtom, "wrong type");
   return reinterpret_cast<nsIAtom*>(GetPtr());
 }
 
 inline PRInt32
 nsAttrValue::GetIntegerValue() const
 {
   NS_PRECONDITION(Type() == eInteger, "wrong type");
-  return GetIntInternal();
+  return (BaseType() == eIntegerBase)
+         ? GetIntInternal()
+         : GetMiscContainer()->mInteger;
 }
 
 inline PRInt16
 nsAttrValue::GetEnumValue() const
 {
   NS_PRECONDITION(Type() == eEnum, "wrong type");
   // We don't need to worry about sign extension here since we're
   // returning an PRInt16 which will cut away the top bits.
-  return static_cast<PRInt16>
-                    (GetIntInternal() >> NS_ATTRVALUE_ENUMTABLEINDEX_BITS);
+  return static_cast<PRInt16>((
+    (BaseType() == eIntegerBase)
+    ? static_cast<PRUint32>(GetIntInternal())
+    : GetMiscContainer()->mEnumValue)
+      >> NS_ATTRVALUE_ENUMTABLEINDEX_BITS);
 }
 
 inline float
 nsAttrValue::GetPercentValue() const
 {
   NS_PRECONDITION(Type() == ePercent, "wrong type");
-  return static_cast<float>(GetIntInternal()) /
-         100.0f;
+  return ((BaseType() == eIntegerBase)
+          ? GetIntInternal()
+          : GetMiscContainer()->mPercent)
+            / 100.0f;
 }
 
 inline nsCOMArray<nsIAtom>*
 nsAttrValue::GetAtomArrayValue() const
 {
   NS_PRECONDITION(Type() == eAtomArray, "wrong type");
   return GetMiscContainer()->mAtomArray;
 }
@@ -374,35 +399,23 @@ nsAttrValue::SetPtrValueAndType(void* aV
 nsAttrValue::SetPtrValueAndType(void* aValue, ValueBaseType aType)
 {
   NS_ASSERTION(!(NS_PTR_TO_INT32(aValue) & ~NS_ATTRVALUE_POINTERVALUE_MASK),
                "pointer not properly aligned, this will crash");
   mBits = reinterpret_cast<PtrBits>(aValue) | aType;
 }
 
 inline void
-nsAttrValue::SetIntValueAndType(PRInt32 aValue, ValueType aType)
-{
-#ifdef DEBUG
-  {
-    PRInt32 tmp = aValue * NS_ATTRVALUE_INTEGERTYPE_MULTIPLIER;
-    NS_ASSERTION(tmp / NS_ATTRVALUE_INTEGERTYPE_MULTIPLIER == aValue,
-                 "Integer too big to fit");
-  }
-#endif
-  mBits = (aValue * NS_ATTRVALUE_INTEGERTYPE_MULTIPLIER) | aType;
-}
-
-inline void
-nsAttrValue::SetFloatValue(float aValue)
+nsAttrValue::SetFloatValue(float aValue, const nsAString* aStringValue)
 {
   if (EnsureEmptyMiscContainer()) {
     MiscContainer* cont = GetMiscContainer();
     cont->mFloatValue = aValue;
     cont->mType = eFloatValue;
+    SetMiscAtomOrString(aStringValue);
   }
 }
 inline void
 nsAttrValue::ResetIfSet()
 {
   if (mBits) {
     Reset();
   }
diff --git a/content/base/src/nsMappedAttributes.cpp b/content/base/src/nsMappedAttributes.cpp
--- a/content/base/src/nsMappedAttributes.cpp
+++ b/content/base/src/nsMappedAttributes.cpp
@@ -160,17 +160,17 @@ nsMappedAttributes::Equals(const nsMappe
 
   if (mRuleMapper != aOther->mRuleMapper || mAttrCount != aOther->mAttrCount) {
     return PR_FALSE;
   }
 
   PRUint32 i;
   for (i = 0; i < mAttrCount; ++i) {
     if (!Attrs()[i].mName.Equals(aOther->Attrs()[i].mName) ||
-        !Attrs()[i].mValue.Equals(aOther->Attrs()[i].mValue)) {
+        !Attrs()[i].mValue.TypeAndValueEquals(aOther->Attrs()[i].mValue)) {
       return PR_FALSE;
     }
   }
 
   return PR_TRUE;
 }
 
 PRUint32
diff --git a/content/base/test/Makefile.in b/content/base/test/Makefile.in
--- a/content/base/test/Makefile.in
+++ b/content/base/test/Makefile.in
@@ -77,16 +77,17 @@ _TEST_FILES = 	test_bug5141.html \
 _TEST_FILES = 	test_bug5141.html \
 		test_bug51034.html \
 		test_bug199959.html \
 		test_bug218236.html \
 		file_bug218236_multipart.txt \
 		file_bug218236_multipart.txt^headers^ \
 		test_bug218277.html \
 		test_bug238409.html \
+		test_bug254337.html \
 		test_bug276037-1.html \
 		test_bug276037-2.xhtml \
 		test_bug308484.html \
 		test_bug311681.xml \
 		test_bug322317.html \
 		test_bug330925.xhtml \
 		test_bug337631.html \
 		test_bug338541.xhtml \
@@ -189,16 +190,17 @@ _TEST_FILES = 	test_bug5141.html \
 		test_bug435425.html \
 		bug435425.sjs \
 		bug435425_redirect.sjs \
 		test_bug438519.html \
 		test_bug444722.html \
 		test_bug451376.html \
 		test_text_replaceWholeText.html \
 		test_text_wholeText.html \
+		test_bug433533.html \
 		wholeTexty-helper.xml \
 		test_bug444030.xhtml \
 		test_NodeIterator_basics_filters.xhtml \
 		test_NodeIterator_mutations_1.xhtml \
 		test_NodeIterator_mutations_2.html \
 		test_bug28293.html \
 		file_bug28293.sjs \
 		test_bug445225.html \
diff --git a/content/base/test/test_bug254337.html b/content/base/test/test_bug254337.html
new file mode 100644
--- /dev/null
+++ b/content/base/test/test_bug254337.html
@@ -0,0 +1,42 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=254337
+-->
+<head>
+  <title>Test for Bug 254337</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=254337">Mozilla Bug 254337</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 254337 **/
+
+var el = document.createElement("div");
+el.setAttribute("class", "foobar1");
+is(el.className, "foobar1", "Wrong className!");
+el.className += " foobar2 ";
+is(el.className, "foobar1 foobar2 ", "Appending to className didn't work!");
+el.className += "foobar3";
+is(el.className, "foobar1 foobar2 foobar3", "Appending to className didn't work!");
+
+var el = document.createElement("div");
+el.setAttribute("class", " foobar1 ");
+is(el.className, " foobar1 ", "Wrong className!");
+el.className += "foobar2";
+is(el.className, " foobar1 foobar2", "Appending to className didn't work!");
+
+
+</script>
+</pre>
+</body>
+</html>
+
diff --git a/content/base/test/test_bug433533.html b/content/base/test/test_bug433533.html
new file mode 100644
--- /dev/null
+++ b/content/base/test/test_bug433533.html
@@ -0,0 +1,245 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=433533
+-->
+<head>
+  <title>Test for Bug 433533</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=433533">Mozilla Bug 433533</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 433533 **/
+
+var input = document.createElement("input");
+input.setAttribute("type", "hidden");
+is(input.getAttribute("type"), "hidden", "Setting type attribute didn't work!");
+input.setAttribute("type", "hiDDen");
+is(input.getAttribute("type"), "hiDDen", "Type attribute didn't store the original value");
+is(input.type, "hidden", "Wrong input.type!");
+input.setAttribute("type", "HIDDEN");
+is(input.getAttribute("type"), "HIDDEN", "Type attribute didn't store the original value");
+is(input.type, "hidden", "Wrong input.type!");
+
+var td = document.createElement("td");
+td.setAttribute("scope", "rOW");
+is(td.getAttribute("scope"), "rOW", "Scope attribute didn't store the original value");
+td.setAttribute("scope", "row");
+is(td.getAttribute("scope"), "row", "Scope attribute didn't store the original value");
+td.setAttribute("colspan", "100k");
+is(td.getAttribute("colspan"), "100k", "Colspan attribute didn't store the original value");
+td.setAttribute("colspan", " 100 ");
+is(td.getAttribute("colspan"), " 100 ", "Colspan attribute didn't store the original value");
+td.setAttribute("colspan", "100");
+is(td.getAttribute("colspan"), "100", "Colspan attribute didn't store the original value");
+
+// Note, if colspan is negative, it is set to 1, because of backwards compatibility.
+// @see nsHTMLTableCellElement::ParseAttribute
+td.setAttribute("colspan", "-100k");
+is(td.getAttribute("colspan"), "1", "Colspan attribute didn't store the original value");
+td.setAttribute("colspan", " -100 ");
+is(td.getAttribute("colspan"), "1", "Colspan attribute didn't store the original value");
+td.setAttribute("colspan", "-100");
+is(td.getAttribute("colspan"), "1", "Colspan attribute didn't store the original value");
+
+
+td.setAttribute("colspan", "foobar");
+is(td.getAttribute("colspan"), "foobar", "Colspan attribute didn't store the original value");
+
+var iframe = document.createElement("iframe");
+iframe.setAttribute("marginwidth", "50%");
+is(iframe.getAttribute("marginwidth"), "50%",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "50");
+is(iframe.getAttribute("marginwidth"), "50",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "0");
+is(iframe.getAttribute("marginwidth"), "0",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "0%");
+is(iframe.getAttribute("marginwidth"), "0%",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "9999999999999999999999");
+is(iframe.getAttribute("marginwidth"), "9999999999999999999999",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "9999999999999999999999%");
+is(iframe.getAttribute("marginwidth"), "9999999999999999999999%",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "-9999999999999999999999");
+is(iframe.getAttribute("marginwidth"), "-9999999999999999999999",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-9999999999999999999999%");
+is(iframe.getAttribute("marginwidth"), "-9999999999999999999999%",
+   "Marginwidth attribute didn't store the original value");
+
+   
+// Test PRInt32 min/max value
+iframe.setAttribute("marginwidth", "2147483647");
+is(iframe.getAttribute("marginwidth"), "2147483647",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "2147483647%");
+is(iframe.getAttribute("marginwidth"), "2147483647%",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "-2147483648");
+is(iframe.getAttribute("marginwidth"), "-2147483648",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-2147483648%");
+is(iframe.getAttribute("marginwidth"), "-2147483648%",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "2147483646");
+is(iframe.getAttribute("marginwidth"), "2147483646",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "2147483647%");
+is(iframe.getAttribute("marginwidth"), "2147483647%",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "-2147483647");
+is(iframe.getAttribute("marginwidth"), "-2147483647",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-2147483647%");
+is(iframe.getAttribute("marginwidth"), "-2147483647%",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "2147483648");
+is(iframe.getAttribute("marginwidth"), "2147483648",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "2147483648%");
+is(iframe.getAttribute("marginwidth"), "2147483648%",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "-2147483649");
+is(iframe.getAttribute("marginwidth"), "-2147483649",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-2147483649%");
+is(iframe.getAttribute("marginwidth"), "-2147483649%",
+   "Marginwidth attribute didn't store the original value");
+
+// some values 0 > x > NS_ATTRVALUE_INTEGERTYPE_MAXVALUE
+iframe.setAttribute("marginwidth", "134217726");
+is(iframe.getAttribute("marginwidth"), "134217726",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "134217727");
+is(iframe.getAttribute("marginwidth"), "134217727",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "134217728");
+is(iframe.getAttribute("marginwidth"), "134217728",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "134217729");
+is(iframe.getAttribute("marginwidth"), "134217729",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "134217726%");
+is(iframe.getAttribute("marginwidth"), "134217726%",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "134217727%");
+is(iframe.getAttribute("marginwidth"), "134217727%",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "134217728%");
+is(iframe.getAttribute("marginwidth"), "134217728%",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "134217729%");
+is(iframe.getAttribute("marginwidth"), "134217729%",
+   "Marginwidth attribute didn't store the original value");
+
+// some values 0 < x < NS_ATTRVALUE_INTEGERTYPE_MINVALUE
+iframe.setAttribute("marginwidth", "-134217727");
+is(iframe.getAttribute("marginwidth"), "-134217727",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-134217728");
+is(iframe.getAttribute("marginwidth"), "-134217728",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-134217729");
+is(iframe.getAttribute("marginwidth"), "-134217729",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-134217730");
+is(iframe.getAttribute("marginwidth"), "-134217730",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-134217727%");
+is(iframe.getAttribute("marginwidth"), "-134217727%",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-134217728%");
+is(iframe.getAttribute("marginwidth"), "-134217728%",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-134217729%");
+is(iframe.getAttribute("marginwidth"), "-134217729%",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-134217730%");
+is(iframe.getAttribute("marginwidth"), "-134217730%",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "-0");
+is(iframe.getAttribute("marginwidth"), "-0",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-0%");
+is(iframe.getAttribute("marginwidth"), "-0%",
+   "Marginwidth attribute didn't store the original value");   
+iframe.setAttribute("marginwidth", " 0 ");
+is(iframe.getAttribute("marginwidth"), " 0 ",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", " 0% ");
+is(iframe.getAttribute("marginwidth"), " 0% ",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-50%");
+is(iframe.getAttribute("marginwidth"), "-50%",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-50");
+is(iframe.getAttribute("marginwidth"), "-50",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", " -50% ");
+is(iframe.getAttribute("marginwidth"), " -50% ",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", " -50 ");
+is(iframe.getAttribute("marginwidth"), " -50 ",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "foobar");
+is(iframe.getAttribute("marginwidth"), "foobar",
+   "Marginwidth attribute didn't store the original value");
+
+var bd = document.createElement("body");
+bd.setAttribute("bgcolor", "red");
+is(bd.getAttribute("bgcolor"), "red", "Bgcolor attribute didn't store the original value");
+bd.setAttribute("bgcolor", "  red  ");
+todo(bd.getAttribute("bgcolor") == "  red  ", "Bgcolor attribute didn't store the original value");
+td.setAttribute("colspan", "100k");
+is(td.getAttribute("colspan"), "100k", "Colspan attribute didn't store the original value");
+bd.setAttribute("bgcolor", "red");
+is(bd.bgColor, "#ff0000", ".bgColor didn't return the right value!");
+bd.setAttribute("bgcolor", "  red  ");
+is(bd.bgColor, "#ff0000", ".bgColor didn't return the right value!");
+bd.setAttribute("bgcolor", "#ff0000");
+is(bd.bgColor, "#ff0000", ".bgColor didn't return the right value!");
+
+var video = document.createElement("video");
+video.setAttribute("playbackrate", "1");
+is(video.getAttribute('playbackrate'), "1",
+   "Playbackrate attribute didn't store the original value");
+video.setAttribute("playbackrate", "1.5");
+is(video.getAttribute('playbackrate'), "1.5",
+   "Playbackrate attribute didn't store the original value");
+video.setAttribute("playbackrate", "999999999999999999");
+is(video.getAttribute('playbackrate'), "999999999999999999",
+   "Playbackrate attribute didn't store the original value");
+video.setAttribute("playbackrate", "-999999999999999999");
+is(video.getAttribute('playbackrate'), "-999999999999999999",
+   "Playbackrate attribute didn't store the original value");
+video.setAttribute("playbackrate", "foo");
+is(video.getAttribute('playbackrate'), "foo",
+   "Playbackrate attribute didn't store the original value");
+</script>
+</pre>
+</body>
+</html>
+
diff --git a/content/html/content/src/nsHTMLTableCellElement.cpp b/content/html/content/src/nsHTMLTableCellElement.cpp
--- a/content/html/content/src/nsHTMLTableCellElement.cpp
+++ b/content/html/content/src/nsHTMLTableCellElement.cpp
@@ -338,28 +338,28 @@ nsHTMLTableCellElement::ParseAttribute(P
     if (aAttribute == nsGkAtoms::colspan) {
       PRBool res = aResult.ParseIntWithBounds(aValue, -1);
       if (res) {
         PRInt32 val = aResult.GetIntegerValue();
         // reset large colspan values as IE and opera do
         // quirks mode does not honor the special html 4 value of 0
         if (val > MAX_COLSPAN || val < 0 ||
             (0 == val && InNavQuirksMode(GetOwnerDoc()))) {
-          aResult.SetTo(1);
+          aResult.SetTo(1, NS_LITERAL_STRING("1"));
         }
       }
       return res;
     }
     if (aAttribute == nsGkAtoms::rowspan) {
       PRBool res = aResult.ParseIntWithBounds(aValue, -1, MAX_ROWSPAN);
       if (res) {
         PRInt32 val = aResult.GetIntegerValue();
         // quirks mode does not honor the special html 4 value of 0
         if (val < 0 || (0 == val && InNavQuirksMode(GetOwnerDoc()))) {
-          aResult.SetTo(1);
+          aResult.SetTo(1, NS_LITERAL_STRING("1"));
         }
       }
       return res;
     }
     if (aAttribute == nsGkAtoms::height) {
       return aResult.ParseSpecialIntValue(aValue, PR_TRUE);
     }
     if (aAttribute == nsGkAtoms::width) {
diff --git a/content/html/content/src/nsHTMLTableElement.cpp b/content/html/content/src/nsHTMLTableElement.cpp
--- a/content/html/content/src/nsHTMLTableElement.cpp
+++ b/content/html/content/src/nsHTMLTableElement.cpp
@@ -935,17 +935,17 @@ nsHTMLTableElement::ParseAttribute(PRInt
       return aResult.ParseSpecialIntValue(aValue, PR_TRUE);
     }
     if (aAttribute == nsGkAtoms::cols) {
       return aResult.ParseIntWithBounds(aValue, 0);
     }
     if (aAttribute == nsGkAtoms::border) {
       if (!aResult.ParseIntWithBounds(aValue, 0)) {
         // XXX this should really be NavQuirks only to allow non numeric value
-        aResult.SetTo(1);
+        aResult.SetTo(1, NS_LITERAL_STRING("1"));
       }
 
       return PR_TRUE;
     }
     if (aAttribute == nsGkAtoms::height) {
       return aResult.ParseSpecialIntValue(aValue, PR_TRUE);
     }
     if (aAttribute == nsGkAtoms::width) {
diff --git a/parser/htmlparser/tests/mochitest/regressions.txt b/parser/htmlparser/tests/mochitest/regressions.txt
--- a/parser/htmlparser/tests/mochitest/regressions.txt
+++ b/parser/htmlparser/tests/mochitest/regressions.txt
@@ -114,17 +114,17 @@ x { content:"</style" } "
 | <html>
 |   <head>
 |   <body>
 |     <table>
 |       <tbody>
 |         <tr>
 |           <td>
 |           <input>
-|             type="hidden"
+|             type="hiDDen"
 |           <td>
 
 #data
 <!DOCTYPE html><body><table><tr><td></td><input tYPe="  hiDDen  "><td></td></tr></table></body>
 #errors
 #document
 | <!DOCTYPE HTML>
 | <html>
