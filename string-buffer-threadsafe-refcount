From: L. David Baron <dbaron@dbaron.org>

Make nsStringBuffer's reference count use the minimum memory synchronization needed.

This is the same optimization made for ThreadSafeAutoRefCnt in bug
1277709.  However, nsStringBuffer uses a 32-bit reference count all the
time, so it can't easily use ThreadSafeAutoRefCnt.

MozReview-Commit-ID: LpB3xaYbaEE

diff --git a/xpcom/string/nsStringBuffer.h b/xpcom/string/nsStringBuffer.h
--- a/xpcom/string/nsStringBuffer.h
+++ b/xpcom/string/nsStringBuffer.h
@@ -2,17 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef nsStringBuffer_h__
 #define nsStringBuffer_h__
 
-#include "mozilla/Atomics.h"
+#include <atomic>
 #include "mozilla/MemoryReporting.h"
 
 template<class T> struct already_AddRefed;
 
 /**
  * This structure precedes the string buffers "we" allocate.  It may be the
  * case that nsTAString::mData does not point to one of these special
  * buffers.  The mFlags member variable distinguishes the buffer type.
@@ -21,17 +21,17 @@ template<class T> struct already_AddRefe
  * tracking.  NOTE: A string buffer can be modified only if its reference
  * count is 1.
  */
 class nsStringBuffer
 {
 private:
   friend class CheckStaticAtomSizes;
 
-  mozilla::Atomic<int32_t> mRefCount;
+  std::atomic<uint32_t> mRefCount;
   uint32_t mStorageSize;
 
 public:
 
   /**
    * Allocates a new string buffer, with given size in bytes and a
    * reference count of one.  When the string buffer is no longer needed,
    * it should be released via Release.
@@ -104,17 +104,37 @@ public:
    * reference to the string buffer is the only reference to the string
    * buffer, and therefore it has exclusive access to the string buffer and
    * associated data.  However, if this function returns true, then other
    * consumers may rely on the data in this buffer being immutable and
    * other threads may access this buffer simultaneously.
    */
   bool IsReadonly() const
   {
-    return mRefCount > 1;
+    // This doesn't lead to the destruction of the buffer, so we don't
+    // need to perform acquire memory synchronization for the normal
+    // reason that a reference count needs acquire synchronization
+    // (ensuring that all writes to the object made on other threads are
+    // visible to the thread destroying the object).
+    //
+    // We then need to consider the possibility that there were prior
+    // writes to the buffer on a different thread:  one that has either
+    // since released its reference count, or one that also has access
+    // to this buffer through the same reference.  There are two ways
+    // for that to happen: either the buffer pointer or a data structure
+    // (e.g., string object) pointing to the buffer was transferred from
+    // one thread to another, or the data structure pointing to the
+    // buffer was already visible on both threads.  In the first case
+    // (transfer), the transfer of data from one thread to another would
+    // have handled the memory synchronization.  In the latter case
+    // (data structure visible on both threads), the caller needed some
+    // sort of higher level memory synchronization to protect against
+    // the string object being mutated at the same time on multiple
+    // threads.
+    return mRefCount.load(std::memory_order_relaxed) > 1;
   }
 
   /**
    * The FromString methods return a string buffer for the given string
    * object or null if the string object does not have a string buffer.
    * The reference count of the string buffer is NOT incremented by these
    * methods.  If the caller wishes to hold onto the returned value, then
    * the returned string buffer must have its reference count incremented
diff --git a/xpcom/string/nsSubstring.cpp b/xpcom/string/nsSubstring.cpp
--- a/xpcom/string/nsSubstring.cpp
+++ b/xpcom/string/nsSubstring.cpp
@@ -181,27 +181,45 @@ public:
   }
 };
 
 // ---------------------------------------------------------------------------
 
 void
 nsStringBuffer::AddRef()
 {
-  ++mRefCount;
+  // Memory synchronization is not required when incrementing a
+  // reference count.  The first increment of a reference count on a
+  // thread is not important, since the first use of the object on a
+  // thread can happen before it.  What is important is the transfer
+  // of the pointer to that thread, which may happen prior to the
+  // first increment on that thread.  The necessary memory
+  // synchronization is done by the mechanism that transfers the
+  // pointer between threads.
+  uint32_t count = mRefCount.fetch_add(1, std::memory_order_relaxed) + 1;
   STRING_STAT_INCREMENT(Share);
-  NS_LOG_ADDREF(this, mRefCount, "nsStringBuffer", sizeof(*this));
+  NS_LOG_ADDREF(this, count, "nsStringBuffer", sizeof(*this));
 }
 
 void
 nsStringBuffer::Release()
 {
-  int32_t count = --mRefCount;
+  // Since this may be the last release on this thread, we need
+  // release semantics so that prior writes on this thread are visible
+  // to the thread that destroys the object when it reads mValue with
+  // acquire semantics.
+  uint32_t count = mRefCount.fetch_sub(1, std::memory_order_release) - 1;
   NS_LOG_RELEASE(this, count, "nsStringBuffer");
   if (count == 0) {
+    // We're going to destroy the object on this thread, so we need
+    // acquire semantics to synchronize with the memory released by
+    // the last release on other threads, that is, to ensure that
+    // writes prior to that release are now visible on this thread.
+    count = mRefCount.load(std::memory_order_acquire);
+
     STRING_STAT_INCREMENT(Free);
     free(this); // we were allocated with |malloc|
   }
 }
 
 /**
  * Alloc returns a pointer to a new string header with set capacity.
  */
