From: L. David Baron <dbaron@dbaron.org>

Make nsStringBuffer's reference count be a ThreadSafeAutoRefCnt.

This allows it to benefit from the optimizations in ThreadSafeAutoRefCnt
such as bug 1277709.

MozReview-Commit-ID: LpB3xaYbaEE

diff --git a/xpcom/base/nsISupportsImpl.h b/xpcom/base/nsISupportsImpl.h
--- a/xpcom/base/nsISupportsImpl.h
+++ b/xpcom/base/nsISupportsImpl.h
@@ -339,21 +339,24 @@ public:
   MOZ_ALWAYS_INLINE nsrefcnt operator=(nsrefcnt aValue)
   {
     // Use release semantics since we're not sure what the caller is
     // doing.
     mValue.store(aValue, std::memory_order_release);
     return aValue;
   }
   MOZ_ALWAYS_INLINE operator nsrefcnt() const { return get(); }
-  MOZ_ALWAYS_INLINE nsrefcnt get() const
+
+
+  // Default to acquire memory synchronization since we're not sure what
+  // the caller is doing.
+  MOZ_ALWAYS_INLINE nsrefcnt get(std::memory_order aOrder =
+                                   std::memory_order_acquire) const
   {
-    // Use acquire semantics since we're not sure what the caller is
-    // doing.
-    return mValue.load(std::memory_order_acquire);
+    return mValue.load(aOrder);
   }
 
   static const bool isThreadSafe = true;
 private:
   nsrefcnt operator++(int) = delete;
   nsrefcnt operator--(int) = delete;
   std::atomic<nsrefcnt> mValue;
 };
diff --git a/xpcom/string/nsStringBuffer.h b/xpcom/string/nsStringBuffer.h
--- a/xpcom/string/nsStringBuffer.h
+++ b/xpcom/string/nsStringBuffer.h
@@ -2,17 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef nsStringBuffer_h__
 #define nsStringBuffer_h__
 
-#include "mozilla/Atomics.h"
+#include "nsISupportsImpl.h"
 #include "mozilla/MemoryReporting.h"
 
 template<class T> struct already_AddRefed;
 
 /**
  * This structure precedes the string buffers "we" allocate.  It may be the
  * case that nsTAString::mData does not point to one of these special
  * buffers.  The mFlags member variable distinguishes the buffer type.
@@ -21,17 +21,17 @@ template<class T> struct already_AddRefe
  * tracking.  NOTE: A string buffer can be modified only if its reference
  * count is 1.
  */
 class nsStringBuffer
 {
 private:
   friend class CheckStaticAtomSizes;
 
-  mozilla::Atomic<int32_t> mRefCount;
+  mozilla::ThreadSafeAutoRefCnt mRefCount;
   uint32_t mStorageSize;
 
 public:
 
   /**
    * Allocates a new string buffer, with given size in bytes and a
    * reference count of one.  When the string buffer is no longer needed,
    * it should be released via Release.
@@ -104,17 +104,37 @@ public:
    * reference to the string buffer is the only reference to the string
    * buffer, and therefore it has exclusive access to the string buffer and
    * associated data.  However, if this function returns true, then other
    * consumers may rely on the data in this buffer being immutable and
    * other threads may access this buffer simultaneously.
    */
   bool IsReadonly() const
   {
-    return mRefCount > 1;
+    // This doesn't lead to the destruction of the buffer, so we don't
+    // need to perform acquire memory synchronization for the normal
+    // reason that a reference count needs acquire synchronization
+    // (ensuring that all writes to the object made on other threads are
+    // visible to the thread destroying the object).
+    //
+    // We then need to consider the possibility that there were prior
+    // writes to the buffer on a different thread:  one that has either
+    // since released its reference count, or one that also has access
+    // to this buffer through the same reference.  There are two ways
+    // for that to happen: either the buffer pointer or a data structure
+    // (e.g., string object) pointing to the buffer was transferred from
+    // one thread to another, or the data structure pointing to the
+    // buffer was already visible on both threads.  In the first case
+    // (transfer), the transfer of data from one thread to another would
+    // have handled the memory synchronization.  In the latter case
+    // (data structure visible on both threads), the caller needed some
+    // sort of higher level memory synchronization to protect against
+    // the string object being mutated at the same time on multiple
+    // threads.
+    return mRefCount.get(std::memory_order_relaxed) > 1;
   }
 
   /**
    * The FromString methods return a string buffer for the given string
    * object or null if the string object does not have a string buffer.
    * The reference count of the string buffer is NOT incremented by these
    * methods.  If the caller wishes to hold onto the returned value, then
    * the returned string buffer must have its reference count incremented
diff --git a/xpcom/string/nsSubstring.cpp b/xpcom/string/nsSubstring.cpp
--- a/xpcom/string/nsSubstring.cpp
+++ b/xpcom/string/nsSubstring.cpp
@@ -181,25 +181,25 @@ public:
   }
 };
 
 // ---------------------------------------------------------------------------
 
 void
 nsStringBuffer::AddRef()
 {
-  ++mRefCount;
+  nsrefcnt count = ++mRefCount;
   STRING_STAT_INCREMENT(Share);
-  NS_LOG_ADDREF(this, mRefCount, "nsStringBuffer", sizeof(*this));
+  NS_LOG_ADDREF(this, count, "nsStringBuffer", sizeof(*this));
 }
 
 void
 nsStringBuffer::Release()
 {
-  int32_t count = --mRefCount;
+  nsrefcnt count = --mRefCount;
   NS_LOG_RELEASE(this, count, "nsStringBuffer");
   if (count == 0) {
     STRING_STAT_INCREMENT(Free);
     free(this); // we were allocated with |malloc|
   }
 }
 
 /**
