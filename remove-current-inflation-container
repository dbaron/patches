From: L. David Baron <dbaron@dbaron.org>

Remove caching of current inflation container and its width from the pres context.  (Bug 747720, patch 6)  r=roc

This is no longer needed because we're getting the width from
nsFontInflationData and the null-ness of the container from
mInflationDisabledForShrinkWrap.

diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -1126,26 +1126,16 @@ protected:
   // a specific language, however (e.g, if it is inferred from the
   // charset rather than explicitly specified as a lang attribute).
   nsIAtom*              mLanguage;      // [STRONG]
 
 public:
   // The following are public member variables so that we can use them
   // with mozilla::AutoToggle or mozilla::AutoRestore.
 
-  // The frame that is the container for font size inflation for the
-  // reflow or intrinsic width computation currently happening.  If this
-  // frame is null, then font inflation should not be performed.
-  nsIFrame*             mCurrentInflationContainer; // [WEAK]
-
-  // The content-rect width of mCurrentInflationContainer.  If
-  // mCurrentInflationContainer is currently in reflow, this is its new
-  // width, which is not yet set on its rect.
-  nscoord               mCurrentInflationContainerWidth;
-
   // Should we disable font size inflation because we're inside of
   // shrink-wrapping calculations on an inflation container?
   bool                  mInflationDisabledForShrinkWrap;
 
 protected:
 
   nsRefPtrHashtable<nsPtrHashKey<nsIFrame>, nsImageLoader>
                         mImageLoaders[IMAGE_LOAD_TYPE_COUNT];
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -7326,30 +7326,16 @@ PresShell::DoReflow(nsIFrame* target, bo
   nsIFrame* rootFrame = mFrameConstructor->GetRootFrame();
 
   nsRefPtr<nsRenderingContext> rcx = GetReferenceRenderingContext();
   if (!rcx) {
     NS_NOTREACHED("CreateRenderingContext failure");
     return false;
   }
 
-  NS_ASSERTION(!mPresContext->mCurrentInflationContainer,
-               "current inflation container should be null");
-  AutoRestore<nsIFrame*> restoreInflationContainer(mPresContext->
-                           mCurrentInflationContainer);
-  for (nsIFrame *f = target->GetParent(); f; f = f->GetParent()) {
-    if (nsLayoutUtils::IsContainerForFontSizeInflation(f)) {
-      NS_ASSERTION(!(f->GetStateBits() & NS_FRAME_IN_REFLOW),
-                   "a frame outside should not be in reflow");
-      mPresContext->mCurrentInflationContainer = f;
-      mPresContext->mCurrentInflationContainerWidth = f->GetContentRect().width;
-      break;
-    }
-  }
-
 #ifdef DEBUG
   mCurrentReflowRoot = target;
 #endif
 
   target->WillReflow(mPresContext);
 
   // If the target frame is the root of the frame hierarchy, then
   // use all the available space. If it's simply a `reflow root',
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -85,19 +85,16 @@ static eNormalLineHeightControl sNormalL
 // use for measuring things.
 nsHTMLReflowState::nsHTMLReflowState(nsPresContext*       aPresContext,
                                      nsIFrame*            aFrame,
                                      nsRenderingContext* aRenderingContext,
                                      const nsSize&        aAvailableSpace)
   : nsCSSOffsetState(aFrame, aRenderingContext)
   , mBlockDelta(0)
   , mReflowDepth(0)
-  , mRestoreCurrentInflationContainer(aPresContext->mCurrentInflationContainer)
-  , mRestoreCurrentInflationContainerWidth(aPresContext->
-                                             mCurrentInflationContainerWidth)
 {
   NS_PRECONDITION(aPresContext, "no pres context");
   NS_PRECONDITION(aRenderingContext, "no rendering context");
   NS_PRECONDITION(aFrame, "no frame");
   parentReflowState = nsnull;
   availableWidth = aAvailableSpace.width;
   availableHeight = aAvailableSpace.height;
   mFloatManager = nsnull;
@@ -124,19 +121,16 @@ nsHTMLReflowState::nsHTMLReflowState(nsP
                                      const nsSize&            aAvailableSpace,
                                      nscoord                  aContainingBlockWidth,
                                      nscoord                  aContainingBlockHeight,
                                      bool                     aInit)
   : nsCSSOffsetState(aFrame, aParentReflowState.rendContext)
   , mBlockDelta(0)
   , mReflowDepth(aParentReflowState.mReflowDepth + 1)
   , mFlags(aParentReflowState.mFlags)
-  , mRestoreCurrentInflationContainer(aPresContext->mCurrentInflationContainer)
-  , mRestoreCurrentInflationContainerWidth(aPresContext->
-                                             mCurrentInflationContainerWidth)
 {
   NS_PRECONDITION(aPresContext, "no pres context");
   NS_PRECONDITION(aFrame, "no frame");
   NS_PRECONDITION((aContainingBlockWidth == -1) ==
                     (aContainingBlockHeight == -1),
                   "cb width and height should only be non-default together");
   NS_PRECONDITION(!mFlags.mSpecialHeightReflow ||
                   !NS_SUBTREE_DIRTY(aFrame),
@@ -1948,21 +1942,16 @@ nsHTMLReflowState::InitConstraints(nsPre
     }
   }
   // Check for blinking text and permission to display it
   mFlags.mBlinks = (parentReflowState && parentReflowState->mFlags.mBlinks);
   if (!mFlags.mBlinks && BlinkIsAllowed()) {
     const nsStyleTextReset* st = frame->GetStyleTextReset();
     mFlags.mBlinks = (st->mTextBlink != NS_STYLE_TEXT_BLINK_NONE);
   }
-
-  if (nsLayoutUtils::IsContainerForFontSizeInflation(frame)) {
-    aPresContext->mCurrentInflationContainer = frame;
-    aPresContext->mCurrentInflationContainerWidth = mComputedWidth;
-  }
 }
 
 static void
 UpdateProp(FrameProperties& aProps,
            const FramePropertyDescriptor* aProperty,
            bool aNeeded,
            nsMargin& aNewValue)
 {
diff --git a/layout/generic/nsHTMLReflowState.h b/layout/generic/nsHTMLReflowState.h
--- a/layout/generic/nsHTMLReflowState.h
+++ b/layout/generic/nsHTMLReflowState.h
@@ -365,22 +365,16 @@ public:
                                      // basis?
     PRUint16 mTableIsSplittable:1;   // tables are splittable, this should happen only inside a page
                                      // and never insider a column frame
     PRUint16 mHeightDependsOnAncestorCell:1;   // Does frame height depend on
                                                // an ancestor table-cell?
     PRUint16 mIsColumnBalancing:1;   // nsColumnSetFrame is balancing columns
   } mFlags;
 
-private:
-
-  mozilla::AutoRestore<nsIFrame*> mRestoreCurrentInflationContainer;
-  mozilla::AutoRestore<nscoord> mRestoreCurrentInflationContainerWidth;
-
-public:
   // Note: The copy constructor is written by the compiler automatically. You
   // can use that and then override specific values if you want, or you can
   // call Init as desired...
 
   // Initialize a <b>root</b> reflow state with a rendering context to
   // use for measuring things.
   nsHTMLReflowState(nsPresContext*           aPresContext,
                     nsIFrame*                aFrame,
diff --git a/layout/svg/base/src/nsSVGForeignObjectFrame.cpp b/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
--- a/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
+++ b/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
@@ -572,24 +572,16 @@ nsSVGForeignObjectFrame::DoReflow()
   // initiate a synchronous reflow here and now:  
   nsIPresShell* presShell = presContext->PresShell();
   NS_ASSERTION(presShell, "null presShell");
   nsRefPtr<nsRenderingContext> renderingContext =
     presShell->GetReferenceRenderingContext();
   if (!renderingContext)
     return;
 
-  AutoRestore<nsIFrame*> restoreCurrentInflationContainer(
-    presContext->mCurrentInflationContainer);
-  AutoRestore<nscoord> restoreCurrentInflationContainerWidth(
-    presContext->mCurrentInflationContainerWidth);
-
-  presContext->mCurrentInflationContainer = this;
-  presContext->mCurrentInflationContainerWidth = mRect.width;
-
   mInReflow = true;
 
   nsHTMLReflowState reflowState(presContext, kid,
                                 renderingContext,
                                 nsSize(mRect.width, NS_UNCONSTRAINEDSIZE));
   nsHTMLReflowMetrics desiredSize;
   nsReflowStatus status;
 
diff --git a/layout/xul/base/src/nsBox.cpp b/layout/xul/base/src/nsBox.cpp
--- a/layout/xul/base/src/nsBox.cpp
+++ b/layout/xul/base/src/nsBox.cpp
@@ -532,28 +532,16 @@ nsBox::IsCollapsed()
   return GetStyleVisibility()->mVisible == NS_STYLE_VISIBILITY_COLLAPSE;
 }
 
 nsresult
 nsIFrame::Layout(nsBoxLayoutState& aState)
 {
   NS_ASSERTION(aState.GetRenderingContext(), "must have rendering context");
 
-  nsPresContext *presContext = aState.PresContext();
-  AutoRestore<nsIFrame*> restoreCurrentInflationContainer(presContext->
-                           mCurrentInflationContainer);
-  AutoRestore<nscoord> restoreCurrentInflationContainerWidth(presContext->
-                         mCurrentInflationContainerWidth);
-  if (nsLayoutUtils::IsContainerForFontSizeInflation(mParent) &&
-      mParent->IsBoxFrame()) {
-    presContext->mCurrentInflationContainer = mParent;
-    presContext->mCurrentInflationContainerWidth =
-      mParent->GetContentRect().width;
-  }
-
   nsBox *box = static_cast<nsBox*>(this);
   DISPLAY_LAYOUT(box);
 
   box->BeginLayout(aState);
 
   box->DoLayout(aState);
 
   box->EndLayout(aState);
