From: L. David Baron <dbaron@dbaron.org>

Bug 841789, patch 2:  Fix callers that are going through the style context to get style structs rather than using the nsIFrame shortcuts.

This is just a code simplification that I noticed while reading through
patch 1.

diff --git a/layout/base/nsBidiPresUtils.cpp b/layout/base/nsBidiPresUtils.cpp
--- a/layout/base/nsBidiPresUtils.cpp
+++ b/layout/base/nsBidiPresUtils.cpp
@@ -987,17 +987,17 @@ nsBidiPresUtils::TraverseFrames(nsBlockF
       nsIContent* content = frame->GetContent();
       aBpd->AppendFrame(frame, aLineIter, content);
 
       // Append the content of the frame to the paragraph buffer
       nsIAtom* frameType = frame->GetType();
       if (nsGkAtoms::textFrame == frameType) {
         if (content != aBpd->mPrevContent) {
           aBpd->mPrevContent = content;
-          if (!frame->StyleContext()->GetStyleText()->NewlineIsSignificant()) {
+          if (!frame->GetStyleText()->NewlineIsSignificant()) {
             content->AppendTextTo(aBpd->mBuffer);
           } else {
             /*
              * For preformatted text we have to do bidi resolution on each line
              * separately. 
              */
             nsAutoString text;
             content->AppendTextTo(text);
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -4303,20 +4303,20 @@ nsLayoutUtils::HasNonZeroCornerOnSide(co
       return true;
   }
   return false;
 }
 
 /* static */ nsTransparencyMode
 nsLayoutUtils::GetFrameTransparency(nsIFrame* aBackgroundFrame,
                                     nsIFrame* aCSSRootFrame) {
-  if (aCSSRootFrame->StyleContext()->GetStyleDisplay()->mOpacity < 1.0f)
+  if (aCSSRootFrame->GetStyleDisplay()->mOpacity < 1.0f)
     return eTransparencyTransparent;
 
-  if (HasNonZeroCorner(aCSSRootFrame->StyleContext()->GetStyleBorder()->mBorderRadius))
+  if (HasNonZeroCorner(aCSSRootFrame->GetStyleBorder()->mBorderRadius))
     return eTransparencyTransparent;
 
   if (aCSSRootFrame->GetStyleDisplay()->mAppearance == NS_THEME_WIN_GLASS)
     return eTransparencyGlass;
 
   if (aCSSRootFrame->GetStyleDisplay()->mAppearance == NS_THEME_WIN_BORDERLESS_GLASS)
     return eTransparencyBorderlessGlass;
 
diff --git a/layout/generic/nsCanvasFrame.cpp b/layout/generic/nsCanvasFrame.cpp
--- a/layout/generic/nsCanvasFrame.cpp
+++ b/layout/generic/nsCanvasFrame.cpp
@@ -379,19 +379,17 @@ nsCanvasFrame::PaintFocus(nsRenderingCon
     focusRect.width = portRect.width;
     focusRect.height = portRect.height;
     focusRect.MoveBy(scrollableFrame->GetScrollPosition());
   }
 
  // XXX use the root frame foreground color, but should we find BODY frame
  // for HTML documents?
   nsIFrame* root = mFrames.FirstChild();
-  const nsStyleColor* color =
-    root ? root->StyleContext()->GetStyleColor() :
-           mStyleContext->GetStyleColor();
+  const nsStyleColor* color = root ? root->GetStyleColor() : GetStyleColor();
   if (!color) {
     NS_ERROR("current color cannot be found");
     return;
   }
 
   nsCSSRendering::PaintFocus(PresContext(), aRenderingContext,
                              focusRect, color->mColor);
 }
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -1068,17 +1068,17 @@ nsIFrame::HasPerspective() const
     return true;
   }
   return false;
 }
 
 bool
 nsIFrame::ChildrenHavePerspective() const
 {
-  const nsStyleDisplay *disp = StyleContext()->GetStyleDisplay();
+  const nsStyleDisplay *disp = GetStyleDisplay();
   if (disp &&
       disp->mChildPerspective.GetUnit() == eStyleUnit_Coord &&
       disp->mChildPerspective.GetCoordValue() > 0.0) {
     return true;
   }
   return false;
 }
 
@@ -6075,17 +6075,17 @@ FindBlockFrameOrBR(nsIFrame* aFrame, nsD
     if (result.mContent)
       result.mOffset = result.mContent->IndexOf(content) + 
         (aDirection == eDirPrevious ? 1 : 0);
     return result;
   }
 
   // If this is a preformatted text frame, see if it ends with a newline
   if (aFrame->HasTerminalNewline() &&
-      aFrame->StyleContext()->GetStyleText()->NewlineIsSignificant()) {
+      aFrame->GetStyleText()->NewlineIsSignificant()) {
     int32_t startOffset, endOffset;
     aFrame->GetOffsets(startOffset, endOffset);
     result.mContent = aFrame->GetContent();
     result.mOffset = endOffset - (aDirection == eDirPrevious ? 0 : 1);
     return result;
   }
 
   // Iterate over children and call ourselves recursively
@@ -7517,18 +7517,17 @@ nsIFrame::VerticalAlignEnum() const
       if (dominantBaseline != NS_STYLE_DOMINANT_BASELINE_AUTO ||
           frame->GetType() == nsGkAtoms::svgTextFrame) {
         break;
       }
     }
     return ConvertSVGDominantBaselineToVerticalAlign(dominantBaseline);
   }
 
-  const nsStyleCoord& verticalAlign =
-    StyleContext()->GetStyleTextReset()->mVerticalAlign;
+  const nsStyleCoord& verticalAlign = GetStyleTextReset()->mVerticalAlign;
   if (verticalAlign.GetUnit() == eStyleUnit_Enumerated) {
     return verticalAlign.GetIntValue();
   }
 
   return eInvalidVerticalAlign;
 }
 
 /* static */
diff --git a/layout/svg/nsSVGContainerFrame.cpp b/layout/svg/nsSVGContainerFrame.cpp
--- a/layout/svg/nsSVGContainerFrame.cpp
+++ b/layout/svg/nsSVGContainerFrame.cpp
@@ -200,17 +200,17 @@ nsSVGDisplayContainerFrame::PaintSVG(nsR
                                      const nsIntRect *aDirtyRect)
 {
   NS_ASSERTION(!NS_SVGDisplayListPaintingEnabled() ||
                (mState & NS_STATE_SVG_NONDISPLAY_CHILD) ||
                PresContext()->IsGlyph(),
                "If display lists are enabled, only painting of non-display "
                "SVG should take this code path");
 
-  const nsStyleDisplay *display = mStyleContext->GetStyleDisplay();
+  const nsStyleDisplay *display = GetStyleDisplay();
   if (display->mOpacity == 0.0)
     return NS_OK;
 
   for (nsIFrame* kid = mFrames.FirstChild(); kid;
        kid = kid->GetNextSibling()) {
     nsSVGUtils::PaintFrameWithEffects(aContext, aDirtyRect, kid);
   }
 
diff --git a/layout/svg/nsSVGGlyphFrame.cpp b/layout/svg/nsSVGGlyphFrame.cpp
--- a/layout/svg/nsSVGGlyphFrame.cpp
+++ b/layout/svg/nsSVGGlyphFrame.cpp
@@ -1831,17 +1831,17 @@ nsSVGGlyphFrame::EnsureTextRun(float *aD
       textRunSize = std::max(textRunSize, double(CLAMP_MIN_SIZE));
       textRunSize = std::min(textRunSize, double(CLAMP_MAX_SIZE));
     }
 
     const nsFont& font = fontData->mFont;
     bool printerFont = (presContext->Type() == nsPresContext::eContext_PrintPreview ||
                           presContext->Type() == nsPresContext::eContext_Print);
     gfxFontStyle fontStyle(font.style, font.weight, font.stretch, textRunSize,
-                           mStyleContext->GetStyleFont()->mLanguage,
+                           GetStyleFont()->mLanguage,
                            font.sizeAdjust, font.systemFont,
                            printerFont,
                            font.languageOverride);
 
     font.AddFontFeaturesToStyle(&fontStyle);
 
     nsRefPtr<gfxFontGroup> fontGroup =
       gfxPlatform::GetPlatform()->CreateFontGroup(font.name, &fontStyle, presContext->GetUserFontSet());
diff --git a/layout/svg/nsSVGSwitchFrame.cpp b/layout/svg/nsSVGSwitchFrame.cpp
--- a/layout/svg/nsSVGSwitchFrame.cpp
+++ b/layout/svg/nsSVGSwitchFrame.cpp
@@ -108,17 +108,17 @@ NS_IMETHODIMP
 nsSVGSwitchFrame::PaintSVG(nsRenderingContext* aContext,
                            const nsIntRect *aDirtyRect)
 {
   NS_ASSERTION(!NS_SVGDisplayListPaintingEnabled() ||
                (mState & NS_STATE_SVG_NONDISPLAY_CHILD),
                "If display lists are enabled, only painting of non-display "
                "SVG should take this code path");
 
-  const nsStyleDisplay *display = mStyleContext->GetStyleDisplay();
+  const nsStyleDisplay *display = GetStyleDisplay();
   if (display->mOpacity == 0.0)
     return NS_OK;
 
   nsIFrame *kid = GetActiveChildFrame();
   if (kid) {
     nsSVGUtils::PaintFrameWithEffects(aContext, aDirtyRect, kid);
   }
   return NS_OK;
diff --git a/layout/xul/base/src/nsBoxFrame.cpp b/layout/xul/base/src/nsBoxFrame.cpp
--- a/layout/xul/base/src/nsBoxFrame.cpp
+++ b/layout/xul/base/src/nsBoxFrame.cpp
@@ -1296,17 +1296,17 @@ nsBoxFrame::BuildDisplayList(nsDisplayLi
   // forcelayer is only supported on XUL elements with box layout
   bool forceLayer =
     GetContent()->HasAttr(kNameSpaceID_None, nsGkAtoms::layer) &&
     GetContent()->IsXUL();
 
   // Check for frames that are marked as a part of the region used
   // in calculating glass margins on Windows.
   if (GetContent()->IsXUL()) {
-      const nsStyleDisplay* styles = mStyleContext->GetStyleDisplay();
+      const nsStyleDisplay* styles = GetStyleDisplay();
       if (styles && styles->mAppearance == NS_THEME_WIN_EXCLUDE_GLASS) {
         nsRect rect = nsRect(aBuilder->ToReferenceFrame(this), GetSize());
         aBuilder->AddExcludedGlassRegion(rect);
       }
   }
 
   nsDisplayListCollection tempLists;
   const nsDisplayListSet& destination = forceLayer ? tempLists : aLists;
