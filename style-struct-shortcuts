From: L. David Baron <dbaron@dbaron.org>

Fix callers that are going through the style context to get style structs rather than using the nsIFrame shortcuts.

diff --git a/layout/base/nsBidiPresUtils.cpp b/layout/base/nsBidiPresUtils.cpp
--- a/layout/base/nsBidiPresUtils.cpp
+++ b/layout/base/nsBidiPresUtils.cpp
@@ -987,17 +987,17 @@ nsBidiPresUtils::TraverseFrames(nsBlockF
       nsIContent* content = frame->GetContent();
       aBpd->AppendFrame(frame, aLineIter, content);
 
       // Append the content of the frame to the paragraph buffer
       nsIAtom* frameType = frame->GetType();
       if (nsGkAtoms::textFrame == frameType) {
         if (content != aBpd->mPrevContent) {
           aBpd->mPrevContent = content;
-          if (!frame->StyleContext()->GetStyleText()->NewlineIsSignificant()) {
+          if (!frame->GetStyleText()->NewlineIsSignificant()) {
             content->AppendTextTo(aBpd->mBuffer);
           } else {
             /*
              * For preformatted text we have to do bidi resolution on each line
              * separately. 
              */
             nsAutoString text;
             content->AppendTextTo(text);
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -4303,20 +4303,20 @@ nsLayoutUtils::HasNonZeroCornerOnSide(co
       return true;
   }
   return false;
 }
 
 /* static */ nsTransparencyMode
 nsLayoutUtils::GetFrameTransparency(nsIFrame* aBackgroundFrame,
                                     nsIFrame* aCSSRootFrame) {
-  if (aCSSRootFrame->StyleContext()->GetStyleDisplay()->mOpacity < 1.0f)
+  if (aCSSRootFrame->GetStyleDisplay()->mOpacity < 1.0f)
     return eTransparencyTransparent;
 
-  if (HasNonZeroCorner(aCSSRootFrame->StyleContext()->GetStyleBorder()->mBorderRadius))
+  if (HasNonZeroCorner(aCSSRootFrame->GetStyleBorder()->mBorderRadius))
     return eTransparencyTransparent;
 
   if (aCSSRootFrame->GetStyleDisplay()->mAppearance == NS_THEME_WIN_GLASS)
     return eTransparencyGlass;
 
   if (aCSSRootFrame->GetStyleDisplay()->mAppearance == NS_THEME_WIN_BORDERLESS_GLASS)
     return eTransparencyBorderlessGlass;
 
diff --git a/layout/generic/nsCanvasFrame.cpp b/layout/generic/nsCanvasFrame.cpp
--- a/layout/generic/nsCanvasFrame.cpp
+++ b/layout/generic/nsCanvasFrame.cpp
@@ -380,17 +380,17 @@ nsCanvasFrame::PaintFocus(nsRenderingCon
     focusRect.height = portRect.height;
     focusRect.MoveBy(scrollableFrame->GetScrollPosition());
   }
 
  // XXX use the root frame foreground color, but should we find BODY frame
  // for HTML documents?
   nsIFrame* root = mFrames.FirstChild();
   const nsStyleColor* color =
-    root ? root->StyleContext()->GetStyleColor() :
+    root ? root->GetStyleColor() :
            mStyleContext->GetStyleColor();
   if (!color) {
     NS_ERROR("current color cannot be found");
     return;
   }
 
   nsCSSRendering::PaintFocus(PresContext(), aRenderingContext,
                              focusRect, color->mColor);
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -1068,17 +1068,17 @@ nsIFrame::HasPerspective() const
     return true;
   }
   return false;
 }
 
 bool
 nsIFrame::ChildrenHavePerspective() const
 {
-  const nsStyleDisplay *disp = StyleContext()->GetStyleDisplay();
+  const nsStyleDisplay *disp = GetStyleDisplay();
   if (disp &&
       disp->mChildPerspective.GetUnit() == eStyleUnit_Coord &&
       disp->mChildPerspective.GetCoordValue() > 0.0) {
     return true;
   }
   return false;
 }
 
@@ -6075,17 +6075,17 @@ FindBlockFrameOrBR(nsIFrame* aFrame, nsD
     if (result.mContent)
       result.mOffset = result.mContent->IndexOf(content) + 
         (aDirection == eDirPrevious ? 1 : 0);
     return result;
   }
 
   // If this is a preformatted text frame, see if it ends with a newline
   if (aFrame->HasTerminalNewline() &&
-      aFrame->StyleContext()->GetStyleText()->NewlineIsSignificant()) {
+      aFrame->GetStyleText()->NewlineIsSignificant()) {
     int32_t startOffset, endOffset;
     aFrame->GetOffsets(startOffset, endOffset);
     result.mContent = aFrame->GetContent();
     result.mOffset = endOffset - (aDirection == eDirPrevious ? 0 : 1);
     return result;
   }
 
   // Iterate over children and call ourselves recursively
@@ -7518,17 +7518,17 @@ nsIFrame::VerticalAlignEnum() const
           frame->GetType() == nsGkAtoms::svgTextFrame) {
         break;
       }
     }
     return ConvertSVGDominantBaselineToVerticalAlign(dominantBaseline);
   }
 
   const nsStyleCoord& verticalAlign =
-    StyleContext()->GetStyleTextReset()->mVerticalAlign;
+    GetStyleTextReset()->mVerticalAlign;
   if (verticalAlign.GetUnit() == eStyleUnit_Enumerated) {
     return verticalAlign.GetIntValue();
   }
 
   return eInvalidVerticalAlign;
 }
 
 /* static */
