From: L. David Baron <dbaron@dbaron.org>

Don't push floats past break due to total lack of available height when we're required to place something.  (Bug 586973)

diff --git a/layout/generic/crashtests/586973-1.html b/layout/generic/crashtests/586973-1.html
new file mode 100644
--- /dev/null
+++ b/layout/generic/crashtests/586973-1.html
@@ -0,0 +1,9 @@
+<html>
+<head>
+<style>
+hr::before { content:"b"; float:right;}
+</style>
+</head>
+<body>
+<hr style="-moz-column-count: 1;">
+</html>
\ No newline at end of file
diff --git a/layout/generic/crashtests/crashtests.list b/layout/generic/crashtests/crashtests.list
--- a/layout/generic/crashtests/crashtests.list
+++ b/layout/generic/crashtests/crashtests.list
@@ -327,8 +327,9 @@ load 564368-1.xhtml
 load 564968.xhtml
 load 570160.html
 load 571618-1.svg
 load 574958.xhtml
 load 585598-1.xhtml
 load 586806-1.html
 load 586806-2.html
 load 586806-3.html
+load 586973-1.html
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -685,19 +685,26 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
   // block if possible (CSS2 spec section 9.5.1, see the rule list).
   NS_ASSERTION((NS_STYLE_FLOAT_LEFT == floatDisplay->mFloats) ||
 	       (NS_STYLE_FLOAT_RIGHT == floatDisplay->mFloats),
 	       "invalid float type");
 
   // Can the float fit here?
   PRBool keepFloatOnSameLine = PR_FALSE;
 
+  // Are we required to place at least part of the float because we're
+  // at the top of the page (to avoid an infinite loop of pushing and
+  // breaking).
+  PRBool mustPlaceFloat =
+    mReflowState.mFlags.mIsTopOfPage && IsAdjacentWithTop();
+
   for (;;) {
     if (mReflowState.availableHeight != NS_UNCONSTRAINEDSIZE &&
-        floatAvailableSpace.mRect.height <= 0) {
+        floatAvailableSpace.mRect.height <= 0 &&
+        !mustPlaceFloat) {
       // No space, nowhere to put anything.
       PushFloatPastBreak(aFloat);
       return PR_FALSE;
     }
 
     if (CanPlaceFloat(floatMarginWidth, floatAvailableSpace)) {
       // We found an appropriate place.
       break;
@@ -754,16 +761,18 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
       // get a new width for the new band.
       floatAvailableSpace = GetFloatAvailableSpace(mY);
       adjustedAvailableSpace = mBlock->AdjustFloatAvailableSpace(*this,
                                  floatAvailableSpace.mRect, aFloat);
       floatMarginWidth = FloatMarginWidth(mReflowState,
                                           adjustedAvailableSpace.width,
                                           aFloat, offsets);
     }
+
+    mustPlaceFloat = PR_FALSE;
   }
 
   // If the float is continued, it will get the same absolute x value as its prev-in-flow
 
   // We don't worry about the geometry of the prev in flow, let the continuation
   // place and size itself as required.
 
   // Assign an x and y coordinate to the float.
@@ -805,18 +814,17 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
   // to check here that the float's height fit, and if it didn't, bail.
   // (This code is only for DISABLE_FLOAT_BREAKING_IN_COLUMNS .)
   //
   // Likewise, if none of the float fit, and it needs to be pushed in
   // its entirety to the next page (NS_FRAME_IS_TRUNCATED), we need to
   // do the same.
   if ((mContentArea.height != NS_UNCONSTRAINEDSIZE &&
        adjustedAvailableSpace.height == NS_UNCONSTRAINEDSIZE &&
-       (!mReflowState.mFlags.mIsTopOfPage || !IsAdjacentWithTop() ||
-        pushedDown) &&
+       !mustPlaceFloat &&
        aFloat->GetSize().height + floatMargin.TopBottom() >
          mContentArea.YMost() - floatY) ||
       NS_FRAME_IS_TRUNCATED(reflowStatus)) {
 
     PushFloatPastBreak(aFloat);
     return PR_FALSE;
   }
 
