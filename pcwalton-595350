From: Patrick Walton <pwalton@mozilla.com>

Bug 595350 - Fix leaks when closing windows or tabs with the Web Console still open. r=sdwilsh a=blocking-betaN+

diff --git a/toolkit/components/console/hudservice/HUDService.jsm b/toolkit/components/console/hudservice/HUDService.jsm
--- a/toolkit/components/console/hudservice/HUDService.jsm
+++ b/toolkit/components/console/hudservice/HUDService.jsm
@@ -1151,16 +1151,21 @@ function HUD_SERVICE()
     throw new Error("Unsupported Application");
   }
 
   this.mixins = mixins;
   this.storage = new ConsoleStorage();
   this.defaultFilterPrefs = this.storage.defaultDisplayPrefs;
   this.defaultGlobalConsolePrefs = this.storage.defaultGlobalConsolePrefs;
 
+  // These methods access the "this" object, but they're registered as
+  // event listeners. So we hammer in the "this" binding.
+  this.onTabClose = this.onTabClose.bind(this);
+  this.onWindowUnload = this.onWindowUnload.bind(this);
+
   // load stylesheet with StyleSheetService
   var uri = Services.io.newURI(HUD_STYLESHEET_URI, null, null);
   sss.loadAndRegisterSheet(uri, sss.AGENT_SHEET);
 
   // begin observing HTTP traffic
   this.startHTTPObservation();
 };
 
@@ -1353,23 +1358,28 @@ HUD_SERVICE.prototype =
     this.unregisterActiveContext(hudId);
     this.unregisterDisplay(hudId);
     window.focus();
   },
 
   /**
    * Clear the specified HeadsUpDisplay
    *
-   * @param string aId
+   * @param string|nsIDOMNode aHUD
+   *        Either the ID of a HUD or the DOM node corresponding to an outer
+   *        HUD box.
    * @returns void
    */
-  clearDisplay: function HS_clearDisplay(aId)
+  clearDisplay: function HS_clearDisplay(aHUD)
   {
-    var displayNode = this.getOutputNodeById(aId);
-    var outputNode = displayNode.querySelectorAll(".hud-output-node")[0];
+    if (typeof(aHUD) === "string") {
+      aHUD = this.getOutputNodeById(aHUD);
+    }
+
+    var outputNode = aHUD.querySelector(".hud-output-node");
 
     while (outputNode.firstChild) {
       outputNode.removeChild(outputNode.firstChild);
     }
 
     outputNode.lastTimestamp = 0;
   },
 
@@ -1681,93 +1691,93 @@ HUD_SERVICE.prototype =
     else {
       windows.push(aContentWindow);
     }
   },
 
   /**
    * When a display is being destroyed, unregister it first
    *
-   * @param string aId
+   * @param string|nsIDOMNode aHUD
+   *        Either the ID of a HUD or the DOM node corresponding to an outer
+   *        HUD box.
    * @returns void
    */
-  unregisterDisplay: function HS_unregisterDisplay(aId)
+  unregisterDisplay: function HS_unregisterDisplay(aHUD)
   {
     // Remove children from the output. If the output is not cleared, there can
     // be leaks as some nodes has node.onclick = function; set and GC can't
     // remove the nodes then.
-    HUDService.clearDisplay(aId);
+    HUDService.clearDisplay(aHUD);
+
+    var id, outputNode;
+    if (typeof(aHUD) === "string") {
+      id = aHUD;
+      outputNode = this.mixins.getOutputNodeById(aHUD);
+    }
+    else {
+      id = aHUD.getAttribute("id");
+      outputNode = aHUD;
+    }
 
     // remove HUD DOM node and
     // remove display references from local registries get the outputNode
-    var outputNode = this.mixins.getOutputNodeById(aId);
     var parent = outputNode.parentNode;
     var splitters = parent.querySelectorAll("splitter");
     var len = splitters.length;
     for (var i = 0; i < len; i++) {
       if (splitters[i].getAttribute("class") == "hud-splitter") {
         splitters[i].parentNode.removeChild(splitters[i]);
         break;
       }
     }
     // remove the DOM Nodes
     parent.removeChild(outputNode);
 
-    this.windowRegistry[aId].forEach(function(aContentWindow) {
+    this.windowRegistry[id].forEach(function(aContentWindow) {
       if (aContentWindow.wrappedJSObject.console instanceof HUDConsole) {
         delete aContentWindow.wrappedJSObject.console;
       }
     });
 
     // remove our record of the DOM Nodes from the registry
-    delete this._headsUpDisplays[aId];
+    delete this._headsUpDisplays[id];
     // remove the HeadsUpDisplay object from memory
-    this.deleteHeadsUpDisplay(aId);
+    this.deleteHeadsUpDisplay(id);
     // remove the related storage object
-    this.storage.removeDisplay(aId);
+    this.storage.removeDisplay(id);
     // remove the related window objects
-    delete this.windowRegistry[aId];
+    delete this.windowRegistry[id];
 
     let displays = this.displays();
 
-    var uri  = this.displayRegistry[aId];
+    var uri  = this.displayRegistry[id];
     var specHudArr = this.uriRegistry[uri];
 
     for (var i = 0; i < specHudArr.length; i++) {
-      if (specHudArr[i] == aId) {
+      if (specHudArr[i] == id) {
         specHudArr.splice(i, 1);
       }
     }
-    delete displays[aId];
-    delete this.displayRegistry[aId];
+    delete displays[id];
+    delete this.displayRegistry[id];
   },
 
   /**
    * Shutdown all HeadsUpDisplays on xpcom-shutdown
    *
    * @returns void
    */
   shutdown: function HS_shutdown()
   {
     for (var displayId in this._headsUpDisplays) {
       this.unregisterDisplay(displayId);
     }
     // delete the storage as it holds onto channels
     delete this.storage;
-
-     var xulWindow = aContentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
-       .getInterface(Ci.nsIWebNavigation)
-       .QueryInterface(Ci.nsIDocShellTreeItem)
-       .rootTreeItem
-       .QueryInterface(Ci.nsIInterfaceRequestor)
-       .getInterface(Ci.nsIDOMWindow);
-
-    xulWindow = XPCNativeWrapper.unwrap(xulWindow);
-    var gBrowser = xulWindow.gBrowser;
-    gBrowser.tabContainer.removeEventListener("TabClose", this.onTabClose, false);
   },
 
   /**
    * get the nsIDOMNode outputNode via a nsIURI.spec
    *
    * @param string aURISpec
    * @returns nsIDOMNode
    */
@@ -2641,27 +2651,65 @@ HUD_SERVICE.prototype =
   scriptMsgLogLevel: {
     0: "typeError",
     1: "typeWarning",
     2: "typeException",
     4: "typeStrict",
   },
 
   /**
+   * Closes the Console, if any, that resides on the given tab.
+   *
+   * @param nsIDOMNode aTab
+   *        The tab on which to close the console.
+   * @returns void
+   */
+  closeConsoleOnTab: function HS_closeConsoleOnTab(aTab)
+  {
+    let xulDocument = aTab.ownerDocument;
+    let xulWindow = xulDocument.defaultView;
+    let gBrowser = xulWindow.gBrowser;
+    let linkedBrowser = aTab.linkedBrowser;
+    let notificationBox = gBrowser.getNotificationBox(linkedBrowser);
+    let hudId = "hud_" + notificationBox.getAttribute("id");
+    let outputNode = xulDocument.getElementById(hudId);
+    if (outputNode != null) {
+      this.unregisterDisplay(outputNode);
+    }
+  },
+
+  /**
    * onTabClose event handler function
    *
    * @param aEvent
    * @returns void
    */
   onTabClose: function HS_onTabClose(aEvent)
   {
-    var browser = aEvent.target;
-    var tabId = gBrowser.getNotificationBox(browser).getAttribute("id");
-    var hudId = "hud_" + tabId;
-    this.unregisterDisplay(hudId);
+    this.closeConsoleOnTab(aEvent.target);
+  },
+
+  /**
+   * Called whenever a browser window closes. Cleans up any consoles still
+   * around.
+   *
+   * @param nsIDOMEvent aEvent
+   *        The dispatched event.
+   * @returns void
+   */
+  onWindowUnload: function HS_onWindowUnload(aEvent)
+  {
+    let gBrowser = aEvent.target.defaultView.gBrowser;
+    let tabContainer = gBrowser.tabContainer;
+
+    let tab = tabContainer.firstChild;
+    while (tab != null) {
+      this.closeConsoleOnTab(tab);
+      tab = tab.nextSibling;
+    }
   },
 
   /**
    * windowInitializer - checks what Gecko app is running and inits the HUD
    *
    * @param nsIDOMWindow aContentWindow
    * @returns void
    */
@@ -2684,16 +2732,18 @@ HUD_SERVICE.prototype =
 
     if (aContentWindow.document.location.href == "about:blank" &&
         HUDWindowObserver.initialConsoleCreated == false) {
       // TODO: need to make this work with about:blank in the future
       // see bug 568661
       return;
     }
 
+    xulWindow.addEventListener("unload", this.onWindowUnload, false);
+
     let gBrowser = xulWindow.gBrowser;
 
 
     var container = gBrowser.tabContainer;
     container.addEventListener("TabClose", this.onTabClose, false);
 
     if (gBrowser && !HUDWindowObserver.initialConsoleCreated) {
       HUDWindowObserver.initialConsoleCreated = true;
diff --git a/toolkit/components/console/hudservice/tests/browser/Makefile.in b/toolkit/components/console/hudservice/tests/browser/Makefile.in
--- a/toolkit/components/console/hudservice/tests/browser/Makefile.in
+++ b/toolkit/components/console/hudservice/tests/browser/Makefile.in
@@ -52,16 +52,17 @@ _BROWSER_TEST_FILES = \
 	browser_webconsole_bug_585237_line_limit.js \
 	browser_webconsole_bug_586142_insert_newlines.js \
 	browser_webconsole_bug_586388_select_all.js  \
 	browser_webconsole_bug_588967_input_expansion.js \
 	browser_webconsole_bug_580454_timestamp_l10n.js \
 	browser_webconsole_netlogging.js \
 	browser_webconsole_bug_593003_iframe_wrong_hud.js \
 	browser_webconsole_bug_581231_close_button.js \
+	browser_webconsole_bug_595350_multiple_windows_and_tabs.js \
 	browser_webconsole_consoleonpage.js \
 	browser_webconsole_bug_587617_output_copy.js \
 	browser_webconsole_bug_588342_document_focus.js \
 	$(NULL)
 
 _BROWSER_TEST_PAGES = \
 	test-console.html \
 	test-network.html \
diff --git a/toolkit/components/console/hudservice/tests/browser/browser_webconsole_bug_595350_multiple_windows_and_tabs.js b/toolkit/components/console/hudservice/tests/browser/browser_webconsole_bug_595350_multiple_windows_and_tabs.js
new file mode 100644
--- /dev/null
+++ b/toolkit/components/console/hudservice/tests/browser/browser_webconsole_bug_595350_multiple_windows_and_tabs.js
@@ -0,0 +1,74 @@
+/* vim:set ts=2 sw=2 sts=2 et: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/
+ *
+ * Contributor(s):
+ *  Patrick Walton <pcwalton@mozilla.com>
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+// Tests that the Web Console doesn't leak when multiple tabs and windows are
+// opened and then closed.
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/HUDService.jsm");
+
+const TEST_URI = "http://example.com/";
+
+let mainWindowTabs = [], newWindowTabs = [];
+let loadedTabCount = 0;
+let newWindow;
+
+function test() {
+  waitForExplicitFinish();
+  waitForFocus(onFocus);
+}
+
+function onFocus() {
+  window.open(TEST_URI);
+  executeSoon(onWindowLoad);
+}
+
+function onWindowLoad() {
+  newWindow = Services.wm.getMostRecentWindow("navigator:browser");
+  ok(newWindow, "we have the window");
+
+  addTabs(mainWindowTabs, gBrowser);
+  addTabs(newWindowTabs, newWindow.gBrowser);
+}
+
+function addTabs(aTabList, aGBrowser) {
+  for (let i = 0; i < 3; i++) {
+    let tab = aGBrowser.addTab(TEST_URI);
+    tab.linkedBrowser.addEventListener("DOMContentLoaded",
+                                       onTabLoad.bind(this, tab), false);
+    aTabList.push(tab);
+  }
+}
+
+function onTabLoad(aTab) {
+  loadedTabCount++;
+  if (loadedTabCount < 6) {
+    return;
+  }
+
+  testMultipleWindowsAndTabs();
+}
+
+function testMultipleWindowsAndTabs() {
+  for (let i = 0; i < 3; i++) {
+    HUDService.activateHUDForContext(mainWindowTabs[i]);
+    HUDService.activateHUDForContext(newWindowTabs[i]);
+  }
+
+  executeSoon(function() {
+    newWindow.close();
+    for (let i = 0; i < 3; i++) {
+      gBrowser.removeTab(mainWindowTabs[i]);
+    }
+
+    finish();
+  });
+}
+
