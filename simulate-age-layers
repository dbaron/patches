From: L. David Baron <dbaron@dbaron.org>

Make DOMWindowUtils::AdvanceTimeAndRefresh age the ActiveLayerTracker.

FIXME: Test failures in layout/style/test/test_animations_omta.html
(and I didn't even try any other test files)

diff --git a/dom/base/nsDOMWindowUtils.cpp b/dom/base/nsDOMWindowUtils.cpp
--- a/dom/base/nsDOMWindowUtils.cpp
+++ b/dom/base/nsDOMWindowUtils.cpp
@@ -101,16 +101,17 @@
 #include "nsIDOMStyleSheet.h"
 #include "nsIStyleSheetService.h"
 #include "nsContentPermissionHelper.h"
 #include "nsCSSPseudoElements.h"            // for CSSPseudoElementType
 #include "nsNetUtil.h"
 #include "nsDocument.h"
 #include "HTMLImageElement.h"
 #include "mozilla/css/ImageLoader.h"
+#include "ActiveLayerTracker.h"
 #include "mozilla/layers/APZCTreeManager.h" // for layers::ZoomToRectBehavior
 #include "mozilla/dom/Promise.h"
 #include "mozilla/CSSStyleSheet.h"
 
 #ifdef XP_WIN
 #undef GetClassName
 #endif
 
@@ -2279,16 +2280,18 @@ nsDOMWindowUtils::AdvanceTimeAndRefresh(
   nsCOMPtr<nsIDocument> doc = GetDocument();
   if (doc) {
     PendingAnimationTracker* tracker = doc->GetPendingAnimationTracker();
     if (tracker) {
       tracker->TriggerPendingAnimationsNow();
     }
   }
 
+  ActiveLayerTracker::SimulateTimeAdvance(aMilliseconds);
+
   nsPresContext* presContext = GetPresContext();
   if (presContext) {
     nsRefreshDriver* driver = presContext->RefreshDriver();
     driver->AdvanceTimeAndRefresh(aMilliseconds);
 
     RefPtr<LayerTransactionChild> transaction = GetLayerTransaction();
     if (transaction && transaction->IPCOpen()) {
       transaction->SendSetTestSampleTime(driver->MostRecentRefresh());
diff --git a/layout/base/ActiveLayerTracker.cpp b/layout/base/ActiveLayerTracker.cpp
--- a/layout/base/ActiveLayerTracker.cpp
+++ b/layout/base/ActiveLayerTracker.cpp
@@ -111,16 +111,17 @@ public:
   // Number of restyle operations detected
   uint8_t mRestyleCounts[ACTIVITY_COUNT];
   bool mContentActive;
 };
 
 class LayerActivityTracker final : public nsExpirationTracker<LayerActivity,4> {
 public:
   // 75-100ms is a good timeout period. We use 4 generations of 25ms each.
+  // FIXME: Nope, this is 4 generations of 100ms each!
   enum { GENERATION_MS = 100 };
   LayerActivityTracker()
     : nsExpirationTracker<LayerActivity,4>(GENERATION_MS,
                                            "LayerActivityTracker")
     , mDestroying(false)
   {}
   ~LayerActivityTracker() {
     mDestroying = true;
@@ -531,15 +532,34 @@ ActiveLayerTracker::SetCurrentScrollHand
 {
   if (!gLayerActivityTracker) {
     gLayerActivityTracker = new LayerActivityTracker();
   }
   gLayerActivityTracker->mCurrentScrollHandlerFrame = aFrame;
 }
 
 /* static */ void
+ActiveLayerTracker::SimulateTimeAdvance(int64_t aMilliseconds)
+{
+  if (aMilliseconds < 0) {
+    return;
+  }
+
+  if (gLayerActivityTracker) {
+    // Round to the nearest number of iterations.
+    uint32_t timerPeriod = gLayerActivityTracker->TimerPeriod();
+    uint32_t iterations = (aMilliseconds + timerPeriod / 2) / timerPeriod;
+    iterations = std::min(iterations, gLayerActivityTracker->GenerationCount());
+
+    while (iterations-- != 0) {
+      gLayerActivityTracker->AgeOneGeneration();
+    }
+  }
+}
+
+/* static */ void
 ActiveLayerTracker::Shutdown()
 {
   delete gLayerActivityTracker;
   gLayerActivityTracker = nullptr;
 }
 
 } // namespace mozilla
diff --git a/layout/base/ActiveLayerTracker.h b/layout/base/ActiveLayerTracker.h
--- a/layout/base/ActiveLayerTracker.h
+++ b/layout/base/ActiveLayerTracker.h
@@ -1,16 +1,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef ACTIVELAYERTRACKER_H_
 #define ACTIVELAYERTRACKER_H_
 
 #include "nsCSSProperty.h"
+#include "mozilla/Types.h"
 
 class nsIFrame;
 class nsIContent;
 class nsDisplayListBuilder;
 class nsDOMCSSDeclaration;
 
 namespace mozilla {
 
@@ -124,13 +125,19 @@ public:
   static bool IsContentActive(nsIFrame* aFrame);
 
   /**
    * Called before and after a scroll event handler is executed, with the
    * scrollframe or nullptr, respectively. This acts as a hint to treat
    * inline style changes during the handler differently.
    */
   static void SetCurrentScrollHandlerFrame(nsIFrame* aFrame);
+
+  /**
+   * Method to allow tests to simulate the advance of time.  Rounds to
+   * the granularity of the expiration tracker.
+   */
+  static void SimulateTimeAdvance(int64_t aMilliseconds);
 };
 
 } // namespace mozilla
 
 #endif /* ACTIVELAYERTRACKER_H_ */
diff --git a/xpcom/ds/nsExpirationTracker.h b/xpcom/ds/nsExpirationTracker.h
--- a/xpcom/ds/nsExpirationTracker.h
+++ b/xpcom/ds/nsExpirationTracker.h
@@ -96,16 +96,38 @@ public:
   ~nsExpirationTracker()
   {
     if (mTimer) {
       mTimer->Cancel();
     }
     mObserver->Destroy();
   }
 
+  uint32_t GenerationCount() const
+  {
+    return K;
+  }
+
+  // The timer period (interval for aging one generation), in milliseconds.
+  uint32_t TimerPeriod() const
+  {
+    return mTimerPeriod;
+  }
+
+  // The bounds (in milliseconds) on object expiration, assuming
+  // accurate timer firing.
+  uint32_t MinExpirationInterval() const
+  {
+    return TimerPeriod() * (GenerationCount() - 1);
+  }
+  uint32_t MaxExpirationInterval() const
+  {
+    return TimerPeriod() * GenerationCount();
+  }
+
   /**
    * Add an object to be tracked. It must not already be tracked. It will
    * be added to the newest generation, i.e., as if it was just used.
    * @return an error on out-of-memory
    */
   nsresult AddObject(T* aObj)
   {
     nsExpirationState* state = aObj->GetExpirationState();
