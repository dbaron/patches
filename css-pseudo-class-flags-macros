From: L. David Baron <dbaron@dbaron.org>

Bug 1082899 patch 1 - Add a flags field to the CSS_PSEUDO_CLASS and related macros.  r=birtles

diff --git a/layout/inspector/inDOMUtils.cpp b/layout/inspector/inDOMUtils.cpp
--- a/layout/inspector/inDOMUtils.cpp
+++ b/layout/inspector/inDOMUtils.cpp
@@ -971,19 +971,19 @@ inDOMUtils::GetUsedFontFaces(nsIDOMRange
 }
 
 static EventStates
 GetStatesForPseudoClass(const nsAString& aStatePseudo)
 {
   // An array of the states that are relevant for various pseudoclasses.
   // XXXbz this duplicates code in nsCSSRuleProcessor
   static const EventStates sPseudoClassStates[] = {
-#define CSS_PSEUDO_CLASS(_name, _value, _pref)	\
+#define CSS_PSEUDO_CLASS(_name, _value, _flags, _pref) \
     EventStates(),
-#define CSS_STATE_PSEUDO_CLASS(_name, _value, _pref, _states)	\
+#define CSS_STATE_PSEUDO_CLASS(_name, _value, _flags, _pref, _states) \
     _states,
 #include "nsCSSPseudoClassList.h"
 #undef CSS_STATE_PSEUDO_CLASS
 #undef CSS_PSEUDO_CLASS
 
     // Add more entries for our fake values to make sure we can't
     // index out of bounds into this array no matter what.
     EventStates(),
diff --git a/layout/style/nsCSSPseudoClassList.h b/layout/style/nsCSSPseudoClassList.h
--- a/layout/style/nsCSSPseudoClassList.h
+++ b/layout/style/nsCSSPseudoClassList.h
@@ -7,212 +7,219 @@
 
 /*
  * This file contains the list of nsIAtoms and their values for CSS
  * pseudo-classes.  It is designed to be used as inline input to
  * nsCSSPseudoClasses.cpp *only* through the magic of C preprocessing.
  * All entries must be enclosed in the macros CSS_PSEUDO_CLASS,
  * CSS_STATE_DEPENDENT_PSEUDO_CLASS, or CSS_STATE_PSEUDO_CLASS which
  * will have cruel and unusual things done to them.  The entries should
- * be kept in some sort of logical order.  The first argument to
- * CSS_PSEUDO_CLASS is the C++ identifier of the atom.  The second
- * argument is the string value of the atom.  The third argument is the
- * name of the preference controlling whether the pseudo-class is
- * recognized by the parser, or the empty string if it's unconditional.
- *
- * CSS_STATE_DEPENDENT_PSEUDO_CLASS and CSS_STATE_PSEUDO_CLASS also take
- * the name of the state bits that the class corresponds to.  Only one
- * of the bits needs to match for a CSS_STATE_PSEUDO_CLASS to match;
- * CSS_STATE_DEPENDENT_PSEUDO_CLASS matching depends on a customized per-class
- * algorithm which should be defined in SelectorMatches() in
- * nsCSSRuleProcessor.cpp.
+ * be kept in some sort of logical order.  The common arguments to these
+ * macros are:
+ * name_  : The C++ identifier used for the atom (which will be a member
+ *          of nsCSSPseudoClasses)
+ * value_ : The pseudo-class as a string, including the initial colon,
+ *          used as the string value of the atom.
+ * flags_ : A bitfield containing flags defined in nsCSSPseudoClasses.h
+ * pref_  : The name of the preference controlling whether the
+ *          pseudo-class is recognized by the parser, or the empty
+ *          string if it's unconditional.
+ * CSS_STATE_PSEUDO_CLASS has an additional argument:
+ * bit_   : The event state bit or bits that corresponds to the
+ *          pseudo-class, i.e., causes it to match (only one bit
+ *          required).
+ * CSS_STATE_DEPENDENT_PSEUDO_CLASS has an additional argument:
+ * bit_   : The event state bits that affect whether the pseudo-class
+ *          matches.  Matching depends on a customized per-class
+ *          algorithm which should be defined in SelectorMatches() in
+ *          nsCSSRuleProcessor.cpp.
  *
  * If CSS_STATE_PSEUDO_CLASS is not defined, it'll be automatically
  * defined to CSS_STATE_DEPENDENT_PSEUDO_CLASS;
  * if CSS_STATE_DEPENDENT_PSEUDO_CLASS is not defined, it'll be
  * automatically defined to CSS_PSEUDO_CLASS.
  */
 
 // OUTPUT_CLASS=nsCSSPseudoClasses
 // MACRO_NAME=CSS_PSEUDO_CLASS
 
 #ifdef DEFINED_CSS_STATE_DEPENDENT_PSEUDO_CLASS
 #error "CSS_STATE_DEPENDENT_PSEUDO_CLASS shouldn't be defined"
 #endif
 
 #ifndef CSS_STATE_DEPENDENT_PSEUDO_CLASS
-#define CSS_STATE_DEPENDENT_PSEUDO_CLASS(_name, _value, _pref, _bit)  \
-  CSS_PSEUDO_CLASS(_name, _value, _pref)
+#define CSS_STATE_DEPENDENT_PSEUDO_CLASS(_name, _value, _flags, _pref, _bit)  \
+  CSS_PSEUDO_CLASS(_name, _value, _flags, _pref)
 #define DEFINED_CSS_STATE_DEPENDENT_PSEUDO_CLASS
 #endif
 
 #ifdef DEFINED_CSS_STATE_PSEUDO_CLASS
 #error "CSS_STATE_PSEUDO_CLASS shouldn't be defined"
 #endif
 
 #ifndef CSS_STATE_PSEUDO_CLASS
-#define CSS_STATE_PSEUDO_CLASS(_name, _value, _pref, _bit)      \
-  CSS_STATE_DEPENDENT_PSEUDO_CLASS(_name, _value, _pref, _bit)
+#define CSS_STATE_PSEUDO_CLASS(_name, _value, _flags, _pref, _bit)      \
+  CSS_STATE_DEPENDENT_PSEUDO_CLASS(_name, _value, _flags, _pref, _bit)
 #define DEFINED_CSS_STATE_PSEUDO_CLASS
 #endif
 
 // The CSS_PSEUDO_CLASS entries should all come before the
 // CSS_STATE_PSEUDO_CLASS entries.  The CSS_PSEUDO_CLASS entry order
 // must be the same as the order of cases in SelectorMatches.  :not
 // must be the last CSS_PSEUDO_CLASS.
 
-CSS_PSEUDO_CLASS(empty, ":empty", "")
-CSS_PSEUDO_CLASS(mozOnlyWhitespace, ":-moz-only-whitespace", "")
-CSS_PSEUDO_CLASS(mozEmptyExceptChildrenWithLocalname, ":-moz-empty-except-children-with-localname", "")
-CSS_PSEUDO_CLASS(lang, ":lang", "")
-CSS_PSEUDO_CLASS(mozBoundElement, ":-moz-bound-element", "")
-CSS_PSEUDO_CLASS(root, ":root", "")
-CSS_PSEUDO_CLASS(any, ":-moz-any", "")
+CSS_PSEUDO_CLASS(empty, ":empty", 0, "")
+CSS_PSEUDO_CLASS(mozOnlyWhitespace, ":-moz-only-whitespace", 0, "")
+CSS_PSEUDO_CLASS(mozEmptyExceptChildrenWithLocalname, ":-moz-empty-except-children-with-localname", 0, "")
+CSS_PSEUDO_CLASS(lang, ":lang", 0, "")
+CSS_PSEUDO_CLASS(mozBoundElement, ":-moz-bound-element", 0, "")
+CSS_PSEUDO_CLASS(root, ":root", 0, "")
+CSS_PSEUDO_CLASS(any, ":-moz-any", 0, "")
 
-CSS_PSEUDO_CLASS(firstChild, ":first-child", "")
-CSS_PSEUDO_CLASS(firstNode, ":-moz-first-node", "")
-CSS_PSEUDO_CLASS(lastChild, ":last-child", "")
-CSS_PSEUDO_CLASS(lastNode, ":-moz-last-node", "")
-CSS_PSEUDO_CLASS(onlyChild, ":only-child", "")
-CSS_PSEUDO_CLASS(firstOfType, ":first-of-type", "")
-CSS_PSEUDO_CLASS(lastOfType, ":last-of-type", "")
-CSS_PSEUDO_CLASS(onlyOfType, ":only-of-type", "")
-CSS_PSEUDO_CLASS(nthChild, ":nth-child", "")
-CSS_PSEUDO_CLASS(nthLastChild, ":nth-last-child", "")
-CSS_PSEUDO_CLASS(nthOfType, ":nth-of-type", "")
-CSS_PSEUDO_CLASS(nthLastOfType, ":nth-last-of-type", "")
+CSS_PSEUDO_CLASS(firstChild, ":first-child", 0, "")
+CSS_PSEUDO_CLASS(firstNode, ":-moz-first-node", 0, "")
+CSS_PSEUDO_CLASS(lastChild, ":last-child", 0, "")
+CSS_PSEUDO_CLASS(lastNode, ":-moz-last-node", 0, "")
+CSS_PSEUDO_CLASS(onlyChild, ":only-child", 0, "")
+CSS_PSEUDO_CLASS(firstOfType, ":first-of-type", 0, "")
+CSS_PSEUDO_CLASS(lastOfType, ":last-of-type", 0, "")
+CSS_PSEUDO_CLASS(onlyOfType, ":only-of-type", 0, "")
+CSS_PSEUDO_CLASS(nthChild, ":nth-child", 0, "")
+CSS_PSEUDO_CLASS(nthLastChild, ":nth-last-child", 0, "")
+CSS_PSEUDO_CLASS(nthOfType, ":nth-of-type", 0, "")
+CSS_PSEUDO_CLASS(nthLastOfType, ":nth-last-of-type", 0, "")
 
 // Match nodes that are HTML but not XHTML
-CSS_PSEUDO_CLASS(mozIsHTML, ":-moz-is-html", "")
+CSS_PSEUDO_CLASS(mozIsHTML, ":-moz-is-html", 0, "")
 
 // Matches anything when the specified look-and-feel metric is set
-CSS_PSEUDO_CLASS(mozSystemMetric, ":-moz-system-metric", "")
+CSS_PSEUDO_CLASS(mozSystemMetric, ":-moz-system-metric", 0, "")
 
 // -moz-locale-dir(ltr) and -moz-locale-dir(rtl) may be used
 // to match based on the locale's chrome direction
-CSS_PSEUDO_CLASS(mozLocaleDir, ":-moz-locale-dir", "")
+CSS_PSEUDO_CLASS(mozLocaleDir, ":-moz-locale-dir", 0, "")
 
 // -moz-lwtheme may be used to match a document that has a lightweight theme
-CSS_PSEUDO_CLASS(mozLWTheme, ":-moz-lwtheme", "")
+CSS_PSEUDO_CLASS(mozLWTheme, ":-moz-lwtheme", 0, "")
 
 // -moz-lwtheme-brighttext matches a document that has a dark lightweight theme
-CSS_PSEUDO_CLASS(mozLWThemeBrightText, ":-moz-lwtheme-brighttext", "")
+CSS_PSEUDO_CLASS(mozLWThemeBrightText, ":-moz-lwtheme-brighttext", 0, "")
 
 // -moz-lwtheme-darktext matches a document that has a bright lightweight theme
-CSS_PSEUDO_CLASS(mozLWThemeDarkText, ":-moz-lwtheme-darktext", "")
+CSS_PSEUDO_CLASS(mozLWThemeDarkText, ":-moz-lwtheme-darktext", 0, "")
 
 // Matches anything when the containing window is inactive
-CSS_PSEUDO_CLASS(mozWindowInactive, ":-moz-window-inactive", "")
+CSS_PSEUDO_CLASS(mozWindowInactive, ":-moz-window-inactive", 0, "")
 
 // Matches any table elements that have a nonzero border attribute,
 // according to HTML integer attribute parsing rules.
-CSS_PSEUDO_CLASS(mozTableBorderNonzero, ":-moz-table-border-nonzero", "")
+CSS_PSEUDO_CLASS(mozTableBorderNonzero, ":-moz-table-border-nonzero", 0, "")
 
 // Matches whatever the contextual reference elements are for the
 // matching operation.
-CSS_PSEUDO_CLASS(scope, ":scope", "layout.css.scope-pseudo.enabled")
+CSS_PSEUDO_CLASS(scope, ":scope", 0, "layout.css.scope-pseudo.enabled")
 
 // :not needs to come at the end of the non-bit pseudo-class list, since
 // it doesn't actually get directly matched on in SelectorMatches.
-CSS_PSEUDO_CLASS(notPseudo, ":not", "")
+CSS_PSEUDO_CLASS(notPseudo, ":not", 0, "")
 
 // :-moz-dir(ltr) and :-moz-dir(rtl) match elements whose resolved
 // directionality in the markup language is ltr or rtl respectively
-CSS_STATE_DEPENDENT_PSEUDO_CLASS(dir, ":-moz-dir", "",
+CSS_STATE_DEPENDENT_PSEUDO_CLASS(dir, ":-moz-dir", 0, "",
                                  NS_EVENT_STATE_LTR | NS_EVENT_STATE_RTL)
 
-CSS_STATE_PSEUDO_CLASS(link, ":link", "", NS_EVENT_STATE_UNVISITED)
+CSS_STATE_PSEUDO_CLASS(link, ":link", 0, "", NS_EVENT_STATE_UNVISITED)
 // what matches :link or :visited
-CSS_STATE_PSEUDO_CLASS(mozAnyLink, ":-moz-any-link", "",
+CSS_STATE_PSEUDO_CLASS(mozAnyLink, ":-moz-any-link", 0, "",
                        NS_EVENT_STATE_VISITED | NS_EVENT_STATE_UNVISITED)
-CSS_STATE_PSEUDO_CLASS(visited, ":visited", "", NS_EVENT_STATE_VISITED)
+CSS_STATE_PSEUDO_CLASS(visited, ":visited", 0, "", NS_EVENT_STATE_VISITED)
 
-CSS_STATE_PSEUDO_CLASS(active, ":active", "", NS_EVENT_STATE_ACTIVE)
-CSS_STATE_PSEUDO_CLASS(checked, ":checked", "", NS_EVENT_STATE_CHECKED)
-CSS_STATE_PSEUDO_CLASS(disabled, ":disabled", "", NS_EVENT_STATE_DISABLED)
-CSS_STATE_PSEUDO_CLASS(enabled, ":enabled", "", NS_EVENT_STATE_ENABLED)
-CSS_STATE_PSEUDO_CLASS(focus, ":focus", "", NS_EVENT_STATE_FOCUS)
-CSS_STATE_PSEUDO_CLASS(hover, ":hover", "", NS_EVENT_STATE_HOVER)
-CSS_STATE_PSEUDO_CLASS(mozDragOver, ":-moz-drag-over", "", NS_EVENT_STATE_DRAGOVER)
-CSS_STATE_PSEUDO_CLASS(target, ":target", "", NS_EVENT_STATE_URLTARGET)
-CSS_STATE_PSEUDO_CLASS(indeterminate, ":indeterminate", "",
+CSS_STATE_PSEUDO_CLASS(active, ":active", 0, "", NS_EVENT_STATE_ACTIVE)
+CSS_STATE_PSEUDO_CLASS(checked, ":checked", 0, "", NS_EVENT_STATE_CHECKED)
+CSS_STATE_PSEUDO_CLASS(disabled, ":disabled", 0, "", NS_EVENT_STATE_DISABLED)
+CSS_STATE_PSEUDO_CLASS(enabled, ":enabled", 0, "", NS_EVENT_STATE_ENABLED)
+CSS_STATE_PSEUDO_CLASS(focus, ":focus", 0, "", NS_EVENT_STATE_FOCUS)
+CSS_STATE_PSEUDO_CLASS(hover, ":hover", 0, "", NS_EVENT_STATE_HOVER)
+CSS_STATE_PSEUDO_CLASS(mozDragOver, ":-moz-drag-over", 0, "", NS_EVENT_STATE_DRAGOVER)
+CSS_STATE_PSEUDO_CLASS(target, ":target", 0, "", NS_EVENT_STATE_URLTARGET)
+CSS_STATE_PSEUDO_CLASS(indeterminate, ":indeterminate", 0, "",
                        NS_EVENT_STATE_INDETERMINATE)
 
-CSS_STATE_PSEUDO_CLASS(mozDevtoolsHighlighted, ":-moz-devtools-highlighted", "",
+CSS_STATE_PSEUDO_CLASS(mozDevtoolsHighlighted, ":-moz-devtools-highlighted", 0, "",
                        NS_EVENT_STATE_DEVTOOLS_HIGHLIGHTED)
 
 // Matches the element which is being displayed full-screen, and
 // any containing frames.
-CSS_STATE_PSEUDO_CLASS(mozFullScreen, ":-moz-full-screen", "", NS_EVENT_STATE_FULL_SCREEN)
+CSS_STATE_PSEUDO_CLASS(mozFullScreen, ":-moz-full-screen", 0, "", NS_EVENT_STATE_FULL_SCREEN)
 
 // Matches any element which is an ancestor of the DOM full-screen element,
 // or an ancestor of a containing frame of the full-screen element.
-CSS_STATE_PSEUDO_CLASS(mozFullScreenAncestor, ":-moz-full-screen-ancestor", "", NS_EVENT_STATE_FULL_SCREEN_ANCESTOR)
+CSS_STATE_PSEUDO_CLASS(mozFullScreenAncestor, ":-moz-full-screen-ancestor", 0, "", NS_EVENT_STATE_FULL_SCREEN_ANCESTOR)
 
 // Matches if the element is focused and should show a focus ring
-CSS_STATE_PSEUDO_CLASS(mozFocusRing, ":-moz-focusring", "", NS_EVENT_STATE_FOCUSRING)
+CSS_STATE_PSEUDO_CLASS(mozFocusRing, ":-moz-focusring", 0, "", NS_EVENT_STATE_FOCUSRING)
 
 // Image, object, etc state pseudo-classes
-CSS_STATE_PSEUDO_CLASS(mozBroken, ":-moz-broken", "", NS_EVENT_STATE_BROKEN)
-CSS_STATE_PSEUDO_CLASS(mozUserDisabled, ":-moz-user-disabled", "",
+CSS_STATE_PSEUDO_CLASS(mozBroken, ":-moz-broken", 0, "", NS_EVENT_STATE_BROKEN)
+CSS_STATE_PSEUDO_CLASS(mozUserDisabled, ":-moz-user-disabled", 0, "",
                        NS_EVENT_STATE_USERDISABLED)
-CSS_STATE_PSEUDO_CLASS(mozSuppressed, ":-moz-suppressed", "",
+CSS_STATE_PSEUDO_CLASS(mozSuppressed, ":-moz-suppressed", 0, "",
                        NS_EVENT_STATE_SUPPRESSED)
-CSS_STATE_PSEUDO_CLASS(mozLoading, ":-moz-loading", "", NS_EVENT_STATE_LOADING)
-CSS_STATE_PSEUDO_CLASS(mozTypeUnsupported, ":-moz-type-unsupported", "",
+CSS_STATE_PSEUDO_CLASS(mozLoading, ":-moz-loading", 0, "", NS_EVENT_STATE_LOADING)
+CSS_STATE_PSEUDO_CLASS(mozTypeUnsupported, ":-moz-type-unsupported", 0, "",
                        NS_EVENT_STATE_TYPE_UNSUPPORTED)
-CSS_STATE_PSEUDO_CLASS(mozTypeUnsupportedPlatform, ":-moz-type-unsupported-platform", "",
+CSS_STATE_PSEUDO_CLASS(mozTypeUnsupportedPlatform, ":-moz-type-unsupported-platform", 0, "",
                        NS_EVENT_STATE_TYPE_UNSUPPORTED_PLATFORM)
-CSS_STATE_PSEUDO_CLASS(mozHandlerClickToPlay, ":-moz-handler-clicktoplay", "",
+CSS_STATE_PSEUDO_CLASS(mozHandlerClickToPlay, ":-moz-handler-clicktoplay", 0, "",
                        NS_EVENT_STATE_TYPE_CLICK_TO_PLAY)
-CSS_STATE_PSEUDO_CLASS(mozHandlerPlayPreview, ":-moz-handler-playpreview", "",
+CSS_STATE_PSEUDO_CLASS(mozHandlerPlayPreview, ":-moz-handler-playpreview", 0, "",
                        NS_EVENT_STATE_TYPE_PLAY_PREVIEW)
-CSS_STATE_PSEUDO_CLASS(mozHandlerVulnerableUpdatable, ":-moz-handler-vulnerable-updatable", "",
+CSS_STATE_PSEUDO_CLASS(mozHandlerVulnerableUpdatable, ":-moz-handler-vulnerable-updatable", 0, "",
                        NS_EVENT_STATE_VULNERABLE_UPDATABLE)
-CSS_STATE_PSEUDO_CLASS(mozHandlerVulnerableNoUpdate, ":-moz-handler-vulnerable-no-update", "",
+CSS_STATE_PSEUDO_CLASS(mozHandlerVulnerableNoUpdate, ":-moz-handler-vulnerable-no-update", 0, "",
                        NS_EVENT_STATE_VULNERABLE_NO_UPDATE)
-CSS_STATE_PSEUDO_CLASS(mozHandlerDisabled, ":-moz-handler-disabled", "",
+CSS_STATE_PSEUDO_CLASS(mozHandlerDisabled, ":-moz-handler-disabled", 0, "",
                        NS_EVENT_STATE_HANDLER_DISABLED)
-CSS_STATE_PSEUDO_CLASS(mozHandlerBlocked, ":-moz-handler-blocked", "",
+CSS_STATE_PSEUDO_CLASS(mozHandlerBlocked, ":-moz-handler-blocked", 0, "",
                        NS_EVENT_STATE_HANDLER_BLOCKED)
-CSS_STATE_PSEUDO_CLASS(mozHandlerCrashed, ":-moz-handler-crashed", "",
+CSS_STATE_PSEUDO_CLASS(mozHandlerCrashed, ":-moz-handler-crashed", 0, "",
                        NS_EVENT_STATE_HANDLER_CRASHED)
 
 CSS_STATE_PSEUDO_CLASS(mozMathIncrementScriptLevel,
-                       ":-moz-math-increment-script-level", "",
+                       ":-moz-math-increment-script-level", 0, "",
                        NS_EVENT_STATE_INCREMENT_SCRIPT_LEVEL)
 
 // CSS 3 UI
 // http://www.w3.org/TR/2004/CR-css3-ui-20040511/#pseudo-classes
-CSS_STATE_PSEUDO_CLASS(required, ":required", "", NS_EVENT_STATE_REQUIRED)
-CSS_STATE_PSEUDO_CLASS(optional, ":optional", "", NS_EVENT_STATE_OPTIONAL)
-CSS_STATE_PSEUDO_CLASS(valid, ":valid", "", NS_EVENT_STATE_VALID)
-CSS_STATE_PSEUDO_CLASS(invalid, ":invalid", "", NS_EVENT_STATE_INVALID)
-CSS_STATE_PSEUDO_CLASS(inRange, ":in-range", "", NS_EVENT_STATE_INRANGE)
-CSS_STATE_PSEUDO_CLASS(outOfRange, ":out-of-range", "", NS_EVENT_STATE_OUTOFRANGE)
-CSS_STATE_PSEUDO_CLASS(defaultPseudo, ":default", "", NS_EVENT_STATE_DEFAULT)
-CSS_STATE_PSEUDO_CLASS(mozReadOnly, ":-moz-read-only", "",
+CSS_STATE_PSEUDO_CLASS(required, ":required", 0, "", NS_EVENT_STATE_REQUIRED)
+CSS_STATE_PSEUDO_CLASS(optional, ":optional", 0, "", NS_EVENT_STATE_OPTIONAL)
+CSS_STATE_PSEUDO_CLASS(valid, ":valid", 0, "", NS_EVENT_STATE_VALID)
+CSS_STATE_PSEUDO_CLASS(invalid, ":invalid", 0, "", NS_EVENT_STATE_INVALID)
+CSS_STATE_PSEUDO_CLASS(inRange, ":in-range", 0, "", NS_EVENT_STATE_INRANGE)
+CSS_STATE_PSEUDO_CLASS(outOfRange, ":out-of-range", 0, "", NS_EVENT_STATE_OUTOFRANGE)
+CSS_STATE_PSEUDO_CLASS(defaultPseudo, ":default", 0, "", NS_EVENT_STATE_DEFAULT)
+CSS_STATE_PSEUDO_CLASS(mozReadOnly, ":-moz-read-only", 0, "",
                        NS_EVENT_STATE_MOZ_READONLY)
-CSS_STATE_PSEUDO_CLASS(mozReadWrite, ":-moz-read-write", "",
+CSS_STATE_PSEUDO_CLASS(mozReadWrite, ":-moz-read-write", 0, "",
                        NS_EVENT_STATE_MOZ_READWRITE)
-CSS_STATE_PSEUDO_CLASS(mozSubmitInvalid, ":-moz-submit-invalid", "",
+CSS_STATE_PSEUDO_CLASS(mozSubmitInvalid, ":-moz-submit-invalid", 0, "",
                        NS_EVENT_STATE_MOZ_SUBMITINVALID)
-CSS_STATE_PSEUDO_CLASS(mozUIInvalid, ":-moz-ui-invalid", "",
+CSS_STATE_PSEUDO_CLASS(mozUIInvalid, ":-moz-ui-invalid", 0, "",
                        NS_EVENT_STATE_MOZ_UI_INVALID)
-CSS_STATE_PSEUDO_CLASS(mozUIValid, ":-moz-ui-valid", "",
+CSS_STATE_PSEUDO_CLASS(mozUIValid, ":-moz-ui-valid", 0, "",
                        NS_EVENT_STATE_MOZ_UI_VALID)
-CSS_STATE_PSEUDO_CLASS(mozMeterOptimum, ":-moz-meter-optimum", "",
+CSS_STATE_PSEUDO_CLASS(mozMeterOptimum, ":-moz-meter-optimum", 0, "",
                        NS_EVENT_STATE_OPTIMUM)
-CSS_STATE_PSEUDO_CLASS(mozMeterSubOptimum, ":-moz-meter-sub-optimum", "",
+CSS_STATE_PSEUDO_CLASS(mozMeterSubOptimum, ":-moz-meter-sub-optimum", 0, "",
                        NS_EVENT_STATE_SUB_OPTIMUM)
-CSS_STATE_PSEUDO_CLASS(mozMeterSubSubOptimum, ":-moz-meter-sub-sub-optimum", "",
+CSS_STATE_PSEUDO_CLASS(mozMeterSubSubOptimum, ":-moz-meter-sub-sub-optimum", 0, "",
                        NS_EVENT_STATE_SUB_SUB_OPTIMUM)
 
 // Those values should be parsed but do nothing.
-CSS_STATE_PSEUDO_CLASS(mozPlaceholder, ":-moz-placeholder", "", NS_EVENT_STATE_IGNORE)
+CSS_STATE_PSEUDO_CLASS(mozPlaceholder, ":-moz-placeholder", 0, "", NS_EVENT_STATE_IGNORE)
 
 #ifdef DEFINED_CSS_STATE_PSEUDO_CLASS
 #undef DEFINED_CSS_STATE_PSEUDO_CLASS
 #undef CSS_STATE_PSEUDO_CLASS
 #endif
 
 #ifdef DEFINED_CSS_STATE_DEPENDENT_PSEUDO_CLASS
 #undef DEFINED_CSS_STATE_DEPENDENT_PSEUDO_CLASS
diff --git a/layout/style/nsCSSPseudoClasses.cpp b/layout/style/nsCSSPseudoClasses.cpp
--- a/layout/style/nsCSSPseudoClasses.cpp
+++ b/layout/style/nsCSSPseudoClasses.cpp
@@ -10,45 +10,45 @@
 #include "nsCSSPseudoClasses.h"
 #include "nsStaticAtom.h"
 #include "mozilla/Preferences.h"
 #include "nsString.h"
 
 using namespace mozilla;
 
 // define storage for all atoms
-#define CSS_PSEUDO_CLASS(_name, _value, _pref) \
+#define CSS_PSEUDO_CLASS(_name, _value, _flags, _pref) \
   static nsIAtom* sPseudoClass_##_name;
 #include "nsCSSPseudoClassList.h"
 #undef CSS_PSEUDO_CLASS
 
-#define CSS_PSEUDO_CLASS(name_, value_, pref_)  \
+#define CSS_PSEUDO_CLASS(name_, value_, flags_, pref_) \
   NS_STATIC_ATOM_BUFFER(name_##_pseudo_class_buffer, value_)
 #include "nsCSSPseudoClassList.h"
 #undef CSS_PSEUDO_CLASS
 
 static const nsStaticAtom CSSPseudoClasses_info[] = {
-#define CSS_PSEUDO_CLASS(name_, value_, pref_)            \
+#define CSS_PSEUDO_CLASS(name_, value_, flags_, pref_) \
   NS_STATIC_ATOM(name_##_pseudo_class_buffer, &sPseudoClass_##name_),
 #include "nsCSSPseudoClassList.h"
 #undef CSS_PSEUDO_CLASS
 };
 
 static bool sPseudoClassEnabled[] = {
-#define CSS_PSEUDO_CLASS(name_, value_, pref_)            \
+#define CSS_PSEUDO_CLASS(name_, value_, flags_, pref_) \
   true,
 #include "nsCSSPseudoClassList.h"
 #undef CSS_PSEUDO_CLASS
 };  
 
 void nsCSSPseudoClasses::AddRefAtoms()
 {
   NS_RegisterStaticAtoms(CSSPseudoClasses_info);
   
-#define CSS_PSEUDO_CLASS(name_, value_, pref_)                               \
+#define CSS_PSEUDO_CLASS(name_, value_, flags_, pref_)                       \
   if (pref_[0]) {                                                            \
     Preferences::AddBoolVarCache(&sPseudoClassEnabled[ePseudoClass_##name_], \
                                  pref_);                                     \
   }
 #include "nsCSSPseudoClassList.h"
 #undef CSS_PSEUDO_CLASS
 }
 
diff --git a/layout/style/nsCSSPseudoClasses.h b/layout/style/nsCSSPseudoClasses.h
--- a/layout/style/nsCSSPseudoClasses.h
+++ b/layout/style/nsCSSPseudoClasses.h
@@ -13,17 +13,17 @@
 class nsIAtom;
 
 class nsCSSPseudoClasses {
 public:
 
   static void AddRefAtoms();
 
   enum Type {
-#define CSS_PSEUDO_CLASS(_name, _value, _pref)        \
+#define CSS_PSEUDO_CLASS(_name, _value, _flags, _pref) \
     ePseudoClass_##_name,
 #include "nsCSSPseudoClassList.h"
 #undef CSS_PSEUDO_CLASS
     ePseudoClass_Count,
     ePseudoClass_NotPseudoClass /* This value MUST be last!  SelectorMatches
                                    depends on it. */
   };
 
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1625,33 +1625,33 @@ checkGenericEmptyMatches(Element* aEleme
     // stop at first non-comment (and non-whitespace for
     // :-moz-only-whitespace) node        
   } while (child && !IsSignificantChild(child, true, isWhitespaceSignificant));
   return (child == nullptr);
 }
 
 // Arrays of the states that are relevant for various pseudoclasses.
 static const EventStates sPseudoClassStateDependences[] = {
-#define CSS_PSEUDO_CLASS(_name, _value, _pref)  \
+#define CSS_PSEUDO_CLASS(_name, _value, _flags, _pref) \
   EventStates(),
-#define CSS_STATE_DEPENDENT_PSEUDO_CLASS(_name, _value, _pref, _states)  \
+#define CSS_STATE_DEPENDENT_PSEUDO_CLASS(_name, _value, _flags, _pref, _states) \
   _states,
 #include "nsCSSPseudoClassList.h"
 #undef CSS_STATE_DEPENDENT_PSEUDO_CLASS
 #undef CSS_PSEUDO_CLASS
   // Add more entries for our fake values to make sure we can't
   // index out of bounds into this array no matter what.
   EventStates(),
   EventStates()
 };
 
 static const EventStates sPseudoClassStates[] = {
-#define CSS_PSEUDO_CLASS(_name, _value, _pref)  \
+#define CSS_PSEUDO_CLASS(_name, _value, _flags, _pref) \
   EventStates(),
-#define CSS_STATE_PSEUDO_CLASS(_name, _value, _pref, _states) \
+#define CSS_STATE_PSEUDO_CLASS(_name, _value, _flags, _pref, _states) \
   _states,
 #include "nsCSSPseudoClassList.h"
 #undef CSS_STATE_PSEUDO_CLASS
 #undef CSS_PSEUDO_CLASS
   // Add more entries for our fake values to make sure we can't
   // index out of bounds into this array no matter what.
   EventStates(),
   EventStates()
