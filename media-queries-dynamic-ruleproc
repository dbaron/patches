Implement media queries, part 3: infrastructure for dynamic change handling at the rule processor and style set level.  b=156716

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -730,8 +730,9 @@ RuleCascadeData::AttributeListFor(nsIAto
 //
 
 nsCSSRuleProcessor::nsCSSRuleProcessor(const nsCOMArray<nsICSSStyleSheet>& aSheets)
-  : mSheets(aSheets),
-    mRuleCascades(nsnull)
+  : mSheets(aSheets)
+  , mRuleCascades(nsnull)
+  , mLastPresContext(nsnull)
 {
   for (PRInt32 i = mSheets.Count() - 1; i >= 0; --i)
     mSheets[i]->AddRuleProcessor(this);
@@ -2040,6 +2041,16 @@ nsCSSRuleProcessor::HasAttributeDependen
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsCSSRuleProcessor::MediumFeaturesChanged(nsPresContext* aPresContext,
+                                          PRBool* aRulesChanged)
+{
+  RuleCascadeData *old = mRuleCascades;
+  RefreshRuleCascade(aPresContext);
+  *aRulesChanged = (old != mRuleCascades);
+  return NS_OK;
+}
+
 nsresult
 nsCSSRuleProcessor::ClearRuleCascades()
 {
@@ -2302,6 +2313,24 @@ RuleCascadeData*
 RuleCascadeData*
 nsCSSRuleProcessor::GetRuleCascade(nsPresContext* aPresContext)
 {
+  // If anything changes about the presentation context, we will be
+  // notified.  Otherwise, our cache is valid if mLastPresContext
+  // matches aPresContext.  (The only rule processors used for multiple
+  // pres contexts are for XBL.  These rule processors are probably less
+  // likely to have @media rules, and thus the cache is pretty likely to
+  // hit instantly even when we're switching between pres contexts.)
+
+  if (!mRuleCascades || aPresContext != mLastPresContext) {
+    RefreshRuleCascade(aPresContext);
+  }
+  mLastPresContext = aPresContext;
+
+  return mRuleCascades;
+}
+
+void
+nsCSSRuleProcessor::RefreshRuleCascade(nsPresContext* aPresContext)
+{
   // Having RuleCascadeData objects be per-medium works for now since
   // nsCSSRuleProcessor objects are per-document.  (For a given set
   // of stylesheets they can vary based on medium (@media) or document
@@ -2311,8 +2340,14 @@ nsCSSRuleProcessor::GetRuleCascade(nsPre
   RuleCascadeData **cascadep = &mRuleCascades;
   RuleCascadeData *cascade;
   while ((cascade = *cascadep)) {
-    if (cascade->mCacheKey.Matches(aPresContext))
-      return cascade;
+    if (cascade->mCacheKey.Matches(aPresContext)) {
+      // Ensure that the current one is always mRuleCascades.
+      *cascadep = cascade->mNext;
+      cascade->mNext = mRuleCascades;
+      mRuleCascades = cascade;
+
+      return;
+    }
     cascadep = &cascade->mNext;
   }
 
@@ -2324,9 +2359,9 @@ nsCSSRuleProcessor::GetRuleCascade(nsPre
       CascadeEnumData data(aPresContext, newCascade->mCacheKey,
                            newCascade->mRuleHash.Arena());
       if (!data.mRulesByWeight.ops)
-        return nsnull;
+        return; /* out of memory */
       if (!mSheets.EnumerateForwards(CascadeSheetRulesInto, &data))
-        return nsnull;
+        return; /* out of memory */
 
       // Sort the hash table of per-weight linked lists by weight.
       PRUint32 weightCount = data.mRulesByWeight.entryCount;
@@ -2348,14 +2383,16 @@ nsCSSRuleProcessor::GetRuleCascade(nsPre
           // Calling |AddRule| reuses mNext!
           RuleValue *next = ruleValue->mNext;
           if (!AddRule(ruleValue, newCascade))
-            return nsnull;
+            return; /* out of memory */
           ruleValue = next;
         } while (ruleValue);
       }
 
-      *cascadep = newCascade;
+      // Ensure that the current one is always mRuleCascades.
+      newCascade->mNext = mRuleCascades;
+      mRuleCascades = newCascade;
       cascade = newCascade.forget();
     }
   }
-  return cascade;
+  return;
 }
diff --git a/layout/style/nsCSSRuleProcessor.h b/layout/style/nsCSSRuleProcessor.h
--- a/layout/style/nsCSSRuleProcessor.h
+++ b/layout/style/nsCSSRuleProcessor.h
@@ -84,13 +84,21 @@ public:
   NS_IMETHOD HasAttributeDependentStyle(AttributeRuleProcessorData* aData,
                                         nsReStyleHint* aResult);
 
+  NS_IMETHOD MediumFeaturesChanged(nsPresContext* aPresContext,
+                                   PRBool* aRulesChanged);
+
 protected:
   RuleCascadeData* GetRuleCascade(nsPresContext* aPresContext);
+  void RefreshRuleCascade(nsPresContext* aPresContext);
 
   // The sheet order here is the same as in nsStyleSet::mSheets
   nsCOMArray<nsICSSStyleSheet> mSheets;
 
+  // active first, then cached (most recent first)
   RuleCascadeData* mRuleCascades;
+
+  // The last pres context for which GetRuleCascades was called.
+  nsPresContext *mLastPresContext;
 };
 
 #endif /* nsCSSRuleProcessor_h_ */
diff --git a/layout/style/nsHTMLCSSStyleSheet.cpp b/layout/style/nsHTMLCSSStyleSheet.cpp
--- a/layout/style/nsHTMLCSSStyleSheet.cpp
+++ b/layout/style/nsHTMLCSSStyleSheet.cpp
@@ -366,6 +366,8 @@ public:
 
   NS_IMETHOD HasAttributeDependentStyle(AttributeRuleProcessorData* aData,
                                         nsReStyleHint* aResult);
+  NS_IMETHOD MediumFeaturesChanged(nsPresContext* aPresContext,
+                                  PRBool* aResult);
 
 #ifdef DEBUG
   virtual void List(FILE* out = stdout, PRInt32 aIndent = 0) const;
@@ -492,6 +494,13 @@ HTMLCSSStyleSheetImpl::HasAttributeDepen
   return NS_OK;
 }
 
+NS_IMETHODIMP
+HTMLCSSStyleSheetImpl::MediumFeaturesChanged(nsPresContext* aPresContext,
+                                             PRBool* aRulesChanged)
+{
+  *aRulesChanged = PR_FALSE;
+  return NS_OK;
+}
 
 
 NS_IMETHODIMP 
diff --git a/layout/style/nsHTMLStyleSheet.cpp b/layout/style/nsHTMLStyleSheet.cpp
--- a/layout/style/nsHTMLStyleSheet.cpp
+++ b/layout/style/nsHTMLStyleSheet.cpp
@@ -562,6 +562,14 @@ nsHTMLStyleSheet::HasAttributeDependentS
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsHTMLStyleSheet::MediumFeaturesChanged(nsPresContext* aPresContext,
+                                        PRBool* aRulesChanged)
+{
+  *aRulesChanged = PR_FALSE;
+  return NS_OK;
+}
+
 
 NS_IMETHODIMP
 nsHTMLStyleSheet::RulesMatching(PseudoRuleProcessorData* aData)
diff --git a/layout/style/nsHTMLStyleSheet.h b/layout/style/nsHTMLStyleSheet.h
--- a/layout/style/nsHTMLStyleSheet.h
+++ b/layout/style/nsHTMLStyleSheet.h
@@ -83,6 +83,8 @@ public:
                                     nsReStyleHint* aResult);
   NS_IMETHOD HasAttributeDependentStyle(AttributeRuleProcessorData* aData,
                                         nsReStyleHint* aResult);
+  NS_IMETHOD MediumFeaturesChanged(nsPresContext* aPresContext,
+                                   PRBool* aRulesChanged);
 
   nsresult Init(nsIURI* aURL, nsIDocument* aDocument);
   nsresult Reset(nsIURI* aURL);
diff --git a/layout/style/nsIStyleRuleProcessor.h b/layout/style/nsIStyleRuleProcessor.h
--- a/layout/style/nsIStyleRuleProcessor.h
+++ b/layout/style/nsIStyleRuleProcessor.h
@@ -239,6 +239,14 @@ public:
    */
   NS_IMETHOD HasAttributeDependentStyle(AttributeRuleProcessorData* aData,
                                         nsReStyleHint* aResult) = 0;
+
+  /**
+   * Do any processing that needs to happen as a result of a change in
+   * the characteristics of the medium, and return whether this rule
+   * processor's rules have changed (e.g., because of media queries).
+   */
+  NS_IMETHOD MediumFeaturesChanged(nsPresContext* aPresContext,
+                                   PRBool* aRulesChanged) = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIStyleRuleProcessor,
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -22,6 +22,7 @@
  * Contributor(s):
  *   Daniel Glazman <glazman@netscape.com>
  *   Brian Ryner    <bryner@brianryner.com>
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
@@ -954,3 +955,22 @@ nsStyleSet::HasAttributeDependentStyle(n
 
   return result;
 }
+
+PRBool
+nsStyleSet::MediumFeaturesChanged(nsPresContext* aPresContext)
+{
+  // We can't use WalkRuleProcessors without a content node.
+  // XXX We don't notify mBindingManager.  Should we?
+  PRBool stylesChanged = PR_FALSE;
+  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(mRuleProcessors); ++i) {
+    nsIStyleRuleProcessor *processor = mRuleProcessors[i];
+    if (!processor) {
+      continue;
+    }
+    PRBool thisChanged = PR_FALSE;
+    processor->MediumFeaturesChanged(aPresContext, &thisChanged);
+    stylesChanged = stylesChanged || thisChanged;
+  }
+
+  return stylesChanged;
+}
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -22,6 +22,7 @@
  * Contributor(s):
  *   Daniel Glazman <glazman@netscape.com>
  *   Brian Ryner    <bryner@brianryner.com>
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
@@ -142,6 +143,13 @@ class nsStyleSet
                                            nsIAtom*       aAttribute,
                                            PRInt32        aModType,
                                            PRUint32       aStateMask);
+
+  /*
+   * Do any processing that needs to happen as a result of a change in
+   * the characteristics of the medium, and return whether style rules
+   * may have changed as a result.
+   */
+  PRBool MediumFeaturesChanged(nsPresContext* aPresContext);
 
   // APIs for registering objects that can supply additional
   // rules during processing.
