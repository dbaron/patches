From: L. David Baron <dbaron@dbaron.org>

Make GraphWalker use templates instead of virtual functions.  (Bug 537547)  r=smaug

diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -1037,30 +1037,38 @@ struct nsCycleCollector
 struct DoWalkDebugInfo
 {
     PtrInfo *mCurrentPI;
     EdgePool::Iterator mFirstChild;
     EdgePool::Iterator mLastChild;
     EdgePool::Iterator mCurrentChild;
 };
 
+/**
+ * GraphWalker is templatized over a Visitor class that must provide
+ * the following two methods:
+ *
+ * PRBool ShouldVisitNode(PtrInfo const *pi);
+ * void VisitNode(PtrInfo *pi);
+ */
+template <class Visitor>
 class GraphWalker
 {
 private:
+    Visitor mVisitor;
     DoWalkDebugInfo *mDebugInfo;
 
     void DoWalk(nsDeque &aQueue);
 
 public:
     void Walk(PtrInfo *s0);
     void WalkFromRoots(GCGraph &aGraph);
-
-    // Provided by concrete walker subtypes.
-    virtual PRBool ShouldVisitNode(PtrInfo const *pi) = 0;
-    virtual void VisitNode(PtrInfo *pi) = 0;
+    // copy-constructing the visitor should be cheap, and less
+    // indirection than using a reference
+    GraphWalker(const Visitor aVisitor) : mVisitor(aVisitor) {}
 };
 
 
 ////////////////////////////////////////////////////////////////////////
 // The static collector object
 ////////////////////////////////////////////////////////////////////////
 
 
@@ -1220,26 +1228,28 @@ nsCycleCollectionParticipant *
 nsCycleCollectionXPCOMRuntime::ToParticipant(void *p)
 {
     nsXPCOMCycleCollectionParticipant *cp;
     ::ToParticipant(static_cast<nsISupports*>(p), &cp);
     return cp;
 }
 
 
+template <class Visitor>
 void
-GraphWalker::Walk(PtrInfo *s0)
+GraphWalker<Visitor>::Walk(PtrInfo *s0)
 {
     nsDeque queue;
     queue.Push(s0);
     DoWalk(queue);
 }
 
+template <class Visitor>
 void
-GraphWalker::WalkFromRoots(GCGraph& aGraph)
+GraphWalker<Visitor>::WalkFromRoots(GCGraph& aGraph)
 {
     nsDeque queue;
     NodePool::Enumerator etor(aGraph.mNodes);
     for (PRUint32 i = 0; i < aGraph.mRootCount; ++i) {
         queue.Push(etor.GetNext());
     }
     DoWalk(queue);
 }
@@ -1281,32 +1291,33 @@ NodePool::CheckPtrInfo(PtrInfo *aPtrInfo
     do {
         if(aPtrInfo >= &block->mEntries[0] &&
            aPtrInfo <= &block->mEntries[BlockSize - 1])
            break;
     } while ((block = block->mNext));
     CC_RUNTIME_ABORT_IF_FALSE(block, "Pointer is outside blocks.");
 }
 
+template <class Visitor>
 void
-GraphWalker::DoWalk(nsDeque &aQueue)
+GraphWalker<Visitor>::DoWalk(nsDeque &aQueue)
 {
     // Use a aQueue to match the breadth-first traversal used when we
     // built the graph, for hopefully-better locality.
     DoWalkDebugInfo debugInfo;
     mDebugInfo = &debugInfo;
 
     while (aQueue.GetSize() > 0) {
         PtrInfo *pi = static_cast<PtrInfo*>(aQueue.PopFront());
 
         sCollector->mGraph.mNodes.CheckPtrInfo(pi);
 
         debugInfo.mCurrentPI = pi;
-        if (this->ShouldVisitNode(pi)) {
-            this->VisitNode(pi);
+        if (mVisitor.ShouldVisitNode(pi)) {
+            mVisitor.VisitNode(pi);
             debugInfo.mFirstChild = pi->mFirstChild;
             debugInfo.mLastChild = pi->mLastChild;
             debugInfo.mCurrentChild = pi->mFirstChild;
             for (EdgePool::Iterator child = pi->mFirstChild,
                                 child_end = pi->mLastChild;
                  child != child_end; ++child, debugInfo.mCurrentChild = child) {
                 sCollector->mGraph.mEdges.CheckIterator(child);
                 aQueue.Push(*child);
@@ -1688,19 +1699,20 @@ nsCycleCollector::MarkRoots(GCGraphBuild
 }
 
 
 ////////////////////////////////////////////////////////////////////////
 // Bacon & Rajan's |ScanRoots| routine.
 ////////////////////////////////////////////////////////////////////////
 
 
-struct ScanBlackWalker : public GraphWalker
+struct ScanBlackVisitor
 {
-    ScanBlackWalker(PRUint32 &aWhiteNodeCount) : mWhiteNodeCount(aWhiteNodeCount)
+    ScanBlackVisitor(PRUint32 &aWhiteNodeCount)
+        : mWhiteNodeCount(aWhiteNodeCount)
     {
     }
 
     PRBool ShouldVisitNode(PtrInfo const *pi)
     { 
         return pi->mColor != black;
     }
 
@@ -1713,19 +1725,19 @@ struct ScanBlackWalker : public GraphWal
         sCollector->mStats.mSetColorBlack++;
 #endif
     }
 
     PRUint32 &mWhiteNodeCount;
 };
 
 
-struct scanWalker : public GraphWalker
+struct scanVisitor
 {
-    scanWalker(PRUint32 &aWhiteNodeCount) : mWhiteNodeCount(aWhiteNodeCount)
+    scanVisitor(PRUint32 &aWhiteNodeCount) : mWhiteNodeCount(aWhiteNodeCount)
     {
     }
 
     PRBool ShouldVisitNode(PtrInfo const *pi)
     { 
         return pi->mColor == grey;
     }
 
@@ -1736,34 +1748,34 @@ struct scanWalker : public GraphWalker
 
         if (pi->mInternalRefs == pi->mRefCount || pi->mRefCount == 0) {
             pi->mColor = white;
             ++mWhiteNodeCount;
 #ifdef DEBUG_CC
             sCollector->mStats.mSetColorWhite++;
 #endif
         } else {
-            ScanBlackWalker(mWhiteNodeCount).Walk(pi);
+            GraphWalker<ScanBlackVisitor>(ScanBlackVisitor(mWhiteNodeCount)).Walk(pi);
             NS_ASSERTION(pi->mColor == black,
-                         "Why didn't ScanBlackWalker make pi black?");
+                         "Why didn't ScanBlackVisitor make pi black?");
         }
     }
 
     PRUint32 &mWhiteNodeCount;
 };
 
 void
 nsCycleCollector::ScanRoots()
 {
     mWhiteNodeCount = 0;
 
     // On the assumption that most nodes will be black, it's
     // probably faster to use a GraphWalker than a
     // NodePool::Enumerator.
-    scanWalker(mWhiteNodeCount).WalkFromRoots(mGraph); 
+    GraphWalker<scanVisitor>(scanVisitor(mWhiteNodeCount)).WalkFromRoots(mGraph); 
 
 #ifdef DEBUG_CC
     // Sanity check: scan should have colored all grey nodes black or
     // white. So we ensure we have no grey nodes at this point.
     NodePool::Enumerator etor(mGraph.mNodes);
     while (!etor.IsDone())
     {
         PtrInfo *pinfo = etor.GetNext();
@@ -2755,26 +2767,26 @@ AddExpectedGarbage(nsVoidPtrHashKey *p, 
 {
     GCGraphBuilder *builder = static_cast<GCGraphBuilder*>(arg);
     nsISupports *root =
       static_cast<nsISupports*>(const_cast<void*>(p->GetKey()));
     builder->NoteXPCOMRoot(root);
     return PL_DHASH_NEXT;
 }
 
-struct SetSCCWalker : public GraphWalker
+struct SetSCCVisitor
 {
-    SetSCCWalker(PRUint32 aIndex) : mIndex(aIndex) {}
+    SetSCCVisitor(PRUint32 aIndex) : mIndex(aIndex) {}
     PRBool ShouldVisitNode(PtrInfo const *pi) { return pi->mSCCIndex == 0; }
     void VisitNode(PtrInfo *pi) { pi->mSCCIndex = mIndex; }
 private:
     PRUint32 mIndex;
 };
 
-struct SetNonRootGreyWalker : public GraphWalker
+struct SetNonRootGreyVisitor
 {
     PRBool ShouldVisitNode(PtrInfo const *pi) { return pi->mColor == white; }
     void VisitNode(PtrInfo *pi) { pi->mColor = grey; }
 };
 
 static void
 PrintPathToExpectedGarbage(PtrInfo *pi)
 {
@@ -3000,34 +3012,34 @@ nsCycleCollector::ExplainLiveExpectedGar
                     while (!etor_clear.IsDone()) {
                         PtrInfo *pi = etor_clear.GetNext();
                         pi->mSCCIndex = 0;
                     }
 
                     PRUint32 currentSCC = 1;
 
                     while (DFSPostOrder.GetSize() > 0) {
-                        SetSCCWalker(currentSCC).Walk((PtrInfo*)DFSPostOrder.PopFront());
+                        GraphWalker<SetSCCVisitor>(SetSCCVisitor(currentSCC)).Walk((PtrInfo*)DFSPostOrder.PopFront());
                         ++currentSCC;
                     }
                 }
 
                 // Mark any white nodes reachable from other components as
                 // grey.
                 {
                     NodePool::Enumerator queue(mGraph.mNodes);
                     while (!queue.IsDone()) {
                         PtrInfo *pi = queue.GetNext();
                         if (pi->mColor != white)
                             continue;
                         for (EdgePool::Iterator child = pi->mFirstChild,
                                             child_end = pi->mLastChild;
                              child != child_end; ++child) {
                             if ((*child)->mSCCIndex != pi->mSCCIndex) {
-                                SetNonRootGreyWalker().Walk(*child);
+                                GraphWalker<SetNonRootGreyVisitor>(SetNonRootGreyVisitor()).Walk(*child);
                             }
                         }
                     }
                 }
 
                 {
                     NodePool::Enumerator queue(mGraph.mNodes);
                     while (!queue.IsDone()) {
