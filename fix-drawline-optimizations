From: L. David Baron <dbaron@dbaron.org>

Fix both the test for whether to use the DrawLine optimization for table border drawing and the optimization itself.  (NEED TO ADD TESTS OTHER THAN layout/reftests/bugs/356774-1.html WHICH FAILS ON MAC THAT WOULD FAIL WITH THE BROKEN CODE; WE CURRENTLY HAVE NONE)  (BREAKS THINGS WITH ZOOM SINCE NUMBER IS TWIPS PER CSS PIXEL)

diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -2926,24 +2926,24 @@ DrawSolidBorderSegment(nsIRenderingConte
                        PRUint8              aEndBevelSide = 0,
                        nscoord              aEndBevelOffset = 0)
 {
 
   if ((aRect.width == aTwipsPerPixel) || (aRect.height == aTwipsPerPixel) ||
       ((0 == aStartBevelOffset) && (0 == aEndBevelOffset))) {
     // simple line or rectangle
     if ((NS_SIDE_TOP == aStartBevelSide) || (NS_SIDE_BOTTOM == aStartBevelSide)) {
-      if (1 == aRect.height)
-        aContext.DrawLine(aRect.x, aRect.y, aRect.x, aRect.y + aRect.height);
+      if (aTwipsPerPixel == aRect.height)
+        aContext.DrawLine(aRect.x, aRect.y, aRect.x + aRect.width, aRect.y);
       else
         aContext.FillRect(aRect);
     }
     else {
-      if (1 == aRect.width)
-        aContext.DrawLine(aRect.x, aRect.y, aRect.x + aRect.width, aRect.y);
+      if (aTwipsPerPixel == aRect.width)
+        aContext.DrawLine(aRect.x, aRect.y, aRect.x, aRect.y + aRect.height);
       else
         aContext.FillRect(aRect);
     }
   }
   else {
     // polygon with beveling
     nsPoint poly[5];
     SetPoly(aRect, poly);
