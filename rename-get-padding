From: L. David Baron <dbaron@dbaron.org>

Bug 1053986 - Rename nsIFrame::GetPadding to GetXULPadding.  r=dholbert

This is a manual subset of changes written with sed, over .h and .cpp
files in layout/.

MozReview-Commit-ID: ENHslSI6hch

diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -8984,17 +8984,17 @@ nsFrame::BoxReflow(nsBoxLayoutState&    
 
     // This may not do very much useful, but it's probably worth trying.
     if (parentSize.width != NS_INTRINSICSIZE)
       parentReflowState.SetComputedWidth(std::max(parentSize.width, 0));
     if (parentSize.height != NS_INTRINSICSIZE)
       parentReflowState.SetComputedHeight(std::max(parentSize.height, 0));
     parentReflowState.ComputedPhysicalMargin().SizeTo(0, 0, 0, 0);
     // XXX use box methods
-    parentFrame->GetPadding(parentReflowState.ComputedPhysicalPadding());
+    parentFrame->GetXULPadding(parentReflowState.ComputedPhysicalPadding());
     parentFrame->GetXULBorder(parentReflowState.ComputedPhysicalBorderPadding());
     parentReflowState.ComputedPhysicalBorderPadding() +=
       parentReflowState.ComputedPhysicalPadding();
 
     // Construct the parent chain manually since constructing it normally
     // messes up dimensions.
     const nsHTMLReflowState *outerReflowState = aState.OuterReflowState();
     NS_ASSERTION(!outerReflowState || outerReflowState->frame != this,
diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -789,22 +789,22 @@ nsHTMLScrollFrame::GetMinISize(nsRenderi
 nsHTMLScrollFrame::GetPrefISize(nsRenderingContext *aRenderingContext)
 {
   nscoord result = mHelper.mScrolledFrame->GetPrefISize(aRenderingContext);
   DISPLAY_PREF_WIDTH(this, result);
   return NSCoordSaturatingAdd(result, GetIntrinsicVScrollbarWidth(aRenderingContext));
 }
 
 nsresult
-nsHTMLScrollFrame::GetPadding(nsMargin& aMargin)
+nsHTMLScrollFrame::GetXULPadding(nsMargin& aMargin)
 {
   // Our padding hangs out on the inside of the scrollframe, but XUL doesn't
   // reaize that.  If we're stuck inside a XUL box, we need to claim no
   // padding.
-  // @see also nsXULScrollFrame::GetPadding.
+  // @see also nsXULScrollFrame::GetXULPadding.
   aMargin.SizeTo(0,0,0,0);
   return NS_OK;
 }
 
 bool
 nsHTMLScrollFrame::IsXULCollapsed()
 {
   // We're never collapsed in the box sense.
@@ -1362,17 +1362,17 @@ nsXULScrollFrame::RemoveFrame(ChildListI
 
 nsSplittableType
 nsXULScrollFrame::GetSplittableType() const
 {
   return NS_FRAME_NOT_SPLITTABLE;
 }
 
 nsresult
-nsXULScrollFrame::GetPadding(nsMargin& aMargin)
+nsXULScrollFrame::GetXULPadding(nsMargin& aMargin)
 {
   aMargin.SizeTo(0,0,0,0);
   return NS_OK;
 }
 
 nsIAtom*
 nsXULScrollFrame::GetType() const
 {
diff --git a/layout/generic/nsGfxScrollFrame.h b/layout/generic/nsGfxScrollFrame.h
--- a/layout/generic/nsGfxScrollFrame.h
+++ b/layout/generic/nsGfxScrollFrame.h
@@ -694,17 +694,17 @@ public:
 
   virtual bool GetBorderRadii(const nsSize& aFrameSize, const nsSize& aBorderArea,
                               Sides aSkipSides, nscoord aRadii[8]) const override {
     return mHelper.GetBorderRadii(aFrameSize, aBorderArea, aSkipSides, aRadii);
   }
 
   virtual nscoord GetMinISize(nsRenderingContext *aRenderingContext) override;
   virtual nscoord GetPrefISize(nsRenderingContext *aRenderingContext) override;
-  virtual nsresult GetPadding(nsMargin& aPadding) override;
+  virtual nsresult GetXULPadding(nsMargin& aPadding) override;
   virtual bool IsXULCollapsed() override;
   
   virtual void Reflow(nsPresContext*           aPresContext,
                       nsHTMLReflowMetrics&     aDesiredSize,
                       const nsHTMLReflowState& aReflowState,
                       nsReflowStatus&          aStatus) override;
 
   virtual bool UpdateOverflow() override {
@@ -1125,17 +1125,17 @@ public:
                                         uint32_t aFilter) override;
 
   virtual nsSize GetXULMinSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULPrefSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nsSize GetXULMaxSize(nsBoxLayoutState& aBoxLayoutState) override;
   virtual nscoord GetXULBoxAscent(nsBoxLayoutState& aBoxLayoutState) override;
 
   NS_IMETHOD DoLayout(nsBoxLayoutState& aBoxLayoutState) override;
-  virtual nsresult GetPadding(nsMargin& aPadding) override;
+  virtual nsresult GetXULPadding(nsMargin& aPadding) override;
 
   virtual bool GetBorderRadii(const nsSize& aFrameSize, const nsSize& aBorderArea,
                               Sides aSkipSides, nscoord aRadii[8]) const override {
     return mHelper.GetBorderRadii(aFrameSize, aBorderArea, aSkipSides, aRadii);
   }
 
   nsresult XULLayout(nsBoxLayoutState& aState);
   void LayoutScrollArea(nsBoxLayoutState& aState, const nsPoint& aScrollPosition);
diff --git a/layout/generic/nsIFrame.h b/layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h
+++ b/layout/generic/nsIFrame.h
@@ -2909,17 +2909,17 @@ public:
   // convenience.
   virtual void SetXULBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
                             bool aRemoveOverflowAreas = false) = 0;
   nsresult XULLayout(nsBoxLayoutState& aBoxLayoutState);
   // Box methods.  Note that these do NOT just get the CSS border, padding,
   // etc.  They also talk to nsITheme.
   virtual nsresult GetXULBorderAndPadding(nsMargin& aBorderAndPadding);
   virtual nsresult GetXULBorder(nsMargin& aBorder)=0;
-  virtual nsresult GetPadding(nsMargin& aBorderAndPadding)=0;
+  virtual nsresult GetXULPadding(nsMargin& aBorderAndPadding)=0;
   virtual nsresult GetMargin(nsMargin& aMargin)=0;
   virtual void SetLayoutManager(nsBoxLayout* aLayout) { }
   virtual nsBoxLayout* GetLayoutManager() { return nullptr; }
   nsresult GetClientRect(nsRect& aContentRect);
 
   // For nsSprocketLayout
   virtual Valignment GetVAlign() const = 0;
   virtual Halignment GetHAlign() const = 0;
diff --git a/layout/xul/grid/nsGrid.cpp b/layout/xul/grid/nsGrid.cpp
--- a/layout/xul/grid/nsGrid.cpp
+++ b/layout/xul/grid/nsGrid.cpp
@@ -653,17 +653,17 @@ nsGrid::GetRowOffsets(int32_t aIndex, ns
   if (box && !row->mIsBogus)
   {
     if (!box->IsXULCollapsed())
     {
        // get real border and padding. GetXULBorderAndPadding
        // is redefined on nsGridRowLeafFrame. If we called it here
        // we would be in finite recurson.
        box->GetXULBorder(border);
-       box->GetPadding(padding);
+       box->GetXULPadding(padding);
 
        totalBorderPadding += border;
        totalBorderPadding += padding;
      }
 
      // if we are the first or last row
      // take into account <rows> tags around us
      // that could have borders or margins.
@@ -722,17 +722,17 @@ nsGrid::GetRowOffsets(int32_t aIndex, ns
            // include the margin of the columns. To the row
            // at this point border/padding and margins all added
            // up to more needed space.
            margin = GetBoxTotalMargin(box, !aIsHorizontal);
            // get real border and padding. GetXULBorderAndPadding
            // is redefined on nsGridRowLeafFrame. If we called it here
            // we would be in finite recurson.
            box->GetXULBorder(border);
-           box->GetPadding(padding);
+           box->GetXULPadding(padding);
            totalChildBorderPadding += border;
            totalChildBorderPadding += padding;
            totalChildBorderPadding += margin;
         }
 
         nscoord top;
         nscoord bottom;
 
diff --git a/layout/xul/grid/nsGridRowLeafLayout.cpp b/layout/xul/grid/nsGridRowLeafLayout.cpp
--- a/layout/xul/grid/nsGridRowLeafLayout.cpp
+++ b/layout/xul/grid/nsGridRowLeafLayout.cpp
@@ -156,17 +156,17 @@ nsGridRowLeafLayout::PopulateBoxSizes(ns
 
       if (i == firstIndex || i == lastIndex) {
         nsMargin offset = GetTotalMargin(aBox, isHorizontal);
 
         nsMargin border(0,0,0,0);
         // can't call GetBorderPadding we will get into recursion
         aBox->GetXULBorder(border);
         offset += border;
-        aBox->GetPadding(border);
+        aBox->GetXULPadding(border);
         offset += border;
 
         // subtract from out left and right
         if (i == firstIndex) 
         {
           if (isHorizontal)
            left -= offset.left;
           else
diff --git a/layout/xul/nsBox.cpp b/layout/xul/nsBox.cpp
--- a/layout/xul/nsBox.cpp
+++ b/layout/xul/nsBox.cpp
@@ -287,17 +287,17 @@ nsresult
 nsIFrame::GetXULBorderAndPadding(nsMargin& aBorderAndPadding)
 {
   aBorderAndPadding.SizeTo(0, 0, 0, 0);
   nsresult rv = GetXULBorder(aBorderAndPadding);
   if (NS_FAILED(rv))
     return rv;
 
   nsMargin padding;
-  rv = GetPadding(padding);
+  rv = GetXULPadding(padding);
   if (NS_FAILED(rv))
     return rv;
 
   aBorderAndPadding += padding;
 
   return rv;
 }
 
@@ -323,17 +323,17 @@ nsBox::GetXULBorder(nsMargin& aMargin)
   }
 
   aMargin = StyleBorder()->GetComputedBorder();
 
   return NS_OK;
 }
 
 nsresult
-nsBox::GetPadding(nsMargin& aMargin)
+nsBox::GetXULPadding(nsMargin& aMargin)
 {
   const nsStyleDisplay *disp = StyleDisplay();
   if (disp->mAppearance && gTheme) {
     // Go to the theme for the padding.
     nsPresContext *context = PresContext();
     if (gTheme->ThemeSupportsWidget(context, this, disp->mAppearance)) {
       nsIntMargin margin(0, 0, 0, 0);
       bool useThemePadding;
diff --git a/layout/xul/nsBox.h b/layout/xul/nsBox.h
--- a/layout/xul/nsBox.h
+++ b/layout/xul/nsBox.h
@@ -28,17 +28,17 @@ public:
   virtual nsSize GetXULMinSizeForScrollArea(nsBoxLayoutState& aBoxLayoutState) override;
 
   virtual bool IsXULCollapsed() override;
 
   virtual void SetXULBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
                             bool aRemoveOverflowAreas = false) override;
 
   virtual nsresult GetXULBorder(nsMargin& aBorderAndPadding) override;
-  virtual nsresult GetPadding(nsMargin& aBorderAndPadding) override;
+  virtual nsresult GetXULPadding(nsMargin& aBorderAndPadding) override;
   virtual nsresult GetMargin(nsMargin& aMargin) override;
 
   virtual Valignment GetVAlign() const override { return vAlign_Top; }
   virtual Halignment GetHAlign() const override { return hAlign_Left; }
 
   virtual nsresult RelayoutChildAtOrdinal(nsIFrame* aChild) override;
 
 #ifdef DEBUG_LAYOUT
