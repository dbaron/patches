From: L. David Baron <dbaron@dbaron.org>

Convert nsBlockReflowState::mFloatCombinedArea and part of nsBlockFrame to split overflow areas.  (Bug 542595, patch 9)

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -3544,17 +3544,17 @@ nsBlockFrame::DoReflowInlineFrames(nsBlo
                                    nsFloatManager::SavedState*
                                      aFloatStateBeforeLine,
                                    PRBool* aKeepReflowGoing,
                                    LineReflowStatus* aLineReflowStatus,
                                    PRBool aAllowPullUp)
 {
   // Forget all of the floats on the line
   aLine->FreeFloats(aState.mFloatCacheFreeList);
-  aState.mFloatCombinedArea.SetRect(0, 0, 0, 0);
+  aState.mFloatOverflowAreas.SetZero();
 
   // We need to set this flag on the line if any of our reflow passes
   // are impacted by floats.
   if (aFloatAvailableSpace.mHasFloats)
     aLine->SetLineIsImpactedByFloat(PR_TRUE);
 #ifdef REALLY_NOISY_REFLOW
   printf("nsBlockFrame::DoReflowInlineFrames %p impacted = %d\n",
          this, aFloatAvailableSpace.mHasFloats);
@@ -4328,34 +4328,44 @@ nsBlockFrame::PlaceLine(nsBlockReflowSta
     aLine->AppendFloats(aState.mBelowCurrentLineFloats);
   }
 
   // When a line has floats, factor them into the combined-area
   // computations.
   if (aLine->HasFloats()) {
     // Combine the float combined area (stored in aState) and the
     // value computed by the line layout code.
-    nsRect lineCombinedArea(aLine->GetCombinedArea());
+    nsOverflowAreas lineOverflowAreas;
+    NS_FOR_FRAME_OVERFLOW_TYPES(type) {
+      lineOverflowAreas[type] = aLine->GetOverflowArea(type);
 #ifdef NOISY_COMBINED_AREA
-    ListTag(stdout);
-    printf(": lineCA=%d,%d,%d,%d floatCA=%d,%d,%d,%d\n",
-           lineCombinedArea.x, lineCombinedArea.y,
-           lineCombinedArea.width, lineCombinedArea.height,
-           aState.mFloatCombinedArea.x, aState.mFloatCombinedArea.y,
-           aState.mFloatCombinedArea.width,
-           aState.mFloatCombinedArea.height);
+      ListTag(stdout);
+      printf(": overflow %d lineCA=%d,%d,%d,%d floatCA=%d,%d,%d,%d\n",
+             type,
+             lineOverflowAreas[type].x,
+             lineOverflowAreas[type].y,
+             lineOverflowAreas[type].width,
+             lineOverflowAreas[type].height,
+             aState.mFloatOverflowAreas[type].x,
+             aState.mFloatOverflowAreas[type].y,
+             aState.mFloatOverflowAreas[type].width,
+             aState.mFloatOverflowAreas[type].height);
 #endif
-    lineCombinedArea.UnionRect(aState.mFloatCombinedArea, lineCombinedArea);
-
-    aLine->SetCombinedArea(lineCombinedArea);
+      lineOverflowAreas[type].UnionRect(aState.mFloatOverflowAreas[type],
+                                        lineOverflowAreas[type]);
+
 #ifdef NOISY_COMBINED_AREA
-    printf("  ==> final lineCA=%d,%d,%d,%d\n",
-           lineCombinedArea.x, lineCombinedArea.y,
-           lineCombinedArea.width, lineCombinedArea.height);
+      printf("  ==> final lineCA=%d,%d,%d,%d\n",
+             lineOverflowAreas[type].x,
+             lineOverflowAreas[type].y,
+             lineOverflowAreas[type].width,
+             lineOverflowAreas[type].height);
 #endif
+    }
+    aLine->SetOverflowAreas(lineOverflowAreas);
   }
 
   // Apply break-after clearing if necessary
   // This must stay in sync with |ReflowDirtyLines|.
   if (aLine->HasFloatBreakAfter()) {
     aState.mY = aState.ClearFloats(aState.mY, aLine->GetBreakTypeAfter());
   }
   return PR_TRUE;
diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -840,20 +840,21 @@ nsBlockReflowState::FlowAndPlaceFloat(ns
   // Position the float and make sure and views are properly
   // positioned. We need to explicitly position its child views as
   // well, since we're moving the float after flowing it.
   aFloat->SetPosition(origin);
   nsContainerFrame::PositionFrameView(aFloat);
   nsContainerFrame::PositionChildViews(aFloat);
 
   // Update the float combined area state
-  nsRect combinedArea = aFloat->GetOverflowRect() + origin;
-
-  // XXX Floats should really just get invalidated here if necessary
-  mFloatCombinedArea.UnionRect(combinedArea, mFloatCombinedArea);
+  NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
+    // XXX Floats should really just get invalidated here if necessary
+    mFloatOverflowAreas[otype].UnionRect(
+      aFloat->GetOverflowRect(otype) + origin, mFloatOverflowAreas[otype]);
+  }
 
   // Place the float in the float manager
   // calculate region
   nsRect region = nsFloatManager::CalculateRegionFor(aFloat, floatMargin);
   // if the float split, then take up all of the vertical height
   if (NS_FRAME_IS_NOT_COMPLETE(reflowStatus) &&
       (NS_UNCONSTRAINEDSIZE != mContentArea.height)) {
     region.height = NS_MAX(region.height, mContentArea.height - floatY);
diff --git a/layout/generic/nsBlockReflowState.h b/layout/generic/nsBlockReflowState.h
--- a/layout/generic/nsBlockReflowState.h
+++ b/layout/generic/nsBlockReflowState.h
@@ -290,18 +290,18 @@ public:
   // which we know is adjacent to the top of the block (in other words,
   // all lines before it are empty and do not have clearance. This line is
   // always before the current line.
   nsLineList::iterator mLineAdjacentToTop;
 
   // The current Y coordinate in the block
   nscoord mY;
 
-  // The combined area of all floats placed so far
-  nsRect mFloatCombinedArea;
+  // The overflow areas of all floats placed so far
+  nsOverflowAreas mFloatOverflowAreas;
 
   nsFloatCacheFreeList mFloatCacheFreeList;
 
   // Previous child. This is used when pulling up a frame to update
   // the sibling list.
   nsIFrame* mPrevChild;
 
   // The previous child frames collapsed bottom margin value.
