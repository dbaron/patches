diff --git a/xpcom/reflect/xptinfo/xptiInterfaceInfo.cpp b/xpcom/reflect/xptinfo/xptiInterfaceInfo.cpp
--- a/xpcom/reflect/xptinfo/xptiInterfaceInfo.cpp
+++ b/xpcom/reflect/xptinfo/xptiInterfaceInfo.cpp
@@ -31,16 +31,17 @@ xptiInterfaceEntry::xptiInterfaceEntry(c
     : mIID(aEntry->mIID)
     , mDescriptor(aEntry->mInterfaceDescriptor)
     , mTypelib(aTypelib)
     , mParent(nullptr)
     , mInfo(nullptr)
     , mMethodBaseIndex(0)
     , mConstantBaseIndex(0)
     , mFlags(0)
+    , mUsed(false)
     , mName(aEntry->mName)
 {
     SetResolvedState(PARTIALLY_RESOLVED);
     SetScriptableFlag(mDescriptor->IsScriptable());
     SetBuiltinClassFlag(mDescriptor->IsBuiltinClass());
     SetMainProcessScriptableOnlyFlag(mDescriptor->IsMainProcessScriptableOnly());
 }
 
diff --git a/xpcom/reflect/xptinfo/xptiInterfaceInfoManager.cpp b/xpcom/reflect/xptinfo/xptiInterfaceInfoManager.cpp
--- a/xpcom/reflect/xptinfo/xptiInterfaceInfoManager.cpp
+++ b/xpcom/reflect/xptinfo/xptiInterfaceInfoManager.cpp
@@ -13,16 +13,17 @@
 #include "mozilla/StaticPtr.h"
 
 #include "xptiprivate.h"
 #include "nsDependentString.h"
 #include "nsString.h"
 #include "nsArrayEnumerator.h"
 #include "nsDirectoryService.h"
 #include "nsIMemoryReporter.h"
+#include "nsXULAppAPI.h"
 
 using namespace mozilla;
 
 NS_IMPL_ISUPPORTS(
   XPTInterfaceInfoManager,
   nsIInterfaceInfoManager,
   nsIMemoryReporter)
 
@@ -80,16 +81,42 @@ XPTInterfaceInfoManager::FreeInterfaceIn
 XPTInterfaceInfoManager::XPTInterfaceInfoManager()
     :   mWorkingSet(),
         mResolveLock("XPTInterfaceInfoManager.mResolveLock")
 {
 }
 
 XPTInterfaceInfoManager::~XPTInterfaceInfoManager()
 {
+    {
+        // Mark all ancestors of used entries as used.
+        for (auto iter = mWorkingSet.mNameTable.Iter(); !iter.Done(); iter.Next()) {
+            xptiInterfaceEntry* entry = iter.UserData();
+            if (entry->IsUsed()) {
+                while ((entry = entry->Parent())) {
+                    entry->MarkUsed();
+                }
+            }
+        }
+
+        const char* pTypeString = XRE_ChildProcessTypeToString(XRE_GetProcessType());
+        printf("XPTInterfaceInfoManager shutdown, process type %s, unused interfaces are:\n",
+               pTypeString);
+        for (auto iter = mWorkingSet.mNameTable.Iter(); !iter.Done(); iter.Next()) {
+            xptiInterfaceEntry* entry = iter.UserData();
+            if (entry->IsUsed()) {
+                continue;
+            }
+            const char* scriptableString = entry->GetScriptableFlag()
+              ? "scriptable" : "NOT scriptable";
+            printf("unused interface\t%s\t%s\t%s\n",
+                   entry->GetTheName(), scriptableString, pTypeString);
+        }
+    }
+
     // We only do this on shutdown of the service.
     mWorkingSet.InvalidateInterfaceInfos();
 
     UnregisterWeakMemoryReporter(this);
 }
 
 void
 XPTInterfaceInfoManager::InitMemoryReporter()
@@ -170,16 +197,18 @@ XPTInterfaceInfoManager::VerifyAndAddEnt
 static nsresult
 EntryToInfo(xptiInterfaceEntry* entry, nsIInterfaceInfo **_retval)
 {
     if (!entry) {
         *_retval = nullptr;
         return NS_ERROR_FAILURE;
     }
 
+    entry->MarkUsed();
+
     RefPtr<xptiInterfaceInfo> info = entry->InterfaceInfo();
     info.forget(_retval);
     return NS_OK;
 }
 
 xptiInterfaceEntry*
 XPTInterfaceInfoManager::GetInterfaceEntryForIID(const nsIID *iid)
 {
diff --git a/xpcom/reflect/xptinfo/xptiprivate.h b/xpcom/reflect/xptinfo/xptiprivate.h
--- a/xpcom/reflect/xptinfo/xptiprivate.h
+++ b/xpcom/reflect/xptinfo/xptiprivate.h
@@ -191,16 +191,19 @@ public:
     bool GetHasNotXPCOMFlag() const
     {
         return mFlags.GetFlagBit(HASNOTXPCOM);
     }
 
     const nsID* GetTheIID()  const {return &mIID;}
     const char* GetTheName() const {return mName;}
 
+    void MarkUsed() { mUsed = true; }
+    bool IsUsed() const { return mUsed; }
+
     bool EnsureResolved()
         {return IsFullyResolved() ? true : Resolve();}
 
     already_AddRefed<xptiInterfaceInfo> InterfaceInfo();
     bool     InterfaceInfoEquals(const xptiInterfaceInfo* info) const
         {return info == mInfo;}
 
     void     LockedInvalidateInterfaceInfo();
@@ -293,16 +296,18 @@ private:
                                       "by the semantics of xptiWorkingSet.")
                             mInfo;        // May come and go.
 
     uint16_t mMethodBaseIndex;
     uint16_t mConstantBaseIndex;
 
     xptiInfoFlags           mFlags;
 
+    bool mUsed;
+
     const char*             mName;
 };
 
 class xptiInterfaceInfo final : public nsIInterfaceInfo
 {
 public:
     NS_DECL_THREADSAFE_ISUPPORTS
 
