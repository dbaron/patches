From: L. David Baron <dbaron@dbaron.org>

Set inflation container to null during ComputeSize calls for inflation containers, when we should not have inflation applied.  (Bug 706609, patch 4.5)

diff --git a/layout/generic/nsBlockReflowState.cpp b/layout/generic/nsBlockReflowState.cpp
--- a/layout/generic/nsBlockReflowState.cpp
+++ b/layout/generic/nsBlockReflowState.cpp
@@ -57,16 +57,17 @@
 
 #include "mozilla/Util.h" // for DebugOnly
 
 #ifdef DEBUG
 #include "nsBlockDebugFlags.h"
 #endif
 
 using namespace mozilla;
+using namespace mozilla::layout;
 
 nsBlockReflowState::nsBlockReflowState(const nsHTMLReflowState& aReflowState,
                                        nsPresContext* aPresContext,
                                        nsBlockFrame* aFrame,
                                        const nsHTMLReflowMetrics& aMetrics,
                                        bool aTopMarginRoot,
                                        bool aBottomMarginRoot,
                                        bool aBlockNeedsFloatManager)
@@ -592,16 +593,17 @@ nsBlockReflowState::CanPlaceFloat(nscoor
 }
 
 static nscoord
 FloatMarginWidth(const nsHTMLReflowState& aCBReflowState,
                  nscoord aFloatAvailableWidth,
                  nsIFrame *aFloat,
                  const nsCSSOffsetState& aFloatOffsetState)
 {
+  AutoMaybeNullInflationContainer an(aFloat);
   return aFloat->ComputeSize(
     aCBReflowState.rendContext,
     nsSize(aCBReflowState.ComputedWidth(),
            aCBReflowState.ComputedHeight()),
     aFloatAvailableWidth,
     nsSize(aFloatOffsetState.mComputedMargin.LeftRight(),
            aFloatOffsetState.mComputedMargin.TopBottom()),
     nsSize(aFloatOffsetState.mComputedBorderPadding.LeftRight() -
diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -62,16 +62,17 @@
 
 #ifdef NS_DEBUG
 #undef NOISY_VERTICAL_ALIGN
 #else
 #undef NOISY_VERTICAL_ALIGN
 #endif
 
 using namespace mozilla;
+using namespace mozilla::layout;
 
 // Prefs-driven control for |text-decoration: blink|
 static bool sPrefIsLoaded = false;
 static bool sBlinkIsAllowed = true;
 
 enum eNormalLineHeightControl {
   eUninitialized = -1,
   eNoExternalLeading = 0,   // does not include external leading 
@@ -1238,34 +1239,38 @@ nsHTMLReflowState::InitAbsoluteConstrain
     mComputedOffsets.top = hypotheticalBox.mTop;
     topIsAuto = false;
   }
 
   bool widthIsAuto = eStyleUnit_Auto == mStylePosition->mWidth.GetUnit();
   bool heightIsAuto = eStyleUnit_Auto == mStylePosition->mHeight.GetUnit();
 
   bool shrinkWrap = leftIsAuto || rightIsAuto;
-  nsSize size =
-    frame->ComputeSize(rendContext,
-                       nsSize(containingBlockWidth,
-                              containingBlockHeight),
-                       containingBlockWidth, // XXX or availableWidth?
-                       nsSize(mComputedMargin.LeftRight() +
-                                mComputedOffsets.LeftRight(),
-                              mComputedMargin.TopBottom() +
-                                mComputedOffsets.TopBottom()),
-                       nsSize(mComputedBorderPadding.LeftRight() -
-                                mComputedPadding.LeftRight(),
-                              mComputedBorderPadding.TopBottom() -
+  {
+    AutoMaybeNullInflationContainer an(frame);
+
+    nsSize size =
+      frame->ComputeSize(rendContext,
+                         nsSize(containingBlockWidth,
+                                containingBlockHeight),
+                         containingBlockWidth, // XXX or availableWidth?
+                         nsSize(mComputedMargin.LeftRight() +
+                                  mComputedOffsets.LeftRight(),
+                                mComputedMargin.TopBottom() +
+                                  mComputedOffsets.TopBottom()),
+                         nsSize(mComputedBorderPadding.LeftRight() -
+                                  mComputedPadding.LeftRight(),
+                                mComputedBorderPadding.TopBottom() -
+                                  mComputedPadding.TopBottom()),
+                         nsSize(mComputedPadding.LeftRight(),
                                 mComputedPadding.TopBottom()),
-                       nsSize(mComputedPadding.LeftRight(),
-                              mComputedPadding.TopBottom()),
-                       shrinkWrap);
-  mComputedWidth = size.width;
-  mComputedHeight = size.height;
+                         shrinkWrap);
+    mComputedWidth = size.width;
+    mComputedHeight = size.height;
+  }
   NS_ASSERTION(mComputedWidth >= 0, "Bogus width");
   NS_ASSERTION(mComputedHeight == NS_UNCONSTRAINEDSIZE ||
                mComputedHeight >= 0, "Bogus height");
 
   // XXX Now that we have ComputeSize, can we condense many of the
   // branches off of widthIsAuto?
 
   if (leftIsAuto) {
@@ -1857,16 +1862,18 @@ nsHTMLReflowState::InitConstraints(nsPre
       mComputedMinWidth = mComputedMinHeight = 0;
       mComputedMaxWidth = mComputedMaxHeight = NS_UNCONSTRAINEDSIZE;
 
     } else if (NS_FRAME_GET_TYPE(mFrameType) == NS_CSS_FRAME_TYPE_ABSOLUTE) {
       // XXX not sure if this belongs here or somewhere else - cwk
       InitAbsoluteConstraints(aPresContext, cbrs, aContainingBlockWidth,
                               aContainingBlockHeight, aFrameType);
     } else {
+      AutoMaybeNullInflationContainer an(frame);
+
       bool isBlock =
         NS_CSS_FRAME_TYPE_BLOCK == NS_FRAME_GET_TYPE(mFrameType);
       // make sure legend frames with display:block and width:auto still
       // shrink-wrap
       bool shrinkWrap = !isBlock || aFrameType == nsGkAtoms::legendFrame;
       nsSize size =
         frame->ComputeSize(rendContext,
                            nsSize(aContainingBlockWidth,
diff --git a/layout/tables/nsTableOuterFrame.cpp b/layout/tables/nsTableOuterFrame.cpp
--- a/layout/tables/nsTableOuterFrame.cpp
+++ b/layout/tables/nsTableOuterFrame.cpp
@@ -530,16 +530,18 @@ nsTableOuterFrame::GetPrefWidth(nsRender
 // aMarginResult is non-null, fill it with the part of the margin-width
 // that was contributed by the margin.
 static nscoord
 ChildShrinkWrapWidth(nsRenderingContext *aRenderingContext,
                      nsIFrame *aChildFrame,
                      nsSize aCBSize, nscoord aAvailableWidth,
                      nscoord *aMarginResult = nsnull)
 {
+  AutoMaybeNullInflationContainer an(aChildFrame);
+
   nsCSSOffsetState offsets(aChildFrame, aRenderingContext, aCBSize.width);
   nsSize size = aChildFrame->ComputeSize(aRenderingContext, aCBSize,
                   aAvailableWidth,
                   nsSize(offsets.mComputedMargin.LeftRight(),
                          offsets.mComputedMargin.TopBottom()),
                   nsSize(offsets.mComputedBorderPadding.LeftRight() -
                            offsets.mComputedPadding.LeftRight(),
                          offsets.mComputedBorderPadding.TopBottom() -
