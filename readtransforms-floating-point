From: L. David Baron <dbaron@dbaron.org>

Avoid accumulating unnecessary floating point error in ReadTransforms.

diff --git a/layout/style/nsStyleTransformMatrix.cpp b/layout/style/nsStyleTransformMatrix.cpp
--- a/layout/style/nsStyleTransformMatrix.cpp
+++ b/layout/style/nsStyleTransformMatrix.cpp
@@ -618,15 +618,32 @@ ReadTransforms(const nsCSSValueList* aLi
                  "Incoming function is too short!");
 
     /* Read in a single transform matrix. */
     MatrixForTransformFunction(result, currElem.GetArrayValue(), aContext,
                                aPresContext, aCanStoreInRuleTree, aBounds);
   }
 
   float scale = float(nsPresContext::AppUnitsPerCSSPixel()) / aAppUnitsPerMatrixUnit;
-  result.Scale(1/scale, 1/scale, 1/scale);
-  result.ScalePost(scale, scale, scale);
-  
+  // What we want to do here is conceptually this:
+  //   result.Scale(1/scale, 1/scale, 1/scale);
+  //   result.ScalePost(scale, scale, scale);
+  // in order to convert |result| from a matrix that applies to CSS
+  // pixels into a matrix that applies to device pixels.  (Essentially,
+  // we apply one scale transform device pixels into CSS pixels, apply
+  // the matrix, and then apply the inverse.)
+  //
+  // However, actually making those calls would apply multiplication by
+  // both scale and 1/scale to the _11, _12, _13, _21, _22, _23, _31,
+  // _32, and _33 components of the matrix.  This leads to accumulation
+  // of floating point error.  So, instead, we'll do the equivalent but
+  // only actually touch the components we need to touch.
+  result._14 *= 1/scale;
+  result._24 *= 1/scale;
+  result._34 *= 1/scale;
+  result._41 *= scale;
+  result._42 *= scale;
+  result._43 *= scale;
+
   return result;
 }
 
 } // namespace nsStyleTransformMatrix
