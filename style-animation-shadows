From: L. David Baron <dbaron@dbaron.org>

Add support for animation of text-shadow and -moz-box-shadow.  (TODO: MAYBE RECONSIDER USING nsStyleCoord?)

diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -1138,18 +1138,18 @@ CSS_PROP_BORDER(
     MozBoxShadow,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mBoxShadow,
     eCSSType_ValueList,
     kBoxShadowTypeKTable,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleBorder, mBoxShadow),
+    eStyleAnimType_Shadow)
 CSS_PROP_POSITION(
     -moz-box-sizing,
     box_sizing,
     MozBoxSizing,
     0,
     Position,
     mBoxSizing,
     eCSSType_Value,
@@ -2303,18 +2303,18 @@ CSS_PROP_TEXT(
     TextShadow,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Text,
     mTextShadow,
     eCSSType_ValueList,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleText, mTextShadow),
+    eStyleAnimType_Shadow)
 CSS_PROP_TEXT(
     text-transform,
     text_transform,
     TextTransform,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE,
     Text,
     mTextTransform,
     eCSSType_Value,
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -90,16 +90,19 @@ enum nsStyleAnimType {
   eStyleAnimType_float,
 
   // nscolor values
   eStyleAnimType_Color,
 
   // nsStyleSVGPaint values
   eStyleAnimType_PaintServer,
 
+  // nsRefPtr<nsCSSShadowArray> values
+  eStyleAnimType_Shadow,
+
   // property not animatable
   eStyleAnimType_None
 };
 
 class nsCSSProps {
 public:
   static void AddRefTable(void);
   static void ReleaseTable(void);
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -46,16 +46,17 @@
 #include "nsString.h"
 #include "nsStyleContext.h"
 #include "nsStyleSet.h"
 #include "nsComputedDOMStyle.h"
 #include "nsICSSParser.h"
 #include "nsICSSLoader.h"
 #include "nsCSSDataBlock.h"
 #include "nsCSSDeclaration.h"
+#include "nsCSSStruct.h"
 #include "prlog.h"
 #include <math.h>
 
 // HELPER METHODS
 // --------------
 /*
  * Given two units, this method returns a common unit that they can both be
  * converted into, if possible.  This is intended to facilitate
@@ -149,16 +150,20 @@ nsStyleAnimation::Add(Value& aDest, cons
         ClampColor(NS_GET_G(destColor) + aCount * NS_GET_G(colorToAdd));
       PRUint8 resultB =
         ClampColor(NS_GET_B(destColor) + aCount * NS_GET_B(colorToAdd));
       PRUint8 resultA =
         ClampColor(NS_GET_A(destColor) + aCount * NS_GET_A(colorToAdd));
       aDest.SetColorValue(NS_RGBA(resultR, resultG, resultB, resultA));
       break;
     }
+    case eUnit_Shadow:
+      // FIXME: WRITE ME
+      success = PR_FALSE;
+      break;
     case eUnit_Null:
       success = PR_FALSE;
       break;
     default:
       NS_NOTREACHED("Can't add Values using the given common unit");
       success = PR_FALSE;
       break;
   }
@@ -224,16 +229,20 @@ nsStyleAnimation::ComputeDistance(const 
       double diffA = startA - endA;
       double diffR = startR - endR;
       double diffG = startG - endG;
       double diffB = startB - endB;
       aDistance = sqrt(diffA * diffA + diffR * diffR +
                        diffG * diffG + diffB * diffB);
       break;
     }
+    case eUnit_Shadow:
+      // FIXME: WRITE ME
+      success = PR_FALSE;
+      break;
     case eUnit_Null:
       success = PR_FALSE;
       break;
     default:
       NS_NOTREACHED("Can't compute distance using the given common unit");
       success = PR_FALSE;
       break;
   }
@@ -310,16 +319,20 @@ nsStyleAnimation::Interpolate(const Valu
         resultColor = NS_RGBA(resR, resG, resB, resA);
       }
       aResultValue.SetColorValue(resultColor);
       break;
     }
     case eUnit_Null:
       success = PR_FALSE;
       break;
+    case eUnit_Shadow:
+      // FIXME: WRITE ME
+      success = PR_FALSE;
+      break;
     default:
       NS_NOTREACHED("Can't interpolate using the given common unit");
       success = PR_FALSE;
       break;
   }
   return success;
 }
 
@@ -466,16 +479,19 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
           SetBothValuesTo(val);
       } else {
         NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
                           "type mismatch");
         static_cast<nsCSSValue*>(aSpecifiedValue)->
           SetColorValue(aComputedValue.GetColorValue());
       }
       break;
+    case eUnit_Shadow:
+      // FIXME: WRITE ME!
+      return PR_FALSE;
     default:
       return PR_FALSE;
   }
   return PR_TRUE;
 }
 
 PRBool
 nsStyleAnimation::UncomputeValue(nsCSSProperty aProperty,
@@ -694,16 +710,20 @@ nsStyleAnimation::ExtractComputedValue(n
         return PR_TRUE;
       }
       if (paint.mType == eStyleSVGPaintType_None) {
         aComputedValue.SetNoneValue();
         return PR_TRUE;
       }
       return PR_FALSE;
     }
+    case eStyleAnimType_Shadow: {
+      // FIXME: WRITE ME!
+      return PR_FALSE;
+    }
     case eStyleAnimType_None:
       NS_NOTREACHED("shouldn't use on non-animatable properties");
   }
   return PR_FALSE;
 }
 
 nsStyleAnimation::Value::Value(nscoord aLength, CoordConstructorType)
 {
@@ -746,16 +766,19 @@ nsStyleAnimation::Value::operator=(const
       break;
     case eUnit_Percent:
     case eUnit_Float:
       mValue.mFloat = aOther.mValue.mFloat;
       break;
     case eUnit_Color:
       mValue.mColor = aOther.mValue.mColor;
       break;
+    case eUnit_Shadow:
+      mValue.mCSSValueList = aOther.mValue.mCSSValueList
+                               ? aOther.mValue.mCSSValueList->Clone() : nsnull;
   }
 
   return *this;
 }
 
 void
 nsStyleAnimation::Value::SetNormalValue()
 {
@@ -805,18 +828,36 @@ void
 nsStyleAnimation::Value::SetColorValue(nscolor aColor)
 {
   FreeValue();
   mUnit = eUnit_Color;
   mValue.mColor = aColor;
 }
 
 void
+nsStyleAnimation::Value::SetCSSValueListValue(nsCSSValueList *aValue,
+                                              Unit aUnit,
+                                              PRBool aTakeOwnership)
+{
+  FreeValue();
+  NS_ASSERTION(IsCSSValueListUnit(aUnit), "bad unit");
+  mUnit = aUnit;
+  if (aTakeOwnership) {
+    mValue.mCSSValueList = aValueList;
+  } else {
+    mValue.mCSSValueList = aValueList ? aValueList->Clone() : nsnull;
+  }
+}
+
+void
 nsStyleAnimation::Value::FreeValue()
 {
+  if (IsCSSValueListUnit(mUnit)) {
+    delete mValue.mCSSValueList;
+  }
 }
 
 PRBool
 nsStyleAnimation::Value::operator==(const Value& aOther) const
 {
   if (mUnit != aOther.mUnit) {
     return PR_FALSE;
   }
@@ -829,14 +870,17 @@ nsStyleAnimation::Value::operator==(cons
       return PR_TRUE;
     case eUnit_Coord:
       return mValue.mCoord == aOther.mValue.mCoord;
     case eUnit_Percent:
     case eUnit_Float:
       return mValue.mFloat == aOther.mValue.mFloat;
     case eUnit_Color:
       return mValue.mColor == aOther.mValue.mColor;
+    case eUnit_Shadow:
+      return nsCSSValueList::Equal(mValue.mCSSValueList,
+                                   aOther.mValue.mCSSValueList);
   }
 
   NS_NOTREACHED("incomplete case");
   return PR_FALSE;
 }
 
diff --git a/layout/style/nsStyleAnimation.h b/layout/style/nsStyleAnimation.h
--- a/layout/style/nsStyleAnimation.h
+++ b/layout/style/nsStyleAnimation.h
@@ -47,16 +47,17 @@
 #include "nsCSSProperty.h"
 #include "nsCoord.h"
 #include "nsColor.h"
 
 class nsCSSDeclaration;
 class nsIContent;
 class nsPresContext;
 class nsStyleContext;
+struct nsCSSValueList;
 
 /**
  * Utility class to handle animated style values
  */
 class nsStyleAnimation {
 public:
   class Value;
 
@@ -186,26 +187,28 @@ public:
   enum Unit {
     eUnit_Null, // not initialized
     eUnit_Normal,
     eUnit_Auto,
     eUnit_None,
     eUnit_Coord,
     eUnit_Percent,
     eUnit_Float,
-    eUnit_Color
+    eUnit_Color,
+    eUnit_Shadow  // nsCSSValueList*
   };
 
   class Value {
   private:
     Unit mUnit;
     union {
       nscoord mCoord;
       float mFloat;
       nscolor mColor;
+      nsCSSValueList* mCSSValueList;
     } mValue;
   public:
     Unit GetUnit() const {
       NS_ASSERTION(mUnit != eUnit_Null, "uninitialized");
       return mUnit;
     }
 
     // Accessor to let us verify assumptions about presence of null unit,
@@ -225,16 +228,20 @@ public:
     float GetFloatValue() const {
       NS_ASSERTION(mUnit == eUnit_Float, "unit mismatch");
       return mValue.mFloat;
     }
     nscolor GetColorValue() const {
       NS_ASSERTION(mUnit == eUnit_Color, "unit mismatch");
       return mValue.mColor;
     }
+    nsCSSValueList* GetCSSValueListValue() const {
+      NS_ASSERTION(IsCSSValueListUnit(mUnit), "unit mismatch");
+      return mValue.mShadow;
+    }
 
     explicit Value(Unit aUnit = eUnit_Null) : mUnit(aUnit) {
       NS_ASSERTION(aUnit == eUnit_Null || aUnit == eUnit_Normal ||
                    aUnit == eUnit_Auto || aUnit == eUnit_None,
                    "must be valueless unit");
     }
     Value(const Value& aOther) : mUnit(eUnit_Null) { *this = aOther; }
     enum CoordConstructorType { CoordConstructor };
@@ -250,21 +257,27 @@ public:
 
     void SetNormalValue();
     void SetAutoValue();
     void SetNoneValue();
     void SetCoordValue(nscoord aCoord);
     void SetPercentValue(float aPercent);
     void SetFloatValue(float aFloat);
     void SetColorValue(nscolor aColor);
+    void SetCSSValueListValue(nsCSSValueList *aValue, Unit aUnit,
+                              PRBool aTakeOwnership);
 
     Value& operator=(const Value& aOther);
 
     PRBool operator==(const Value& aOther) const;
     PRBool operator!=(const Value& aOther) const
       { return !(*this == aOther); }
 
   private:
     void FreeValue();
+
+    static PRBool IsCSSValueListUnit(Unit aUnit) {
+      return aUnit == eUnit_Shadow;
+    }
   };
 };
 
 #endif
