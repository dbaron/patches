From: L. David Baron <dbaron@dbaron.org>

Add support for animation of text-shadow and -moz-box-shadow.  (TODO: MAYBE RECONSIDER USING nsStyleCoord?)

diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -1138,18 +1138,18 @@ CSS_PROP_BORDER(
     MozBoxShadow,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mBoxShadow,
     eCSSType_ValueList,
     kBoxShadowTypeKTable,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleBorder, mBoxShadow),
+    eStyleAnimType_Shadow)
 CSS_PROP_POSITION(
     -moz-box-sizing,
     box_sizing,
     MozBoxSizing,
     0,
     Position,
     mBoxSizing,
     eCSSType_Value,
@@ -2303,18 +2303,18 @@ CSS_PROP_TEXT(
     TextShadow,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Text,
     mTextShadow,
     eCSSType_ValueList,
     nsnull,
-    CSS_PROP_NO_OFFSET,
-    eStyleAnimType_None)
+    offsetof(nsStyleText, mTextShadow),
+    eStyleAnimType_Shadow)
 CSS_PROP_TEXT(
     text-transform,
     text_transform,
     TextTransform,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE,
     Text,
     mTextTransform,
     eCSSType_Value,
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -90,16 +90,19 @@ enum nsStyleAnimType {
   eStyleAnimType_float,
 
   // nscolor values
   eStyleAnimType_Color,
 
   // nsStyleSVGPaint values
   eStyleAnimType_PaintServer,
 
+  // nsRefPtr<nsCSSShadowArray> values
+  eStyleAnimType_Shadow,
+
   // property not animatable
   eStyleAnimType_None
 };
 
 class nsCSSProps {
 public:
   static void AddRefTable(void);
   static void ReleaseTable(void);
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -46,16 +46,17 @@
 #include "nsString.h"
 #include "nsStyleContext.h"
 #include "nsStyleSet.h"
 #include "nsComputedDOMStyle.h"
 #include "nsICSSParser.h"
 #include "nsICSSLoader.h"
 #include "nsCSSDataBlock.h"
 #include "nsCSSDeclaration.h"
+#include "nsCSSStruct.h"
 #include "prlog.h"
 #include <math.h>
 
 // HELPER METHODS
 // --------------
 /*
  * Given two units, this method returns a common unit that they can both be
  * converted into, if possible.  This is intended to facilitate
@@ -149,16 +150,20 @@ nsStyleAnimation::Add(Value& aDest, cons
         ClampColor(NS_GET_G(destColor) + aCount * NS_GET_G(colorToAdd));
       PRUint8 resultB =
         ClampColor(NS_GET_B(destColor) + aCount * NS_GET_B(colorToAdd));
       PRUint8 resultA =
         ClampColor(NS_GET_A(destColor) + aCount * NS_GET_A(colorToAdd));
       aDest.SetColorValue(NS_RGBA(resultR, resultG, resultB, resultA));
       break;
     }
+    case eUnit_Shadow:
+      // FIXME: WRITE ME
+      success = PR_FALSE;
+      break;
     case eUnit_Null:
       success = PR_FALSE;
       break;
     default:
       NS_NOTREACHED("Can't add Values using the given common unit");
       success = PR_FALSE;
       break;
   }
@@ -224,27 +229,97 @@ nsStyleAnimation::ComputeDistance(const 
       double diffA = startA - endA;
       double diffR = startR - endR;
       double diffG = startG - endG;
       double diffB = startB - endB;
       aDistance = sqrt(diffA * diffA + diffR * diffR +
                        diffG * diffG + diffB * diffB);
       break;
     }
+    case eUnit_Shadow:
+      // FIXME: WRITE ME
+      success = PR_FALSE;
+      break;
     case eUnit_Null:
       success = PR_FALSE;
       break;
     default:
       NS_NOTREACHED("Can't compute distance using the given common unit");
       success = PR_FALSE;
       break;
   }
   return success;
 }
 
+static PRBool
+InterpolateShadowItem(const nsCSSValue &aStartValue,
+                      const nsCSSValue &aEndValue,
+                      double aPortion,
+                      nsCSSValueList **&aResultTail)
+{
+  // X, Y, Radius, Spread, Color, Inset
+  NS_ABORT_IF_FALSE(aStartValue.GetUnit() == eCSSUnit_Array,
+                    "wrong unit");
+  NS_ABORT_IF_FALSE(aEndValue.GetUnit() == eCSSUnit_Array,
+                    "wrong unit");
+  nsCSSValue::Array *startArray = aStartValue.GetArrayValue();
+  nsCSSValue::Array *endArray = aEndValue.GetArrayValue();
+  nsRefPtr<nsCSSValue::Array> resultArray = nsCSSValue::Array::Create(6);
+  if (!resultArray) {
+    return PR_FALSE;
+  }
+
+  for (PRUint32 i = 0; i < 4; ++i) {
+    NS_ABORT_IF_FALSE(startArray->Item(i).GetUnit() == eCSSUnit_Pixel,
+                      "unexpected unit");
+    NS_ABORT_IF_FALSE(endArray->Item(i).GetUnit() == eCSSUnit_Pixel,
+                      "unexpected unit");
+    double startPixel = startArray->Item(i).GetFloatValue();
+    double endPixel = endArray->Item(i).GetFloatValue();
+    resultArray->Item(i).SetFloatValue(
+      startPixel + aPortion * (endPixel - startPixel), eCSSUnit_Pixel);
+  }
+
+  const nsCSSValue& startColor = startArray->Item(4);
+  const nsCSSValue& endColor = endArray->Item(4);
+  const nsCSSValue& startInset = startArray->Item(5);
+  const nsCSSValue& endInset = endArray->Item(5);
+  if (startColor.GetUnit() != endColor.GetUnit() ||
+      startInset.GetUnit() != endInset.GetUnit()) {
+    // We don't know how to animate between color and no-color, or
+    // between inset and not-inset.
+    return PR_FALSE;
+  }
+
+  nsStyleAnimation::Value startColorValue
+    (startColor.GetColorValue(), nsStyleAnimation::Value::ColorConstructor);
+  nsStyleAnimation::Value endColorValue
+    (endColor.GetColorValue(), nsStyleAnimation::Value::ColorConstructor);
+  nsStyleAnimation::Value resultColorValue;
+#ifdef DEBUG
+  PRBool ok =
+#endif
+    nsStyleAnimation::Interpolate(startColorValue, endColorValue,
+                                  aPortion, resultColorValue);
+  NS_ABORT_IF_FALSE(ok, "should not fail");
+  resultArray->Item(4).SetColorValue(resultColorValue.GetColorValue());
+
+  NS_ABORT_IF_FALSE(startInset == endInset, "should match");
+  resultArray->Item(5) = startInset;
+
+  nsCSSValueList *resultItem = new nsCSSValueList;
+  if (!resultItem) {
+    return PR_FALSE;
+  }
+  resultItem->mValue.SetArrayValue(resultArray, eCSSUnit_Array);
+  *aResultTail = resultItem;
+  aResultTail = &resultItem->mNext;
+  return PR_TRUE;
+}
+
 PRBool
 nsStyleAnimation::Interpolate(const Value& aStartValue,
                               const Value& aEndValue,
                               double aPortion,
                               Value& aResultValue)
 {
   NS_ABORT_IF_FALSE(aPortion >= 0.0 && aPortion <= 1.0,
                     "aPortion out of bounds");
@@ -307,16 +382,72 @@ nsStyleAnimation::Interpolate(const Valu
         PRUint8 resR = NSToIntRound((startR * inv + endR * aPortion) * factor);
         PRUint8 resG = NSToIntRound((startG * inv + endG * aPortion) * factor);
         PRUint8 resB = NSToIntRound((startB * inv + endB * aPortion) * factor);
         resultColor = NS_RGBA(resR, resG, resB, resA);
       }
       aResultValue.SetColorValue(resultColor);
       break;
     }
+    case eUnit_Shadow: {
+      // This is implemented according to:
+      // http://dev.w3.org/csswg/css3-transitions/#animation-of-property-types-
+      // and the third item in the summary of:
+      // http://lists.w3.org/Archives/Public/www-style/2009Jul/0050.html
+      const nsCSSValueList *startShadow = aStartValue.GetCSSValueListValue();
+      const nsCSSValueList *endShadow = aEndValue.GetCSSValueListValue();
+      nsCSSValueList *result = nsnull;
+      nsCSSValueList **resultTail = &result;
+      while (startShadow && endShadow) {
+        if (!InterpolateShadowItem(startShadow->mValue, endShadow->mValue,
+                                   aPortion, resultTail)) {
+          delete result;
+          success = PR_FALSE;
+          break;
+        }
+        startShadow = startShadow->mNext;
+        endShadow = endShadow->mNext;
+      }
+      if (startShadow || endShadow) {
+        const nsCSSValueList *longShadow;
+        double longPortion;
+        if (startShadow) {
+          longShadow = startShadow;
+          longPortion = 1.0 - aPortion;
+        } else {
+          longShadow = endShadow;
+          longPortion = aPortion;
+        }
+
+        while (longShadow) {
+          // X, Y, Radius, Spread, Color, Inset
+          nsRefPtr<nsCSSValue::Array> zeroArray = nsCSSValue::Array::Create(6);
+          for (PRUint32 i = 0; i < 4; ++i) {
+            zeroArray->Item(i).SetFloatValue(0, eCSSUnit_Pixel);
+          }
+          zeroArray->Item(4).SetColorValue(NS_RGBA(0, 0, 0, 0));
+          // Copy inset-or-not from other so we have a better chance at
+          // animating.
+          zeroArray->Item(5) = longShadow->mValue.GetArrayValue()->Item(5);
+
+          nsCSSValue zeroValue(zeroArray, eCSSUnit_Array);
+
+          if (!InterpolateShadowItem(zeroValue, longShadow->mValue, aPortion,
+                                     resultTail)) {
+            delete result;
+            success = PR_FALSE;
+            break;
+          }
+
+          longShadow = longShadow->mNext;
+        }
+      }
+      aResultValue.SetCSSValueListValue(result, eUnit_Shadow, PR_TRUE);
+      break;
+    }
     case eUnit_Null:
       success = PR_FALSE;
       break;
     default:
       NS_NOTREACHED("Can't interpolate using the given common unit");
       success = PR_FALSE;
       break;
   }
@@ -466,16 +597,22 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
           SetBothValuesTo(val);
       } else {
         NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
                           "type mismatch");
         static_cast<nsCSSValue*>(aSpecifiedValue)->
           SetColorValue(aComputedValue.GetColorValue());
       }
       break;
+    case eUnit_Shadow:
+      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
+                          eCSSType_ValueList, "type mismatch");
+      *static_cast<nsCSSValueList**>(aSpecifiedValue) =
+        aComputedValue.GetCSSValueListValue();
+      break;
     default:
       return PR_FALSE;
   }
   return PR_TRUE;
 }
 
 PRBool
 nsStyleAnimation::UncomputeValue(nsCSSProperty aProperty,
@@ -694,16 +831,64 @@ nsStyleAnimation::ExtractComputedValue(n
         return PR_TRUE;
       }
       if (paint.mType == eStyleSVGPaintType_None) {
         aComputedValue.SetNoneValue();
         return PR_TRUE;
       }
       return PR_FALSE;
     }
+    case eStyleAnimType_Shadow: {
+      const nsCSSShadowArray *shadowArray =
+        *static_cast<const nsRefPtr<nsCSSShadowArray>*>(
+          StyleDataAtOffset(styleStruct, ssOffset));
+      if (!shadowArray) {
+        aComputedValue.SetCSSValueListValue(nsnull, eUnit_Shadow, PR_TRUE);
+        return PR_TRUE;
+      }
+      nsCSSValueList *result = nsnull;
+      nsCSSValueList **resultTail = &result;
+      for (PRUint32 i = 0, i_end = shadowArray->Length(); i < i_end; ++i) {
+        const nsCSSShadowItem *shadow = shadowArray->ShadowAt(i);
+        // X, Y, Radius, Spread, Color, Inset
+        nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(6);
+        arr->Item(0).SetFloatValue(
+          nsPresContext::AppUnitsToFloatCSSPixels(shadow->mXOffset),
+          eCSSUnit_Pixel);
+        arr->Item(1).SetFloatValue(
+          nsPresContext::AppUnitsToFloatCSSPixels(shadow->mYOffset),
+          eCSSUnit_Pixel);
+        arr->Item(2).SetFloatValue(
+          nsPresContext::AppUnitsToFloatCSSPixels(shadow->mRadius),
+          eCSSUnit_Pixel);
+        // NOTE: This code sometimes stores mSpread: 0 even when
+        // the parser would be required to leave it null.
+        arr->Item(3).SetFloatValue(
+          nsPresContext::AppUnitsToFloatCSSPixels(shadow->mSpread),
+          eCSSUnit_Pixel);
+        if (shadow->mHasColor) {
+          arr->Item(4).SetColorValue(shadow->mColor);
+        }
+        if (shadow->mInset) {
+          arr->Item(5).SetIntValue(NS_STYLE_BOX_SHADOW_INSET,
+                                   eCSSUnit_Enumerated);
+        }
+
+        nsCSSValueList *resultItem = new nsCSSValueList;
+        if (!resultItem) {
+          delete result;
+          return PR_FALSE;
+        }
+        resultItem->mValue.SetArrayValue(arr, eCSSUnit_Array);
+        *resultTail = resultItem;
+        resultTail = &resultItem->mNext;
+      }
+      aComputedValue.SetCSSValueListValue(result, eUnit_Shadow, PR_TRUE);
+      return PR_TRUE;
+    }
     case eStyleAnimType_None:
       NS_NOTREACHED("shouldn't use on non-animatable properties");
   }
   return PR_FALSE;
 }
 
 nsStyleAnimation::Value::Value(nscoord aLength, CoordConstructorType)
 {
@@ -746,16 +931,19 @@ nsStyleAnimation::Value::operator=(const
       break;
     case eUnit_Percent:
     case eUnit_Float:
       mValue.mFloat = aOther.mValue.mFloat;
       break;
     case eUnit_Color:
       mValue.mColor = aOther.mValue.mColor;
       break;
+    case eUnit_Shadow:
+      mValue.mCSSValueList = aOther.mValue.mCSSValueList
+                               ? aOther.mValue.mCSSValueList->Clone() : nsnull;
   }
 
   return *this;
 }
 
 void
 nsStyleAnimation::Value::SetNormalValue()
 {
@@ -805,18 +993,36 @@ void
 nsStyleAnimation::Value::SetColorValue(nscolor aColor)
 {
   FreeValue();
   mUnit = eUnit_Color;
   mValue.mColor = aColor;
 }
 
 void
+nsStyleAnimation::Value::SetCSSValueListValue(nsCSSValueList *aValueList,
+                                              Unit aUnit,
+                                              PRBool aTakeOwnership)
+{
+  FreeValue();
+  NS_ASSERTION(IsCSSValueListUnit(aUnit), "bad unit");
+  mUnit = aUnit;
+  if (aTakeOwnership) {
+    mValue.mCSSValueList = aValueList;
+  } else {
+    mValue.mCSSValueList = aValueList ? aValueList->Clone() : nsnull;
+  }
+}
+
+void
 nsStyleAnimation::Value::FreeValue()
 {
+  if (IsCSSValueListUnit(mUnit)) {
+    delete mValue.mCSSValueList;
+  }
 }
 
 PRBool
 nsStyleAnimation::Value::operator==(const Value& aOther) const
 {
   if (mUnit != aOther.mUnit) {
     return PR_FALSE;
   }
@@ -829,14 +1035,17 @@ nsStyleAnimation::Value::operator==(cons
       return PR_TRUE;
     case eUnit_Coord:
       return mValue.mCoord == aOther.mValue.mCoord;
     case eUnit_Percent:
     case eUnit_Float:
       return mValue.mFloat == aOther.mValue.mFloat;
     case eUnit_Color:
       return mValue.mColor == aOther.mValue.mColor;
+    case eUnit_Shadow:
+      return nsCSSValueList::Equal(mValue.mCSSValueList,
+                                   aOther.mValue.mCSSValueList);
   }
 
   NS_NOTREACHED("incomplete case");
   return PR_FALSE;
 }
 
diff --git a/layout/style/nsStyleAnimation.h b/layout/style/nsStyleAnimation.h
--- a/layout/style/nsStyleAnimation.h
+++ b/layout/style/nsStyleAnimation.h
@@ -47,16 +47,17 @@
 #include "nsCSSProperty.h"
 #include "nsCoord.h"
 #include "nsColor.h"
 
 class nsCSSDeclaration;
 class nsIContent;
 class nsPresContext;
 class nsStyleContext;
+struct nsCSSValueList;
 
 /**
  * Utility class to handle animated style values
  */
 class nsStyleAnimation {
 public:
   class Value;
 
@@ -186,26 +187,28 @@ public:
   enum Unit {
     eUnit_Null, // not initialized
     eUnit_Normal,
     eUnit_Auto,
     eUnit_None,
     eUnit_Coord,
     eUnit_Percent,
     eUnit_Float,
-    eUnit_Color
+    eUnit_Color,
+    eUnit_Shadow  // nsCSSValueList*
   };
 
   class Value {
   private:
     Unit mUnit;
     union {
       nscoord mCoord;
       float mFloat;
       nscolor mColor;
+      nsCSSValueList* mCSSValueList;
     } mValue;
   public:
     Unit GetUnit() const {
       NS_ASSERTION(mUnit != eUnit_Null, "uninitialized");
       return mUnit;
     }
 
     // Accessor to let us verify assumptions about presence of null unit,
@@ -225,16 +228,20 @@ public:
     float GetFloatValue() const {
       NS_ASSERTION(mUnit == eUnit_Float, "unit mismatch");
       return mValue.mFloat;
     }
     nscolor GetColorValue() const {
       NS_ASSERTION(mUnit == eUnit_Color, "unit mismatch");
       return mValue.mColor;
     }
+    nsCSSValueList* GetCSSValueListValue() const {
+      NS_ASSERTION(IsCSSValueListUnit(mUnit), "unit mismatch");
+      return mValue.mCSSValueList;
+    }
 
     explicit Value(Unit aUnit = eUnit_Null) : mUnit(aUnit) {
       NS_ASSERTION(aUnit == eUnit_Null || aUnit == eUnit_Normal ||
                    aUnit == eUnit_Auto || aUnit == eUnit_None,
                    "must be valueless unit");
     }
     Value(const Value& aOther) : mUnit(eUnit_Null) { *this = aOther; }
     enum CoordConstructorType { CoordConstructor };
@@ -250,21 +257,27 @@ public:
 
     void SetNormalValue();
     void SetAutoValue();
     void SetNoneValue();
     void SetCoordValue(nscoord aCoord);
     void SetPercentValue(float aPercent);
     void SetFloatValue(float aFloat);
     void SetColorValue(nscolor aColor);
+    void SetCSSValueListValue(nsCSSValueList *aValue, Unit aUnit,
+                              PRBool aTakeOwnership);
 
     Value& operator=(const Value& aOther);
 
     PRBool operator==(const Value& aOther) const;
     PRBool operator!=(const Value& aOther) const
       { return !(*this == aOther); }
 
   private:
     void FreeValue();
+
+    static PRBool IsCSSValueListUnit(Unit aUnit) {
+      return aUnit == eUnit_Shadow;
+    }
   };
 };
 
 #endif
diff --git a/layout/style/test/test_transitions_per_property.html b/layout/style/test/test_transitions_per_property.html
--- a/layout/style/test/test_transitions_per_property.html
+++ b/layout/style/test/test_transitions_per_property.html
@@ -42,16 +42,17 @@ function has_num(str)
 }
 
 function any_unit_to_num(str)
 {
     return Number(String(str).match(/^([\d.]+)/)[1]);
 }
 
 var supported_properties = {
+    "-moz-box-shadow": [ test_shadow_transition ],
     "-moz-column-gap": [ test_length_transition ],
     "-moz-column-rule-color": [ test_color_transition ],
     "-moz-column-width": [ test_length_transition ],
     "background-color": [ test_color_transition ],
     "border-bottom-color": [ test_color_transition ],
     "border-bottom-width": [ test_length_transition ],
     "border-left-color": [ test_color_transition ],
     "border-left-width": [ test_length_transition ],
@@ -94,16 +95,17 @@ var supported_properties = {
     "stop-color": [ test_color_transition ],
     "stop-opacity" : [ test_float_zeroToOne_transition ],
     "stroke": [ test_color_transition ],
     "stroke-dashoffset": [ test_length_transition, test_percent_transition ],
     "stroke-miterlimit": [ test_float_aboveOne_transition ],
     "stroke-opacity" : [ test_float_zeroToOne_transition ],
     "stroke-width": [ test_length_transition, test_percent_transition ],
     "text-indent": [ test_length_transition, test_percent_transition ],
+    "text-shadow": [ test_shadow_transition ],
     "top": [ test_length_transition, test_percent_transition ],
     "vertical-align": [ test_length_transition, test_percent_transition ],
     "width": [ test_length_transition, test_percent_transition ],
     "word-spacing": [ test_length_transition ],
 };
 
 var div = document.getElementById("display");
 var cs = getComputedStyle(div, "");
@@ -270,12 +272,49 @@ function test_color_transition(prop) {
   is(cs.getPropertyValue(prop), "rgb(255, 28, 0)",
      "color-valued property " + prop + ": computed value before transition");
   div.style.setProperty("-moz-transition-property", prop, "");
   div.style.setProperty(prop, "rgb(77, 84, 128)", "");
   is(cs.getPropertyValue(prop), "rgb(166, 56, 64)",
      "color-valued property " + prop + ": interpolation of colors");
 }
 
+function test_shadow_transition(prop) {
+  div.style.setProperty("-moz-transition-property", "none", "");
+  div.style.setProperty(prop, "none", "");
+  is(cs.getPropertyValue(prop), "none",
+     "shadow-valued property " + prop + ": computed value before transition");
+  div.style.setProperty("-moz-transition-property", prop, "");
+  div.style.setProperty(prop, "4px 8px 3px red", "");
+  is(cs.getPropertyValue(prop), "2px 8px 3px rgba(255, 0, 0, 0.5)",
+     "shadow-valued property " + prop + ": interpolation of shadows");
+
+  div.style.setProperty("-moz-transition-property", "none", "");
+  div.style.setProperty(prop, "green 4px 4px, 2px 2px blue", "");
+  is(cs.getPropertyValue(prop), "4px 4px green, 2px 2px blue",
+     "shadow-valued property " + prop + ": computed value before transition");
+  div.style.setProperty("-moz-transition-property", prop, "");
+  div.style.setProperty(prop, "8px 8px 8px red", "");
+  is(cs.getPropertyValue(prop), "6px 6px 4px rgb(128, 128, 0), 1px 1px rgb(0, 0, 255, 0.5)",
+     "shadow-valued property " + prop + ": interpolation of shadows");
+
+  if (prop == "-moz-box-shadow") {
+    div.style.setProperty(prop, "8px 8px 8px red inset", "");
+    is(cs.getPropertyValue(prop), "8px 8px 8px red inset",
+       "shadow-valued property " + prop + ": non-interpolable cases");
+    div.style.setProperty(prop, "8px 8px 8px 8px red inset", "");
+    is(cs.getPropertyValue(prop), "8px 8px 8px 8px red inset",
+       "shadow-valued property " + prop + ": non-interpolable cases");
+    // Leave in same state whether in the |if| or not.
+    div.style.setProperty(prop, "8px 8px 8px red", "");
+    is(cs.getPropertyValue(prop), "8px 8px 8px red",
+       "shadow-valued property " + prop + ": non-interpolable cases");
+  }
+
+  div.style.setProperty(prop, "2px 2px 2px", "");
+  is(cs.getPropertyValue(prop), "2px 2px 2px",
+     "shadow-valued property " + prop + ": non-interpolable cases");
+}
+
 </script>
 </pre>
 </body>
 </html>
