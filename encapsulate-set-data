From: L. David Baron <dbaron@dbaron.org>

Bug 1381080 patch 3 - Encapsulate setting mData/mLength/mDataFlags in a new method.  r=erahm

This is needed for patch 4.

MozReview-Commit-ID: 4BFlTtQdtoN

diff --git a/xpcom/string/nsSubstring.cpp b/xpcom/string/nsSubstring.cpp
--- a/xpcom/string/nsSubstring.cpp
+++ b/xpcom/string/nsSubstring.cpp
@@ -142,19 +142,17 @@ public:
   DataFlags flags() const
   {
     return mDataFlags;
   }
 
   void set(char_type* aData, size_type aLen, DataFlags aDataFlags)
   {
     ReleaseData(mData, mDataFlags);
-    mData = aData;
-    mLength = aLen;
-    mDataFlags = aDataFlags;
+    SetData(aData, aLen, aDataFlags);
   }
 };
 
 class nsACStringAccessor : public nsACString
 {
 private:
   nsACStringAccessor(); // NOT IMPLEMENTED
 
@@ -170,19 +168,17 @@ public:
   DataFlags flags() const
   {
     return mDataFlags;
   }
 
   void set(char_type* aData, size_type aLen, DataFlags aDataFlags)
   {
     ReleaseData(mData, mDataFlags);
-    mData = aData;
-    mLength = aLen;
-    mDataFlags = aDataFlags;
+    SetData(aData, aLen, aDataFlags);
   }
 };
 
 // ---------------------------------------------------------------------------
 
 void
 nsStringBuffer::AddRef()
 {
diff --git a/xpcom/string/nsTDependentString.cpp b/xpcom/string/nsTDependentString.cpp
--- a/xpcom/string/nsTDependentString.cpp
+++ b/xpcom/string/nsTDependentString.cpp
@@ -22,19 +22,21 @@ nsTDependentString_CharT::Rebind(const s
   Finalize();
 
   size_type strLength = str.Length();
 
   if (startPos > strLength) {
     startPos = strLength;
   }
 
-  mData = const_cast<char_type*>(static_cast<const char_type*>(str.Data())) + startPos;
-  mLength = strLength - startPos;
-  mDataFlags = str.GetDataFlags() & (DataFlags::TERMINATED | DataFlags::LITERAL);
+  char_type* newData =
+    const_cast<char_type*>(static_cast<const char_type*>(str.Data())) + startPos;
+  size_type newLen = strLength - startPos;
+  DataFlags newDataFlags = str.GetDataFlags() & (DataFlags::TERMINATED | DataFlags::LITERAL);
+  SetData(newData, newLen, newDataFlags);
 }
 
 void
 nsTDependentString_CharT::Rebind(const char_type* aStart, const char_type* aEnd)
 {
   MOZ_RELEASE_ASSERT(aStart <= aEnd, "Overflow!");
   Rebind(aStart, uint32_t(aEnd - aStart));
 }
diff --git a/xpcom/string/nsTDependentSubstring.cpp b/xpcom/string/nsTDependentSubstring.cpp
--- a/xpcom/string/nsTDependentSubstring.cpp
+++ b/xpcom/string/nsTDependentSubstring.cpp
@@ -12,32 +12,36 @@ nsTDependentSubstring_CharT::Rebind(cons
   Finalize();
 
   size_type strLength = str.Length();
 
   if (startPos > strLength) {
     startPos = strLength;
   }
 
-  mData = const_cast<char_type*>(static_cast<const char_type*>(str.Data())) + startPos;
-  mLength = XPCOM_MIN(length, strLength - startPos);
-  mDataFlags = DataFlags(0);
+  char_type* newData =
+    const_cast<char_type*>(static_cast<const char_type*>(str.Data())) + startPos;
+  size_type newLength = XPCOM_MIN(length, strLength - startPos);
+  DataFlags newDataFlags = DataFlags(0);
+  SetData(newData, newLength, newDataFlags);
 }
 
 void
 nsTDependentSubstring_CharT::Rebind(const char_type* data, size_type length)
 {
   NS_ASSERTION(data, "nsTDependentSubstring must wrap a non-NULL buffer");
 
   // If we currently own a buffer, release it.
   Finalize();
 
-  mData = const_cast<char_type*>(static_cast<const char_type*>(data));
-  mLength = length;
-  mDataFlags = DataFlags(0);
+  char_type* newData =
+    const_cast<char_type*>(static_cast<const char_type*>(data));
+  size_type newLength = length;
+  DataFlags newDataFlags = DataFlags(0);
+  SetData(newData, newLength, newDataFlags);
 }
 
 void
 nsTDependentSubstring_CharT::Rebind(const char_type* aStart, const char_type* aEnd)
 {
   MOZ_RELEASE_ASSERT(aStart <= aEnd, "Overflow!");
   Rebind(aStart, size_type(aEnd - aStart));
 }
diff --git a/xpcom/string/nsTPromiseFlatString.cpp b/xpcom/string/nsTPromiseFlatString.cpp
--- a/xpcom/string/nsTPromiseFlatString.cpp
+++ b/xpcom/string/nsTPromiseFlatString.cpp
@@ -3,17 +3,20 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 void
 nsTPromiseFlatString_CharT::Init(const substring_type& str)
 {
   if (str.IsTerminated()) {
-    mData = const_cast<char_type*>(static_cast<const char_type*>(str.Data()));
-    mLength = str.Length();
-    mDataFlags =
+    char_type* newData =
+      const_cast<char_type*>(static_cast<const char_type*>(str.Data()));
+    size_type newLength = str.Length();
+    DataFlags newDataFlags =
       str.GetDataFlags() & (DataFlags::TERMINATED | DataFlags::LITERAL);
     // does not promote DataFlags::VOIDED
+
+    SetData(newData, newLength, newDataFlags);
   } else {
     Assign(str);
   }
 }
diff --git a/xpcom/string/nsTString.cpp b/xpcom/string/nsTString.cpp
--- a/xpcom/string/nsTString.cpp
+++ b/xpcom/string/nsTString.cpp
@@ -13,19 +13,17 @@ nsTAdoptingString_CharT::operator=(const
 
   if (str.mDataFlags & DataFlags::OWNED) {
     // We want to do what Adopt() does, but without actually incrementing
     // the Adopt count.  Note that we can be a little more straightforward
     // about this than Adopt() is, because we know that str.mData is
     // non-null.  Should we be able to assert that str is not void here?
     NS_ASSERTION(str.mData, "String with null mData?");
     Finalize();
-    mData = str.mData;
-    mLength = str.mLength;
-    mDataFlags = DataFlags::TERMINATED | DataFlags::OWNED;
+    SetData(str.mData, str.mLength, DataFlags::TERMINATED | DataFlags::OWNED);
 
     // Make str forget the buffer we just took ownership of.
     new (mutable_str) self_type();
   } else {
     Assign(str);
 
     mutable_str->Truncate();
   }
@@ -34,14 +32,12 @@ nsTAdoptingString_CharT::operator=(const
 }
 
 void
 nsTString_CharT::Rebind(const char_type* data, size_type length)
 {
   // If we currently own a buffer, release it.
   Finalize();
 
-  mData = const_cast<char_type*>(data);
-  mLength = length;
-  mDataFlags = DataFlags::TERMINATED;
+  SetData(const_cast<char_type*>(data), length, DataFlags::TERMINATED);
   AssertValidDependentString();
 }
 
diff --git a/xpcom/string/nsTSubstring.cpp b/xpcom/string/nsTSubstring.cpp
--- a/xpcom/string/nsTSubstring.cpp
+++ b/xpcom/string/nsTSubstring.cpp
@@ -164,20 +164,18 @@ nsTSubstring_CharT::MutatePrep(size_type
     newData = (char_type*)newHdr->Data();
     newDataFlags = DataFlags::TERMINATED | DataFlags::SHARED;
   }
 
   // save old data and flags
   *aOldData = mData;
   *aOldDataFlags = mDataFlags;
 
-  mData = newData;
-  mDataFlags = newDataFlags;
-
   // mLength does not change
+  SetData(newData, mLength, newDataFlags);
 
   // though we are not necessarily terminated at the moment, now is probably
   // still the best time to set DataFlags::TERMINATED.
 
   return true;
 }
 
 void
@@ -406,19 +404,18 @@ nsTSubstring_CharT::AssignASCII(const ch
   char_traits::copyASCII(mData, aData, aLength);
   return true;
 }
 
 void
 nsTSubstring_CharT::AssignLiteral(const char_type* aData, size_type aLength)
 {
   ::ReleaseData(mData, mDataFlags);
-  mData = const_cast<char_type*>(aData);
-  mLength = aLength;
-  mDataFlags = DataFlags::TERMINATED | DataFlags::LITERAL;
+  SetData(const_cast<char_type*>(aData), aLength,
+          DataFlags::TERMINATED | DataFlags::LITERAL);
 }
 
 void
 nsTSubstring_CharT::Assign(const self_type& aStr)
 {
   if (!Assign(aStr, mozilla::fallible)) {
     AllocFailed(aStr.Length());
   }
@@ -443,19 +440,18 @@ nsTSubstring_CharT::Assign(const self_ty
   if (aStr.mDataFlags & DataFlags::SHARED) {
     // nice! we can avoid a string copy :-)
 
     // |aStr| should be null-terminated
     NS_ASSERTION(aStr.mDataFlags & DataFlags::TERMINATED, "shared, but not terminated");
 
     ::ReleaseData(mData, mDataFlags);
 
-    mData = aStr.mData;
-    mLength = aStr.mLength;
-    mDataFlags = DataFlags::TERMINATED | DataFlags::SHARED;
+    SetData(aStr.mData, aStr.mLength,
+            DataFlags::TERMINATED | DataFlags::SHARED);
 
     // get an owning reference to the mData
     nsStringBuffer::FromData(mData)->AddRef();
     return true;
   } else if (aStr.mDataFlags & DataFlags::LITERAL) {
     MOZ_ASSERT(aStr.mDataFlags & DataFlags::TERMINATED, "Unterminated literal");
 
     AssignLiteral(aStr.mData, aStr.mLength);
@@ -509,19 +505,17 @@ nsTSubstring_CharT::Adopt(char_type* aDa
     ::ReleaseData(mData, mDataFlags);
 
     if (aLength == size_type(-1)) {
       aLength = char_traits::length(aData);
     }
 
     MOZ_RELEASE_ASSERT(CheckCapacity(aLength), "adopting a too-long string");
 
-    mData = aData;
-    mLength = aLength;
-    mDataFlags = DataFlags::TERMINATED | DataFlags::OWNED;
+    SetData(aData, aLength, DataFlags::TERMINATED | DataFlags::OWNED);
 
     STRING_STAT_INCREMENT(Adopt);
     // Treat this as construction of a "StringAdopt" object for leak
     // tracking purposes.
     MOZ_LOG_CTOR(mData, "StringAdopt", 1);
   } else {
     SetIsVoid(true);
   }
diff --git a/xpcom/string/nsTSubstring.h b/xpcom/string/nsTSubstring.h
--- a/xpcom/string/nsTSubstring.h
+++ b/xpcom/string/nsTSubstring.h
@@ -1083,16 +1083,23 @@ protected:
 
   void SetToEmptyBuffer()
   {
     mData = char_traits::sEmptyBuffer;
     mLength = 0;
     mDataFlags = DataFlags::TERMINATED;
   }
 
+  void SetData(char_type* aData, size_type aLength, DataFlags aDataFlags)
+  {
+    mData = aData;
+    mLength = aLength;
+    mDataFlags = aDataFlags;
+  }
+
   /**
    * this function releases mData and does not change the value of
    * any of its member variables.  in other words, this function acts
    * like a destructor.
    */
   void NS_FASTCALL Finalize();
 
   /**
