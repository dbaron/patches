From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Make AddStyleUpdatesTo handle pseudo-elements.

FIXME: Will this approach even work?  Is more needed?

diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -357,16 +357,42 @@ ElementAnimations::HasAnimationOfPropert
     const ElementAnimation &anim = mAnimations[animIdx];
     if (anim.HasAnimationOfProperty(aProperty)) {
       return true;
     }
   }
   return false;
 }
 
+mozilla::dom::Element*
+ElementAnimations::ElementToRestyle() const
+{
+  if (mElementProperty == nsGkAtoms::animationsProperty) {
+    return mElement;
+  }
+
+  nsIFrame* primaryFrame = mElement->GetPrimaryFrame();
+  if (!primaryFrame) {
+    return nullptr;
+  }
+  nsIFrame* pseudoFrame;
+  if (mElementProperty == nsGkAtoms::animationsOfBeforeProperty) {
+    pseudoFrame = nsLayoutUtils::GetBeforeFrame(primaryFrame);
+  } else if (mElementProperty == nsGkAtoms::animationsOfAfterProperty) {
+    pseudoFrame = nsLayoutUtils::GetAfterFrame(primaryFrame);
+  } else {
+    MOZ_ASSERT("unknown mElementProperty");
+    return nullptr;
+  }
+  if (!pseudoFrame) {
+    return nullptr;
+  }
+  return pseudoFrame->GetContent()->AsElement();
+}
+
 bool
 ElementAnimations::CanPerformOnCompositorThread(CanAnimateFlags aFlags) const
 {
   nsIFrame* frame = nsLayoutUtils::GetStyleFrame(mElement);
   if (!frame) {
     return false;
   }
 
@@ -1145,20 +1171,15 @@ nsAnimationManager::StopAllAnimations()
 void
 nsAnimationManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
 {
   PRCList *next = PR_LIST_HEAD(&mElementData);
   while (next != &mElementData) {
     ElementAnimations *ea = static_cast<ElementAnimations*>(next);
     next = PR_NEXT_LINK(next);
 
-    if (ea->mElementProperty != nsGkAtoms::animationsProperty) {
-      // We don't support compositor-driven animation of :before/:after
-      // transitions, so at least skip those.
-      // FIXME: We'll need to handle this before using this for the
-      // transitions redesign.
-      continue;
+    dom::Element* elementToRestyle = ea->ElementToRestyle();
+    if (elementToRestyle) {
+      aTracker.AddPendingRestyle(elementToRestyle, eRestyle_CSSAnimations,
+                                 nsChangeHint(0));
     }
-
-    aTracker.AddPendingRestyle(ea->mElement, eRestyle_CSSAnimations,
-                               nsChangeHint(0));
   }
 }
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -170,16 +170,18 @@ struct ElementAnimations MOZ_FINAL
   {
     return mElementProperty == nsGkAtoms::animationsProperty ?
              EmptyString() :
              mElementProperty == nsGkAtoms::animationsOfBeforeProperty ?
                NS_LITERAL_STRING("::before") :
                NS_LITERAL_STRING("::after");
   }
 
+  mozilla::dom::Element* ElementToRestyle() const;
+
   void PostRestyleForAnimation(nsPresContext *aPresContext) {
     nsRestyleHint styleHint = IsForElement() ? eRestyle_Self : eRestyle_Subtree;
     aPresContext->PresShell()->RestyleForAnimation(mElement, styleHint);
   }
 
   // If aFlags contains CanAnimate_AllowPartial, returns whether the
   // state of this element's animations at the current refresh driver
   // time contains animation data that can be done on the compositor
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -134,16 +134,42 @@ ElementTransitions::HasAnimationOfProper
     const ElementPropertyTransition& pt = mPropertyTransitions[tranIdx];
     if (aProperty == pt.mProperty && !pt.IsRemovedSentinel()) {
       return true;
     }
   }
   return false;
 }
 
+mozilla::dom::Element*
+ElementTransitions::ElementToRestyle() const
+{
+  if (mElementProperty == nsGkAtoms::transitionsProperty) {
+    return mElement;
+  }
+
+  nsIFrame* primaryFrame = mElement->GetPrimaryFrame();
+  if (!primaryFrame) {
+    return nullptr;
+  }
+  nsIFrame* pseudoFrame;
+  if (mElementProperty == nsGkAtoms::transitionsOfBeforeProperty) {
+    pseudoFrame = nsLayoutUtils::GetBeforeFrame(primaryFrame);
+  } else if (mElementProperty == nsGkAtoms::transitionsOfAfterProperty) {
+    pseudoFrame = nsLayoutUtils::GetAfterFrame(primaryFrame);
+  } else {
+    MOZ_ASSERT("unknown mElementProperty");
+    return nullptr;
+  }
+  if (!pseudoFrame) {
+    return nullptr;
+  }
+  return pseudoFrame->GetContent()->AsElement();
+}
+
 bool
 ElementTransitions::CanPerformOnCompositorThread(CanAnimateFlags aFlags) const
 {
   nsIFrame* frame = nsLayoutUtils::GetStyleFrame(mElement);
   if (!frame) {
     return false;
   }
 
@@ -213,26 +239,21 @@ ElementTransitions::CanPerformOnComposit
 void
 nsTransitionManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
 {
   PRCList *next = PR_LIST_HEAD(&mElementData);
   while (next != &mElementData) {
     ElementTransitions *et = static_cast<ElementTransitions*>(next);
     next = PR_NEXT_LINK(next);
 
-    if (et->mElementProperty != nsGkAtoms::transitionsProperty) {
-      // We don't support compositor-driven animation of :before/:after
-      // transitions, so at least skip those.
-      // FIXME: We'll need to handle this before using this for the
-      // transitions redesign.
-      continue;
+    dom::Element* elementToRestyle = et->ElementToRestyle();
+    if (elementToRestyle) {
+      aTracker.AddPendingRestyle(elementToRestyle, eRestyle_CSSTransitions,
+                                 nsChangeHint(0));
     }
-
-    aTracker.AddPendingRestyle(et->mElement, eRestyle_CSSTransitions,
-                               nsChangeHint(0));
   }
 }
 
 void
 nsTransitionManager::ElementDataRemoved()
 {
   // If we have no transitions or animations left, remove ourselves from
   // the refresh driver.
diff --git a/layout/style/nsTransitionManager.h b/layout/style/nsTransitionManager.h
--- a/layout/style/nsTransitionManager.h
+++ b/layout/style/nsTransitionManager.h
@@ -87,16 +87,18 @@ struct ElementTransitions MOZ_FINAL
   ElementTransitions(mozilla::dom::Element *aElement, nsIAtom *aElementProperty,
                      nsTransitionManager *aTransitionManager,
                      mozilla::TimeStamp aNow);
 
   void EnsureStyleRuleFor(mozilla::TimeStamp aRefreshTime);
 
   virtual bool HasAnimationOfProperty(nsCSSProperty aProperty) const MOZ_OVERRIDE;
 
+  mozilla::dom::Element* ElementToRestyle() const;
+
   // If aFlags contains CanAnimate_AllowPartial, returns whether the
   // state of this element's transitions at the current refresh driver
   // time contains transition data that can be done on the compositor
   // thread.  (This is useful for determining whether a layer should be
   // active, or whether to send data to the layer.)
   // If aFlags does not contain CanAnimate_AllowPartial, returns whether
   // the state of this element's transitions at the current refresh driver
   // time can be fully represented by data sent to the compositor.
