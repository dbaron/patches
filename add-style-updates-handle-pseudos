From: L. David Baron <dbaron@dbaron.org>

Bug 960465 patch N - Make AddStyleUpdatesTo handle pseudo-elements.

FIXME: Will this approach even work?  Is more needed?

diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -604,16 +604,42 @@ ElementAnimationCollection::HasAnimation
     if (anim->HasAnimationOfProperty(aProperty) &&
         !anim->IsFinishedTransition()) {
       return true;
     }
   }
   return false;
 }
 
+mozilla::dom::Element*
+ElementAnimationCollection::ElementToRestyle() const
+{
+  if (IsForElement()) {
+    return mElement;
+  }
+
+  nsIFrame* primaryFrame = mElement->GetPrimaryFrame();
+  if (!primaryFrame) {
+    return nullptr;
+  }
+  nsIFrame* pseudoFrame;
+  if (IsForBeforePseudo()) {
+    pseudoFrame = nsLayoutUtils::GetBeforeFrame(primaryFrame);
+  } else if (IsForAfterPseudo()) {
+    pseudoFrame = nsLayoutUtils::GetAfterFrame(primaryFrame);
+  } else {
+    MOZ_ASSERT("unknown mElementProperty");
+    return nullptr;
+  }
+  if (!pseudoFrame) {
+    return nullptr;
+  }
+  return pseudoFrame->GetContent()->AsElement();
+}
+
 /* static */ void
 ElementAnimationCollection::LogAsyncAnimationFailure(nsCString& aMessage,
                                                      const nsIContent* aContent)
 {
   if (aContent) {
     aMessage.AppendLiteral(" [");
     aMessage.Append(nsAtomCString(aContent->Tag()));
 
diff --git a/layout/style/AnimationCommon.h b/layout/style/AnimationCommon.h
--- a/layout/style/AnimationCommon.h
+++ b/layout/style/AnimationCommon.h
@@ -412,28 +412,39 @@ struct ElementAnimationCollection : publ
   bool CanPerformOnCompositorThread(CanAnimateFlags aFlags) const;
   bool HasAnimationOfProperty(nsCSSProperty aProperty) const;
 
   bool IsForElement() const { // rather than for a pseudo-element
     return mElementProperty == nsGkAtoms::animationsProperty ||
            mElementProperty == nsGkAtoms::transitionsProperty;
   }
 
+  bool IsForBeforePseudo() const {
+    return mElementProperty == nsGkAtoms::animationsOfBeforeProperty ||
+           mElementProperty == nsGkAtoms::transitionsOfBeforeProperty;
+  }
+
+  bool IsForAfterPseudo() const {
+    return mElementProperty == nsGkAtoms::animationsOfAfterProperty ||
+           mElementProperty == nsGkAtoms::transitionsOfAfterProperty;
+  }
+
   nsString PseudoElement()
   {
     if (IsForElement()) {
       return EmptyString();
-    } else if (mElementProperty == nsGkAtoms::animationsOfBeforeProperty ||
-               mElementProperty == nsGkAtoms::transitionsOfBeforeProperty) {
+    } else if (IsForBeforePseudo()) {
       return NS_LITERAL_STRING("::before");
     } else {
       return NS_LITERAL_STRING("::after");
     }
   }
 
+  mozilla::dom::Element* ElementToRestyle() const;
+
   void PostRestyleForAnimation(nsPresContext *aPresContext) {
     nsRestyleHint styleHint = IsForElement() ? eRestyle_Self : eRestyle_Subtree;
     aPresContext->PresShell()->RestyleForAnimation(mElement, styleHint);
   }
 
   static void LogAsyncAnimationFailure(nsCString& aMessage,
                                        const nsIContent* aContent = nullptr);
 
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -803,20 +803,15 @@ nsAnimationManager::StopAllAnimations()
 void
 nsAnimationManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
 {
   PRCList *next = PR_LIST_HEAD(&mElementCollections);
   while (next != &mElementCollections) {
     ElementAnimationCollection *collection = static_cast<ElementAnimationCollection*>(next);
     next = PR_NEXT_LINK(next);
 
-    if (collection->mElementProperty != nsGkAtoms::animationsProperty) {
-      // We don't support compositor-driven animation of :before/:after
-      // transitions, so at least skip those.
-      // FIXME: We'll need to handle this before using this for the
-      // transitions redesign.
-      continue;
+    dom::Element* elementToRestyle = collection->ElementToRestyle();
+    if (elementToRestyle) {
+      aTracker.AddPendingRestyle(elementToRestyle, eRestyle_CSSAnimations,
+                                 nsChangeHint(0));
     }
-
-    aTracker.AddPendingRestyle(collection->mElement, eRestyle_CSSAnimations,
-                               nsChangeHint(0));
   }
 }
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -74,26 +74,21 @@ ElementPropertyTransition::ValuePortionF
 void
 nsTransitionManager::AddStyleUpdatesTo(RestyleTracker& aTracker)
 {
   PRCList *next = PR_LIST_HEAD(&mElementCollections);
   while (next != &mElementCollections) {
     ElementAnimationCollection *collection = static_cast<ElementAnimationCollection*>(next);
     next = PR_NEXT_LINK(next);
 
-    if (collection->mElementProperty != nsGkAtoms::transitionsProperty) {
-      // We don't support compositor-driven animation of :before/:after
-      // transitions, so at least skip those.
-      // FIXME: We'll need to handle this before using this for the
-      // transitions redesign.
-      continue;
+    dom::Element* elementToRestyle = collection->ElementToRestyle();
+    if (elementToRestyle) {
+      aTracker.AddPendingRestyle(elementToRestyle, eRestyle_CSSTransitions,
+                                 nsChangeHint(0));
     }
-
-    aTracker.AddPendingRestyle(collection->mElement, eRestyle_CSSTransitions,
-                               nsChangeHint(0));
   }
 }
 
 void
 nsTransitionManager::ElementCollectionRemoved()
 {
   // If we have no transitions or animations left, remove ourselves from
   // the refresh driver.
